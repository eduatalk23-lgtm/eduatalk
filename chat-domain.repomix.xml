This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/domains/chat/**, components/chat/**, app/(student)/chat/**, app/(admin)/admin/chat/**, lib/realtime/useChat*.ts, lib/realtime/useChatPresence.ts, lib/realtime/useChatRealtime.ts, app/actions/**/chat*.ts, app/api/**/chat*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  (admin)/
    admin/
      chat/
        _components/
          AdminChatListPage.tsx
          AdminCreateChatModal.tsx
        [roomId]/
          _components/
            AdminChatRoomPage.tsx
          page.tsx
        reports/
          _components/
            ReportDetailModal.tsx
            ReportFilter.tsx
            ReportListPage.tsx
            ReportTable.tsx
          page.tsx
        page.tsx
  (student)/
    chat/
      _components/
        ChatListPage.tsx
        CreateChatModal.tsx
      [roomId]/
        _components/
          ChatRoomPage.tsx
        page.tsx
      page.tsx
components/
  chat/
    atoms/
      AnnouncementBanner.tsx
      DateDivider.tsx
      MessageBubble.tsx
      OnlineStatus.tsx
      ReactionPicker.tsx
      ReactionPills.tsx
      TypingIndicator.tsx
      UnreadBadge.tsx
    molecules/
      AnnouncementDialog.tsx
      ChatInput.tsx
      ChatRoomCard.tsx
      EditMessageDialog.tsx
      MessageContextMenu.tsx
      MessageSearch.tsx
      PinnedMessagesBar.tsx
    organisms/
      ChatList.tsx
      ChatRoom.tsx
      ChatRoomInfo.tsx
      InviteMemberModal.tsx
    index.ts
lib/
  domains/
    chat/
      actions/
        index.ts
        members.ts
        messages.ts
        pins.ts
        reactions.ts
        rooms.ts
        safety.ts
      hooks/
        index.ts
        useChatRoomLogic.ts
      index.ts
      messageGrouping.ts
      repository.ts
      service.ts
      types.ts
  realtime/
    useChatPresence.ts
    useChatRealtime.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(admin)/admin/chat/_components/AdminChatListPage.tsx">
"use client";

/**
 * AdminChatListPage - 관리자 채팅 목록 페이지
 */

import { useState } from "react";
import { ChatList } from "@/components/chat";
import { useChatRoomListRealtime } from "@/lib/realtime";
import { AdminCreateChatModal } from "./AdminCreateChatModal";

interface AdminChatListPageProps {
  userId: string;
}

export function AdminChatListPage({ userId }: AdminChatListPageProps) {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  // 채팅방 목록 실시간 구독
  useChatRoomListRealtime({
    userId,
    userType: "admin",
  });

  return (
    <div className="h-full">
      <ChatList
        basePath="/admin/chat"
        onNewChat={() => setIsCreateModalOpen(true)}
      />

      <AdminCreateChatModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
      />
    </div>
  );
}
</file>

<file path="app/(admin)/admin/chat/_components/AdminCreateChatModal.tsx">
"use client";

/**
 * AdminCreateChatModal - 관리자용 새 채팅 시작 모달
 *
 * 학생 목록에서 선택하여 1:1 채팅 또는 그룹 채팅을 시작합니다.
 */

import { useState, useMemo } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { Avatar } from "@/components/atoms/Avatar";
import { Tabs, type Tab } from "@/components/molecules/Tabs";
import Checkbox from "@/components/atoms/Checkbox";
import {
  startDirectChatAction,
  createChatRoomAction,
} from "@/lib/domains/chat/actions";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { Loader2, MessageSquare, Search, Users } from "lucide-react";
import { cn } from "@/lib/cn";

interface AdminCreateChatModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface Student {
  id: string;
  name: string;
}

const CHAT_TABS: Tab[] = [
  { id: "direct", label: "1:1 채팅" },
  { id: "group", label: "그룹 채팅" },
];

export function AdminCreateChatModal({
  isOpen,
  onClose,
}: AdminCreateChatModalProps) {
  const router = useRouter();

  // 1:1 모드 상태
  const [selectedStudentId, setSelectedStudentId] = useState<string | null>(
    null
  );
  const [searchQuery, setSearchQuery] = useState("");

  // 그룹 모드 상태
  const [activeTab, setActiveTab] = useState<"direct" | "group">("direct");
  const [groupName, setGroupName] = useState("");
  const [selectedStudentIds, setSelectedStudentIds] = useState<Set<string>>(
    new Set()
  );

  // 학생 목록 조회
  const { data: students, isLoading } = useQuery({
    queryKey: ["chat-available-students"],
    queryFn: async () => {
      const supabase = createSupabaseBrowserClient();
      const { data, error } = await supabase
        .from("students")
        .select("id, name")
        .order("name");

      if (error) throw error;
      return data as Student[];
    },
    enabled: isOpen,
  });

  // 검색 필터링
  const filteredStudents = students?.filter((student) =>
    student.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // 그룹 모드 선택 토글
  const toggleStudentSelection = (studentId: string) => {
    setSelectedStudentIds((prev) => {
      const next = new Set(prev);
      if (next.has(studentId)) {
        next.delete(studentId);
      } else {
        next.add(studentId);
      }
      return next;
    });
  };

  // 유효성 검사
  const isSubmitEnabled = useMemo(() => {
    if (activeTab === "direct") {
      return selectedStudentId !== null;
    }
    return groupName.trim().length > 0 && selectedStudentIds.size > 0;
  }, [activeTab, selectedStudentId, groupName, selectedStudentIds]);

  // 채팅 시작/생성
  const startChatMutation = useMutation({
    mutationFn: async () => {
      if (activeTab === "direct") {
        // 1:1 모드: 기존 로직
        const result = await startDirectChatAction(selectedStudentId!, "student");
        if (!result.success) throw new Error(result.error);
        return result.data;
      } else {
        // 그룹 모드: 새 로직
        const memberIds = Array.from(selectedStudentIds);
        const result = await createChatRoomAction({
          type: "group",
          name: groupName.trim(),
          memberIds,
          memberTypes: memberIds.map(() => "student"),
        });
        if (!result.success) throw new Error(result.error);
        return result.data;
      }
    },
    onSuccess: (room) => {
      handleClose();
      router.push(`/admin/chat/${room?.id}`);
    },
  });

  const handleStartChat = () => {
    if (isSubmitEnabled) {
      startChatMutation.mutate();
    }
  };

  const handleClose = () => {
    setSearchQuery("");
    setSelectedStudentId(null);
    setGroupName("");
    setSelectedStudentIds(new Set());
    setActiveTab("direct");
    onClose();
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && handleClose()}
      title={activeTab === "direct" ? "학생과 채팅 시작" : "그룹 채팅 만들기"}
      size="md"
    >
      <DialogContent>
        {/* 탭 선택 */}
        <Tabs
          tabs={CHAT_TABS}
          activeTab={activeTab}
          onChange={(tabId) => setActiveTab(tabId as "direct" | "group")}
          variant="pill"
          fullWidth
        />

        {/* 그룹 이름 입력 (그룹 모드 전용) */}
        {activeTab === "group" && (
          <div className="pt-4">
            <input
              type="text"
              value={groupName}
              onChange={(e) => setGroupName(e.target.value)}
              placeholder="그룹 이름 입력 (필수)"
              className="w-full px-4 py-2 rounded-lg bg-bg-secondary text-sm text-text-primary placeholder:text-text-tertiary border border-transparent focus:border-primary focus:outline-none"
            />
          </div>
        )}

        {/* 검색 */}
        <div className={cn("relative", activeTab === "direct" ? "pt-4" : "pt-3")}>
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary mt-[8px]" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="학생 이름 검색..."
            className="w-full pl-10 pr-4 py-2 rounded-lg bg-bg-secondary text-sm text-text-primary placeholder:text-text-tertiary border border-transparent focus:border-primary focus:outline-none"
          />
        </div>

        {/* 선택 카운트 (그룹 모드 전용) */}
        {activeTab === "group" && selectedStudentIds.size > 0 && (
          <div className="pt-2 text-sm text-primary font-medium">
            {selectedStudentIds.size}명 선택됨
          </div>
        )}

        <div className="pt-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
            </div>
          ) : filteredStudents && filteredStudents.length > 0 ? (
            <div className="space-y-2 max-h-60 overflow-y-auto">
              {filteredStudents.map((student) => {
                const isSelectedDirect = selectedStudentId === student.id;
                const isSelectedGroup = selectedStudentIds.has(student.id);
                const isSelected =
                  activeTab === "direct" ? isSelectedDirect : isSelectedGroup;

                return (
                  <button
                    key={student.id}
                    type="button"
                    onClick={() => {
                      if (activeTab === "direct") {
                        setSelectedStudentId(student.id);
                      } else {
                        toggleStudentSelection(student.id);
                      }
                    }}
                    className={cn(
                      "w-full flex items-center gap-3 p-3 rounded-lg transition-colors",
                      isSelected
                        ? "bg-primary/10 border-2 border-primary"
                        : "hover:bg-bg-secondary border-2 border-transparent"
                    )}
                  >
                    {/* 그룹 모드: 체크박스 표시 */}
                    {activeTab === "group" && (
                      <Checkbox
                        checked={isSelectedGroup}
                        onChange={() => toggleStudentSelection(student.id)}
                        onClick={(e) => e.stopPropagation()}
                      />
                    )}
                    <Avatar name={student.name} size="md" />
                    <div className="flex-1 text-left">
                      <p className="font-medium text-text-primary">
                        {student.name}
                      </p>
                    </div>
                  </button>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-8 text-text-secondary text-sm">
              {searchQuery ? "검색 결과가 없습니다" : "학생이 없습니다"}
            </div>
          )}
        </div>
      </DialogContent>

      <DialogFooter>
        <button
          type="button"
          onClick={handleClose}
          className="flex-1 px-4 py-2 rounded-lg border border-border text-text-secondary hover:bg-bg-secondary transition-colors"
        >
          취소
        </button>
        <button
          type="button"
          onClick={handleStartChat}
          disabled={!isSubmitEnabled || startChatMutation.isPending}
          className={cn(
            "flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors",
            isSubmitEnabled && !startChatMutation.isPending
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          {startChatMutation.isPending ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : activeTab === "direct" ? (
            <MessageSquare className="w-4 h-4" />
          ) : (
            <Users className="w-4 h-4" />
          )}
          {activeTab === "direct" ? "채팅 시작" : "그룹 만들기"}
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="app/(admin)/admin/chat/[roomId]/_components/AdminChatRoomPage.tsx">
"use client";

/**
 * AdminChatRoomPage - 관리자 채팅방 페이지
 */

import { useRouter } from "next/navigation";
import { ChatRoom } from "@/components/chat";

interface AdminChatRoomPageProps {
  roomId: string;
  userId: string;
}

export function AdminChatRoomPage({ roomId, userId }: AdminChatRoomPageProps) {
  const router = useRouter();

  const handleBack = () => {
    router.push("/admin/chat");
  };

  return (
    <div className="h-full">
      <ChatRoom
        roomId={roomId}
        userId={userId}
        onBack={handleBack}
      />
    </div>
  );
}
</file>

<file path="app/(admin)/admin/chat/[roomId]/page.tsx">
/**
 * 관리자 채팅방 페이지
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatRoomPage } from "./_components/AdminChatRoomPage";

export const metadata = {
  title: "채팅 | 관리자 - TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function AdminChatRoomPageRoute({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatRoomPage roomId={roomId} userId={user.userId} />;
}
</file>

<file path="app/(admin)/admin/chat/reports/_components/ReportDetailModal.tsx">
"use client";

/**
 * 신고 상세 모달 컴포넌트
 */

import { useState } from "react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import type { ChatReportWithDetails, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { Loader2, User, MessageSquare, Clock, FileText } from "lucide-react";

interface ReportDetailModalProps {
  isOpen: boolean;
  onClose: () => void;
  report: ChatReportWithDetails;
  onResolve: (
    reportId: string,
    status: "resolved" | "dismissed",
    notes?: string
  ) => void;
  isResolving: boolean;
}

// 사유 라벨
const REASON_LABELS: Record<ReportReason, string> = {
  spam: "스팸",
  harassment: "괴롭힘",
  inappropriate: "부적절한 내용",
  hate_speech: "혐오 발언",
  other: "기타",
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export function ReportDetailModal({
  isOpen,
  onClose,
  report,
  onResolve,
  isResolving,
}: ReportDetailModalProps) {
  const [notes, setNotes] = useState("");

  const handleResolve = (status: "resolved" | "dismissed") => {
    onResolve(report.id, status, notes || undefined);
  };

  const isPending = report.status === "pending";

  return (
    <Dialog
      open={isOpen}
      onOpenChange={onClose}
      title="신고 상세"
      size="lg"
    >
      <DialogContent className="space-y-6 overflow-y-auto max-h-[60vh]">
        {/* 신고 정보 */}
        <section className="space-y-3">
          <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
            <FileText className="w-4 h-4" />
            신고 정보
          </h3>
          <div className="bg-bg-secondary rounded-lg p-4 space-y-2">
            <div className="flex items-center justify-between">
              <span className="text-sm text-text-secondary">사유</span>
              <span className="text-sm font-medium text-text-primary">
                {REASON_LABELS[report.reason]}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-sm text-text-secondary">신고 일시</span>
              <span className="text-sm text-text-primary">
                {formatDate(report.created_at)}
              </span>
            </div>
            {report.description && (
              <div className="pt-2 border-t border-border space-y-1">
                <span className="text-sm text-text-secondary block">
                  상세 설명
                </span>
                <p className="text-sm text-text-primary">
                  {report.description}
                </p>
              </div>
            )}
          </div>
        </section>

        {/* 신고자 정보 */}
        {report.reporter && (
          <section className="space-y-3">
            <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
              <User className="w-4 h-4" />
              신고자
            </h3>
            <div className="bg-bg-secondary rounded-lg p-4">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center">
                  <User className="w-5 h-5 text-primary" />
                </div>
                <div>
                  <p className="text-sm font-medium text-text-primary">
                    {report.reporter.name}
                  </p>
                  <p className="text-xs text-text-tertiary">
                    {report.reporter.type === "admin" ? "관리자" : "학생"}
                  </p>
                </div>
              </div>
            </div>
          </section>
        )}

        {/* 신고된 메시지 */}
        {report.reportedMessage && (
          <section className="space-y-3">
            <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
              <MessageSquare className="w-4 h-4" />
              신고된 메시지
            </h3>
            <div className="bg-error/5 border border-error/20 rounded-lg p-4 space-y-3">
              <p className="text-sm text-text-primary whitespace-pre-wrap">
                {report.reportedMessage.content}
              </p>
              <div className="flex items-center gap-2 pt-3 border-t border-error/10">
                <Clock className="w-3 h-3 text-text-tertiary" />
                <span className="text-xs text-text-tertiary">
                  {formatDate(report.reportedMessage.created_at)}
                </span>
              </div>
            </div>
          </section>
        )}

        {/* 처리 영역 (대기 중인 신고만) */}
        {isPending && (
          <section className="space-y-3 pt-3 border-t border-border">
            <h3 className="text-sm font-medium text-text-primary">처리</h3>
            <textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="처리 메모를 입력하세요 (선택)"
              rows={3}
              className={cn(
                "w-full px-3 py-2 text-sm rounded-lg",
                "bg-bg-secondary text-text-primary",
                "border border-border focus:border-primary focus:outline-none",
                "placeholder:text-text-tertiary resize-none"
              )}
            />
          </section>
        )}

        {/* 이미 처리된 신고 */}
        {!isPending && report.resolution_notes && (
          <section className="space-y-3 pt-3 border-t border-border">
            <h3 className="text-sm font-medium text-text-primary">처리 내역</h3>
            <div className="bg-bg-secondary rounded-lg p-4 space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-sm text-text-secondary">처리 상태</span>
                <span
                  className={cn(
                    "text-sm font-medium",
                    report.status === "resolved"
                      ? "text-success"
                      : "text-text-tertiary"
                  )}
                >
                  {report.status === "resolved" ? "승인됨" : "기각됨"}
                </span>
              </div>
              {report.reviewed_at && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-text-secondary">처리 일시</span>
                  <span className="text-sm text-text-primary">
                    {formatDate(report.reviewed_at)}
                  </span>
                </div>
              )}
              {report.resolution_notes && (
                <div className="pt-2 border-t border-border space-y-1">
                  <span className="text-sm text-text-secondary block">
                    처리 메모
                  </span>
                  <p className="text-sm text-text-primary">
                    {report.resolution_notes}
                  </p>
                </div>
              )}
            </div>
          </section>
        )}
      </DialogContent>

      {/* 푸터 (대기 중인 신고만) */}
      {isPending && (
        <DialogFooter>
          <button
            type="button"
            onClick={() => handleResolve("dismissed")}
            disabled={isResolving}
            className={cn(
              "px-4 py-2 text-sm font-medium rounded-lg",
              "bg-bg-tertiary text-text-primary hover:bg-bg-secondary",
              "transition-colors disabled:opacity-50"
            )}
          >
            기각
          </button>
          <button
            type="button"
            onClick={() => handleResolve("resolved")}
            disabled={isResolving}
            className={cn(
              "px-4 py-2 text-sm font-medium rounded-lg",
              "bg-primary text-white hover:bg-primary-hover",
              "transition-colors disabled:opacity-50",
              "flex items-center justify-center gap-2"
            )}
          >
            {isResolving && <Loader2 className="w-4 h-4 animate-spin" />}
            승인 처리
          </button>
        </DialogFooter>
      )}
    </Dialog>
  );
}
</file>

<file path="app/(admin)/admin/chat/reports/_components/ReportFilter.tsx">
"use client";

/**
 * 신고 필터 컴포넌트
 */

import type { ReportStatus, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";

interface ReportFilterProps {
  statusFilter: ReportStatus | "all";
  reasonFilter: ReportReason | "all";
  onStatusChange: (status: ReportStatus | "all") => void;
  onReasonChange: (reason: ReportReason | "all") => void;
  onReset: () => void;
}

const STATUS_OPTIONS: Array<{ value: ReportStatus | "all"; label: string }> = [
  { value: "all", label: "전체 상태" },
  { value: "pending", label: "대기중" },
  { value: "reviewed", label: "검토중" },
  { value: "resolved", label: "승인됨" },
  { value: "dismissed", label: "기각됨" },
];

const REASON_OPTIONS: Array<{ value: ReportReason | "all"; label: string }> = [
  { value: "all", label: "전체 사유" },
  { value: "spam", label: "스팸" },
  { value: "harassment", label: "괴롭힘" },
  { value: "inappropriate", label: "부적절한 내용" },
  { value: "hate_speech", label: "혐오 발언" },
  { value: "other", label: "기타" },
];

export function ReportFilter({
  statusFilter,
  reasonFilter,
  onStatusChange,
  onReasonChange,
  onReset,
}: ReportFilterProps) {
  const hasActiveFilter = statusFilter !== "all" || reasonFilter !== "all";

  return (
    <div className="flex flex-wrap items-center gap-3 p-4 bg-bg-secondary rounded-lg">
      {/* 상태 필터 */}
      <div className="flex items-center gap-2">
        <label
          htmlFor="status-filter"
          className="text-sm text-text-secondary whitespace-nowrap"
        >
          상태
        </label>
        <select
          id="status-filter"
          value={statusFilter}
          onChange={(e) =>
            onStatusChange(e.target.value as ReportStatus | "all")
          }
          className={cn(
            "px-3 py-1.5 text-sm rounded-lg border border-border",
            "bg-bg-primary text-text-primary",
            "focus:outline-none focus:ring-2 focus:ring-primary/20"
          )}
        >
          {STATUS_OPTIONS.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>

      {/* 사유 필터 */}
      <div className="flex items-center gap-2">
        <label
          htmlFor="reason-filter"
          className="text-sm text-text-secondary whitespace-nowrap"
        >
          사유
        </label>
        <select
          id="reason-filter"
          value={reasonFilter}
          onChange={(e) =>
            onReasonChange(e.target.value as ReportReason | "all")
          }
          className={cn(
            "px-3 py-1.5 text-sm rounded-lg border border-border",
            "bg-bg-primary text-text-primary",
            "focus:outline-none focus:ring-2 focus:ring-primary/20"
          )}
        >
          {REASON_OPTIONS.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>

      {/* 필터 초기화 */}
      {hasActiveFilter && (
        <button
          type="button"
          onClick={onReset}
          className="px-3 py-1.5 text-sm text-text-secondary hover:text-text-primary transition-colors"
        >
          필터 초기화
        </button>
      )}
    </div>
  );
}
</file>

<file path="app/(admin)/admin/chat/reports/_components/ReportListPage.tsx">
"use client";

/**
 * 관리자 신고 관리 페이지 클라이언트 컴포넌트
 */

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  getAllReportsAction,
  resolveReportAction,
  getReportDetailsAction,
} from "@/lib/domains/chat/actions/safety";
import type {
  ChatReport,
  ChatReportWithDetails,
  ReportStatus,
  ReportReason,
} from "@/lib/domains/chat/types";
import { useToast } from "@/components/ui/ToastProvider";
import { ReportTable } from "./ReportTable";
import { ReportFilter } from "./ReportFilter";
import { ReportDetailModal } from "./ReportDetailModal";
import { Loader2, AlertTriangle } from "lucide-react";

export function ReportListPage() {
  const queryClient = useQueryClient();
  const { showToast } = useToast();

  // 필터 상태
  const [statusFilter, setStatusFilter] = useState<ReportStatus | "all">("all");
  const [reasonFilter, setReasonFilter] = useState<ReportReason | "all">("all");

  // 모달 상태
  const [selectedReport, setSelectedReport] =
    useState<ChatReportWithDetails | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isLoadingDetails, setIsLoadingDetails] = useState(false);

  // 신고 목록 조회
  const {
    data: reports,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["admin-chat-reports", statusFilter, reasonFilter],
    queryFn: async () => {
      const result = await getAllReportsAction({
        status: statusFilter,
        reason: reasonFilter,
      });
      if (!result.success) throw new Error(result.error);
      return result.data ?? [];
    },
  });

  // 신고 처리 뮤테이션
  const resolveMutation = useMutation({
    mutationFn: async ({
      reportId,
      status,
      notes,
    }: {
      reportId: string;
      status: "resolved" | "dismissed";
      notes?: string;
    }) => {
      const result = await resolveReportAction(reportId, status, notes);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      showToast("신고가 처리되었습니다.", "success");
      queryClient.invalidateQueries({ queryKey: ["admin-chat-reports"] });
      setIsModalOpen(false);
      setSelectedReport(null);
    },
    onError: (error: Error) => {
      showToast(error.message || "신고 처리에 실패했습니다.", "error");
    },
  });

  // 신고 상세 조회
  const handleViewDetails = async (report: ChatReport) => {
    setIsLoadingDetails(true);
    try {
      const result = await getReportDetailsAction(report.id);
      if (result.success && result.data) {
        setSelectedReport(result.data);
        setIsModalOpen(true);
      } else {
        showToast(result.error || "상세 정보를 불러오지 못했습니다.", "error");
      }
    } catch {
      showToast("상세 정보를 불러오지 못했습니다.", "error");
    } finally {
      setIsLoadingDetails(false);
    }
  };

  // 신고 처리 핸들러
  const handleResolve = (
    reportId: string,
    status: "resolved" | "dismissed",
    notes?: string
  ) => {
    resolveMutation.mutate({ reportId, status, notes });
  };

  // 필터 초기화
  const handleResetFilters = () => {
    setStatusFilter("all");
    setReasonFilter("all");
  };

  return (
    <div className="p-6 space-y-6">
      {/* 헤더 */}
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <h1 className="text-2xl font-bold text-text-primary">신고 관리</h1>
          <p className="text-sm text-text-secondary">
            사용자 신고를 검토하고 처리합니다
          </p>
        </div>
        <button
          type="button"
          onClick={() => refetch()}
          className="px-4 py-2 text-sm bg-bg-secondary hover:bg-bg-tertiary rounded-lg transition-colors"
        >
          새로고침
        </button>
      </div>

      {/* 필터 */}
      <ReportFilter
        statusFilter={statusFilter}
        reasonFilter={reasonFilter}
        onStatusChange={setStatusFilter}
        onReasonChange={setReasonFilter}
        onReset={handleResetFilters}
      />

      {/* 테이블 또는 로딩/에러 상태 */}
      {isLoading ? (
        <div className="flex items-center justify-center py-12">
          <Loader2 className="w-8 h-8 animate-spin text-text-tertiary" />
        </div>
      ) : error ? (
        <div className="flex flex-col items-center justify-center py-12 text-center gap-4">
          <AlertTriangle className="w-12 h-12 text-warning" />
          <p className="text-text-secondary">신고 목록을 불러오지 못했습니다</p>
          <button
            type="button"
            onClick={() => refetch()}
            className="px-4 py-2 text-sm bg-primary text-white rounded-lg hover:bg-primary-hover"
          >
            다시 시도
          </button>
        </div>
      ) : reports && reports.length > 0 ? (
        <ReportTable
          reports={reports}
          onViewDetails={handleViewDetails}
          isLoadingDetails={isLoadingDetails}
        />
      ) : (
        <div className="flex flex-col items-center justify-center py-12 text-center bg-bg-secondary rounded-lg">
          <p className="text-text-secondary">신고 내역이 없습니다</p>
        </div>
      )}

      {/* 상세 모달 */}
      {selectedReport && (
        <ReportDetailModal
          isOpen={isModalOpen}
          onClose={() => {
            setIsModalOpen(false);
            setSelectedReport(null);
          }}
          report={selectedReport}
          onResolve={handleResolve}
          isResolving={resolveMutation.isPending}
        />
      )}
    </div>
  );
}
</file>

<file path="app/(admin)/admin/chat/reports/_components/ReportTable.tsx">
"use client";

/**
 * 신고 목록 테이블 컴포넌트
 */

import type { ChatReport, ReportStatus, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { Eye, Loader2 } from "lucide-react";

interface ReportTableProps {
  reports: ChatReport[];
  onViewDetails: (report: ChatReport) => void;
  isLoadingDetails: boolean;
}

// 상태별 스타일
const STATUS_STYLES: Record<ReportStatus, { bg: string; text: string; label: string }> = {
  pending: { bg: "bg-warning/10", text: "text-warning", label: "대기중" },
  reviewed: { bg: "bg-info/10", text: "text-info", label: "검토중" },
  resolved: { bg: "bg-success/10", text: "text-success", label: "승인됨" },
  dismissed: { bg: "bg-text-tertiary/10", text: "text-text-tertiary", label: "기각됨" },
};

// 사유별 스타일
const REASON_STYLES: Record<ReportReason, { bg: string; text: string; label: string }> = {
  spam: { bg: "bg-error/10", text: "text-error", label: "스팸" },
  harassment: { bg: "bg-warning/10", text: "text-warning", label: "괴롭힘" },
  inappropriate: { bg: "bg-warning/10", text: "text-warning", label: "부적절" },
  hate_speech: { bg: "bg-error/10", text: "text-error", label: "혐오 발언" },
  other: { bg: "bg-text-tertiary/10", text: "text-text-tertiary", label: "기타" },
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export function ReportTable({
  reports,
  onViewDetails,
  isLoadingDetails,
}: ReportTableProps) {
  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="border-b border-border">
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              신고일시
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              사유
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              상태
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              설명
            </th>
            <th className="px-4 py-3 text-center text-sm font-medium text-text-secondary">
              액션
            </th>
          </tr>
        </thead>
        <tbody>
          {reports.map((report) => {
            const statusStyle = STATUS_STYLES[report.status];
            const reasonStyle = REASON_STYLES[report.reason];

            return (
              <tr
                key={report.id}
                className="border-b border-border hover:bg-bg-secondary/50 transition-colors"
              >
                {/* 신고일시 */}
                <td className="px-4 py-3 text-sm text-text-primary whitespace-nowrap">
                  {formatDate(report.created_at)}
                </td>

                {/* 사유 */}
                <td className="px-4 py-3">
                  <span
                    className={cn(
                      "inline-flex px-2 py-0.5 text-xs font-medium rounded-full",
                      reasonStyle.bg,
                      reasonStyle.text
                    )}
                  >
                    {reasonStyle.label}
                  </span>
                </td>

                {/* 상태 */}
                <td className="px-4 py-3">
                  <span
                    className={cn(
                      "inline-flex px-2 py-0.5 text-xs font-medium rounded-full",
                      statusStyle.bg,
                      statusStyle.text
                    )}
                  >
                    {statusStyle.label}
                  </span>
                </td>

                {/* 설명 */}
                <td className="px-4 py-3 text-sm text-text-secondary max-w-xs truncate">
                  {report.description || "-"}
                </td>

                {/* 액션 */}
                <td className="px-4 py-3 text-center">
                  <button
                    type="button"
                    onClick={() => onViewDetails(report)}
                    disabled={isLoadingDetails}
                    className={cn(
                      "inline-flex items-center gap-1 px-3 py-1.5 text-sm",
                      "bg-primary text-white rounded-lg",
                      "hover:bg-primary-hover transition-colors",
                      "disabled:opacity-50 disabled:cursor-not-allowed"
                    )}
                  >
                    {isLoadingDetails ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Eye className="w-4 h-4" />
                    )}
                    상세
                  </button>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="app/(admin)/admin/chat/reports/page.tsx">
/**
 * 관리자 채팅 신고 관리 페이지
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ReportListPage } from "./_components/ReportListPage";

export const metadata = {
  title: "신고 관리 | 관리자 - TimeLevelUp",
};

export default async function AdminChatReportsPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ReportListPage />;
}
</file>

<file path="app/(admin)/admin/chat/page.tsx">
/**
 * 관리자 채팅 목록 페이지
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatListPage } from "./_components/AdminChatListPage";

export const metadata = {
  title: "채팅 | 관리자 - TimeLevelUp",
};

export default async function AdminChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatListPage userId={user.userId} />;
}
</file>

<file path="app/(student)/chat/_components/ChatListPage.tsx">
"use client";

/**
 * ChatListPage - 채팅 목록 페이지 클라이언트 컴포넌트
 */

import { useState } from "react";
import { ChatList } from "@/components/chat";
import { useChatRoomListRealtime } from "@/lib/realtime";
import { CreateChatModal } from "./CreateChatModal";

interface ChatListPageProps {
  userId: string;
  basePath: string;
}

export function ChatListPage({ userId, basePath }: ChatListPageProps) {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  // 채팅방 목록 실시간 구독
  useChatRoomListRealtime({
    userId,
    userType: "student",
  });

  return (
    <div className="h-full">
      <ChatList
        basePath={basePath}
        onNewChat={() => setIsCreateModalOpen(true)}
      />

      <CreateChatModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        basePath={basePath}
      />
    </div>
  );
}
</file>

<file path="app/(student)/chat/_components/CreateChatModal.tsx">
"use client";

/**
 * CreateChatModal - 새 채팅 시작 모달
 *
 * 관리자 목록에서 선택하여 1:1 채팅을 시작합니다.
 */

import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { Avatar } from "@/components/atoms/Avatar";
import { startDirectChatAction } from "@/lib/domains/chat/actions";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { Loader2, MessageSquare } from "lucide-react";
import { cn } from "@/lib/cn";

interface CreateChatModalProps {
  isOpen: boolean;
  onClose: () => void;
  basePath: string;
}

interface AdminUser {
  id: string;
  role: string;
  // Note: admin_users 테이블에 name 컬럼이 없어 역할로만 표시
}

export function CreateChatModal({
  isOpen,
  onClose,
  basePath,
}: CreateChatModalProps) {
  const router = useRouter();
  const [selectedAdminId, setSelectedAdminId] = useState<string | null>(null);

  // 관리자 목록 조회 (같은 tenant의 admin/consultant)
  const { data: admins, isLoading } = useQuery({
    queryKey: ["chat-available-admins"],
    queryFn: async () => {
      const supabase = createSupabaseBrowserClient();
      const { data, error } = await supabase
        .from("admin_users")
        .select("id, role")
        .in("role", ["admin", "consultant"]);

      if (error) throw error;
      return data as AdminUser[];
    },
    enabled: isOpen,
  });

  // 채팅 시작
  const startChatMutation = useMutation({
    mutationFn: async (adminId: string) => {
      const result = await startDirectChatAction(adminId, "admin");
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: (room) => {
      onClose();
      router.push(`${basePath}/${room?.id}`);
    },
  });

  const handleStartChat = () => {
    if (selectedAdminId) {
      startChatMutation.mutate(selectedAdminId);
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && onClose()}
      title="새 채팅 시작"
      description="대화할 상담사/관리자를 선택하세요"
      size="md"
    >
      <DialogContent>
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
          </div>
        ) : admins && admins.length > 0 ? (
          <div className="space-y-2 max-h-60 overflow-y-auto">
            {admins.map((admin) => (
              <button
                key={admin.id}
                type="button"
                onClick={() => setSelectedAdminId(admin.id)}
                className={cn(
                  "w-full flex items-center gap-3 p-3 rounded-lg transition-colors",
                  selectedAdminId === admin.id
                    ? "bg-primary/10 border-2 border-primary"
                    : "hover:bg-bg-secondary border-2 border-transparent"
                )}
              >
                <Avatar name={admin.role} size="md" />
                <div className="flex-1 text-left">
                  <p className="font-medium text-text-primary">
                    {admin.role === "admin" ? "관리자" : "상담사"}
                  </p>
                  <p className="text-xs text-text-tertiary">
                    {admin.role === "admin" ? "학원 관리자" : "학습 상담사"}
                  </p>
                </div>
              </button>
            ))}
          </div>
        ) : (
          <div className="text-center py-8 text-text-secondary text-sm">
            대화할 수 있는 관리자가 없습니다
          </div>
        )}
      </DialogContent>

      <DialogFooter>
        <button
          type="button"
          onClick={onClose}
          className="flex-1 px-4 py-2 rounded-lg border border-border text-text-secondary hover:bg-bg-secondary transition-colors"
        >
          취소
        </button>
        <button
          type="button"
          onClick={handleStartChat}
          disabled={!selectedAdminId || startChatMutation.isPending}
          className={cn(
            "flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors",
            selectedAdminId && !startChatMutation.isPending
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          {startChatMutation.isPending ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <MessageSquare className="w-4 h-4" />
          )}
          채팅 시작
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="app/(student)/chat/[roomId]/_components/ChatRoomPage.tsx">
"use client";

/**
 * ChatRoomPage - 채팅방 페이지 클라이언트 컴포넌트
 */

import { useRouter } from "next/navigation";
import { ChatRoom } from "@/components/chat";

interface ChatRoomPageProps {
  roomId: string;
  userId: string;
  basePath: string;
}

export function ChatRoomPage({ roomId, userId, basePath }: ChatRoomPageProps) {
  const router = useRouter();

  const handleBack = () => {
    router.push(basePath);
  };

  return (
    <div className="h-full">
      <ChatRoom
        roomId={roomId}
        userId={userId}
        onBack={handleBack}
      />
    </div>
  );
}
</file>

<file path="app/(student)/chat/[roomId]/page.tsx">
/**
 * 학생 채팅방 페이지
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatRoomPage } from "./_components/ChatRoomPage";

export const metadata = {
  title: "채팅 | TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function StudentChatRoomPage({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatRoomPage roomId={roomId} userId={user.userId} basePath="/chat" />;
}
</file>

<file path="app/(student)/chat/page.tsx">
/**
 * 학생 채팅 목록 페이지
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatListPage } from "./_components/ChatListPage";

export const metadata = {
  title: "채팅 | TimeLevelUp",
};

export default async function StudentChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatListPage userId={user.userId} basePath="/chat" />;
}
</file>

<file path="components/chat/atoms/AnnouncementBanner.tsx">
"use client";

/**
 * AnnouncementBanner - 채팅방 공지 배너
 *
 * 채팅방 상단에 공지를 표시합니다.
 * 클릭하면 전체 공지를 볼 수 있고, 권한이 있으면 편집/삭제 가능.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { Megaphone, X, ChevronDown, ChevronUp, Edit2 } from "lucide-react";
import type { AnnouncementInfo } from "@/lib/domains/chat/types";

interface AnnouncementBannerProps {
  /** 공지 정보 */
  announcement: AnnouncementInfo;
  /** 공지 설정/삭제 권한 여부 */
  canEdit: boolean;
  /** 공지 편집 버튼 클릭 */
  onEdit?: () => void;
  /** 공지 삭제 버튼 클릭 */
  onDelete?: () => void;
}

function AnnouncementBannerComponent({
  announcement,
  canEdit,
  onEdit,
  onDelete,
}: AnnouncementBannerProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  // 공지 내용이 길면 축약 표시
  const isLongContent = announcement.content.length > 100;
  const displayContent = isExpanded
    ? announcement.content
    : announcement.content.slice(0, 100) + (isLongContent ? "..." : "");

  return (
    <div className="bg-warning-50 dark:bg-warning-900/20 border-b border-warning-200 dark:border-warning-900/30">
      <div className="flex items-start gap-2 px-4 py-2">
        <Megaphone className="w-4 h-4 text-warning-600 dark:text-warning-400 flex-shrink-0 mt-0.5" />

        <div className="flex-1 min-w-0">
          {/* 공지 내용 */}
          <div
            className={cn(
              "text-sm text-text-primary whitespace-pre-wrap break-words",
              !isExpanded && isLongContent && "cursor-pointer"
            )}
            onClick={() => isLongContent && setIsExpanded(!isExpanded)}
          >
            {displayContent}
          </div>

          {/* 작성자 + 시간 */}
          <div className="flex items-center gap-2 mt-1 text-xs text-text-tertiary">
            <span>{announcement.authorName}</span>
            <span>·</span>
            <span>
              {new Date(announcement.createdAt).toLocaleDateString("ko-KR", {
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })}
            </span>
          </div>
        </div>

        {/* 액션 버튼들 */}
        <div className="flex items-center gap-1 flex-shrink-0">
          {/* 펼침/접기 버튼 (긴 내용일 때만) */}
          {isLongContent && (
            <button
              type="button"
              onClick={() => setIsExpanded(!isExpanded)}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label={isExpanded ? "접기" : "펼치기"}
            >
              {isExpanded ? (
                <ChevronUp className="w-4 h-4 text-text-tertiary" />
              ) : (
                <ChevronDown className="w-4 h-4 text-text-tertiary" />
              )}
            </button>
          )}

          {/* 편집 버튼 (권한 있을 때) */}
          {canEdit && onEdit && (
            <button
              type="button"
              onClick={onEdit}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label="공지 편집"
            >
              <Edit2 className="w-3.5 h-3.5 text-text-tertiary hover:text-primary" />
            </button>
          )}

          {/* 삭제 버튼 (권한 있을 때) */}
          {canEdit && onDelete && (
            <button
              type="button"
              onClick={onDelete}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label="공지 삭제"
            >
              <X className="w-3.5 h-3.5 text-text-tertiary hover:text-error" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export const AnnouncementBanner = memo(AnnouncementBannerComponent);
</file>

<file path="components/chat/atoms/DateDivider.tsx">
"use client";

/**
 * DateDivider - 날짜 구분선 컴포넌트
 *
 * 채팅 메시지 목록에서 날짜가 바뀌는 지점에 표시됩니다.
 */

import { memo } from "react";

interface DateDividerProps {
  /** 포맷된 날짜 텍스트 (예: "2024년 1월 15일 월요일") */
  date: string;
}

function DateDividerComponent({ date }: DateDividerProps) {
  return (
    <div className="flex items-center justify-center py-4">
      <div className="flex items-center gap-3 w-full max-w-md">
        {/* 왼쪽 선 */}
        <div className="flex-1 h-px bg-secondary-200 dark:bg-secondary-700" />

        {/* 날짜 텍스트 */}
        <span className="text-xs text-text-tertiary font-medium px-2 whitespace-nowrap">
          {date}
        </span>

        {/* 오른쪽 선 */}
        <div className="flex-1 h-px bg-secondary-200 dark:bg-secondary-700" />
      </div>
    </div>
  );
}

export const DateDivider = memo(DateDividerComponent);
</file>

<file path="components/chat/atoms/MessageBubble.tsx">
"use client";

/**
 * MessageBubble - 채팅 메시지 버블
 *
 * 단일 채팅 메시지를 표시합니다.
 * 본인/타인 메시지에 따라 스타일이 달라집니다.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { format } from "date-fns";
import { ko } from "date-fns/locale";
import { AlertCircle, Loader2 } from "lucide-react";
import type { ReactionSummary, ReactionEmoji, ReplyTargetInfo } from "@/lib/domains/chat/types";
import { ReactionPills } from "./ReactionPills";
import { ReactionPicker } from "./ReactionPicker";
import { useLongPress } from "@/lib/hooks/useLongPress";

interface MessageBubbleProps {
  /** 메시지 내용 */
  content: string;
  /** 본인 메시지 여부 */
  isOwn: boolean;
  /** 발신자 이름 (타인 메시지일 때 표시) */
  senderName?: string;
  /** 메시지 생성 시간 */
  createdAt: string;
  /** 시스템 메시지 여부 */
  isSystem?: boolean;
  /** 수정된 메시지 여부 */
  isEdited?: boolean;
  /** 읽지 않은 사람 수 (본인 메시지에만 표시) */
  unreadCount?: number;
  /** 편집 가능 여부 (5분 이내 본인 메시지) */
  canEdit?: boolean;
  /** 리액션 요약 목록 */
  reactions?: ReactionSummary[];
  /** 답장 원본 메시지 정보 */
  replyTarget?: ReplyTargetInfo | null;
  /** 고정된 메시지 여부 */
  isPinned?: boolean;
  /** 고정 권한 여부 */
  canPin?: boolean;
  /** 발신자 이름 표시 여부 (그룹핑용, 기본값: true) */
  showName?: boolean;
  /** 시간 표시 여부 (그룹핑용, 기본값: true) */
  showTime?: boolean;
  /** 그룹핑된 메시지 여부 (간격 축소용) */
  isGrouped?: boolean;
  /** 리액션 토글 콜백 */
  onToggleReaction?: (emoji: ReactionEmoji) => void;
  /** 답장 클릭 콜백 */
  onReply?: () => void;
  /** 답장 원본 클릭 콜백 (해당 메시지로 스크롤) */
  onReplyTargetClick?: () => void;
  /** 편집 클릭 콜백 */
  onEdit?: () => void;
  /** 삭제 클릭 콜백 */
  onDelete?: () => void;
  /** 신고 클릭 콜백 (타인 메시지) */
  onReport?: () => void;
  /** 고정/해제 클릭 콜백 */
  onTogglePin?: () => void;
  /** 클릭 시 콜백 (길게 눌러 신고 등) */
  onLongPress?: () => void;
  /** 전송 실패 상태 */
  isError?: boolean;
  /** 재전송 중 상태 */
  isRetrying?: boolean;
  /** 재전송 콜백 */
  onRetry?: () => void;
  /** 전송 실패 메시지 삭제 콜백 */
  onRemoveFailed?: () => void;
}

function MessageBubbleComponent({
  content,
  isOwn,
  senderName,
  createdAt,
  isSystem = false,
  isEdited = false,
  unreadCount,
  canEdit = false,
  reactions = [],
  replyTarget,
  isPinned = false,
  canPin = false,
  showName = true,
  showTime = true,
  isGrouped = false,
  onToggleReaction,
  onReply,
  onReplyTargetClick,
  onEdit,
  onDelete,
  onReport,
  onTogglePin,
  onLongPress,
  isError = false,
  isRetrying = false,
  onRetry,
  onRemoveFailed,
}: MessageBubbleProps) {
  const [showPicker, setShowPicker] = useState(false);

  // Long press 핸들러 (모바일 터치 + 데스크톱 우클릭)
  const longPressHandlers = useLongPress({
    onLongPress: () => onLongPress?.(),
    disabled: isSystem,
  });

  // 시스템 메시지 (입장/퇴장 등)
  if (isSystem) {
    return (
      <div className="flex justify-center py-2">
        <span className="text-xs text-text-tertiary bg-secondary-100 dark:bg-secondary-800 px-3 py-1 rounded-full">
          {content}
        </span>
      </div>
    );
  }

  // 시간 포맷 (절대 시간: "오후 3:45")
  const formattedTime = format(new Date(createdAt), "a h:mm", { locale: ko });

  const handleReactionSelect = (emoji: ReactionEmoji) => {
    onToggleReaction?.(emoji);
    setShowPicker(false);
  };

  return (
    <div
      {...longPressHandlers}
      className={cn(
        "group flex flex-col gap-1 max-w-[80%]",
        isOwn ? "items-end ml-auto" : "items-start mr-auto"
      )}
    >
      {/* 발신자 이름 (타인 메시지, 그룹핑 시 첫 메시지만) */}
      {!isOwn && showName && senderName && (
        <span className="text-xs text-text-secondary pl-1">{senderName}</span>
      )}

      {/* 메시지 버블 + 리액션 영역 */}
      <div className="relative flex flex-col gap-1">
        {/* 답장 원본 메시지 표시 */}
        {replyTarget && (
          <button
            type="button"
            onClick={onReplyTargetClick}
            className={cn(
              "px-3 py-1.5 rounded-t-lg text-xs text-left cursor-pointer",
              "bg-secondary-50 dark:bg-secondary-900/50",
              "border-l-2 border-primary",
              "hover:bg-secondary-100 dark:hover:bg-secondary-900 transition-colors"
            )}
          >
            <p className="font-medium text-primary">{replyTarget.senderName}</p>
            <p className="text-text-secondary truncate max-w-[200px]">
              {replyTarget.isDeleted ? "삭제된 메시지" : replyTarget.content}
            </p>
          </button>
        )}

        {/* 메시지 버블 */}
        <div
          className={cn(
            "px-4 py-2 rounded-2xl break-words whitespace-pre-wrap",
            isOwn
              ? "bg-primary-500 text-white rounded-br-sm"
              : "bg-secondary-100 dark:bg-secondary-800 text-text-primary rounded-bl-sm",
            replyTarget && "rounded-t-none",
            isError && "opacity-60"
          )}
        >
          {content}
        </div>

        {/* 전송 실패 표시 (본인 메시지 + 에러 상태) */}
        {isOwn && isError && (
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={onRetry}
              disabled={isRetrying}
              className={cn(
                "flex items-center gap-1 text-xs text-error",
                "hover:underline transition-opacity",
                isRetrying && "opacity-50 cursor-not-allowed"
              )}
            >
              {isRetrying ? (
                <>
                  <Loader2 className="w-3 h-3 animate-spin" />
                  <span>재전송 중...</span>
                </>
              ) : (
                <>
                  <AlertCircle className="w-3 h-3" />
                  <span>전송 실패 - 다시 시도</span>
                </>
              )}
            </button>
            {!isRetrying && onRemoveFailed && (
              <button
                type="button"
                onClick={onRemoveFailed}
                className="text-xs text-text-tertiary hover:text-error transition-colors"
                aria-label="전송 취소 및 삭제"
              >
                삭제
              </button>
            )}
          </div>
        )}

        {/* 리액션 표시 */}
        {reactions.length > 0 && (
          <div className={cn(isOwn ? "flex justify-end" : "flex justify-start")}>
            <ReactionPills
              reactions={reactions}
              onToggle={(emoji) => onToggleReaction?.(emoji)}
              disabled={!onToggleReaction}
            />
          </div>
        )}

        {/* 리액션 피커 (호버 시 + 버튼) */}
        {onToggleReaction && (
          <div
            className={cn(
              "absolute top-0 opacity-0 group-hover:opacity-100 transition-opacity",
              isOwn ? "-left-8" : "-right-8"
            )}
          >
            <button
              type="button"
              onClick={() => setShowPicker(!showPicker)}
              className={cn(
                "w-6 h-6 flex items-center justify-center",
                "rounded-full bg-bg-secondary hover:bg-bg-tertiary",
                "text-text-tertiary hover:text-text-secondary",
                "transition-colors text-sm"
              )}
              aria-label="리액션 추가"
            >
              +
            </button>
          </div>
        )}

        {/* 리액션 피커 팝업 */}
        {showPicker && onToggleReaction && (
          <ReactionPicker
            onSelect={handleReactionSelect}
            onClose={() => setShowPicker(false)}
            className={cn(
              "bottom-full pb-1",
              isOwn ? "right-0" : "left-0"
            )}
          />
        )}
      </div>

      {/* 하단 정보 (시간, 수정됨, 읽음 수) - 그룹핑 시 마지막 메시지만 표시 */}
      {showTime && (
        <div
          className={cn(
            "flex items-center gap-2 text-xs text-text-tertiary",
            isOwn ? "flex-row-reverse" : "flex-row"
          )}
        >
          <span>{formattedTime}</span>
          {isEdited && (
            <span className="text-text-tertiary">(수정됨)</span>
          )}
          {isOwn && unreadCount !== undefined && unreadCount > 0 && (
            <span className="text-primary font-medium">{unreadCount}</span>
          )}
        </div>
      )}

      {/* 액션 메뉴 (마우스 호버 시 표시) */}
      <div
        className={cn(
          "flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity",
          isOwn ? "flex-row-reverse" : "flex-row"
        )}
      >
        {onReply && (
          <button
            type="button"
            onClick={onReply}
            className="text-xs text-text-tertiary hover:text-primary px-1"
          >
            답장
          </button>
        )}
        {canPin && onTogglePin && (
          <button
            type="button"
            onClick={onTogglePin}
            className={cn(
              "text-xs px-1",
              isPinned
                ? "text-primary hover:text-text-tertiary"
                : "text-text-tertiary hover:text-primary"
            )}
          >
            {isPinned ? "고정 해제" : "고정"}
          </button>
        )}
        {isOwn && canEdit && onEdit && (
          <button
            type="button"
            onClick={onEdit}
            className="text-xs text-text-tertiary hover:text-text-secondary px-1"
          >
            편집
          </button>
        )}
        {isOwn && onDelete && (
          <button
            type="button"
            onClick={onDelete}
            className="text-xs text-text-tertiary hover:text-error px-1"
          >
            삭제
          </button>
        )}
        {!isOwn && onReport && (
          <button
            type="button"
            onClick={onReport}
            className="text-xs text-text-tertiary hover:text-error px-1"
          >
            신고
          </button>
        )}
      </div>
    </div>
  );
}

export const MessageBubble = memo(MessageBubbleComponent);
</file>

<file path="components/chat/atoms/OnlineStatus.tsx">
"use client";

/**
 * OnlineStatus - 온라인 상태 표시
 *
 * 사용자의 접속 상태를 녹색 점으로 표시합니다.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";

interface OnlineStatusProps {
  /** 온라인 여부 */
  isOnline: boolean;
  /** 크기 */
  size?: "sm" | "md";
  /** 추가 클래스 */
  className?: string;
}

function OnlineStatusComponent({
  isOnline,
  size = "sm",
  className,
}: OnlineStatusProps) {
  return (
    <span
      className={cn(
        "inline-block rounded-full flex-shrink-0",
        size === "sm" ? "w-2 h-2" : "w-3 h-3",
        isOnline ? "bg-success" : "bg-text-tertiary",
        className
      )}
      aria-label={isOnline ? "온라인" : "오프라인"}
    />
  );
}

export const OnlineStatus = memo(OnlineStatusComponent);
</file>

<file path="components/chat/atoms/ReactionPicker.tsx">
"use client";

/**
 * ReactionPicker - 리액션 이모지 선택 팝업
 *
 * 메시지에 추가할 리액션 이모지를 선택합니다.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import { useClickOutside, useEscapeKey } from "@/lib/accessibility/hooks";
import { REACTION_EMOJIS, type ReactionEmoji } from "@/lib/domains/chat/types";

interface ReactionPickerProps {
  /** 이모지 선택 콜백 */
  onSelect: (emoji: ReactionEmoji) => void;
  /** 닫기 콜백 */
  onClose: () => void;
  /** 추가 클래스 */
  className?: string;
}

function ReactionPickerComponent({
  onSelect,
  onClose,
  className,
}: ReactionPickerProps) {
  // 외부 클릭 시 닫기
  const containerRef = useClickOutside<HTMLDivElement>(onClose);

  // ESC 키로 닫기
  useEscapeKey(onClose);

  const handleSelect = (emoji: ReactionEmoji) => {
    onSelect(emoji);
    onClose();
  };

  return (
    <div
      ref={containerRef}
      className={cn(
        "absolute z-50",
        "flex items-center gap-1 p-1.5",
        "bg-bg-primary rounded-lg shadow-lg",
        "border border-border",
        "animate-in fade-in-0 zoom-in-95 duration-150",
        className
      )}
      role="menu"
      aria-label="리액션 선택"
    >
      {REACTION_EMOJIS.map((emoji) => (
        <button
          key={emoji}
          type="button"
          onClick={() => handleSelect(emoji)}
          className={cn(
            "w-8 h-8 flex items-center justify-center",
            "rounded-md text-lg",
            "hover:bg-bg-secondary hover:scale-110",
            "active:scale-95",
            "transition-all duration-100"
          )}
          role="menuitem"
          aria-label={`${emoji} 리액션 추가`}
        >
          {emoji}
        </button>
      ))}
    </div>
  );
}

export const ReactionPicker = memo(ReactionPickerComponent);
</file>

<file path="components/chat/atoms/ReactionPills.tsx">
"use client";

/**
 * ReactionPills - 메시지 리액션 표시
 *
 * 메시지 하단에 리액션 요약을 표시합니다.
 * 클릭 시 해당 리액션을 토글합니다.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import type { ReactionSummary, ReactionEmoji } from "@/lib/domains/chat/types";

interface ReactionPillsProps {
  /** 리액션 요약 목록 */
  reactions: ReactionSummary[];
  /** 리액션 토글 콜백 */
  onToggle: (emoji: ReactionEmoji) => void;
  /** 비활성화 여부 */
  disabled?: boolean;
  /** 추가 클래스 */
  className?: string;
}

function ReactionPillsComponent({
  reactions,
  onToggle,
  disabled = false,
  className,
}: ReactionPillsProps) {
  // 리액션이 없으면 렌더링하지 않음
  if (reactions.length === 0) {
    return null;
  }

  return (
    <div className={cn("flex flex-wrap items-center gap-1", className)}>
      {reactions.map((reaction) => (
        <button
          key={reaction.emoji}
          type="button"
          onClick={() => onToggle(reaction.emoji)}
          disabled={disabled}
          className={cn(
            "inline-flex items-center gap-1 px-2 py-0.5 rounded-full",
            "text-sm transition-colors",
            "hover:bg-bg-tertiary active:scale-95",
            "disabled:opacity-50 disabled:cursor-not-allowed",
            reaction.hasReacted
              ? "bg-primary/10 border border-primary/30"
              : "bg-bg-secondary border border-transparent"
          )}
          aria-label={`${reaction.emoji} ${reaction.count}명이 리액션함${
            reaction.hasReacted ? ", 내 리액션" : ""
          }`}
        >
          <span className="text-sm leading-none">{reaction.emoji}</span>
          <span
            className={cn(
              "text-xs font-medium",
              reaction.hasReacted ? "text-primary" : "text-text-secondary"
            )}
          >
            {reaction.count}
          </span>
        </button>
      ))}
    </div>
  );
}

export const ReactionPills = memo(ReactionPillsComponent);
</file>

<file path="components/chat/atoms/TypingIndicator.tsx">
"use client";

/**
 * TypingIndicator - 타이핑 중 표시
 *
 * 다른 사용자가 메시지를 입력 중일 때 표시합니다.
 */

import { memo } from "react";
import type { PresenceUser } from "@/lib/domains/chat/types";

interface TypingIndicatorProps {
  /** 타이핑 중인 사용자 목록 */
  users: PresenceUser[];
}

function TypingIndicatorComponent({ users }: TypingIndicatorProps) {
  if (users.length === 0) return null;

  // 최대 2명까지 이름 표시
  const displayNames =
    users.length <= 2
      ? users.map((u) => u.name).join(", ")
      : `${users[0].name} 외 ${users.length - 1}명`;

  return (
    <div className="flex items-center gap-2 px-4 py-2 text-sm text-text-tertiary">
      {/* 애니메이션 점 */}
      <div className="flex items-center gap-0.5">
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:0ms]" />
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:150ms]" />
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:300ms]" />
      </div>

      {/* 텍스트 */}
      <span>{displayNames}님이 입력 중...</span>
    </div>
  );
}

export const TypingIndicator = memo(TypingIndicatorComponent);
</file>

<file path="components/chat/atoms/UnreadBadge.tsx">
"use client";

/**
 * UnreadBadge - 읽지 않은 메시지 수 배지
 */

import { memo } from "react";
import { cn } from "@/lib/cn";

interface UnreadBadgeProps {
  /** 읽지 않은 메시지 수 */
  count: number;
  /** 크기 */
  size?: "sm" | "md";
  /** 추가 클래스 */
  className?: string;
}

function UnreadBadgeComponent({
  count,
  size = "md",
  className,
}: UnreadBadgeProps) {
  if (count <= 0) return null;

  const displayCount = count > 99 ? "99+" : count.toString();

  return (
    <span
      className={cn(
        "inline-flex items-center justify-center rounded-full bg-primary text-white font-medium",
        size === "sm" ? "min-w-[18px] h-[18px] text-[10px] px-1" : "min-w-[22px] h-[22px] text-xs px-1.5",
        className
      )}
    >
      {displayCount}
    </span>
  );
}

export const UnreadBadge = memo(UnreadBadgeComponent);
</file>

<file path="components/chat/molecules/AnnouncementDialog.tsx">
"use client";

/**
 * AnnouncementDialog - 채팅방 공지 설정 다이얼로그
 *
 * 공지 작성/편집을 위한 모달 다이얼로그입니다.
 */

import { memo, useState, useEffect } from "react";
import { Dialog } from "@/components/ui/Dialog";
import Button from "@/components/atoms/Button";

interface AnnouncementDialogProps {
  /** 다이얼로그 열림 여부 */
  open: boolean;
  /** 다이얼로그 닫기 */
  onOpenChange: (open: boolean) => void;
  /** 현재 공지 내용 (편집 시) */
  currentContent?: string | null;
  /** 저장 콜백 */
  onSave: (content: string) => void;
  /** 저장 중 여부 */
  isSaving?: boolean;
}

function AnnouncementDialogComponent({
  open,
  onOpenChange,
  currentContent,
  onSave,
  isSaving = false,
}: AnnouncementDialogProps) {
  const [content, setContent] = useState(currentContent ?? "");

  // 다이얼로그가 열릴 때 현재 공지 내용으로 초기화
  useEffect(() => {
    if (open) {
      setContent(currentContent ?? "");
    }
  }, [open, currentContent]);

  const handleSave = () => {
    const trimmedContent = content.trim();
    if (trimmedContent) {
      onSave(trimmedContent);
    }
  };

  const isValidContent = content.trim().length > 0 && content.trim().length <= 500;
  const characterCount = content.length;

  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title={currentContent ? "공지 편집" : "공지 설정"}
      size="md"
    >
      <div className="space-y-4">
        {/* 입력 영역 */}
        <div>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="채팅방 공지를 입력하세요..."
            className="w-full h-32 p-3 text-sm border border-border rounded-lg resize-none
              focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent
              bg-background text-text-primary placeholder:text-text-tertiary"
            maxLength={500}
            disabled={isSaving}
          />
          <div className="flex justify-end mt-1">
            <span
              className={`text-xs ${
                characterCount > 500 ? "text-error" : "text-text-tertiary"
              }`}
            >
              {characterCount}/500
            </span>
          </div>
        </div>

        {/* 버튼 영역 */}
        <div className="flex justify-end gap-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={() => onOpenChange(false)}
            disabled={isSaving}
          >
            취소
          </Button>
          <Button
            variant="primary"
            size="sm"
            onClick={handleSave}
            disabled={!isValidContent || isSaving}
          >
            {isSaving ? "저장 중..." : "저장"}
          </Button>
        </div>
      </div>
    </Dialog>
  );
}

export const AnnouncementDialog = memo(AnnouncementDialogComponent);
</file>

<file path="components/chat/molecules/ChatInput.tsx">
"use client";

/**
 * ChatInput - 메시지 입력 컴포넌트
 *
 * 텍스트 입력 + 전송 버튼 + 답장 표시
 */

import { memo, useState, useCallback, useRef, useEffect } from "react";
import { cn } from "@/lib/cn";
import { Send, X } from "lucide-react";
import type { ReplyTargetInfo } from "@/lib/domains/chat/types";

interface ChatInputProps {
  /** 메시지 전송 핸들러 */
  onSend: (content: string) => void;
  /** 전송 중 상태 */
  isSending?: boolean;
  /** 비활성화 */
  disabled?: boolean;
  /** 플레이스홀더 */
  placeholder?: string;
  /** 최대 글자 수 */
  maxLength?: number;
  /** 타이핑 상태 변경 핸들러 */
  onTypingChange?: (isTyping: boolean) => void;
  /** 답장 대상 메시지 정보 */
  replyTarget?: ReplyTargetInfo | null;
  /** 답장 취소 핸들러 */
  onCancelReply?: () => void;
}

function ChatInputComponent({
  onSend,
  isSending = false,
  disabled = false,
  placeholder = "메시지를 입력하세요...",
  maxLength = 1000,
  onTypingChange,
  replyTarget,
  onCancelReply,
}: ChatInputProps) {
  const [value, setValue] = useState("");
  const [isComposing, setIsComposing] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // 자동 높이 조절
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${Math.min(textarea.scrollHeight, 120)}px`;
    }
  }, [value]);

  const handleSubmit = useCallback(() => {
    const trimmed = value.trim();
    if (!trimmed || isSending || disabled) return;

    onSend(trimmed);
    setValue("");
    onTypingChange?.(false);

    // 높이 초기화
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }
  }, [value, isSending, disabled, onSend, onTypingChange]);

  // 한글 IME 조합 이벤트 핸들러
  const handleCompositionStart = useCallback(() => {
    setIsComposing(true);
  }, []);

  const handleCompositionEnd = useCallback(() => {
    setIsComposing(false);
  }, []);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      // Enter로 전송 (Shift+Enter는 줄바꿈, 한글 조합 중에는 전송 방지)
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit, isComposing]
  );

  const canSend = value.trim().length > 0 && !isSending && !disabled;

  return (
    <div className="flex flex-col bg-bg-primary border-t border-border">
      {/* 답장 대상 표시 */}
      {replyTarget && (
        <div className="flex items-center gap-2 px-3 py-2 bg-bg-secondary border-b border-border">
          <div className="w-1 h-8 bg-primary rounded-full flex-shrink-0" />
          <div className="flex-1 min-w-0">
            <p className="text-xs text-primary font-medium">{replyTarget.senderName}에게 답장</p>
            <p className="text-xs text-text-secondary truncate">
              {replyTarget.isDeleted ? "삭제된 메시지" : replyTarget.content}
            </p>
          </div>
          {onCancelReply && (
            <button
              type="button"
              onClick={onCancelReply}
              className="p-1 hover:bg-bg-tertiary rounded-full transition-colors"
              aria-label="답장 취소"
            >
              <X className="w-4 h-4 text-text-tertiary" />
            </button>
          )}
        </div>
      )}

      <div className="flex items-end gap-2 p-3">
        {/* 텍스트 입력 */}
        <div className="flex-1 relative">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={(e) => {
              const newValue = e.target.value.slice(0, maxLength);
              setValue(newValue);
              onTypingChange?.(newValue.length > 0);
            }}
            onKeyDown={handleKeyDown}
            onCompositionStart={handleCompositionStart}
            onCompositionEnd={handleCompositionEnd}
            placeholder={placeholder}
            disabled={disabled}
            rows={1}
            className={cn(
              "w-full resize-none rounded-2xl px-4 py-2.5 text-sm",
              "bg-bg-secondary text-text-primary placeholder:text-text-tertiary",
              "border border-transparent focus:border-primary focus:outline-none",
              "transition-colors",
              disabled && "opacity-50 cursor-not-allowed"
            )}
          />
          {/* 글자 수 표시 (임계치 근처) */}
          {value.length > maxLength * 0.8 && (
            <span
              className={cn(
                "absolute right-3 bottom-1 text-[10px]",
                value.length >= maxLength ? "text-error" : "text-text-tertiary"
              )}
            >
              {value.length}/{maxLength}
            </span>
          )}
        </div>

        {/* 전송 버튼 */}
        <button
          type="button"
          onClick={handleSubmit}
          disabled={!canSend}
          className={cn(
            "flex items-center justify-center w-10 h-10 rounded-full",
            "transition-colors",
            canSend
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          <Send className="w-5 h-5" />
        </button>
      </div>
    </div>
  );
}

export const ChatInput = memo(ChatInputComponent);
</file>

<file path="components/chat/molecules/ChatRoomCard.tsx">
"use client";

/**
 * ChatRoomCard - 채팅방 목록 카드
 *
 * 채팅방 목록에서 각 방을 표시합니다.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import { formatDistanceToNow } from "date-fns";
import { ko } from "date-fns/locale";
import { Avatar } from "@/components/atoms/Avatar";
import { UnreadBadge } from "../atoms/UnreadBadge";
import { Users } from "lucide-react";
import type { ChatRoomListItem } from "@/lib/domains/chat/types";

interface ChatRoomCardProps {
  /** 채팅방 정보 */
  room: ChatRoomListItem;
  /** 클릭 핸들러 */
  onClick: () => void;
  /** 선택 상태 */
  isSelected?: boolean;
}

function ChatRoomCardComponent({
  room,
  onClick,
  isSelected = false,
}: ChatRoomCardProps) {
  // 표시할 이름 결정
  const displayName =
    room.type === "direct"
      ? room.otherUser?.name ?? "알 수 없음"
      : room.name ?? `그룹 (${room.memberCount}명)`;

  // 시간 포맷
  const timeDisplay = room.lastMessage
    ? formatDistanceToNow(new Date(room.lastMessage.createdAt), {
        addSuffix: true,
        locale: ko,
      })
    : "";

  return (
    <button
      type="button"
      onClick={onClick}
      className={cn(
        "w-full flex items-center gap-3 p-3 rounded-xl",
        "transition-colors text-left",
        isSelected ? "bg-primary/10" : "hover:bg-bg-secondary"
      )}
    >
      {/* 아바타 */}
      <div className="relative flex-shrink-0">
        {room.type === "direct" && room.otherUser ? (
          <Avatar
            name={room.otherUser.name}
            src={room.otherUser.profileImageUrl}
            size="md"
          />
        ) : (
          <div className="w-11 h-11 rounded-full bg-bg-tertiary flex items-center justify-center">
            <Users className="w-5 h-5 text-text-secondary" />
          </div>
        )}
      </div>

      {/* 정보 */}
      <div className="flex-1 min-w-0 flex flex-col gap-0.5">
        <div className="flex items-center justify-between gap-2">
          <span className="font-medium text-text-primary truncate">
            {displayName}
          </span>
          {timeDisplay && (
            <span className="text-xs text-text-tertiary flex-shrink-0">
              {timeDisplay}
            </span>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <span className="text-sm text-text-secondary truncate">
            {room.lastMessage ? (
              <>
                {room.type === "group" && (
                  <span className="text-text-tertiary">
                    {room.lastMessage.senderName}:{" "}
                  </span>
                )}
                {room.lastMessage.content}
              </>
            ) : (
              <span className="text-text-tertiary">메시지가 없습니다</span>
            )}
          </span>

          {room.unreadCount > 0 && (
            <UnreadBadge count={room.unreadCount} size="sm" />
          )}
        </div>
      </div>
    </button>
  );
}

export const ChatRoomCard = memo(ChatRoomCardComponent);
</file>

<file path="components/chat/molecules/EditMessageDialog.tsx">
"use client";

/**
 * EditMessageDialog - 메시지 수정 다이얼로그
 *
 * 채팅 메시지 수정을 위한 모달 다이얼로그입니다.
 */

import { memo, useState } from "react";
import { Dialog } from "@/components/ui/Dialog";
import Button from "@/components/atoms/Button";

interface EditMessageDialogProps {
  /** 다이얼로그 열림 여부 */
  open: boolean;
  /** 다이얼로그 닫기 */
  onOpenChange: (open: boolean) => void;
  /** 현재 메시지 내용 */
  currentContent: string;
  /** 저장 콜백 */
  onSave: (content: string) => void;
  /** 저장 중 여부 */
  isSaving?: boolean;
}

interface EditMessageFormProps {
  currentContent: string;
  onSave: (content: string) => void;
  onCancel: () => void;
  isSaving: boolean;
}

function EditMessageForm({
  currentContent,
  onSave,
  onCancel,
  isSaving,
}: EditMessageFormProps) {
  const [content, setContent] = useState(currentContent);

  const handleSave = () => {
    const trimmedContent = content.trim();
    if (trimmedContent && trimmedContent !== currentContent.trim()) {
      onSave(trimmedContent);
    }
  };

  const trimmedContent = content.trim();
  const isValidContent = trimmedContent.length > 0 && trimmedContent.length <= 1000;
  const hasChanged = trimmedContent !== currentContent.trim();
  const characterCount = content.length;

  return (
    <div className="space-y-4">
      {/* 입력 영역 */}
      <div className="flex flex-col gap-1">
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="메시지를 입력하세요..."
          className="w-full h-32 p-3 text-sm border border-border rounded-lg resize-none
            focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent
            bg-background text-text-primary placeholder:text-text-tertiary"
          maxLength={1000}
          disabled={isSaving}
          autoFocus
        />
        <div className="flex justify-end">
          <span
            className={`text-xs ${
              characterCount > 1000 ? "text-error" : "text-text-tertiary"
            }`}
          >
            {characterCount}/1000
          </span>
        </div>
      </div>

      {/* 버튼 영역 */}
      <div className="flex justify-end gap-2">
        <Button
          variant="secondary"
          size="sm"
          onClick={onCancel}
          disabled={isSaving}
        >
          취소
        </Button>
        <Button
          variant="primary"
          size="sm"
          onClick={handleSave}
          disabled={!isValidContent || !hasChanged || isSaving}
        >
          {isSaving ? "저장 중..." : "저장"}
        </Button>
      </div>
    </div>
  );
}

function EditMessageDialogComponent({
  open,
  onOpenChange,
  currentContent,
  onSave,
  isSaving = false,
}: EditMessageDialogProps) {
  // 폼 상태 초기화를 위한 key (content가 변경될 때마다 갱신)
  const formKey = open ? currentContent : "";

  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title="메시지 수정"
      size="md"
    >
      {open && (
        <EditMessageForm
          key={formKey}
          currentContent={currentContent}
          onSave={onSave}
          onCancel={() => onOpenChange(false)}
          isSaving={isSaving}
        />
      )}
    </Dialog>
  );
}

export const EditMessageDialog = memo(EditMessageDialogComponent);
</file>

<file path="components/chat/molecules/MessageContextMenu.tsx">
"use client";

/**
 * MessageContextMenu - 메시지 컨텍스트 메뉴
 *
 * 메시지를 길게 누르거나 우클릭 시 나타나는 하단 시트 메뉴입니다.
 * 리액션 추가, 복사, 답장, 편집, 삭제, 신고 등의 액션을 제공합니다.
 */

import { memo, useEffect } from "react";
import { createPortal } from "react-dom";
import { cn } from "@/lib/cn";
import { useClickOutside, useEscapeKey } from "@/lib/accessibility/hooks";
import { REACTION_EMOJIS, type ReactionEmoji } from "@/lib/domains/chat/types";
import { Copy, Reply, Edit2, Trash2, Flag, Pin, PinOff } from "lucide-react";

/** 메시지 메뉴 컨텍스트 정보 */
export interface MessageMenuContext {
  /** 메시지 ID */
  messageId: string;
  /** 메시지 내용 */
  content: string;
  /** 본인 메시지 여부 */
  isOwn: boolean;
  /** 편집 가능 여부 */
  canEdit: boolean;
  /** 고정 권한 여부 */
  canPin: boolean;
  /** 현재 고정 상태 */
  isPinned: boolean;
}

interface MessageContextMenuProps {
  /** 메뉴 열림 상태 */
  isOpen: boolean;
  /** 메뉴 닫기 콜백 */
  onClose: () => void;
  /** 메시지 컨텍스트 정보 */
  context: MessageMenuContext | null;
  /** 복사 클릭 콜백 */
  onCopy: () => void;
  /** 답장 클릭 콜백 */
  onReply: () => void;
  /** 편집 클릭 콜백 (본인 메시지 + 편집 가능 시) */
  onEdit?: () => void;
  /** 삭제 클릭 콜백 (본인 메시지) */
  onDelete?: () => void;
  /** 신고 클릭 콜백 (타인 메시지) */
  onReport?: () => void;
  /** 고정/해제 클릭 콜백 (고정 권한 있을 때) */
  onTogglePin?: () => void;
  /** 리액션 토글 콜백 */
  onToggleReaction: (emoji: ReactionEmoji) => void;
}

function MessageContextMenuComponent({
  isOpen,
  onClose,
  context,
  onCopy,
  onReply,
  onEdit,
  onDelete,
  onReport,
  onTogglePin,
  onToggleReaction,
}: MessageContextMenuProps) {
  // 외부 클릭 시 닫기
  const sheetRef = useClickOutside<HTMLDivElement>(onClose, isOpen);

  // ESC 키로 닫기
  useEscapeKey(onClose, isOpen);

  // 메뉴 열렸을 때 body 스크롤 방지
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
      return () => {
        document.body.style.overflow = "";
      };
    }
  }, [isOpen]);

  if (!isOpen || !context) return null;

  const handleReactionClick = (emoji: ReactionEmoji) => {
    onToggleReaction(emoji);
  };

  const menuContent = (
    <>
      {/* 딤 배경 */}
      <div
        className={cn(
          "fixed inset-0 z-40 bg-black/50",
          "animate-in fade-in-0 duration-200"
        )}
        aria-hidden="true"
      />

      {/* 하단 시트 */}
      <div
        ref={sheetRef}
        className={cn(
          "fixed inset-x-0 bottom-0 z-50",
          "bg-bg-primary rounded-t-2xl",
          "animate-in slide-in-from-bottom duration-200",
          "pb-safe max-h-[80vh] overflow-y-auto"
        )}
        role="dialog"
        aria-modal="true"
        aria-label="메시지 메뉴"
      >
        {/* 드래그 핸들 바 */}
        <div className="flex justify-center pt-3 pb-2">
          <div className="w-10 h-1 bg-secondary-300 dark:bg-secondary-600 rounded-full" />
        </div>

        {/* 빠른 리액션 바 */}
        <div className="flex justify-center gap-2 px-4 py-3">
          {REACTION_EMOJIS.map((emoji) => (
            <button
              key={emoji}
              type="button"
              onClick={() => handleReactionClick(emoji)}
              className={cn(
                "w-11 h-11 flex items-center justify-center",
                "rounded-full text-2xl",
                "bg-secondary-100 dark:bg-secondary-800",
                "hover:bg-secondary-200 dark:hover:bg-secondary-700",
                "active:scale-95",
                "transition-all duration-100"
              )}
              aria-label={`${emoji} 리액션 추가`}
            >
              {emoji}
            </button>
          ))}
        </div>

        {/* 구분선 */}
        <div className="px-4">
          <div className="h-px bg-border" />
        </div>

        {/* 액션 목록 */}
        <div className="py-2">
          {/* 복사 - 항상 표시 */}
          <button
            type="button"
            onClick={onCopy}
            className={cn(
              "w-full flex items-center gap-3 px-4 py-3",
              "hover:bg-bg-secondary active:bg-bg-tertiary",
              "transition-colors text-text-primary"
            )}
          >
            <Copy className="w-5 h-5 text-text-secondary" />
            <span>복사</span>
          </button>

          {/* 답장 - 항상 표시 */}
          <button
            type="button"
            onClick={onReply}
            className={cn(
              "w-full flex items-center gap-3 px-4 py-3",
              "hover:bg-bg-secondary active:bg-bg-tertiary",
              "transition-colors text-text-primary"
            )}
          >
            <Reply className="w-5 h-5 text-text-secondary" />
            <span>답장</span>
          </button>

          {/* 편집 - 본인 메시지 + 편집 가능 시 */}
          {context.isOwn && context.canEdit && onEdit && (
            <button
              type="button"
              onClick={onEdit}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-text-primary"
              )}
            >
              <Edit2 className="w-5 h-5 text-text-secondary" />
              <span>편집</span>
            </button>
          )}

          {/* 고정/해제 - 고정 권한 있을 때 */}
          {context.canPin && onTogglePin && (
            <button
              type="button"
              onClick={onTogglePin}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-text-primary"
              )}
            >
              {context.isPinned ? (
                <>
                  <PinOff className="w-5 h-5 text-text-secondary" />
                  <span>고정 해제</span>
                </>
              ) : (
                <>
                  <Pin className="w-5 h-5 text-text-secondary" />
                  <span>고정</span>
                </>
              )}
            </button>
          )}

          {/* 삭제 - 본인 메시지 (위험 스타일) */}
          {context.isOwn && onDelete && (
            <button
              type="button"
              onClick={onDelete}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-error"
              )}
            >
              <Trash2 className="w-5 h-5" />
              <span>삭제</span>
            </button>
          )}

          {/* 신고 - 타인 메시지 (위험 스타일) */}
          {!context.isOwn && onReport && (
            <button
              type="button"
              onClick={onReport}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-error"
              )}
            >
              <Flag className="w-5 h-5" />
              <span>신고</span>
            </button>
          )}
        </div>

        {/* 취소 버튼 */}
        <div className="px-4 pb-4">
          <button
            type="button"
            onClick={onClose}
            className={cn(
              "w-full py-3 rounded-xl",
              "bg-secondary-100 dark:bg-secondary-800",
              "hover:bg-secondary-200 dark:hover:bg-secondary-700",
              "text-text-primary font-medium",
              "transition-colors"
            )}
          >
            취소
          </button>
        </div>
      </div>
    </>
  );

  // Portal로 body에 직접 렌더링
  if (typeof window === "undefined") return null;
  return createPortal(menuContent, document.body);
}

export const MessageContextMenu = memo(MessageContextMenuComponent);
</file>

<file path="components/chat/molecules/MessageSearch.tsx">
"use client";

/**
 * MessageSearch - 채팅방 내 메시지 검색 컴포넌트
 *
 * 검색어 입력 및 결과 표시
 * 검색 결과 클릭 시 해당 메시지로 스크롤
 */

import { useState, useCallback, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { cn } from "@/lib/cn";
import { Search, X, Loader2 } from "lucide-react";
import { searchMessagesAction } from "@/lib/domains/chat/actions/messages";
import type { ChatMessageWithSender } from "@/lib/domains/chat/types";
import { formatDistanceToNow } from "date-fns";
import { ko } from "date-fns/locale";

interface MessageSearchProps {
  /** 채팅방 ID */
  roomId: string;
  /** 검색 모드 종료 */
  onClose: () => void;
  /** 검색 결과 메시지 클릭 */
  onSelectMessage: (messageId: string) => void;
}

export function MessageSearch({
  roomId,
  onClose,
  onSelectMessage,
}: MessageSearchProps) {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);

  // 자동 포커스
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  // Debounce 검색어
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query.trim());
    }, 300);

    return () => clearTimeout(timer);
  }, [query]);

  // 검색 쿼리
  const { data, isLoading, error } = useQuery({
    queryKey: ["chat-search", roomId, debouncedQuery],
    queryFn: async () => {
      if (!debouncedQuery) return null;
      const result = await searchMessagesAction(roomId, debouncedQuery, {
        limit: 20,
      });
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    enabled: debouncedQuery.length > 0,
  });

  // 검색어 하이라이트
  const highlightText = useCallback(
    (text: string, searchQuery: string) => {
      if (!searchQuery) return text;

      const parts = text.split(new RegExp(`(${searchQuery})`, "gi"));
      return parts.map((part, i) =>
        part.toLowerCase() === searchQuery.toLowerCase() ? (
          <mark key={i} className="bg-warning/30 text-text-primary rounded px-0.5">
            {part}
          </mark>
        ) : (
          part
        )
      );
    },
    []
  );

  return (
    <div className="flex flex-col h-full bg-bg-primary">
      {/* 검색 입력창 */}
      <div className="flex items-center gap-2 p-3 border-b border-border">
        <Search className="w-5 h-5 text-text-tertiary flex-shrink-0" />
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="메시지 검색..."
          className={cn(
            "flex-1 bg-transparent text-text-primary",
            "placeholder:text-text-tertiary",
            "focus:outline-none"
          )}
        />
        {query && (
          <button
            type="button"
            onClick={() => setQuery("")}
            className="p-1 text-text-tertiary hover:text-text-secondary"
          >
            <X className="w-4 h-4" />
          </button>
        )}
        <button
          type="button"
          onClick={onClose}
          className="text-sm text-text-secondary hover:text-text-primary"
        >
          취소
        </button>
      </div>

      {/* 검색 결과 */}
      <div className="flex-1 overflow-y-auto">
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
          </div>
        ) : error ? (
          <div className="flex items-center justify-center py-8 text-error">
            검색 중 오류가 발생했습니다
          </div>
        ) : !debouncedQuery ? (
          <div className="flex items-center justify-center py-8 text-text-tertiary">
            검색어를 입력하세요
          </div>
        ) : data?.messages.length === 0 ? (
          <div className="flex items-center justify-center py-8 text-text-tertiary">
            &ldquo;{debouncedQuery}&rdquo; 검색 결과가 없습니다
          </div>
        ) : (
          <div className="divide-y divide-border">
            {/* 검색 결과 헤더 */}
            {data && (
              <div className="px-4 py-2 text-xs text-text-tertiary bg-bg-secondary">
                {data.total}개의 결과
              </div>
            )}

            {/* 결과 목록 */}
            {data?.messages.map((message) => (
              <SearchResultItem
                key={message.id}
                message={message}
                query={debouncedQuery}
                highlightText={highlightText}
                onSelect={() => onSelectMessage(message.id)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

interface SearchResultItemProps {
  message: ChatMessageWithSender;
  query: string;
  highlightText: (text: string, query: string) => React.ReactNode;
  onSelect: () => void;
}

function SearchResultItem({
  message,
  query,
  highlightText,
  onSelect,
}: SearchResultItemProps) {
  const timeAgo = formatDistanceToNow(new Date(message.created_at), {
    addSuffix: true,
    locale: ko,
  });

  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        "w-full px-4 py-3 text-left",
        "hover:bg-bg-secondary transition-colors"
      )}
    >
      <div className="flex items-center justify-between gap-2">
        <span className="text-sm font-medium text-text-primary">
          {message.sender.name}
        </span>
        <span className="text-xs text-text-tertiary flex-shrink-0">
          {timeAgo}
        </span>
      </div>
      <p className="text-sm text-text-secondary line-clamp-2">
        {highlightText(message.content, query)}
      </p>
    </button>
  );
}
</file>

<file path="components/chat/molecules/PinnedMessagesBar.tsx">
"use client";

/**
 * PinnedMessagesBar - 고정 메시지 바
 *
 * 채팅방 상단에 고정된 메시지 목록을 표시합니다.
 * 클릭 시 해당 메시지로 스크롤, 관리자는 고정 해제 가능.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { Pin, ChevronDown, ChevronUp, X } from "lucide-react";
import type { PinnedMessageWithContent } from "@/lib/domains/chat/types";

interface PinnedMessagesBarProps {
  /** 고정된 메시지 목록 */
  pinnedMessages: PinnedMessageWithContent[];
  /** 고정 해제 권한 여부 */
  canUnpin: boolean;
  /** 메시지 클릭 시 스크롤 */
  onMessageClick: (messageId: string) => void;
  /** 고정 해제 콜백 */
  onUnpin?: (messageId: string) => void;
}

function PinnedMessagesBarComponent({
  pinnedMessages,
  canUnpin,
  onMessageClick,
  onUnpin,
}: PinnedMessagesBarProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);

  if (pinnedMessages.length === 0) {
    return null;
  }

  // 단일 메시지 모드 (펼침 버튼 표시)
  if (!isExpanded && pinnedMessages.length === 1) {
    const pinned = pinnedMessages[0];
    return (
      <div className="flex items-center gap-2 px-4 py-2 bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
        <Pin className="w-4 h-4 text-primary flex-shrink-0" />
        <button
          type="button"
          onClick={() => onMessageClick(pinned.message_id)}
          className="flex-1 text-left text-sm truncate hover:text-primary transition-colors"
        >
          <span className="font-medium text-primary">
            {pinned.message.senderName}:
          </span>{" "}
          <span className="text-text-secondary">
            {pinned.message.isDeleted ? "삭제된 메시지" : pinned.message.content}
          </span>
        </button>
        {canUnpin && onUnpin && (
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              onUnpin(pinned.message_id);
            }}
            className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
            aria-label="고정 해제"
          >
            <X className="w-3 h-3 text-text-tertiary hover:text-error" />
          </button>
        )}
      </div>
    );
  }

  // 축소 모드 (여러 개 - 캐러셀 형태)
  if (!isExpanded && pinnedMessages.length > 1) {
    const pinned = pinnedMessages[currentIndex];
    return (
      <div className="flex items-center gap-2 px-4 py-2 bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
        <Pin className="w-4 h-4 text-primary flex-shrink-0" />
        <button
          type="button"
          onClick={() => onMessageClick(pinned.message_id)}
          className="flex-1 text-left text-sm truncate hover:text-primary transition-colors"
        >
          <span className="font-medium text-primary">
            {pinned.message.senderName}:
          </span>{" "}
          <span className="text-text-secondary">
            {pinned.message.isDeleted ? "삭제된 메시지" : pinned.message.content}
          </span>
        </button>
        <span className="text-xs text-text-tertiary">
          {currentIndex + 1}/{pinnedMessages.length}
        </span>
        <button
          type="button"
          onClick={() => setCurrentIndex((i) => (i + 1) % pinnedMessages.length)}
          className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
          aria-label="다음 고정 메시지"
        >
          <ChevronDown className="w-4 h-4 text-text-tertiary" />
        </button>
        <button
          type="button"
          onClick={() => setIsExpanded(true)}
          className="text-xs text-primary hover:underline"
        >
          전체 보기
        </button>
      </div>
    );
  }

  // 확장 모드 (전체 목록)
  return (
    <div className="bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
      <div className="flex items-center justify-between px-4 py-2">
        <div className="flex items-center gap-2">
          <Pin className="w-4 h-4 text-primary" />
          <span className="text-sm font-medium text-primary">
            고정된 메시지 ({pinnedMessages.length})
          </span>
        </div>
        <button
          type="button"
          onClick={() => setIsExpanded(false)}
          className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
          aria-label="접기"
        >
          <ChevronUp className="w-4 h-4 text-text-tertiary" />
        </button>
      </div>
      <div className="max-h-40 overflow-y-auto">
        {pinnedMessages.map((pinned) => (
          <div
            key={pinned.id}
            className={cn(
              "flex items-center gap-2 px-4 py-2",
              "hover:bg-primary-100/50 dark:hover:bg-primary-900/40 transition-colors cursor-pointer"
            )}
          >
            <button
              type="button"
              onClick={() => onMessageClick(pinned.message_id)}
              className="flex-1 text-left text-sm truncate"
            >
              <span className="font-medium text-primary">
                {pinned.message.senderName}:
              </span>{" "}
              <span className="text-text-secondary">
                {pinned.message.isDeleted ? "삭제된 메시지" : pinned.message.content}
              </span>
            </button>
            {canUnpin && onUnpin && (
              <button
                type="button"
                onClick={(e) => {
                  e.stopPropagation();
                  onUnpin(pinned.message_id);
                }}
                className="p-1 hover:bg-primary-200 dark:hover:bg-primary-800 rounded transition-colors"
                aria-label="고정 해제"
              >
                <X className="w-3 h-3 text-text-tertiary hover:text-error" />
              </button>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}

export const PinnedMessagesBar = memo(PinnedMessagesBarComponent);
</file>

<file path="components/chat/organisms/ChatList.tsx">
"use client";

/**
 * ChatList - 채팅방 목록
 *
 * 사용자의 채팅방 목록을 표시합니다.
 */

import { memo, useState, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { getChatRoomsAction } from "@/lib/domains/chat/actions";
import { ChatRoomCard } from "../molecules/ChatRoomCard";
import { MessageSquarePlus, Loader2, Search, X, SearchX } from "lucide-react";
import { cn } from "@/lib/cn";

interface ChatListProps {
  /** 현재 선택된 채팅방 ID */
  selectedRoomId?: string;
  /** 채팅방 클릭 핸들러 */
  onRoomClick?: (roomId: string) => void;
  /** 새 채팅 버튼 클릭 핸들러 */
  onNewChat?: () => void;
  /** 라우트 기본 경로 (예: /chat 또는 /admin/chat) */
  basePath?: string;
}

function ChatListComponent({
  selectedRoomId,
  onRoomClick,
  onNewChat,
  basePath = "/chat",
}: ChatListProps) {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState("");

  // 채팅방 목록 조회
  const { data, isLoading, error } = useQuery({
    queryKey: ["chat-rooms"],
    queryFn: async () => {
      const result = await getChatRoomsAction();
      if (!result.success) {
        throw new Error(result.error);
      }
      return result.data;
    },
    staleTime: 30 * 1000, // 30초
  });

  const handleRoomClick = (roomId: string) => {
    if (onRoomClick) {
      onRoomClick(roomId);
    } else {
      router.push(`${basePath}/${roomId}`);
    }
  };

  // 검색 필터링 (Hook은 조건부 반환 전에 호출)
  const filteredRooms = useMemo(() => {
    const rooms = data ?? [];
    if (!searchQuery.trim()) return rooms;
    const query = searchQuery.toLowerCase();

    return rooms.filter((room) => {
      const nameToCheck =
        room.type === "direct" ? room.otherUser?.name : room.name;
      return nameToCheck?.toLowerCase().includes(query);
    });
  }, [data, searchQuery]);

  // 로딩 상태
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-40">
        <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
      </div>
    );
  }

  // 에러 상태
  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-40 text-center px-4 gap-1">
        <p className="text-text-secondary text-sm">
          채팅 목록을 불러오지 못했습니다
        </p>
        <p className="text-text-tertiary text-xs">
          {error instanceof Error ? error.message : "알 수 없는 오류"}
        </p>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* 헤더 */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-border">
        <h2 className="font-semibold text-lg text-text-primary">채팅</h2>
        {onNewChat && (
          <button
            type="button"
            onClick={onNewChat}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
            title="새 채팅"
          >
            <MessageSquarePlus className="w-5 h-5 text-text-secondary" />
          </button>
        )}
      </div>

      {/* 검색창 */}
      <div className="px-4 py-2">
        <div
          className={cn(
            "flex items-center gap-2 px-3 py-2",
            "bg-bg-secondary rounded-xl"
          )}
        >
          <Search className="w-5 h-5 text-text-tertiary flex-shrink-0" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="채팅방 검색..."
            className={cn(
              "flex-1 bg-transparent text-sm text-text-primary",
              "placeholder:text-text-tertiary",
              "focus:outline-none"
            )}
          />
          {searchQuery && (
            <button
              type="button"
              onClick={() => setSearchQuery("")}
              className="p-1 text-text-tertiary hover:text-text-secondary"
            >
              <X className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>

      {/* 채팅방 목록 */}
      <div className="flex-1 overflow-y-auto px-2 py-2">
        {filteredRooms.length === 0 && searchQuery.trim() ? (
          <div className="flex flex-col items-center justify-center h-full text-center px-4 gap-2">
            <SearchX className="w-8 h-8 text-text-tertiary" />
            <p className="text-text-secondary text-sm">검색 결과가 없습니다</p>
          </div>
        ) : filteredRooms.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-center px-4 gap-3">
            <p className="text-text-secondary text-sm">아직 채팅이 없습니다</p>
            {onNewChat && (
              <button
                type="button"
                onClick={onNewChat}
                className="text-primary text-sm font-medium hover:underline"
              >
                새 채팅 시작하기
              </button>
            )}
          </div>
        ) : (
          <div className="space-y-1">
            {filteredRooms.map((room) => (
              <ChatRoomCard
                key={room.id}
                room={room}
                onClick={() => handleRoomClick(room.id)}
                isSelected={room.id === selectedRoomId}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

export const ChatList = memo(ChatListComponent);
</file>

<file path="components/chat/organisms/ChatRoom.tsx">
"use client";

/**
 * ChatRoom - 채팅방 전체 뷰
 *
 * 메시지 목록 + 입력창을 포함합니다.
 * 비즈니스 로직은 useChatRoomLogic 훅으로 분리되어 있습니다.
 */

import { memo, useRef, useCallback, useState, useMemo } from "react";
import { useChatRoomLogic } from "@/lib/domains/chat/hooks";
import type { ReactionEmoji, ReplyTargetInfo } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { MessageBubble } from "../atoms/MessageBubble";
import { DateDivider } from "../atoms/DateDivider";
import { TypingIndicator } from "../atoms/TypingIndicator";
import { OnlineStatus } from "../atoms/OnlineStatus";
import { ChatInput } from "../molecules/ChatInput";
import { MessageSearch } from "../molecules/MessageSearch";
import { PinnedMessagesBar } from "../molecules/PinnedMessagesBar";
import { AnnouncementBanner } from "../atoms/AnnouncementBanner";
import { AnnouncementDialog } from "../molecules/AnnouncementDialog";
import { MessageContextMenu, type MessageMenuContext } from "../molecules/MessageContextMenu";
import { ChatRoomInfo } from "./ChatRoomInfo";
import { EditMessageDialog } from "../molecules/EditMessageDialog";
import { ConfirmDialog } from "@/components/ui/Dialog";
import { Loader2, ArrowLeft, MoreVertical, Search, Megaphone, ChevronDown } from "lucide-react";
import { Virtuoso, type VirtuosoHandle } from "react-virtuoso";

interface ChatRoomProps {
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID */
  userId: string;
  /** 뒤로 가기 핸들러 */
  onBack?: () => void;
  /** 메뉴 버튼 클릭 핸들러 */
  onMenuClick?: () => void;
}

function ChatRoomComponent({
  roomId,
  userId,
  onBack,
}: ChatRoomProps) {
  // ============================================
  // UI 상태
  // ============================================
  const virtuosoRef = useRef<VirtuosoHandle>(null);
  const messageRefs = useRef<Map<string, HTMLDivElement>>(new Map());
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [isSearchMode, setIsSearchMode] = useState(false);
  const [isAnnouncementDialogOpen, setIsAnnouncementDialogOpen] = useState(false);
  const [firstItemIndex, setFirstItemIndex] = useState(10000);
  const [hasNewMessages, setHasNewMessages] = useState(false);
  const [menuContext, setMenuContext] = useState<MessageMenuContext | null>(null);
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isInfoOpen, setIsInfoOpen] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState<string | null>(null);
  const [editingMessage, setEditingMessage] = useState<{
    id: string;
    content: string;
  } | null>(null);

  // ============================================
  // 스크롤 핸들러
  // ============================================
  const scrollToBottom = useCallback(() => {
    virtuosoRef.current?.scrollToIndex({
      index: "LAST",
      behavior: "smooth",
    });
  }, []);

  const handleAtBottomChange = useCallback((atBottom: boolean) => {
    setIsAtBottom(atBottom);
    if (atBottom) {
      setHasNewMessages(false);
    }
  }, []);

  // ============================================
  // 비즈니스 로직 훅
  // ============================================
  const {
    data,
    permissions,
    actions,
    status,
    pinnedMessageIds,
    replyTargetState,
    utils,
  } = useChatRoomLogic({
    roomId,
    userId,
    isAtBottom,
    onNewMessageArrived: useCallback(() => {
      if (isAtBottom) {
        scrollToBottom();
      } else {
        setHasNewMessages(true);
      }
    }, [isAtBottom, scrollToBottom]),
  });

  const { room, messages, pinnedMessages, announcement, readCounts, onlineUsers, typingUsers } = data;
  const { canPin, canSetAnnouncement } = permissions;
  const { sendMessage, toggleReaction, togglePin, setAnnouncement, setTyping, retryMessage, removeFailedMessage } = actions;
  const { isLoading, error, hasNextPage, isFetchingNextPage, fetchNextPage } = status;
  const { replyTarget, setReplyTarget } = replyTargetState;
  const { canEditMessage, isMessageEdited } = utils;

  // ============================================
  // 사이드바 핸들러
  // ============================================
  const handleInfoOpen = useCallback(() => {
    setIsInfoOpen(true);
  }, []);

  const handleInfoClose = useCallback(() => {
    setIsInfoOpen(false);
  }, []);

  // ============================================
  // 무한 스크롤
  // ============================================
  const handleStartReached = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage().then(() => {
        setFirstItemIndex((prev) => prev - 50);
      });
    }
  }, [hasNextPage, isFetchingNextPage, fetchNextPage]);

  // ============================================
  // 메시지 스크롤
  // ============================================
  const scrollToMessage = useCallback((messageId: string) => {
    setIsSearchMode(false);
    const index = messages.findIndex((m) => m.id === messageId);
    if (index !== -1) {
      virtuosoRef.current?.scrollToIndex({
        index: firstItemIndex + index,
        behavior: "smooth",
        align: "center",
      });
      setTimeout(() => {
        const element = messageRefs.current.get(messageId);
        if (element) {
          element.classList.add("bg-warning/20");
          setTimeout(() => element.classList.remove("bg-warning/20"), 2000);
        }
      }, 300);
    }
  }, [messages, firstItemIndex]);

  // ============================================
  // 메시지 액션 핸들러
  // ============================================
  const handleReply = useCallback((message: { id: string; content: string; sender?: { name: string } | null; is_deleted?: boolean }) => {
    setReplyTarget({
      id: message.id,
      content: message.content,
      senderName: message.sender?.name ?? "알 수 없음",
      isDeleted: message.is_deleted ?? false,
    });
  }, [setReplyTarget]);

  const handleEdit = useCallback((messageId: string, currentContent: string) => {
    setEditingMessage({ id: messageId, content: currentContent });
  }, []);

  const handleDelete = useCallback((messageId: string) => {
    setDeleteTarget(messageId);
  }, []);

  const handleDeleteConfirm = useCallback(() => {
    if (deleteTarget) {
      actions.deleteMessage(deleteTarget);
    }
    setDeleteTarget(null);
  }, [deleteTarget, actions]);

  const handleEditSave = useCallback((newContent: string) => {
    if (editingMessage) {
      actions.editMessage(editingMessage.id, newContent);
    }
    setEditingMessage(null);
  }, [editingMessage, actions]);

  // ============================================
  // 컨텍스트 메뉴
  // ============================================
  const handleMessageLongPress = useCallback((message: (typeof messages)[number]) => {
    const isOwn = message.sender_id === userId;
    setMenuContext({
      messageId: message.id,
      content: message.content,
      isOwn,
      canEdit: isOwn && canEditMessage(message.created_at),
      canPin: canPin && message.message_type !== "system",
      isPinned: pinnedMessageIds.has(message.id),
    });
    setIsMenuOpen(true);
  }, [userId, canEditMessage, canPin, pinnedMessageIds]);

  const handleCopy = useCallback(async () => {
    if (menuContext) {
      await navigator.clipboard.writeText(menuContext.content);
    }
    setIsMenuOpen(false);
  }, [menuContext]);

  const handleMenuReply = useCallback(() => {
    if (menuContext) {
      const message = messages.find((m) => m.id === menuContext.messageId);
      if (message) handleReply(message);
    }
    setIsMenuOpen(false);
  }, [menuContext, messages, handleReply]);

  const handleMenuEdit = useCallback(() => {
    if (menuContext?.canEdit) {
      handleEdit(menuContext.messageId, menuContext.content);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleEdit]);

  const handleMenuDelete = useCallback(() => {
    if (menuContext?.isOwn) {
      handleDelete(menuContext.messageId);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleDelete]);

  const handleMenuTogglePin = useCallback(() => {
    if (menuContext?.canPin) {
      togglePin(menuContext.messageId, menuContext.isPinned);
    }
    setIsMenuOpen(false);
  }, [menuContext, togglePin]);

  const handleMenuReaction = useCallback((emoji: ReactionEmoji) => {
    if (menuContext) {
      toggleReaction(menuContext.messageId, emoji);
    }
    setIsMenuOpen(false);
  }, [menuContext, toggleReaction]);

  // ============================================
  // 메시지 렌더링
  // ============================================
  const getRefCallback = useCallback((messageId: string) => (el: HTMLDivElement | null) => {
    if (el) messageRefs.current.set(messageId, el);
    else messageRefs.current.delete(messageId);
  }, []);

  const renderMessage = useCallback((_index: number, message: (typeof messages)[number]) => {
    const isOwn = message.sender_id === userId;
    const messageReplyTarget = (message as { replyTarget?: ReplyTargetInfo | null }).replyTarget;
    const messageStatus = (message as { status?: string }).status;
    const { grouping } = message;

    return (
      <div
        ref={getRefCallback(message.id)}
        className="transition-colors duration-300"
      >
        {grouping.showDateDivider && grouping.dateDividerText && (
          <DateDivider date={grouping.dateDividerText} />
        )}

        <div className={cn("px-4", grouping.isGrouped ? "py-0.5" : "py-1.5")}>
          <MessageBubble
            content={message.content}
            isOwn={isOwn}
            senderName={message.sender?.name}
            createdAt={message.created_at}
            isSystem={message.message_type === "system"}
            isEdited={isMessageEdited(message)}
            unreadCount={isOwn ? readCounts[message.id] : undefined}
            canEdit={isOwn && canEditMessage(message.created_at)}
            reactions={(message as { reactions?: Array<{ emoji: ReactionEmoji; count: number; hasReacted: boolean }> }).reactions ?? []}
            replyTarget={messageReplyTarget}
            isPinned={pinnedMessageIds.has(message.id)}
            canPin={canPin && message.message_type !== "system"}
            showName={grouping.showName}
            showTime={grouping.showTime}
            isGrouped={grouping.isGrouped}
            isError={messageStatus === "error"}
            isRetrying={messageStatus === "sending" && message.id.startsWith("temp-")}
            onRetry={messageStatus === "error" ? () => retryMessage(message) : undefined}
            onRemoveFailed={messageStatus === "error" ? () => removeFailedMessage(message.id) : undefined}
            onToggleReaction={(emoji) => toggleReaction(message.id, emoji)}
            onReply={message.message_type !== "system" ? () => handleReply(message) : undefined}
            onReplyTargetClick={messageReplyTarget ? () => scrollToMessage(messageReplyTarget.id) : undefined}
            onTogglePin={() => togglePin(message.id, pinnedMessageIds.has(message.id))}
            onEdit={() => handleEdit(message.id, message.content)}
            onDelete={() => handleDelete(message.id)}
            onLongPress={() => handleMessageLongPress(message)}
          />
        </div>
      </div>
    );
  }, [
    userId,
    readCounts,
    pinnedMessageIds,
    canPin,
    canEditMessage,
    isMessageEdited,
    getRefCallback,
    retryMessage,
    removeFailedMessage,
    toggleReaction,
    handleReply,
    scrollToMessage,
    togglePin,
    handleEdit,
    handleDelete,
    handleMessageLongPress,
  ]);

  const computeItemKey = useCallback((_index: number, message: (typeof messages)[number]) => message.id, []);

  const ScrollSeekPlaceholder = useCallback(({ height }: { height: number }) => (
    <div style={{ height }} className="px-4 py-1.5">
      <div className="bg-bg-secondary rounded-2xl animate-pulse" style={{ height: Math.max(height - 12, 40) }} />
    </div>
  ), []);

  // ============================================
  // 방 이름 결정
  // ============================================
  const roomName = useMemo(() => {
    if (!room) return "채팅";
    return room.type === "direct"
      ? data.members.find((m) => m.user_id !== userId)?.user?.name ?? "채팅"
      : room.name ?? `그룹 (${data.members.length}명)`;
  }, [room, data.members, userId]);

  // ============================================
  // 렌더링
  // ============================================
  return (
    <div className="relative flex flex-col h-full bg-bg-primary">
      {/* 헤더 */}
      <div className="flex items-center gap-3 px-4 py-3 border-b border-border bg-bg-primary">
        {onBack && (
          <button
            type="button"
            onClick={onBack}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
          >
            <ArrowLeft className="w-5 h-5 text-text-primary" />
          </button>
        )}

        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <h2 className="font-semibold text-text-primary truncate">
              {roomName}
            </h2>
            {room?.type === "direct" && (
              <OnlineStatus isOnline={onlineUsers.length > 0} />
            )}
          </div>
          {room?.type === "group" && (
            <p className="text-xs text-text-tertiary">
              {onlineUsers.length > 0
                ? `${onlineUsers.length + 1}명 온라인`
                : `${data.members.length}명 참여 중`}
            </p>
          )}
        </div>

        <button
          type="button"
          onClick={() => setIsSearchMode(true)}
          className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
        >
          <Search className="w-5 h-5 text-text-secondary" />
        </button>

        {canSetAnnouncement && (
          <button
            type="button"
            onClick={() => setIsAnnouncementDialogOpen(true)}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
            aria-label="공지 설정"
          >
            <Megaphone className="w-5 h-5 text-text-secondary" />
          </button>
        )}

        <button
          type="button"
          onClick={handleInfoOpen}
          className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
          aria-label="채팅방 정보"
        >
          <MoreVertical className="w-5 h-5 text-text-secondary" />
        </button>
      </div>

      {/* 공지 배너 */}
      {announcement && (
        <AnnouncementBanner
          announcement={announcement}
          canEdit={canSetAnnouncement}
          onEdit={() => setIsAnnouncementDialogOpen(true)}
          onDelete={() => {
            if (confirm("공지를 삭제하시겠습니까?")) {
              setAnnouncement(null);
            }
          }}
        />
      )}

      {/* 고정 메시지 바 */}
      {pinnedMessages.length > 0 && (
        <PinnedMessagesBar
          pinnedMessages={pinnedMessages}
          canUnpin={canPin}
          onMessageClick={scrollToMessage}
          onUnpin={(messageId) => {
            togglePin(messageId, true);
          }}
        />
      )}

      {/* 검색 모드 */}
      {isSearchMode && (
        <div className="absolute inset-0 z-10">
          <MessageSearch
            roomId={roomId}
            onClose={() => setIsSearchMode(false)}
            onSelectMessage={scrollToMessage}
          />
        </div>
      )}

      {/* 메시지 목록 */}
      {isLoading ? (
        <div className="flex-1 flex items-center justify-center">
          <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
        </div>
      ) : error ? (
        <div className="flex-1 flex flex-col items-center justify-center text-center">
          <p className="text-text-secondary text-sm">
            메시지를 불러오지 못했습니다
          </p>
        </div>
      ) : messages.length === 0 ? (
        <div className="flex-1 flex flex-col items-center justify-center text-center gap-1">
          <p className="text-text-secondary text-sm">
            아직 메시지가 없습니다
          </p>
          <p className="text-text-tertiary text-xs">
            첫 메시지를 보내보세요!
          </p>
        </div>
      ) : (
        <Virtuoso
          ref={virtuosoRef}
          className="flex-1"
          data={messages}
          firstItemIndex={firstItemIndex}
          initialTopMostItemIndex={messages.length - 1}
          followOutput="smooth"
          atBottomStateChange={handleAtBottomChange}
          startReached={handleStartReached}
          computeItemKey={computeItemKey}
          increaseViewportBy={{ top: 200, bottom: 200 }}
          scrollSeekConfiguration={{
            enter: (velocity) => Math.abs(velocity) > 800,
            exit: (velocity) => Math.abs(velocity) < 100,
          }}
          components={{
            Header: () => (
              isFetchingNextPage ? (
                <div className="flex justify-center py-2">
                  <Loader2 className="w-5 h-5 animate-spin text-text-tertiary" />
                </div>
              ) : null
            ),
            ScrollSeekPlaceholder,
          }}
          itemContent={renderMessage}
        />
      )}

      {/* 맨 아래로 스크롤 버튼 */}
      <div
        className={cn(
          "absolute bottom-28 right-4 z-10",
          "transition-all duration-300 ease-out",
          isAtBottom
            ? "opacity-0 translate-y-4 pointer-events-none"
            : "opacity-100 translate-y-0"
        )}
      >
        <button
          type="button"
          onClick={scrollToBottom}
          className={cn(
            "relative flex items-center justify-center",
            "w-10 h-10 rounded-full",
            "bg-bg-primary border border-border shadow-lg",
            "hover:bg-bg-secondary transition-colors duration-200",
            "hover:scale-105 active:scale-95"
          )}
          aria-label="맨 아래로 스크롤"
        >
          <ChevronDown className="w-5 h-5 text-text-secondary" />

          {hasNewMessages && (
            <span className="absolute -top-1 -right-1 flex items-center justify-center w-5 h-5 text-[10px] font-medium text-white bg-primary rounded-full">
              N
            </span>
          )}
        </button>
      </div>

      {/* 타이핑 인디케이터 */}
      <TypingIndicator users={typingUsers} />

      {/* 입력창 */}
      <ChatInput
        onSend={(content) => sendMessage(content, replyTarget?.id)}
        onTypingChange={setTyping}
        replyTarget={replyTarget}
        onCancelReply={() => setReplyTarget(null)}
      />

      {/* 공지 설정 다이얼로그 */}
      <AnnouncementDialog
        open={isAnnouncementDialogOpen}
        onOpenChange={setIsAnnouncementDialogOpen}
        currentContent={announcement?.content}
        onSave={(content) => {
          setAnnouncement(content);
          setIsAnnouncementDialogOpen(false);
        }}
        isSaving={false}
      />

      {/* 메시지 컨텍스트 메뉴 */}
      <MessageContextMenu
        isOpen={isMenuOpen}
        onClose={() => setIsMenuOpen(false)}
        context={menuContext}
        onCopy={handleCopy}
        onReply={handleMenuReply}
        onEdit={menuContext?.canEdit ? handleMenuEdit : undefined}
        onDelete={menuContext?.isOwn ? handleMenuDelete : undefined}
        onTogglePin={menuContext?.canPin ? handleMenuTogglePin : undefined}
        onToggleReaction={handleMenuReaction}
      />

      {/* 채팅방 정보 사이드바 */}
      <ChatRoomInfo
        isOpen={isInfoOpen}
        onClose={handleInfoClose}
        roomId={roomId}
        userId={userId}
        room={room}
        members={data.members}
        isLoading={!room}
      />

      {/* 메시지 삭제 확인 */}
      <ConfirmDialog
        open={!!deleteTarget}
        onOpenChange={(open) => !open && setDeleteTarget(null)}
        title="메시지 삭제"
        description="이 메시지를 삭제하시겠습니까?"
        confirmLabel="삭제"
        cancelLabel="취소"
        onConfirm={handleDeleteConfirm}
        variant="destructive"
        isLoading={status.isDeleting}
      />

      {/* 메시지 수정 */}
      <EditMessageDialog
        open={!!editingMessage}
        onOpenChange={(open) => !open && setEditingMessage(null)}
        currentContent={editingMessage?.content ?? ""}
        onSave={handleEditSave}
        isSaving={status.isEditing}
      />
    </div>
  );
}

export const ChatRoom = memo(ChatRoomComponent);
</file>

<file path="components/chat/organisms/ChatRoomInfo.tsx">
"use client";

/**
 * ChatRoomInfo - 채팅방 정보 사이드바
 *
 * 채팅방 참여자 목록, 초대, 나가기 기능을 제공합니다.
 */

import { memo, useCallback, useState, useMemo } from "react";
import { useRouter } from "next/navigation";
import { SlideOverPanel } from "@/components/layouts/SlideOver";
import { Avatar } from "@/components/atoms/Avatar";
import { Skeleton } from "@/components/atoms/Skeleton";
import { leaveChatRoomAction } from "@/lib/domains/chat/actions";
import type { ChatRoom, ChatRoomMemberWithUser, ChatMemberRole } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { UserPlus, LogOut, Crown, Shield } from "lucide-react";
import { useToast } from "@/components/ui/ToastProvider";
import { InviteMemberModal } from "./InviteMemberModal";

interface ChatRoomInfoProps {
  /** 사이드바 열림 상태 */
  isOpen: boolean;
  /** 닫기 핸들러 */
  onClose: () => void;
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID */
  userId: string;
  /** 채팅방 정보 */
  room?: ChatRoom;
  /** 멤버 목록 */
  members?: ChatRoomMemberWithUser[];
  /** 로딩 상태 */
  isLoading?: boolean;
}

/** 역할별 배지 텍스트 */
const roleBadges: Record<ChatMemberRole, { text: string; icon: typeof Crown }> = {
  owner: { text: "방장", icon: Crown },
  admin: { text: "관리자", icon: Shield },
  member: { text: "", icon: Crown },
};

function ChatRoomInfoComponent({
  isOpen,
  onClose,
  roomId,
  userId,
  room,
  members,
  isLoading = false,
}: ChatRoomInfoProps) {
  const router = useRouter();
  const { showSuccess, showError } = useToast();

  // 초대 모달 상태
  const [isInviteModalOpen, setIsInviteModalOpen] = useState(false);

  // 활성 멤버만 필터링 (left_at === null)
  const activeMembers = members?.filter((m) => m.left_at === null) ?? [];
  const memberCount = activeMembers.length;

  // 기존 멤버 ID 목록 (초대 모달에서 필터링용)
  const existingMemberIds = useMemo(
    () => activeMembers.map((m) => m.user_id),
    [activeMembers]
  );

  // 채팅방 나가기 핸들러
  const handleLeaveRoom = useCallback(async () => {
    const confirmed = window.confirm("채팅방을 나가시겠습니까?");
    if (!confirmed) return;

    const result = await leaveChatRoomAction(roomId);
    if (result.success) {
      onClose();
      showSuccess("채팅방을 나갔습니다.");
      router.push("/chat");
    } else {
      showError(result.error ?? "채팅방 나가기 실패");
    }
  }, [roomId, onClose, router, showSuccess, showError]);

  // 초대 버튼 핸들러
  const handleInvite = useCallback(() => {
    setIsInviteModalOpen(true);
  }, []);

  // 사이드바 Footer
  const footer = (
    <button
      type="button"
      onClick={handleLeaveRoom}
      className={cn(
        "flex items-center justify-center gap-2 w-full",
        "py-3 rounded-lg",
        "text-red-600 dark:text-red-400",
        "hover:bg-red-50 dark:hover:bg-red-950/30",
        "transition-colors"
      )}
    >
      <LogOut className="w-5 h-5" />
      <span className="font-medium">채팅방 나가기</span>
    </button>
  );

  return (
    <SlideOverPanel
      isOpen={isOpen}
      onClose={onClose}
      id="chat-room-info"
      title="채팅방 정보"
      size="sm"
      footer={footer}
    >
      {/* 로딩 상태 */}
      {isLoading ? (
        <div className="space-y-4">
          {/* 섹션 헤더 스켈레톤 */}
          <Skeleton variant="text" className="h-5 w-24" />

          {/* 멤버 스켈레톤 */}
          <div className="space-y-2">
            {[1, 2, 3].map((i) => (
              <div key={i} className="flex items-center gap-3 py-2">
                <Skeleton variant="circular" width={40} height={40} />
                <Skeleton variant="text" className="h-4 w-24" />
              </div>
            ))}
          </div>
        </div>
      ) : (
        <div className="space-y-6">
          {/* 참여자 섹션 */}
          <section>
            <h3 className="text-sm font-medium text-text-secondary mb-3">
              참여자 ({memberCount}명)
            </h3>

            <ul className="space-y-1">
              {activeMembers.map((member) => {
                const isMe = member.user_id === userId;
                const roleInfo = roleBadges[member.role];

                return (
                  <li
                    key={member.id}
                    className={cn(
                      "flex items-center gap-3 py-2 px-2 rounded-lg",
                      "hover:bg-bg-secondary transition-colors"
                    )}
                  >
                    <Avatar
                      src={member.user.profileImageUrl}
                      name={member.user.name}
                      size="md"
                    />

                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <span className="font-medium text-text-primary truncate">
                          {member.user.name}
                        </span>

                        {/* 나 배지 */}
                        {isMe && (
                          <span className="text-xs text-text-tertiary">(나)</span>
                        )}
                      </div>
                    </div>

                    {/* 역할 배지 */}
                    {member.role !== "member" && (
                      <div
                        className={cn(
                          "flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium",
                          member.role === "owner"
                            ? "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400"
                            : "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400"
                        )}
                      >
                        <roleInfo.icon className="w-3 h-3" />
                        <span>{roleInfo.text}</span>
                      </div>
                    )}
                  </li>
                );
              })}
            </ul>
          </section>

          {/* 초대 버튼 (그룹채팅만) */}
          {room?.type === "group" && (
            <button
              type="button"
              onClick={handleInvite}
              className={cn(
                "flex items-center justify-center gap-2 w-full",
                "py-3 rounded-lg border border-border",
                "text-text-secondary",
                "hover:bg-bg-secondary hover:text-text-primary",
                "transition-colors"
              )}
            >
              <UserPlus className="w-5 h-5" />
              <span className="font-medium">초대하기</span>
            </button>
          )}
        </div>
      )}

      {/* 멤버 초대 모달 */}
      <InviteMemberModal
        isOpen={isInviteModalOpen}
        onClose={() => setIsInviteModalOpen(false)}
        roomId={roomId}
        existingMemberIds={existingMemberIds}
      />
    </SlideOverPanel>
  );
}

export const ChatRoomInfo = memo(ChatRoomInfoComponent);
export default ChatRoomInfo;
</file>

<file path="components/chat/organisms/InviteMemberModal.tsx">
"use client";

/**
 * InviteMemberModal - 그룹 채팅방 멤버 초대 모달
 *
 * 학생 목록에서 선택하여 기존 그룹 채팅방에 새 멤버를 초대합니다.
 */

import { useState, useMemo, useCallback } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { Avatar } from "@/components/atoms/Avatar";
import Checkbox from "@/components/atoms/Checkbox";
import { inviteMembersAction } from "@/lib/domains/chat/actions";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { Loader2, Search, UserPlus } from "lucide-react";
import { cn } from "@/lib/cn";
import { useToast } from "@/components/ui/ToastProvider";

interface InviteMemberModalProps {
  isOpen: boolean;
  onClose: () => void;
  roomId: string;
  existingMemberIds: string[]; // 이미 참여 중인 멤버 ID 목록
}

interface Student {
  id: string;
  name: string;
}

export function InviteMemberModal({
  isOpen,
  onClose,
  roomId,
  existingMemberIds,
}: InviteMemberModalProps) {
  const queryClient = useQueryClient();
  const { showSuccess, showError } = useToast();

  const [searchQuery, setSearchQuery] = useState("");
  const [selectedStudentIds, setSelectedStudentIds] = useState<Set<string>>(
    new Set()
  );

  // 학생 목록 조회
  const { data: students, isLoading } = useQuery({
    queryKey: ["chat-available-students"],
    queryFn: async () => {
      const supabase = createSupabaseBrowserClient();
      const { data, error } = await supabase
        .from("students")
        .select("id, name")
        .order("name");

      if (error) throw error;
      return data as Student[];
    },
    enabled: isOpen,
  });

  // 이미 참여 중인 멤버 제외 + 검색 필터링
  const filteredStudents = useMemo(() => {
    const existingSet = new Set(existingMemberIds);
    return students
      ?.filter((s) => !existingSet.has(s.id))
      .filter((s) => s.name.toLowerCase().includes(searchQuery.toLowerCase()));
  }, [students, existingMemberIds, searchQuery]);

  // 선택 토글
  const toggleStudentSelection = useCallback((studentId: string) => {
    setSelectedStudentIds((prev) => {
      const next = new Set(prev);
      if (next.has(studentId)) {
        next.delete(studentId);
      } else {
        next.add(studentId);
      }
      return next;
    });
  }, []);

  // 유효성 검사
  const isSubmitEnabled = selectedStudentIds.size > 0;

  // 초대 mutation
  const inviteMutation = useMutation({
    mutationFn: async () => {
      const memberIds = Array.from(selectedStudentIds);
      const result = await inviteMembersAction(
        roomId,
        memberIds,
        memberIds.map(() => "student")
      );
      if (!result.success) throw new Error(result.error);
    },
    onSuccess: () => {
      // 멤버 목록 새로고침
      queryClient.invalidateQueries({ queryKey: ["chat-room-members", roomId] });
      showSuccess("멤버를 초대했습니다.");
      handleClose();
    },
    onError: (error) => {
      showError(error instanceof Error ? error.message : "멤버 초대 실패");
    },
  });

  const handleInvite = () => {
    if (isSubmitEnabled) {
      inviteMutation.mutate();
    }
  };

  const handleClose = () => {
    setSearchQuery("");
    setSelectedStudentIds(new Set());
    onClose();
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && handleClose()}
      title="멤버 초대"
      size="md"
    >
      <DialogContent>
        {/* 검색 */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="학생 이름 검색..."
            className="w-full pl-10 pr-4 py-2 rounded-lg bg-bg-secondary text-sm text-text-primary placeholder:text-text-tertiary border border-transparent focus:border-primary focus:outline-none"
          />
        </div>

        {/* 선택 카운트 */}
        {selectedStudentIds.size > 0 && (
          <div className="pt-2 text-sm text-primary font-medium">
            {selectedStudentIds.size}명 선택됨
          </div>
        )}

        <div className="pt-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
            </div>
          ) : filteredStudents && filteredStudents.length > 0 ? (
            <div className="space-y-2 max-h-60 overflow-y-auto">
              {filteredStudents.map((student) => {
                const isSelected = selectedStudentIds.has(student.id);

                return (
                  <button
                    key={student.id}
                    type="button"
                    onClick={() => toggleStudentSelection(student.id)}
                    className={cn(
                      "w-full flex items-center gap-3 p-3 rounded-lg transition-colors",
                      isSelected
                        ? "bg-primary/10 border-2 border-primary"
                        : "hover:bg-bg-secondary border-2 border-transparent"
                    )}
                  >
                    <Checkbox
                      checked={isSelected}
                      onChange={() => toggleStudentSelection(student.id)}
                      onClick={(e) => e.stopPropagation()}
                    />
                    <Avatar name={student.name} size="md" />
                    <div className="flex-1 text-left">
                      <p className="font-medium text-text-primary">
                        {student.name}
                      </p>
                    </div>
                  </button>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-8 text-text-secondary text-sm">
              {searchQuery
                ? "검색 결과가 없습니다"
                : existingMemberIds.length > 0 && students?.length === existingMemberIds.length
                ? "모든 학생이 이미 참여 중입니다"
                : "초대 가능한 학생이 없습니다"}
            </div>
          )}
        </div>
      </DialogContent>

      <DialogFooter>
        <button
          type="button"
          onClick={handleClose}
          className="flex-1 px-4 py-2 rounded-lg border border-border text-text-secondary hover:bg-bg-secondary transition-colors"
        >
          취소
        </button>
        <button
          type="button"
          onClick={handleInvite}
          disabled={!isSubmitEnabled || inviteMutation.isPending}
          className={cn(
            "flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors",
            isSubmitEnabled && !inviteMutation.isPending
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          {inviteMutation.isPending ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <UserPlus className="w-4 h-4" />
          )}
          초대하기
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="components/chat/index.ts">
/**
 * Chat Components
 *
 * 채팅 관련 컴포넌트 모음
 */

// Atoms
export { MessageBubble } from "./atoms/MessageBubble";
export { UnreadBadge } from "./atoms/UnreadBadge";

// Molecules
export { ChatInput } from "./molecules/ChatInput";
export { ChatRoomCard } from "./molecules/ChatRoomCard";

// Organisms
export { ChatList } from "./organisms/ChatList";
export { ChatRoom } from "./organisms/ChatRoom";
</file>

<file path="lib/domains/chat/actions/index.ts">
/**
 * Chat Domain Actions
 *
 * Server Actions for chat functionality.
 */

// Room Actions
export {
  createChatRoomAction,
  getChatRoomsAction,
  getChatRoomDetailAction,
  leaveChatRoomAction,
  startDirectChatAction,
  setAnnouncementAction,
  getAnnouncementAction,
  canSetAnnouncementAction,
} from "./rooms";

// Message Actions
export {
  sendMessageAction,
  getMessagesAction,
  deleteMessageAction,
  markAsReadAction,
  editMessageAction,
  searchMessagesAction,
  getMessagesWithReadStatusAction,
  getSenderInfoAction,
} from "./messages";

// Member Actions
export { inviteMembersAction } from "./members";

// Safety Actions (Block & Report)
export {
  blockUserAction,
  unblockUserAction,
  getBlockedUsersAction,
  reportMessageAction,
  getPendingReportsAction,
  resolveReportAction,
} from "./safety";

// Reaction Actions
export { toggleReactionAction } from "./reactions";

// Pin Actions
export {
  pinMessageAction,
  unpinMessageAction,
  getPinnedMessagesAction,
  canPinMessagesAction,
} from "./pins";
</file>

<file path="lib/domains/chat/actions/members.ts">
"use server";

/**
 * Chat Member Server Actions
 * 멤버 초대/관리
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type { ChatUserType, ChatActionResult } from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 그룹 채팅방에 멤버 초대
 *
 * @param roomId 채팅방 ID
 * @param memberIds 초대할 사용자 ID 목록
 * @param memberTypes 각 사용자의 유형
 */
export async function inviteMembersAction(
  roomId: string,
  memberIds: string[],
  memberTypes: ChatUserType[]
): Promise<ChatActionResult<void>> {
  try {
    // 입력 검증
    if (memberIds.length !== memberTypes.length) {
      return {
        success: false,
        error: "멤버 ID와 유형의 개수가 일치하지 않습니다",
      };
    }

    if (memberIds.length === 0) {
      return {
        success: false,
        error: "초대할 멤버를 선택해주세요",
      };
    }

    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.inviteMembers(
      roomId,
      userId,
      userType,
      memberIds,
      memberTypes
    );
  } catch (error) {
    console.error("[inviteMembersAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "멤버 초대 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/actions/messages.ts">
"use server";

/**
 * Chat Message Server Actions
 * 메시지 전송/조회/삭제
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import * as repository from "../repository";
import type {
  ChatMessage,
  ChatMessageWithSender,
  ChatUserType,
  ChatUser,
  ChatActionResult,
  PaginatedResult,
  GetMessagesOptions,
  SearchMessagesResult,
  MessagesWithReadStatusResult,
} from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 메시지 전송
 *
 * @param roomId 채팅방 ID
 * @param content 메시지 내용 (최대 1000자)
 * @param replyToId 답장 대상 메시지 ID (선택)
 * @returns 전송된 메시지
 */
export async function sendMessageAction(
  roomId: string,
  content: string,
  replyToId?: string | null
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.sendMessage(userId, userType, {
      roomId,
      content,
      replyToId,
    });
  } catch (error) {
    console.error("[sendMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 전송 실패",
    };
  }
}

/**
 * 메시지 목록 조회 (페이지네이션)
 *
 * @param roomId 채팅방 ID
 * @param options 페이지네이션 옵션 (limit, before)
 * @returns 메시지 목록 (발신자 정보 포함)
 */
export async function getMessagesAction(
  roomId: string,
  options: { limit?: number; before?: string } = {}
): Promise<ChatActionResult<PaginatedResult<ChatMessageWithSender>>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    const messageOptions: GetMessagesOptions = {
      roomId,
      limit: options.limit ?? 50,
      before: options.before,
    };

    return await chatService.getMessages(userId, userType, messageOptions);
  } catch (error) {
    console.error("[getMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 조회 실패",
    };
  }
}

/**
 * 메시지 삭제 (본인 메시지만)
 *
 * @param messageId 메시지 ID
 */
export async function deleteMessageAction(
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    return await chatService.deleteMessage(messageId, userId);
  } catch (error) {
    console.error("[deleteMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 삭제 실패",
    };
  }
}

/**
 * 읽음 처리 (채팅방 입장/스크롤 시 호출)
 *
 * @param roomId 채팅방 ID
 */
export async function markAsReadAction(
  roomId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.markRoomAsRead(roomId, userId, userType);
  } catch (error) {
    console.error("[markAsReadAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "읽음 처리 실패",
    };
  }
}

/**
 * 메시지 편집 (본인 메시지, 5분 이내)
 *
 * @param messageId 메시지 ID
 * @param newContent 새 메시지 내용
 */
export async function editMessageAction(
  messageId: string,
  newContent: string
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.editMessage(userId, userType, messageId, newContent);
  } catch (error) {
    console.error("[editMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 수정 실패",
    };
  }
}

/**
 * 메시지 검색
 *
 * @param roomId 채팅방 ID
 * @param query 검색어
 * @param options 페이지네이션 옵션 (limit, offset)
 */
export async function searchMessagesAction(
  roomId: string,
  query: string,
  options: { limit?: number; offset?: number } = {}
): Promise<ChatActionResult<SearchMessagesResult>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.searchMessages(userId, userType, {
      roomId,
      query,
      limit: options.limit,
      offset: options.offset,
    });
  } catch (error) {
    console.error("[searchMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 검색 실패",
    };
  }
}

/**
 * 메시지 목록 조회 (읽음 상태 포함)
 *
 * @param roomId 채팅방 ID
 * @param options 페이지네이션 옵션 (limit, before)
 */
export async function getMessagesWithReadStatusAction(
  roomId: string,
  options: { limit?: number; before?: string } = {}
): Promise<ChatActionResult<MessagesWithReadStatusResult>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.getMessagesWithReadStatus(userId, userType, {
      roomId,
      limit: options.limit ?? 50,
      before: options.before,
    });
  } catch (error) {
    console.error("[getMessagesWithReadStatusAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 조회 실패",
    };
  }
}

/**
 * 발신자 정보 조회 (실시간 이벤트에서 sender 정보 보강용)
 *
 * @param senderId 발신자 ID
 * @param senderType 발신자 타입 (student | admin)
 */
export async function getSenderInfoAction(
  senderId: string,
  senderType: ChatUserType
): Promise<ChatActionResult<ChatUser>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const senderInfo = await repository.findSenderById(senderId, senderType);

    if (!senderInfo) {
      return { success: false, error: "발신자 정보를 찾을 수 없습니다." };
    }

    return {
      success: true,
      data: {
        id: senderInfo.id,
        type: senderType,
        name: senderInfo.name,
        profileImageUrl: senderInfo.profileImageUrl,
      },
    };
  } catch (error) {
    console.error("[getSenderInfoAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "발신자 정보 조회 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/actions/pins.ts">
"use server";

/**
 * Chat Pin Server Actions
 * 메시지 고정/해제 기능
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type {
  ChatActionResult,
  ChatUserType,
  PinnedMessageWithContent,
} from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 메시지 고정
 *
 * @param roomId 채팅방 ID
 * @param messageId 고정할 메시지 ID
 */
export async function pinMessageAction(
  roomId: string,
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.pinMessage(userId, userType, {
      roomId,
      messageId,
    });
  } catch (error) {
    console.error("[pinMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 고정 실패",
    };
  }
}

/**
 * 메시지 고정 해제
 *
 * @param roomId 채팅방 ID
 * @param messageId 고정 해제할 메시지 ID
 */
export async function unpinMessageAction(
  roomId: string,
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.unpinMessage(userId, userType, {
      roomId,
      messageId,
    });
  } catch (error) {
    console.error("[unpinMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 고정 해제 실패",
    };
  }
}

/**
 * 채팅방의 고정 메시지 목록 조회
 *
 * @param roomId 채팅방 ID
 */
export async function getPinnedMessagesAction(
  roomId: string
): Promise<ChatActionResult<PinnedMessageWithContent[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.getPinnedMessages(userId, userType, roomId);
  } catch (error) {
    console.error("[getPinnedMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "고정 메시지 조회 실패",
    };
  }
}

/**
 * 사용자가 고정 권한을 가지고 있는지 확인
 *
 * @param roomId 채팅방 ID
 */
export async function canPinMessagesAction(
  roomId: string
): Promise<ChatActionResult<{ canPin: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);
    const canPin = await chatService.canUserPinMessages(userId, userType, roomId);

    return { success: true, data: { canPin } };
  } catch (error) {
    console.error("[canPinMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "권한 확인 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/actions/reactions.ts">
"use server";

/**
 * Chat Reaction Server Actions
 * 메시지 리액션 토글
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type { ChatActionResult, ChatUserType, ReactionEmoji } from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 메시지 리액션 토글
 * - 리액션이 없으면 추가, 있으면 삭제
 *
 * @param messageId 메시지 ID
 * @param emoji 리액션 이모지 (👍, ❤️, 😂, 🔥, 😮)
 * @returns { added: boolean } - true면 추가됨, false면 삭제됨
 */
export async function toggleReactionAction(
  messageId: string,
  emoji: ReactionEmoji
): Promise<ChatActionResult<{ added: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.toggleReaction(userId, userType, {
      messageId,
      emoji,
    });
  } catch (error) {
    console.error("[toggleReactionAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "리액션 처리 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/actions/rooms.ts">
"use server";

/**
 * Chat Room Server Actions
 * 채팅방 생성/조회/관리
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type {
  ChatRoom,
  ChatRoomListItem,
  ChatRoomMemberWithUser,
  ChatUserType,
  ChatActionResult,
  CreateChatRoomRequest,
  AnnouncementInfo,
} from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 채팅방 생성 (1:1 또는 그룹)
 *
 * @param request 채팅방 생성 요청
 * @returns 생성된 채팅방 또는 기존 1:1 채팅방
 */
export async function createChatRoomAction(
  request: CreateChatRoomRequest
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role, tenantId } = await getCurrentUserRole();

    if (!userId || !role || !tenantId) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.createOrGetRoom(
      tenantId,
      userId,
      userType,
      request
    );
  } catch (error) {
    console.error("[createChatRoomAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 생성 실패",
    };
  }
}

/**
 * 내 채팅방 목록 조회
 *
 * @param options 페이지네이션 옵션
 * @returns 채팅방 목록 (마지막 메시지, 안 읽은 수 포함)
 */
export async function getChatRoomsAction(
  options: { limit?: number; offset?: number } = {}
): Promise<ChatActionResult<ChatRoomListItem[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    const rooms = await chatService.getRoomList(userId, userType, options);

    return { success: true, data: rooms };
  } catch (error) {
    console.error("[getChatRoomsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 목록 조회 실패",
    };
  }
}

/**
 * 채팅방 상세 정보 조회
 *
 * @param roomId 채팅방 ID
 * @returns 채팅방 정보 + 멤버 목록
 */
export async function getChatRoomDetailAction(
  roomId: string
): Promise<ChatActionResult<{ room: ChatRoom; members: ChatRoomMemberWithUser[] }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.getRoomDetail(roomId, userId, userType);
  } catch (error) {
    console.error("[getChatRoomDetailAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 조회 실패",
    };
  }
}

/**
 * 채팅방 나가기
 *
 * @param roomId 채팅방 ID
 */
export async function leaveChatRoomAction(
  roomId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.leaveRoom(roomId, userId, userType);
  } catch (error) {
    console.error("[leaveChatRoomAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 나가기 실패",
    };
  }
}

/**
 * 1:1 채팅 시작 (또는 기존 방 열기)
 *
 * @param targetUserId 대화 상대 ID
 * @param targetUserType 대화 상대 유형
 * @returns 1:1 채팅방
 */
export async function startDirectChatAction(
  targetUserId: string,
  targetUserType: ChatUserType
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role, tenantId } = await getCurrentUserRole();

    if (!userId || !role || !tenantId) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.createOrGetRoom(tenantId, userId, userType, {
      type: "direct",
      memberIds: [targetUserId],
      memberTypes: [targetUserType],
    });
  } catch (error) {
    console.error("[startDirectChatAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅 시작 실패",
    };
  }
}

// ============================================
// 공지 Actions
// ============================================

/**
 * 채팅방 공지 설정
 *
 * @param roomId 채팅방 ID
 * @param content 공지 내용 (null이면 공지 삭제)
 */
export async function setAnnouncementAction(
  roomId: string,
  content: string | null
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.setAnnouncement(userId, userType, {
      roomId,
      content,
    });
  } catch (error) {
    console.error("[setAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "공지 설정 실패",
    };
  }
}

/**
 * 채팅방 공지 조회
 *
 * @param roomId 채팅방 ID
 */
export async function getAnnouncementAction(
  roomId: string
): Promise<ChatActionResult<AnnouncementInfo | null>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.getAnnouncement(userId, userType, roomId);
  } catch (error) {
    console.error("[getAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "공지 조회 실패",
    };
  }
}

/**
 * 사용자가 공지 설정 권한을 가지고 있는지 확인
 *
 * @param roomId 채팅방 ID
 */
export async function canSetAnnouncementAction(
  roomId: string
): Promise<ChatActionResult<{ canSet: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);
    const canSet = await chatService.canUserSetAnnouncement(userId, userType, roomId);

    return { success: true, data: { canSet } };
  } catch (error) {
    console.error("[canSetAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "권한 확인 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/actions/safety.ts">
"use server";

/**
 * Chat Safety Server Actions
 * 차단/신고 기능 (App Store 필수)
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import * as chatRepository from "../repository";
import type {
  ChatUserType,
  ChatActionResult,
  ChatBlock,
  ChatReport,
  ChatReportWithDetails,
  ReportReason,
  GetReportsFilter,
} from "../types";

/**
 * 현재 사용자의 userType 결정
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * 관리자 역할 확인
 */
function isAdminRole(role: string | null): boolean {
  return role === "admin" || role === "consultant";
}

// ============================================
// 차단 기능
// ============================================

/**
 * 사용자 차단
 *
 * @param blockedId 차단할 사용자 ID
 * @param blockedType 차단할 사용자 유형
 */
export async function blockUserAction(
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    // 자기 자신 차단 방지
    if (blockedId === userId) {
      return {
        success: false,
        error: "자기 자신을 차단할 수 없습니다",
      };
    }

    return await chatService.blockUser(
      userId,
      userType,
      blockedId,
      blockedType
    );
  } catch (error) {
    console.error("[blockUserAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "차단 실패",
    };
  }
}

/**
 * 차단 해제
 *
 * @param blockedId 차단 해제할 사용자 ID
 * @param blockedType 차단 해제할 사용자 유형
 */
export async function unblockUserAction(
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.unblockUser(
      userId,
      userType,
      blockedId,
      blockedType
    );
  } catch (error) {
    console.error("[unblockUserAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "차단 해제 실패",
    };
  }
}

/**
 * 내 차단 목록 조회
 */
export async function getBlockedUsersAction(): Promise<
  ChatActionResult<ChatBlock[]>
> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    const blocks = await chatRepository.findBlocksByUser(userId, userType);

    return { success: true, data: blocks };
  } catch (error) {
    console.error("[getBlockedUsersAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "차단 목록 조회 실패",
    };
  }
}

// ============================================
// 신고 기능
// ============================================

/**
 * 메시지 신고
 *
 * @param messageId 신고할 메시지 ID
 * @param reason 신고 사유
 * @param description 상세 설명 (선택)
 */
export async function reportMessageAction(
  messageId: string,
  reason: ReportReason,
  description?: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    const userType = getUserType(role);

    return await chatService.reportMessage(
      userId,
      userType,
      messageId,
      reason,
      description
    );
  } catch (error) {
    console.error("[reportMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 실패",
    };
  }
}

// ============================================
// 관리자 전용 기능
// ============================================

/**
 * 대기 중인 신고 목록 조회 (관리자 전용)
 */
export async function getPendingReportsAction(): Promise<
  ChatActionResult<ChatReport[]>
> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    // 관리자 권한 확인
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "관리자 권한이 필요합니다",
      };
    }

    const reports = await chatRepository.findPendingReports();

    return { success: true, data: reports };
  } catch (error) {
    console.error("[getPendingReportsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 목록 조회 실패",
    };
  }
}

/**
 * 신고 처리 (관리자 전용)
 *
 * @param reportId 신고 ID
 * @param status 처리 상태 (resolved, dismissed)
 * @param notes 처리 메모
 */
export async function resolveReportAction(
  reportId: string,
  status: "resolved" | "dismissed",
  notes?: string
): Promise<ChatActionResult<ChatReport>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    // 관리자 권한 확인
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "관리자 권한이 필요합니다",
      };
    }

    const report = await chatRepository.updateReport(reportId, {
      status,
      reviewed_by: userId,
      reviewed_at: new Date().toISOString(),
      resolution_notes: notes ?? null,
    });

    return { success: true, data: report };
  } catch (error) {
    console.error("[resolveReportAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 처리 실패",
    };
  }
}

/**
 * 모든 신고 목록 조회 (관리자 전용, 필터 지원)
 */
export async function getAllReportsAction(
  filters?: GetReportsFilter
): Promise<ChatActionResult<ChatReport[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    // 관리자 권한 확인
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "관리자 권한이 필요합니다",
      };
    }

    const reports = await chatRepository.findAllReports(filters);

    return { success: true, data: reports };
  } catch (error) {
    console.error("[getAllReportsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 목록 조회 실패",
    };
  }
}

/**
 * 신고 상세 조회 (관리자 전용)
 * 신고 정보 + 신고된 메시지 + 신고자/피신고자 정보
 */
export async function getReportDetailsAction(
  reportId: string
): Promise<ChatActionResult<ChatReportWithDetails>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "인증이 필요합니다." };
    }

    // 관리자 권한 확인
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "관리자 권한이 필요합니다",
      };
    }

    // 신고 기본 정보 조회
    const report = await chatRepository.findReportById(reportId);
    if (!report) {
      return { success: false, error: "신고를 찾을 수 없습니다." };
    }

    // 신고된 메시지 조회
    let reportedMessage = null;
    if (report.reported_message_id) {
      reportedMessage = await chatRepository.findMessageById(
        report.reported_message_id
      );
    }

    // 사용자 정보 배치 조회
    const senderKeys: Array<{ id: string; type: ChatUserType }> = [];

    // 신고자 정보
    senderKeys.push({ id: report.reporter_id, type: report.reporter_type });

    // 피신고자 정보
    if (report.reported_user_id && report.reported_user_type) {
      senderKeys.push({
        id: report.reported_user_id,
        type: report.reported_user_type,
      });
    }

    const senderMap = await chatRepository.findSendersByIds(senderKeys);

    // 신고자 정보 매핑
    const reporterInfo = senderMap.get(
      `${report.reporter_id}_${report.reporter_type}`
    );
    const reporter = reporterInfo
      ? {
          id: reporterInfo.id,
          type: report.reporter_type,
          name: reporterInfo.name,
          profileImageUrl: reporterInfo.profileImageUrl,
        }
      : null;

    // 피신고자 정보 매핑
    let reportedUser = null;
    if (report.reported_user_id && report.reported_user_type) {
      const reportedUserInfo = senderMap.get(
        `${report.reported_user_id}_${report.reported_user_type}`
      );
      if (reportedUserInfo) {
        reportedUser = {
          id: reportedUserInfo.id,
          type: report.reported_user_type,
          name: reportedUserInfo.name,
          profileImageUrl: reportedUserInfo.profileImageUrl,
        };
      }
    }

    const reportWithDetails: ChatReportWithDetails = {
      ...report,
      reportedMessage,
      reporter,
      reportedUser,
    };

    return { success: true, data: reportWithDetails };
  } catch (error) {
    console.error("[getReportDetailsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 상세 조회 실패",
    };
  }
}
</file>

<file path="lib/domains/chat/hooks/index.ts">
/**
 * Chat 도메인 훅 exports
 */

export {
  useChatRoomLogic,
  type UseChatRoomLogicOptions,
  type UseChatRoomLogicReturn,
} from "./useChatRoomLogic";
</file>

<file path="lib/domains/chat/hooks/useChatRoomLogic.ts">
"use client";

/**
 * useChatRoomLogic - 채팅방 비즈니스 로직 훅
 *
 * ChatRoom 컴포넌트의 비즈니스 로직을 분리하여
 * 테스트 용이성과 재사용성을 높입니다.
 */

import { useCallback, useMemo, useState, useEffect, useRef } from "react";
import {
  useInfiniteQuery,
  useQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import {
  getMessagesWithReadStatusAction,
  sendMessageAction,
  markAsReadAction,
  getChatRoomDetailAction,
  editMessageAction,
  deleteMessageAction,
  toggleReactionAction,
  getPinnedMessagesAction,
  pinMessageAction,
  unpinMessageAction,
  canPinMessagesAction,
  getAnnouncementAction,
  setAnnouncementAction,
  canSetAnnouncementAction,
} from "@/lib/domains/chat/actions";
import {
  isMessageEdited,
  type ReactionEmoji,
  type ReplyTargetInfo,
  type PinnedMessageWithContent,
  type AnnouncementInfo,
  type ChatRoom,
  type ChatMessageWithGrouping,
  type ChatRoomMemberWithUser,
  type PresenceUser,
} from "@/lib/domains/chat/types";
import { processMessagesWithGrouping } from "@/lib/domains/chat/messageGrouping";
import { useChatRealtime, useChatPresence } from "@/lib/realtime";
import { useDebouncedCallback } from "@/lib/hooks/useDebounce";

// ============================================
// 타입 정의
// ============================================

export interface UseChatRoomLogicOptions {
  roomId: string;
  userId: string;
  isAtBottom: boolean;
  onNewMessageArrived?: () => void;
}

export interface UseChatRoomLogicReturn {
  data: {
    room: ChatRoom | undefined;
    messages: ChatMessageWithGrouping[];
    pinnedMessages: PinnedMessageWithContent[];
    announcement: AnnouncementInfo | null;
    readCounts: Record<string, number>;
    onlineUsers: PresenceUser[];
    typingUsers: PresenceUser[];
    members: ChatRoomMemberWithUser[];
  };
  permissions: {
    canPin: boolean;
    canSetAnnouncement: boolean;
  };
  actions: {
    sendMessage: (content: string, replyToId?: string | null) => void;
    editMessage: (messageId: string, content: string) => void;
    deleteMessage: (messageId: string) => void;
    toggleReaction: (messageId: string, emoji: ReactionEmoji) => void;
    togglePin: (messageId: string, isPinned: boolean) => void;
    setAnnouncement: (content: string | null) => void;
    markAsRead: () => void;
    setTyping: (isTyping: boolean) => void;
    retryMessage: (message: ChatMessageWithGrouping) => void;
    removeFailedMessage: (messageId: string) => void;
  };
  status: {
    isLoading: boolean;
    isSending: boolean;
    isEditing: boolean;
    isDeleting: boolean;
    error: Error | null;
    hasNextPage: boolean;
    isFetchingNextPage: boolean;
    fetchNextPage: () => Promise<unknown>;
  };
  pinnedMessageIds: Set<string>;
  replyTargetState: {
    replyTarget: ReplyTargetInfo | null;
    setReplyTarget: (target: ReplyTargetInfo | null) => void;
  };
  utils: {
    canEditMessage: (createdAt: string) => boolean;
    isMessageEdited: (message: ChatMessageWithGrouping) => boolean;
  };
}

// ============================================
// 훅 구현
// ============================================

export function useChatRoomLogic({
  roomId,
  userId,
  isAtBottom,
  onNewMessageArrived,
}: UseChatRoomLogicOptions): UseChatRoomLogicReturn {
  const queryClient = useQueryClient();
  const [replyTarget, setReplyTarget] = useState<ReplyTargetInfo | null>(null);

  // isAtBottom을 ref로 추적하여 콜백에서 항상 최신 값 사용
  const isAtBottomRef = useRef(isAtBottom);
  useEffect(() => {
    isAtBottomRef.current = isAtBottom;
  }, [isAtBottom]);

  // ============================================
  // Queries
  // ============================================

  // 채팅방 정보 조회
  const { data: roomData } = useQuery({
    queryKey: ["chat-room", roomId],
    queryFn: async () => {
      const result = await getChatRoomDetailAction(roomId);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
  });

  // 고정 메시지 목록 조회
  const { data: pinnedMessages = [] } = useQuery({
    queryKey: ["chat-pinned", roomId],
    queryFn: async () => {
      const result = await getPinnedMessagesAction(roomId);
      if (!result.success) return [];
      return result.data ?? [];
    },
  });

  // 고정 권한 확인
  const { data: canPinData } = useQuery({
    queryKey: ["chat-can-pin", roomId],
    queryFn: async () => {
      const result = await canPinMessagesAction(roomId);
      if (!result.success) return { canPin: false };
      return result.data ?? { canPin: false };
    },
  });

  const canPin = canPinData?.canPin ?? false;

  // 공지 조회
  const { data: announcementData } = useQuery({
    queryKey: ["chat-announcement", roomId],
    queryFn: async () => {
      const result = await getAnnouncementAction(roomId);
      if (!result.success) return null;
      return result.data;
    },
  });

  // 공지 설정 권한 확인
  const { data: canSetAnnouncementData } = useQuery({
    queryKey: ["chat-can-set-announcement", roomId],
    queryFn: async () => {
      const result = await canSetAnnouncementAction(roomId);
      if (!result.success) return { canSet: false };
      return result.data ?? { canSet: false };
    },
  });

  const canSetAnnouncement = canSetAnnouncementData?.canSet ?? false;

  // 고정된 메시지 ID Set (빠른 조회용)
  const pinnedMessageIds = useMemo(
    () => new Set(pinnedMessages.map((p: PinnedMessageWithContent) => p.message_id)),
    [pinnedMessages]
  );

  // 메시지 목록 조회 (읽음 상태 포함, 무한 스크롤)
  const {
    data: messagesData,
    isLoading,
    error,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["chat-messages", roomId],
    queryFn: async ({ pageParam }) => {
      const result = await getMessagesWithReadStatusAction(roomId, {
        limit: 50,
        before: pageParam,
      });
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    initialPageParam: undefined as string | undefined,
    getNextPageParam: (lastPage) => {
      if (!lastPage?.hasMore || !lastPage?.messages?.length) return undefined;
      return lastPage.messages[0].id; // 가장 오래된 메시지 ID
    },
    staleTime: 10 * 1000, // 10초
  });

  // ============================================
  // Data Transformations
  // ============================================

  // 모든 페이지의 메시지를 시간순 정렬로 병합
  const allMessages = useMemo(() => {
    if (!messagesData?.pages) return [];

    // 과거 → 현재 순서로 병합 (pages는 역순으로 쌓임)
    return messagesData.pages
      .slice()
      .reverse()
      .flatMap((page) => page?.messages ?? []);
  }, [messagesData?.pages]);

  // 메시지에 그룹핑 정보 추가 (날짜 구분선, 이름/시간 표시 여부)
  const messagesWithGrouping = useMemo(() => {
    return processMessagesWithGrouping(allMessages);
  }, [allMessages]);

  // readCounts 병합
  const allReadCounts = useMemo(() => {
    if (!messagesData?.pages) return {};

    return messagesData.pages.reduce(
      (acc, page) => ({
        ...acc,
        ...(page?.readCounts ?? {}),
      }),
      {} as Record<string, number>
    );
  }, [messagesData?.pages]);

  // ============================================
  // Mutations
  // ============================================

  // 메시지 전송 (Optimistic Updates 적용)
  const sendMutation = useMutation({
    mutationFn: async ({
      content,
      replyToId,
    }: {
      content: string;
      replyToId?: string | null;
    }) => {
      const result = await sendMessageAction(roomId, content, replyToId);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onMutate: async ({ content, replyToId }) => {
      // 1. 진행 중인 쿼리 취소 (낙관적 업데이트와 충돌 방지)
      await queryClient.cancelQueries({ queryKey: ["chat-messages", roomId] });

      // 2. 이전 데이터 스냅샷 저장 (롤백용)
      const previousMessages = queryClient.getQueryData(["chat-messages", roomId]);

      // 이전 답장 상태 저장 (복원용)
      const previousReplyTarget = replyTarget;

      // 3. 낙관적 업데이트 (즉시 UI 반영) - InfiniteQuery 구조
      const tempId = `temp-${Date.now()}`;
      const optimisticMessage = {
        id: tempId,
        content,
        sender_id: userId,
        sender_type: "student" as const,
        message_type: "text" as const,
        created_at: new Date().toISOString(),
        room_id: roomId,
        is_deleted: false,
        reply_to_id: replyToId ?? null,
        replyTarget: replyTarget,
        sender: { name: "나", type: "student" as const, id: userId },
        status: "sending" as const,
      };

      queryClient.setQueryData(
        ["chat-messages", roomId],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (old: any) => {
          if (!old?.pages?.length) return old;

          // 첫 번째 페이지(최신)에 메시지 추가
          const firstPage = old.pages[0];
          return {
            ...old,
            pages: [
              { ...firstPage, messages: [...firstPage.messages, optimisticMessage] },
              ...old.pages.slice(1),
            ],
          };
        }
      );

      // 답장 상태 초기화
      setReplyTarget(null);

      // 4. 즉시 스크롤
      setTimeout(() => onNewMessageArrived?.(), 0);

      return { previousMessages, previousReplyTarget, tempId };
    },
    onSuccess: (data, _variables, context) => {
      // 5. 성공 시 temp 메시지를 실제 메시지로 교체 (invalidate 대신 직접 업데이트)
      // 이렇게 하면 실시간 이벤트와의 경쟁 조건을 피할 수 있음
      const tempId = context?.tempId;
      if (tempId && data) {
        queryClient.setQueryData(
          ["chat-messages", roomId],
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (old: any) => {
            if (!old?.pages?.length) return old;
            return {
              ...old,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              pages: old.pages.map((page: any) => ({
                ...page,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                messages: page.messages.map((m: any) =>
                  m.id === tempId
                    ? {
                        ...m,
                        ...data,
                        status: "sent" as const,
                        // sender 정보는 낙관적 업데이트에서 이미 설정됨
                        sender: m.sender,
                        replyTarget: m.replyTarget,
                      }
                    : m
                ),
              })),
            };
          }
        );
      }
    },
    onError: (_err, _variables, context) => {
      // 6. 실패 시 롤백 대신 status를 error로 변경
      const tempId = context?.tempId;
      if (tempId) {
        queryClient.setQueryData(
          ["chat-messages", roomId],
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (old: any) => {
            if (!old?.pages?.length) return old;
            return {
              ...old,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              pages: old.pages.map((page: any) => ({
                ...page,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                messages: page.messages.map((m: any) =>
                  m.id === tempId ? { ...m, status: "error" } : m
                ),
              })),
            };
          }
        );
      }

      // 답장 상태 복원
      if (context?.previousReplyTarget) {
        setReplyTarget(context.previousReplyTarget);
      }
    },
    // onSettled 제거: invalidateQueries가 실시간 이벤트와 경쟁하여 새로고침 문제 발생
    // 대신 onSuccess에서 setQueryData로 직접 업데이트
  });

  // 메시지 편집
  const editMutation = useMutation({
    mutationFn: async ({
      messageId,
      content,
    }: {
      messageId: string;
      content: string;
    }) => {
      const result = await editMessageAction(messageId, content);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // 메시지 삭제
  const deleteMutation = useMutation({
    mutationFn: async (messageId: string) => {
      const result = await deleteMessageAction(messageId);
      if (!result.success) throw new Error(result.error);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // 리액션 토글
  const reactionMutation = useMutation({
    mutationFn: async ({
      messageId,
      emoji,
    }: {
      messageId: string;
      emoji: ReactionEmoji;
    }) => {
      const result = await toggleReactionAction(messageId, emoji);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // 메시지 고정/해제
  const pinMutation = useMutation({
    mutationFn: async ({
      messageId,
      isPinned,
    }: {
      messageId: string;
      isPinned: boolean;
    }) => {
      if (isPinned) {
        const result = await unpinMessageAction(roomId, messageId);
        if (!result.success) throw new Error(result.error);
      } else {
        const result = await pinMessageAction(roomId, messageId);
        if (!result.success) throw new Error(result.error);
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-pinned", roomId] });
    },
  });

  // 공지 설정/삭제
  const announcementMutation = useMutation({
    mutationFn: async (content: string | null) => {
      const result = await setAnnouncementAction(roomId, content);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-announcement", roomId] });
    },
  });

  // 읽음 처리
  const markAsReadMutation = useMutation({
    mutationFn: async () => {
      await markAsReadAction(roomId);
    },
    onSuccess: () => {
      // 채팅방 목록의 unread count 업데이트
      queryClient.invalidateQueries({ queryKey: ["chat-rooms"] });
    },
  });

  // 읽음 처리 Debounce (500ms) - 무제한 DB 쓰기 방지
  const debouncedMarkAsRead = useDebouncedCallback(() => {
    markAsReadMutation.mutate();
  }, 500);

  // ============================================
  // Realtime
  // ============================================

  // 실시간 구독
  useChatRealtime({
    roomId,
    userId,
    onNewMessage: useCallback(() => {
      // 스크롤이 맨 아래에 있으면 자동 스크롤 (ref 사용으로 항상 최신 값)
      if (isAtBottomRef.current) {
        onNewMessageArrived?.();
      }
      // 읽음 처리 (Debounce 적용)
      debouncedMarkAsRead();
    }, [onNewMessageArrived, debouncedMarkAsRead]),
  });

  // 현재 사용자 이름 (Presence용)
  const currentUserName =
    roomData?.members.find((m) => m.user_id === userId)?.user?.name ?? "사용자";

  // Presence (타이핑/온라인 상태)
  const { onlineUsers, typingUsers, setTyping } = useChatPresence({
    roomId,
    userId,
    userName: currentUserName,
    enabled: !!roomData,
  });

  // 입장 시 읽음 처리
  useEffect(() => {
    markAsReadMutation.mutate();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  // ============================================
  // Actions
  // ============================================

  const sendMessage = useCallback(
    (content: string, replyToId?: string | null) => {
      sendMutation.mutate({ content, replyToId });
    },
    [sendMutation]
  );

  const editMessage = useCallback(
    (messageId: string, content: string) => {
      editMutation.mutate({ messageId, content });
    },
    [editMutation]
  );

  const deleteMessage = useCallback(
    (messageId: string) => {
      deleteMutation.mutate(messageId);
    },
    [deleteMutation]
  );

  const toggleReaction = useCallback(
    (messageId: string, emoji: ReactionEmoji) => {
      reactionMutation.mutate({ messageId, emoji });
    },
    [reactionMutation]
  );

  const togglePin = useCallback(
    (messageId: string, isPinned: boolean) => {
      pinMutation.mutate({ messageId, isPinned });
    },
    [pinMutation]
  );

  const setAnnouncementAction_ = useCallback(
    (content: string | null) => {
      announcementMutation.mutate(content);
    },
    [announcementMutation]
  );

  const markAsRead = useCallback(() => {
    markAsReadMutation.mutate();
  }, [markAsReadMutation]);

  // 메시지 재전송 핸들러
  const retryMessage = useCallback(
    (message: ChatMessageWithGrouping) => {
      // 1. status를 sending으로 변경
      queryClient.setQueryData(
        ["chat-messages", roomId],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (old: any) => {
          if (!old?.pages?.length) return old;
          return {
            ...old,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            pages: old.pages.map((page: any) => ({
              ...page,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              messages: page.messages.map((m: any) =>
                m.id === message.id ? { ...m, status: "sending" } : m
              ),
            })),
          };
        }
      );

      // 2. 재전송 (기존 메시지 제거 후 새 메시지 추가)
      const replyToId = (message as { reply_to_id?: string | null }).reply_to_id;
      sendMutation.mutate(
        { content: message.content, replyToId },
        {
          onSuccess: () => {
            // 기존 실패 메시지 제거 (새 메시지가 낙관적 업데이트로 추가됨)
            queryClient.setQueryData(
              ["chat-messages", roomId],
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              (old: any) => {
                if (!old?.pages?.length) return old;
                return {
                  ...old,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  pages: old.pages.map((page: any) => ({
                    ...page,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    messages: page.messages.filter((m: any) => m.id !== message.id),
                  })),
                };
              }
            );
          },
          onError: () => {
            // 다시 error 상태로
            queryClient.setQueryData(
              ["chat-messages", roomId],
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              (old: any) => {
                if (!old?.pages?.length) return old;
                return {
                  ...old,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  pages: old.pages.map((page: any) => ({
                    ...page,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    messages: page.messages.map((m: any) =>
                      m.id === message.id ? { ...m, status: "error" } : m
                    ),
                  })),
                };
              }
            );
          },
        }
      );
    },
    [roomId, queryClient, sendMutation]
  );

  // 전송 실패 메시지 삭제 핸들러
  const removeFailedMessage = useCallback(
    (messageId: string) => {
      queryClient.setQueryData(
        ["chat-messages", roomId],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (old: any) => {
          if (!old?.pages?.length) return old;
          return {
            ...old,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            pages: old.pages.map((page: any) => ({
              ...page,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              messages: page.messages.filter((m: any) => m.id !== messageId),
            })),
          };
        }
      );
    },
    [roomId, queryClient]
  );

  // ============================================
  // Utils
  // ============================================

  // 편집 가능 여부 확인 (5분 이내)
  const canEditMessage = useCallback((createdAt: string) => {
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
    return new Date(createdAt).getTime() > fiveMinutesAgo;
  }, []);

  // ============================================
  // Return
  // ============================================

  return {
    data: {
      room: roomData?.room,
      messages: messagesWithGrouping,
      pinnedMessages,
      announcement: announcementData ?? null,
      readCounts: allReadCounts,
      onlineUsers,
      typingUsers,
      members: roomData?.members ?? [],
    },
    permissions: {
      canPin,
      canSetAnnouncement,
    },
    actions: {
      sendMessage,
      editMessage,
      deleteMessage,
      toggleReaction,
      togglePin,
      setAnnouncement: setAnnouncementAction_,
      markAsRead,
      setTyping,
      retryMessage,
      removeFailedMessage,
    },
    status: {
      isLoading,
      isSending: sendMutation.isPending,
      isEditing: editMutation.isPending,
      isDeleting: deleteMutation.isPending,
      error: error as Error | null,
      hasNextPage: hasNextPage ?? false,
      isFetchingNextPage,
      fetchNextPage,
    },
    pinnedMessageIds,
    replyTargetState: {
      replyTarget,
      setReplyTarget,
    },
    utils: {
      canEditMessage,
      isMessageEdited,
    },
  };
}
</file>

<file path="lib/domains/chat/index.ts">
/**
 * Chat 도메인 Public API
 */

// Types
export type {
  // 기본 타입
  ChatRoom,
  ChatRoomMember,
  ChatMessage,
  ChatBlock,
  ChatReport,
  // Insert/Update 타입
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessageInsert,
  ChatMessageUpdate,
  ChatBlockInsert,
  ChatReportInsert,
  ChatReportUpdate,
  // 열거형
  ChatRoomType,
  ChatUserType,
  ChatMemberRole,
  ChatMessageType,
  ReportReason,
  ReportStatus,
  // 복합 타입
  ChatUser,
  ChatMessageWithSender,
  ChatRoomWithDetails,
  ChatRoomMemberWithUser,
  ChatRoomListItem,
  // API 타입
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
} from "./types";

// Service (비즈니스 로직)
export {
  createOrGetRoom,
  getRoomList,
  getRoomDetail,
  sendMessage,
  getMessages,
  deleteMessage,
  markRoomAsRead,
  inviteMembers,
  leaveRoom,
  blockUser,
  unblockUser,
  reportMessage,
} from "./service";

// Repository (데이터 접근 - 필요 시 직접 사용)
export * as chatRepository from "./repository";
</file>

<file path="lib/domains/chat/messageGrouping.ts">
/**
 * 메시지 그룹핑 유틸리티
 *
 * 연속된 메시지를 그룹핑하고 날짜 구분선을 처리합니다.
 */

import { isSameDay, differenceInSeconds, format } from "date-fns";
import { ko } from "date-fns/locale";
import type {
  ChatMessageWithSender,
  ChatMessageWithGrouping,
  MessageGroupingInfo,
} from "./types";

/** 그룹핑 시간 임계값 (초) - 1분 */
const GROUPING_THRESHOLD_SECONDS = 60;

/**
 * 두 메시지가 같은 날인지 확인
 */
export function isSameMessageDay(date1: string, date2: string): boolean {
  return isSameDay(new Date(date1), new Date(date2));
}

/**
 * 두 메시지가 그룹핑 시간 임계값 내에 있는지 확인
 */
export function isWithinGroupingThreshold(
  date1: string,
  date2: string
): boolean {
  const diff = Math.abs(
    differenceInSeconds(new Date(date1), new Date(date2))
  );
  return diff <= GROUPING_THRESHOLD_SECONDS;
}

/**
 * 날짜 구분선용 포맷 (예: "2024년 1월 15일 월요일")
 */
export function formatDateDivider(dateStr: string): string {
  return format(new Date(dateStr), "yyyy년 M월 d일 EEEE", { locale: ko });
}

/**
 * 메시지 시간 포맷 (예: "오후 3:45")
 */
export function formatMessageTime(dateStr: string): string {
  return format(new Date(dateStr), "a h:mm", { locale: ko });
}

/**
 * 메시지 배열에 그룹핑 정보를 추가
 *
 * 그룹핑 규칙:
 * - 같은 발신자 + 1분 이내 = 그룹핑
 * - 시스템 메시지 = 그룹핑 중단
 * - 답장 메시지 = 그룹핑 중단
 * - 날짜 변경 = 그룹핑 중단 + 날짜 구분선
 *
 * @param messages 메시지 배열 (시간순 정렬됨)
 * @returns 그룹핑 정보가 포함된 메시지 배열
 */
export function processMessagesWithGrouping(
  messages: ChatMessageWithSender[]
): ChatMessageWithGrouping[] {
  if (messages.length === 0) return [];

  const result: ChatMessageWithGrouping[] = [];

  for (let i = 0; i < messages.length; i++) {
    const current = messages[i];
    const prev = i > 0 ? messages[i - 1] : null;
    const next = i < messages.length - 1 ? messages[i + 1] : null;

    // 이전 메시지와 날짜가 다른지 확인
    const showDateDivider =
      !prev || !isSameMessageDay(prev.created_at, current.created_at);
    const dateDividerText = showDateDivider
      ? formatDateDivider(current.created_at)
      : undefined;

    // 현재 메시지가 이전 메시지와 그룹핑될 수 있는지 확인
    const canGroupWithPrev =
      prev &&
      !showDateDivider && // 날짜 변경 시 그룹핑 안 함
      current.message_type !== "system" &&
      prev.message_type !== "system" &&
      current.sender_id === prev.sender_id &&
      isWithinGroupingThreshold(prev.created_at, current.created_at) &&
      !current.reply_to_id; // 답장 메시지는 그룹핑 안 함

    // 다음 메시지가 현재 메시지와 그룹핑될 수 있는지 확인
    const nextIsGrouped =
      next &&
      isSameMessageDay(current.created_at, next.created_at) &&
      next.message_type !== "system" &&
      current.message_type !== "system" &&
      current.sender_id === next.sender_id &&
      isWithinGroupingThreshold(current.created_at, next.created_at) &&
      !next.reply_to_id;

    const grouping: MessageGroupingInfo = {
      // 그룹 첫 메시지에만 이름 표시 (이전과 그룹핑 안 됨)
      showName: !canGroupWithPrev,
      // 그룹 마지막 메시지에만 시간 표시 (다음과 그룹핑 안 됨)
      showTime: !nextIsGrouped,
      // 이전 메시지와 그룹핑됨 (간격 축소용)
      isGrouped: !!canGroupWithPrev,
      showDateDivider,
      dateDividerText,
    };

    result.push({
      ...current,
      grouping,
    });
  }

  return result;
}
</file>

<file path="lib/domains/chat/repository.ts">
/**
 * Chat 도메인 Repository
 * 채팅 데이터 접근 레이어
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import type {
  ChatRoom,
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMember,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessage,
  ChatMessageInsert,
  ChatBlock,
  ChatBlockInsert,
  ChatReport,
  ChatReportInsert,
  ChatReportUpdate,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatUserType,
  SearchMessagesOptions,
  MessageReaction,
  ReactionEmoji,
  PinnedMessage,
  PinnedMessageInsert,
} from "./types";

// ============================================
// 컬럼 정의
// ============================================

const CHAT_ROOM_COLUMNS = `
  id,
  tenant_id,
  type,
  name,
  created_by,
  created_by_type,
  is_active,
  announcement,
  announcement_by,
  announcement_by_type,
  announcement_at,
  created_at,
  updated_at
` as const;

const CHAT_MEMBER_COLUMNS = `
  id,
  room_id,
  user_id,
  user_type,
  role,
  last_read_at,
  is_muted,
  left_at,
  created_at,
  updated_at
` as const;

const CHAT_MESSAGE_COLUMNS = `
  id,
  room_id,
  sender_id,
  sender_type,
  message_type,
  content,
  reply_to_id,
  is_deleted,
  deleted_at,
  created_at,
  updated_at
` as const;

const CHAT_REACTION_COLUMNS = `
  id,
  message_id,
  user_id,
  user_type,
  emoji,
  created_at
` as const;

// ============================================
// 채팅방 Repository
// ============================================

/**
 * 채팅방 ID로 조회
 */
export async function findRoomById(
  roomId: string
): Promise<ChatRoom | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .eq("id", roomId)
    .eq("is_active", true)
    .maybeSingle();

  if (error && error.code !== "PGRST116") {
    throw error;
  }

  return data as ChatRoom | null;
}

/**
 * 사용자의 채팅방 목록 조회 (최신순)
 */
export async function findRoomsByUser(
  userId: string,
  userType: ChatUserType,
  options: GetRoomsOptions = {}
): Promise<ChatRoom[]> {
  const { limit = 20, offset = 0 } = options;
  const supabase = await createSupabaseServerClient();

  // 멤버로 참여 중인 방 ID 목록 조회
  const { data: memberData, error: memberError } = await supabase
    .from("chat_room_members")
    .select("room_id")
    .eq("user_id", userId)
    .eq("user_type", userType)
    .is("left_at", null);

  if (memberError) throw memberError;
  if (!memberData || memberData.length === 0) return [];

  const roomIds = memberData.map((m) => m.room_id);

  // 채팅방 정보 조회
  const { data, error } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .in("id", roomIds)
    .eq("is_active", true)
    .order("updated_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;

  return (data as ChatRoom[]) ?? [];
}

/**
 * 두 사용자 간의 1:1 채팅방 찾기
 */
export async function findDirectRoom(
  user1Id: string,
  user1Type: ChatUserType,
  user2Id: string,
  user2Type: ChatUserType
): Promise<ChatRoom | null> {
  const supabase = await createSupabaseServerClient();

  // user1이 속한 direct 방 조회
  const { data: user1Rooms, error: error1 } = await supabase
    .from("chat_room_members")
    .select("room_id")
    .eq("user_id", user1Id)
    .eq("user_type", user1Type)
    .is("left_at", null);

  if (error1) throw error1;
  if (!user1Rooms || user1Rooms.length === 0) return null;

  const roomIds = user1Rooms.map((r) => r.room_id);

  // user2도 속한 direct 방 찾기
  const { data: matchingRoom, error: error2 } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .in("id", roomIds)
    .eq("type", "direct")
    .eq("is_active", true)
    .maybeSingle();

  if (error2 && error2.code !== "PGRST116") throw error2;
  if (!matchingRoom) return null;

  // user2가 해당 방의 멤버인지 확인
  const { data: user2Member, error: error3 } = await supabase
    .from("chat_room_members")
    .select("id")
    .eq("room_id", matchingRoom.id)
    .eq("user_id", user2Id)
    .eq("user_type", user2Type)
    .is("left_at", null)
    .maybeSingle();

  if (error3 && error3.code !== "PGRST116") throw error3;

  return user2Member ? (matchingRoom as ChatRoom) : null;
}

/**
 * 채팅방 생성
 */
export async function insertRoom(
  input: ChatRoomInsert
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .insert(input)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}

/**
 * 채팅방 수정
 */
export async function updateRoom(
  roomId: string,
  input: ChatRoomUpdate
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .update(input)
    .eq("id", roomId)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}

// ============================================
// 채팅방 멤버 Repository
// ============================================

/**
 * 채팅방의 멤버 목록 조회
 * RLS 정책 우회를 위해 Admin Client 사용
 * (같은 방의 다른 멤버 조회 허용)
 */
export async function findMembersByRoom(
  roomId: string
): Promise<ChatRoomMember[]> {
  // Admin client 사용 (RLS 우회 - 같은 방 멤버 조회 허용)
  const supabase = createSupabaseAdminClient();

  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .eq("room_id", roomId)
    .is("left_at", null)
    .order("created_at", { ascending: true });

  if (error) throw error;

  return (data as ChatRoomMember[]) ?? [];
}

/**
 * 여러 채팅방의 멤버 목록 배치 조회 (N+1 최적화)
 */
export async function findMembersByRoomIds(
  roomIds: string[]
): Promise<Map<string, ChatRoomMember[]>> {
  if (roomIds.length === 0) return new Map();

  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .in("room_id", roomIds)
    .is("left_at", null)
    .order("created_at", { ascending: true });

  if (error) throw error;

  // room_id별로 그룹핑
  const result = new Map<string, ChatRoomMember[]>();
  for (const member of (data as ChatRoomMember[]) ?? []) {
    const existing = result.get(member.room_id) ?? [];
    existing.push(member);
    result.set(member.room_id, existing);
  }

  return result;
}

/**
 * 특정 멤버 조회
 */
export async function findMember(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatRoomMember | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType)
    .is("left_at", null)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatRoomMember | null;
}

/**
 * 멤버 추가
 */
export async function insertMember(
  input: ChatRoomMemberInsert
): Promise<ChatRoomMember> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .insert(input)
    .select(CHAT_MEMBER_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoomMember;
}

/**
 * 멤버 정보 수정
 */
export async function updateMember(
  roomId: string,
  userId: string,
  userType: ChatUserType,
  input: ChatRoomMemberUpdate
): Promise<ChatRoomMember> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .update(input)
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType)
    .select(CHAT_MEMBER_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoomMember;
}

/**
 * 읽음 처리 (last_read_at 업데이트)
 */
export async function markAsRead(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_room_members")
    .update({ last_read_at: new Date().toISOString() })
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType);

  if (error) throw error;
}

// ============================================
// 메시지 Repository
// ============================================

/**
 * 채팅방의 메시지 목록 조회 (페이지네이션)
 */
export async function findMessagesByRoom(
  options: GetMessagesOptions
): Promise<ChatMessage[]> {
  const { roomId, limit = 50, before } = options;
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS)
    .eq("room_id", roomId)
    .eq("is_deleted", false)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (before) {
    query = query.lt("created_at", before);
  }

  const { data, error } = await query;

  if (error) throw error;

  // 오래된 순으로 반환 (UI에서 역순 표시)
  return ((data as ChatMessage[]) ?? []).reverse();
}

/**
 * 여러 채팅방의 마지막 메시지 배치 조회 (N+1 최적화)
 * RPC 함수 사용: DISTINCT ON (room_id) ORDER BY created_at DESC
 */
export async function findLastMessagesByRoomIds(
  roomIds: string[]
): Promise<Map<string, ChatMessage>> {
  if (roomIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // RPC 함수 호출 (DISTINCT ON 사용으로 DB에서 직접 처리)
  const { data, error } = await supabase.rpc("get_last_messages_by_room_ids", {
    p_room_ids: roomIds,
  });

  if (error) throw error;

  // room_id별로 매핑
  const result = new Map<string, ChatMessage>();
  for (const message of (data as ChatMessage[]) ?? []) {
    result.set(message.room_id, message);
  }

  return result;
}

/**
 * 여러 채팅방의 안 읽은 메시지 수 배치 조회 (N+1 최적화)
 * RPC 함수 사용: DB에서 직접 집계하여 성능 최적화
 */
export async function countUnreadByRoomIds(
  roomIds: string[],
  userId: string,
  membershipMap: Map<string, { last_read_at: string }>
): Promise<Map<string, number>> {
  if (roomIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // membershipMap을 JSON 객체로 변환
  const membershipData: Record<string, string> = {};
  for (const [roomId, membership] of membershipMap) {
    membershipData[roomId] = membership.last_read_at;
  }

  // RPC 함수 호출 (DB에서 직접 집계)
  const { data, error } = await supabase.rpc("count_unread_by_room_ids", {
    p_room_ids: roomIds,
    p_user_id: userId,
    p_membership_data: membershipData,
  });

  if (error) throw error;

  // 결과 매핑 (unread가 없는 방은 0으로 초기화)
  const result = new Map<string, number>();
  for (const roomId of roomIds) {
    result.set(roomId, 0);
  }

  for (const row of (data as Array<{ room_id: string; unread_count: number }>) ?? []) {
    result.set(row.room_id, row.unread_count);
  }

  return result;
}

/**
 * 메시지 생성
 */
export async function insertMessage(
  input: ChatMessageInsert
): Promise<ChatMessage> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .insert(input)
    .select(CHAT_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  // chat_rooms.updated_at은 DB 트리거가 자동으로 갱신
  return data as ChatMessage;
}

/**
 * 메시지 삭제 (soft delete)
 */
export async function deleteMessage(
  messageId: string,
  senderId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_messages")
    .update({
      is_deleted: true,
      deleted_at: new Date().toISOString(),
    })
    .eq("id", messageId)
    .eq("sender_id", senderId);

  if (error) throw error;
}

/**
 * 발신자 정보 배치 조회 (N+1 쿼리 최적화)
 * sender_id + sender_type 조합으로 한 번에 조회
 * 병렬 쿼리로 성능 최적화 (3개 순차 쿼리 → 2개 병렬 쿼리)
 */
export async function findSendersByIds(
  senderKeys: Array<{ id: string; type: ChatUserType }>
): Promise<Map<string, { id: string; name: string; profileImageUrl?: string | null }>> {
  if (senderKeys.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // 중복 제거
  const uniqueKeys = Array.from(
    new Map(senderKeys.map((k) => [`${k.id}_${k.type}`, k])).values()
  );

  // student와 admin 분리
  const studentIds = uniqueKeys.filter((k) => k.type === "student").map((k) => k.id);
  const adminIds = uniqueKeys.filter((k) => k.type === "admin").map((k) => k.id);

  const result = new Map<string, { id: string; name: string; profileImageUrl?: string | null }>();

  // 병렬로 학생 + 관리자 정보 조회 (students는 profiles와 JOIN)
  const [studentsResult, adminsResult] = await Promise.all([
    // 학생 정보 + 프로필 이미지 (JOIN으로 한 번에 조회)
    studentIds.length > 0
      ? supabase
          .from("students")
          .select("id, name, student_profiles(profile_image_url)")
          .in("id", studentIds)
      : Promise.resolve({ data: null, error: null }),
    // 관리자 정보
    adminIds.length > 0
      ? supabase
          .from("admin_users")
          .select("id, name")
          .in("id", adminIds)
      : Promise.resolve({ data: null, error: null }),
  ]);

  // 학생 결과 처리
  if (studentsResult.data) {
    for (const student of studentsResult.data) {
      // student_profiles가 배열 또는 객체일 수 있음
      const profiles = student.student_profiles as
        | { profile_image_url: string | null }
        | Array<{ profile_image_url: string | null }>
        | null;
      const profileImageUrl = Array.isArray(profiles)
        ? profiles[0]?.profile_image_url ?? null
        : profiles?.profile_image_url ?? null;

      result.set(`${student.id}_student`, {
        id: student.id,
        name: student.name,
        profileImageUrl,
      });
    }
  }

  // 관리자 결과 처리
  if (adminsResult.data) {
    for (const admin of adminsResult.data) {
      result.set(`${admin.id}_admin`, {
        id: admin.id,
        name: admin.name ?? "관리자",
        profileImageUrl: null,
      });
    }
  }

  return result;
}

/**
 * 안 읽은 메시지 수 계산
 */
export async function countUnreadMessages(
  roomId: string,
  userId: string,
  userType: ChatUserType,
  lastReadAt: string
): Promise<number> {
  const supabase = await createSupabaseServerClient();

  const { count, error } = await supabase
    .from("chat_messages")
    .select("*", { count: "exact", head: true })
    .eq("room_id", roomId)
    .neq("sender_id", userId)
    .eq("is_deleted", false)
    .gt("created_at", lastReadAt);

  if (error) throw error;

  return count ?? 0;
}

// ============================================
// 차단 Repository
// ============================================

/**
 * 차단 목록 조회
 */
export async function findBlocksByUser(
  userId: string,
  userType: ChatUserType
): Promise<ChatBlock[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .select("*")
    .eq("blocker_id", userId)
    .eq("blocker_type", userType);

  if (error) throw error;

  return (data as ChatBlock[]) ?? [];
}

/**
 * 차단 여부 확인
 */
export async function isBlocked(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .select("id")
    .eq("blocker_id", blockerId)
    .eq("blocker_type", blockerType)
    .eq("blocked_id", blockedId)
    .eq("blocked_type", blockedType)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * 차단 추가
 */
export async function insertBlock(
  input: ChatBlockInsert
): Promise<ChatBlock> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .insert(input)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatBlock;
}

/**
 * 차단 해제
 */
export async function deleteBlock(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_blocks")
    .delete()
    .eq("blocker_id", blockerId)
    .eq("blocker_type", blockerType)
    .eq("blocked_id", blockedId)
    .eq("blocked_type", blockedType);

  if (error) throw error;
}

// ============================================
// 신고 Repository
// ============================================

/**
 * 신고 생성
 */
export async function insertReport(
  input: ChatReportInsert
): Promise<ChatReport> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .insert(input)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatReport;
}

/**
 * 대기 중인 신고 목록 조회 (관리자용)
 */
export async function findPendingReports(
  limit = 50
): Promise<ChatReport[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .select("*")
    .eq("status", "pending")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (error) throw error;

  return (data as ChatReport[]) ?? [];
}

/**
 * 신고 상태 업데이트 (관리자용)
 */
export async function updateReport(
  reportId: string,
  input: ChatReportUpdate
): Promise<ChatReport> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .update(input)
    .eq("id", reportId)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatReport;
}

/**
 * 모든 신고 목록 조회 (관리자용, 필터 지원)
 */
export async function findAllReports(
  filters?: { status?: string; reason?: string },
  limit = 100
): Promise<ChatReport[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("chat_reports")
    .select("*")
    .order("created_at", { ascending: false })
    .limit(limit);

  // 상태 필터
  if (filters?.status && filters.status !== "all") {
    query = query.eq("status", filters.status);
  }

  // 사유 필터
  if (filters?.reason && filters.reason !== "all") {
    query = query.eq("reason", filters.reason);
  }

  const { data, error } = await query;

  if (error) throw error;

  return (data as ChatReport[]) ?? [];
}

/**
 * 신고 ID로 조회
 */
export async function findReportById(
  reportId: string
): Promise<ChatReport | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .select("*")
    .eq("id", reportId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatReport | null;
}

/**
 * 메시지 ID로 단일 메시지 조회 (신고된 메시지 상세용)
 */
export async function findMessageById(
  messageId: string
): Promise<ChatMessage | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS)
    .eq("id", messageId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatMessage | null;
}

// ============================================
// 메시지 편집 Repository
// ============================================

/**
 * 메시지 내용 수정
 */
export async function updateMessageContent(
  messageId: string,
  content: string
): Promise<ChatMessage> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .update({ content })
    .eq("id", messageId)
    .select(CHAT_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatMessage;
}

// ============================================
// 메시지 검색 Repository
// ============================================

/**
 * 채팅방 내 메시지 검색 (ILIKE 기반)
 */
export async function searchMessagesByRoom(
  options: SearchMessagesOptions
): Promise<{ messages: ChatMessage[]; total: number }> {
  const { roomId, query, limit = 20, offset = 0 } = options;
  const supabase = await createSupabaseServerClient();

  // 검색어 이스케이프 (SQL 와일드카드 처리)
  const escapedQuery = query.replace(/[%_]/g, "\\$&");

  const { data, error, count } = await supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS, { count: "exact" })
    .eq("room_id", roomId)
    .eq("is_deleted", false)
    .ilike("content", `%${escapedQuery}%`)
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;

  return {
    messages: (data as ChatMessage[]) ?? [],
    total: count ?? 0,
  };
}

// ============================================
// 읽음 표시 Repository
// ============================================

/**
 * 채팅방의 활성 멤버 목록과 last_read_at 조회 (읽음 상태 계산용)
 */
export async function findActiveMembersWithReadStatus(
  roomId: string
): Promise<Array<{ user_id: string; user_type: ChatUserType; last_read_at: string }>> {
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select("user_id, user_type, last_read_at")
    .eq("room_id", roomId)
    .is("left_at", null);

  if (error) throw error;

  return (data ?? []) as Array<{ user_id: string; user_type: ChatUserType; last_read_at: string }>;
}

/**
 * 메시지 목록과 각 메시지의 읽음 상태를 함께 조회
 * 본인 메시지에 대해서만 안 읽은 멤버 수 계산
 */
export async function findMessagesWithReadCounts(
  options: GetMessagesOptions,
  currentUserId: string
): Promise<{ messages: ChatMessage[]; readCounts: Record<string, number> }> {
  const messages = await findMessagesByRoom(options);

  // 방 멤버들의 last_read_at 조회
  const members = await findActiveMembersWithReadStatus(options.roomId);

  const readCounts: Record<string, number> = {};

  // 각 메시지에 대해 안 읽은 멤버 수 계산 (본인 메시지만)
  for (const msg of messages) {
    if (msg.sender_id === currentUserId) {
      // 메시지 시간 이후에 읽지 않은 멤버 수 (발신자 제외)
      const unreadCount = members.filter(
        (m) =>
          m.user_id !== msg.sender_id &&
          new Date(m.last_read_at) < new Date(msg.created_at)
      ).length;

      readCounts[msg.id] = unreadCount;
    } else {
      readCounts[msg.id] = 0;
    }
  }

  return { messages, readCounts };
}

// ============================================
// 리액션 Repository
// ============================================

/**
 * 리액션 추가
 */
export async function insertReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase.from("chat_message_reactions").insert({
    message_id: input.messageId,
    user_id: input.userId,
    user_type: input.userType,
    emoji: input.emoji,
  });

  if (error) throw error;
}

/**
 * 리액션 삭제
 */
export async function deleteReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_message_reactions")
    .delete()
    .eq("message_id", input.messageId)
    .eq("user_id", input.userId)
    .eq("user_type", input.userType)
    .eq("emoji", input.emoji);

  if (error) throw error;
}

/**
 * 리액션 존재 확인 (토글용)
 */
export async function hasReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_message_reactions")
    .select("id")
    .eq("message_id", input.messageId)
    .eq("user_id", input.userId)
    .eq("user_type", input.userType)
    .eq("emoji", input.emoji)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * 메시지별 리액션 조회 (배치)
 * N+1 쿼리 최적화를 위해 여러 메시지의 리액션을 한 번에 조회
 */
export async function findReactionsByMessageIds(
  messageIds: string[]
): Promise<Map<string, MessageReaction[]>> {
  if (messageIds.length === 0) return new Map();

  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_message_reactions")
    .select(CHAT_REACTION_COLUMNS)
    .in("message_id", messageIds)
    .order("created_at", { ascending: true });

  if (error) throw error;

  // message_id별로 그룹핑
  const result = new Map<string, MessageReaction[]>();
  for (const reaction of (data as MessageReaction[]) ?? []) {
    const existing = result.get(reaction.message_id) ?? [];
    existing.push(reaction);
    result.set(reaction.message_id, existing);
  }

  return result;
}

// ============================================
// 답장 원본 메시지 Repository
// ============================================

/**
 * 답장 원본 메시지 배치 조회 (N+1 최적화)
 * 여러 메시지의 원본 메시지를 한 번에 조회
 */
export async function findReplyTargetsByIds(
  replyToIds: string[]
): Promise<Map<string, { id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>> {
  if (replyToIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("chat_messages")
    .select("id, content, sender_id, sender_type, is_deleted")
    .in("id", replyToIds);

  if (error) throw error;

  const result = new Map<string, { id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>();
  for (const msg of (data ?? []) as Array<{ id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>) {
    result.set(msg.id, msg);
  }
  return result;
}

// ============================================
// 고정 메시지 Repository
// ============================================

const PINNED_MESSAGE_COLUMNS = `
  id,
  room_id,
  message_id,
  pinned_by,
  pinned_by_type,
  pin_order,
  created_at
` as const;

/**
 * 채팅방의 고정 메시지 목록 조회 (pin_order 순)
 */
export async function findPinnedMessagesByRoom(
  roomId: string
): Promise<PinnedMessage[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .select(PINNED_MESSAGE_COLUMNS)
    .eq("room_id", roomId)
    .order("pin_order", { ascending: true });

  if (error) throw error;

  return (data as PinnedMessage[]) ?? [];
}

/**
 * 고정 메시지 추가
 */
export async function insertPinnedMessage(
  input: PinnedMessageInsert
): Promise<PinnedMessage> {
  const supabase = await createSupabaseServerClient();

  // 현재 채팅방의 최대 pin_order 조회
  const { data: existing } = await supabase
    .from("chat_pinned_messages")
    .select("pin_order")
    .eq("room_id", input.room_id)
    .order("pin_order", { ascending: false })
    .limit(1)
    .maybeSingle();

  const nextOrder = existing ? existing.pin_order + 1 : 0;

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .insert({
      ...input,
      pin_order: input.pin_order ?? nextOrder,
    })
    .select(PINNED_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  return data as PinnedMessage;
}

/**
 * 고정 메시지 삭제
 */
export async function deletePinnedMessage(
  roomId: string,
  messageId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_pinned_messages")
    .delete()
    .eq("room_id", roomId)
    .eq("message_id", messageId);

  if (error) throw error;
}

/**
 * 메시지가 고정되어 있는지 확인
 */
export async function isPinnedMessage(
  roomId: string,
  messageId: string
): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .select("id")
    .eq("room_id", roomId)
    .eq("message_id", messageId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * 채팅방의 고정 메시지 개수 조회
 */
export async function countPinnedMessages(
  roomId: string
): Promise<number> {
  const supabase = await createSupabaseServerClient();

  const { count, error } = await supabase
    .from("chat_pinned_messages")
    .select("*", { count: "exact", head: true })
    .eq("room_id", roomId);

  if (error) throw error;

  return count ?? 0;
}

// ============================================
// 공지 Repository
// ============================================

/**
 * 채팅방 공지 설정
 * content가 null이면 공지 삭제
 */
export async function setRoomAnnouncement(
  roomId: string,
  userId: string | null,
  userType: ChatUserType | null,
  content: string | null
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const updateData: ChatRoomUpdate = content
    ? {
        announcement: content,
        announcement_by: userId,
        announcement_by_type: userType,
        announcement_at: new Date().toISOString(),
      }
    : {
        announcement: null,
        announcement_by: null,
        announcement_by_type: null,
        announcement_at: null,
      };

  const { data, error } = await supabase
    .from("chat_rooms")
    .update(updateData)
    .eq("id", roomId)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}

// ============================================
// 배치 멤버 관리 (inviteMembers 최적화)
// ============================================

/**
 * 기존 멤버 배치 조회 (N+1 최적화)
 * 특정 채팅방에서 이미 존재하는 멤버들을 한 번에 조회
 */
export async function findExistingMembersByRoomBatch(
  roomId: string,
  memberIds: string[],
  memberTypes: ChatUserType[]
): Promise<Set<string>> {
  if (memberIds.length === 0) return new Set();

  const supabase = await createSupabaseServerClient();

  // RPC 함수 호출
  const { data, error } = await supabase.rpc("find_existing_members_batch", {
    p_room_id: roomId,
    p_member_ids: memberIds,
    p_member_types: memberTypes,
  });

  if (error) throw error;

  // user_id_userType 형태의 Set 생성
  const result = new Set<string>();
  for (const row of (data as Array<{ user_id: string; user_type: string }>) ?? []) {
    result.add(`${row.user_id}_${row.user_type}`);
  }

  return result;
}

/**
 * 멤버 배치 추가 (N+1 최적화)
 * 여러 멤버를 한 번의 INSERT로 추가
 */
export async function insertMembersBatch(
  members: ChatRoomMemberInsert[]
): Promise<ChatRoomMember[]> {
  if (members.length === 0) return [];

  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .insert(members)
    .select(CHAT_MEMBER_COLUMNS);

  if (error) throw error;

  return (data as ChatRoomMember[]) ?? [];
}

// ============================================
// 단일 발신자 정보 조회 (실시간 이벤트용)
// ============================================

/**
 * 단일 발신자 정보 조회 (실시간 이벤트에서 sender 정보 보강용)
 */
export async function findSenderById(
  senderId: string,
  senderType: ChatUserType
): Promise<{ id: string; name: string; profileImageUrl?: string | null } | null> {
  const supabase = await createSupabaseServerClient();

  if (senderType === "student") {
    const { data } = await supabase
      .from("students")
      .select("id, name, student_profiles(profile_image_url)")
      .eq("id", senderId)
      .maybeSingle();

    if (!data) return null;

    const profiles = data.student_profiles as
      | { profile_image_url: string | null }
      | Array<{ profile_image_url: string | null }>
      | null;
    const profileImageUrl = Array.isArray(profiles)
      ? profiles[0]?.profile_image_url ?? null
      : profiles?.profile_image_url ?? null;

    return {
      id: data.id,
      name: data.name,
      profileImageUrl,
    };
  } else {
    const { data } = await supabase
      .from("admin_users")
      .select("id, name")
      .eq("id", senderId)
      .maybeSingle();

    if (!data) return null;

    return {
      id: data.id,
      name: data.name ?? "관리자",
      profileImageUrl: null,
    };
  }
}
</file>

<file path="lib/domains/chat/service.ts">
/**
 * Chat 도메인 Service
 * 채팅 비즈니스 로직
 */

import * as repository from "./repository";
import type {
  ChatRoom,
  ChatRoomMemberWithUser,
  ChatMessage,
  ChatRoomListItem,
  ChatMessageWithSender,
  ChatUser,
  ChatUserType,
  ChatRoomType,
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
  SearchMessagesOptions,
  SearchMessagesResult,
  MessagesWithReadStatusResult,
  ReactionToggleInput,
  ReactionSummary,
  MessageReaction,
  PinMessageInput,
  PinnedMessageWithContent,
  AnnouncementInfo,
  SetAnnouncementInput,
} from "./types";

// 최대 메시지 길이
const MAX_MESSAGE_LENGTH = 1000;

// ============================================
// 사용자 정보 조회 헬퍼
// ============================================

/**
 * 사용자 정보 조회 (student 또는 admin)
 */
async function getUserInfo(
  userId: string,
  userType: ChatUserType
): Promise<ChatUser | null> {
  const { createSupabaseServerClient } = await import("@/lib/supabase/server");
  const supabase = await createSupabaseServerClient();

  if (userType === "student") {
    const { data } = await supabase
      .from("students")
      .select("id, name")
      .eq("id", userId)
      .maybeSingle();

    if (!data) return null;

    // 프로필 이미지 조회
    const { data: profile } = await supabase
      .from("student_profiles")
      .select("profile_image_url")
      .eq("id", userId)
      .maybeSingle();

    return {
      id: data.id,
      type: "student",
      name: data.name,
      profileImageUrl: profile?.profile_image_url ?? null,
    };
  } else {
    // admin (admin_users 테이블에서 조회)
    const { data } = await supabase
      .from("admin_users")
      .select("id")
      .eq("id", userId)
      .maybeSingle();

    if (!data) return null;

    // auth.users에서 이름 가져오기
    // 참고: admin 이름은 user_metadata에서 가져와야 할 수 있음
    return {
      id: data.id,
      type: "admin",
      name: "관리자", // TODO: 실제 이름 조회 로직 추가
      profileImageUrl: null,
    };
  }
}

// ============================================
// 채팅방 서비스
// ============================================

/**
 * 채팅방 생성 또는 기존 방 반환 (1:1의 경우)
 */
export async function createOrGetRoom(
  tenantId: string,
  creatorId: string,
  creatorType: ChatUserType,
  request: CreateChatRoomRequest
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { type, name, memberIds, memberTypes } = request;

    // 1:1 채팅인 경우 기존 방 확인
    if (type === "direct" && memberIds.length === 1) {
      const existingRoom = await repository.findDirectRoom(
        creatorId,
        creatorType,
        memberIds[0],
        memberTypes[0]
      );

      if (existingRoom) {
        return { success: true, data: existingRoom };
      }
    }

    // 새 방 생성
    const room = await repository.insertRoom({
      tenant_id: tenantId,
      type,
      name: type === "group" ? name ?? null : null,
      created_by: creatorId,
      created_by_type: creatorType,
    });

    // 생성자를 멤버로 추가 (owner 역할)
    await repository.insertMember({
      room_id: room.id,
      user_id: creatorId,
      user_type: creatorType,
      role: "owner",
    });

    // 다른 멤버들 추가
    for (let i = 0; i < memberIds.length; i++) {
      await repository.insertMember({
        room_id: room.id,
        user_id: memberIds[i],
        user_type: memberTypes[i],
        role: "member",
      });
    }

    return { success: true, data: room };
  } catch (error) {
    console.error("[ChatService] createOrGetRoom error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 생성 실패",
    };
  }
}

/**
 * 사용자의 채팅방 목록 조회 (UI 표시용 추가 정보 포함)
 * 배치 쿼리로 N+1 문제 해결 (101쿼리 → 5쿼리)
 */
export async function getRoomList(
  userId: string,
  userType: ChatUserType,
  options: GetRoomsOptions = {}
): Promise<ChatRoomListItem[]> {
  const rooms = await repository.findRoomsByUser(userId, userType, options);
  if (rooms.length === 0) return [];

  const roomIds = rooms.map((r) => r.id);

  // 배치 쿼리로 모든 데이터 한 번에 조회
  const [membersMap, lastMessagesMap] = await Promise.all([
    repository.findMembersByRoomIds(roomIds),
    repository.findLastMessagesByRoomIds(roomIds),
  ]);

  // 내 멤버십 정보로 last_read_at 맵 생성
  const membershipMap = new Map<string, { last_read_at: string }>();
  for (const roomId of roomIds) {
    const members = membersMap.get(roomId) ?? [];
    const myMembership = members.find(
      (m) => m.user_id === userId && m.user_type === userType
    );
    if (myMembership) {
      membershipMap.set(roomId, { last_read_at: myMembership.last_read_at });
    }
  }

  // 안 읽은 메시지 수 배치 조회
  const unreadMap = await repository.countUnreadByRoomIds(roomIds, userId, membershipMap);

  // 발신자 정보 배치 조회를 위한 키 수집
  const senderKeys: Array<{ id: string; type: ChatUserType }> = [];

  // 1:1 채팅 상대방 + 마지막 메시지 발신자
  for (const room of rooms) {
    const members = membersMap.get(room.id) ?? [];
    if (room.type === "direct") {
      const otherMember = members.find(
        (m) => !(m.user_id === userId && m.user_type === userType)
      );
      if (otherMember) {
        senderKeys.push({ id: otherMember.user_id, type: otherMember.user_type });
      }
    }
    const lastMsg = lastMessagesMap.get(room.id);
    if (lastMsg) {
      senderKeys.push({ id: lastMsg.sender_id, type: lastMsg.sender_type });
    }
  }

  const senderMap = await repository.findSendersByIds(senderKeys);

  // 결과 조합
  const result: ChatRoomListItem[] = [];

  for (const room of rooms) {
    const members = membersMap.get(room.id) ?? [];
    const lastMessage = lastMessagesMap.get(room.id) ?? null;
    const unreadCount = unreadMap.get(room.id) ?? 0;

    // 1:1인 경우 상대방 정보
    let otherUser: ChatUser | null = null;
    if (room.type === "direct") {
      const otherMember = members.find(
        (m) => !(m.user_id === userId && m.user_type === userType)
      );
      if (otherMember) {
        const key = `${otherMember.user_id}_${otherMember.user_type}`;
        const senderInfo = senderMap.get(key);
        if (senderInfo) {
          otherUser = {
            id: senderInfo.id,
            type: otherMember.user_type,
            name: senderInfo.name,
            profileImageUrl: senderInfo.profileImageUrl,
          };
        }
      }
    }

    // 마지막 메시지 정보
    let lastMessageInfo = null;
    if (lastMessage) {
      const key = `${lastMessage.sender_id}_${lastMessage.sender_type}`;
      const senderInfo = senderMap.get(key);
      lastMessageInfo = {
        content:
          lastMessage.message_type === "system"
            ? lastMessage.content
            : lastMessage.content.length > 50
            ? lastMessage.content.slice(0, 50) + "..."
            : lastMessage.content,
        senderName: senderInfo?.name ?? "알 수 없음",
        createdAt: lastMessage.created_at,
      };
    }

    result.push({
      id: room.id,
      type: room.type as ChatRoomType,
      name: room.name,
      otherUser,
      memberCount: members.length,
      lastMessage: lastMessageInfo,
      unreadCount,
      updatedAt: room.updated_at,
    });
  }

  return result;
}

/**
 * 채팅방 상세 정보 조회
 */
export async function getRoomDetail(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<{ room: ChatRoom; members: ChatRoomMemberWithUser[] }>> {
  try {
    // 방 정보 조회
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "채팅방을 찾을 수 없습니다" };
    }

    // 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 멤버 목록 + 사용자 정보
    const members = await repository.findMembersByRoom(roomId);
    const membersWithUser: ChatRoomMemberWithUser[] = await Promise.all(
      members.map(async (member) => ({
        ...member,
        user: await getUserInfo(member.user_id, member.user_type) ?? {
          id: member.user_id,
          type: member.user_type,
          name: "알 수 없음",
          profileImageUrl: null,
        },
      }))
    );

    return { success: true, data: { room, members: membersWithUser } };
  } catch (error) {
    console.error("[ChatService] getRoomDetail error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 조회 실패",
    };
  }
}

// ============================================
// 메시지 서비스
// ============================================

/**
 * 메시지 전송
 */
export async function sendMessage(
  senderId: string,
  senderType: ChatUserType,
  request: SendMessageRequest
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { roomId, content, messageType = "text", replyToId } = request;

    // 메시지 길이 검증
    if (content.length > MAX_MESSAGE_LENGTH) {
      return {
        success: false,
        error: `메시지는 ${MAX_MESSAGE_LENGTH}자를 초과할 수 없습니다`,
      };
    }

    // 빈 메시지 검증
    if (content.trim().length === 0) {
      return { success: false, error: "메시지 내용을 입력해주세요" };
    }

    // 멤버십은 RLS INSERT 정책이 DB 레벨에서 검증 (별도 조회 불필요)

    // 답장 대상 메시지 검증 (있는 경우)
    if (replyToId) {
      const targetMessage = await repository.findMessageById(replyToId);
      if (!targetMessage) {
        return { success: false, error: "답장 대상 메시지를 찾을 수 없습니다" };
      }
      if (targetMessage.room_id !== roomId) {
        return { success: false, error: "같은 채팅방의 메시지에만 답장할 수 있습니다" };
      }
    }

    // 메시지 생성
    const message = await repository.insertMessage({
      room_id: roomId,
      sender_id: senderId,
      sender_type: senderType,
      message_type: messageType,
      content: content.trim(),
      reply_to_id: replyToId ?? null,
    });

    return { success: true, data: message };
  } catch (error) {
    console.error("[ChatService] sendMessage error:", error);
    // RLS 위반 시 친절한 에러 메시지 반환
    if (error instanceof Error && error.message.includes("row-level security")) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 전송 실패",
    };
  }
}

/**
 * 메시지 목록 조회 (발신자 정보 포함)
 * 배치 쿼리로 N+1 문제 해결 (51쿼리 → 4쿼리)
 */
export async function getMessages(
  userId: string,
  userType: ChatUserType,
  options: GetMessagesOptions
): Promise<ChatActionResult<PaginatedResult<ChatMessageWithSender>>> {
  try {
    const { roomId, limit = 50 } = options;

    // 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 병렬로 차단 목록 + 메시지 조회
    const [blocks, messages] = await Promise.all([
      repository.findBlocksByUser(userId, userType),
      repository.findMessagesByRoom(options),
    ]);

    const blockedIds = new Set(blocks.map((b) => `${b.blocked_id}_${b.blocked_type}`));

    // 차단되지 않은 메시지만 필터링
    const filteredMessages = messages.filter(
      (m) => !blockedIds.has(`${m.sender_id}_${m.sender_type}`)
    );

    // 발신자 정보 배치 조회 (1-2 쿼리로 모든 발신자 정보 가져옴)
    const senderKeys = filteredMessages.map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // 메시지에 발신자 정보 매핑
    const messagesWithSender: ChatMessageWithSender[] = filteredMessages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "알 수 없음",
            },
      };
    });

    return {
      success: true,
      data: {
        data: messagesWithSender,
        hasMore: messages.length === limit,
        nextCursor: messages.length > 0 ? messages[0].created_at : undefined,
      },
    };
  } catch (error) {
    console.error("[ChatService] getMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 조회 실패",
    };
  }
}

/**
 * 메시지 삭제
 */
export async function deleteMessage(
  messageId: string,
  userId: string
): Promise<ChatActionResult<void>> {
  try {
    await repository.deleteMessage(messageId, userId);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] deleteMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 삭제 실패",
    };
  }
}

/**
 * 읽음 처리
 */
export async function markRoomAsRead(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    await repository.markAsRead(roomId, userId, userType);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] markRoomAsRead error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "읽음 처리 실패",
    };
  }
}

// ============================================
// 멤버 서비스
// ============================================

/**
 * 그룹 채팅방에 멤버 초대
 * 배치 쿼리로 N+1 최적화 (N개 순차 쿼리 → 2개 배치 쿼리)
 */
export async function inviteMembers(
  roomId: string,
  inviterId: string,
  inviterType: ChatUserType,
  memberIds: string[],
  memberTypes: ChatUserType[]
): Promise<ChatActionResult<void>> {
  try {
    // 방 정보 확인
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "채팅방을 찾을 수 없습니다" };
    }

    if (room.type !== "group") {
      return { success: false, error: "그룹 채팅방에서만 초대할 수 있습니다" };
    }

    // 초대자 멤버십 확인
    const inviterMembership = await repository.findMember(
      roomId,
      inviterId,
      inviterType
    );
    if (!inviterMembership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 배치로 기존 멤버 조회 (N+1 → 1 쿼리)
    const existingMembers = await repository.findExistingMembersByRoomBatch(
      roomId,
      memberIds,
      memberTypes
    );

    // 새로 추가할 멤버들 필터링
    const newMembers: Array<{
      room_id: string;
      user_id: string;
      user_type: ChatUserType;
      role: "member";
      last_read_at: string;
    }> = [];

    for (let i = 0; i < memberIds.length; i++) {
      const key = `${memberIds[i]}_${memberTypes[i]}`;
      if (!existingMembers.has(key)) {
        newMembers.push({
          room_id: roomId,
          user_id: memberIds[i],
          user_type: memberTypes[i],
          role: "member",
          // 이전 대화를 볼 수 있도록 last_read_at을 epoch으로 설정
          last_read_at: "1970-01-01T00:00:00Z",
        });
      }
    }

    // 배치로 멤버 추가 (N+1 → 1 쿼리)
    if (newMembers.length > 0) {
      await repository.insertMembersBatch(newMembers);
    }

    // 시스템 메시지 추가
    const inviterInfo = await getUserInfo(inviterId, inviterType);
    await repository.insertMessage({
      room_id: roomId,
      sender_id: inviterId,
      sender_type: inviterType,
      message_type: "system",
      content: `${inviterInfo?.name ?? "사용자"}님이 새 멤버를 초대했습니다`,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] inviteMembers error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "멤버 초대 실패",
    };
  }
}

/**
 * 채팅방 나가기
 */
export async function leaveRoom(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    // 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // left_at 설정
    await repository.updateMember(roomId, userId, userType, {
      left_at: new Date().toISOString(),
    });

    // 시스템 메시지
    const userInfo = await getUserInfo(userId, userType);
    await repository.insertMessage({
      room_id: roomId,
      sender_id: userId,
      sender_type: userType,
      message_type: "system",
      content: `${userInfo?.name ?? "사용자"}님이 채팅방을 나갔습니다`,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] leaveRoom error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "채팅방 나가기 실패",
    };
  }
}

// ============================================
// 차단/신고 서비스
// ============================================

/**
 * 사용자 차단
 */
export async function blockUser(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    // 이미 차단했는지 확인
    const alreadyBlocked = await repository.isBlocked(
      blockerId,
      blockerType,
      blockedId,
      blockedType
    );

    if (alreadyBlocked) {
      return { success: false, error: "이미 차단한 사용자입니다" };
    }

    await repository.insertBlock({
      blocker_id: blockerId,
      blocker_type: blockerType,
      blocked_id: blockedId,
      blocked_type: blockedType,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] blockUser error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "차단 실패",
    };
  }
}

/**
 * 차단 해제
 */
export async function unblockUser(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    await repository.deleteBlock(blockerId, blockerType, blockedId, blockedType);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] unblockUser error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "차단 해제 실패",
    };
  }
}

/**
 * 메시지 신고
 */
export async function reportMessage(
  reporterId: string,
  reporterType: ChatUserType,
  messageId: string,
  reason: string,
  description?: string
): Promise<ChatActionResult<void>> {
  try {
    await repository.insertReport({
      reporter_id: reporterId,
      reporter_type: reporterType,
      reported_message_id: messageId,
      reason: reason as "spam" | "harassment" | "inappropriate" | "hate_speech" | "other",
      description: description ?? null,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] reportMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "신고 실패",
    };
  }
}

// ============================================
// 메시지 편집 서비스
// ============================================

/** 메시지 수정 가능 시간 (5분) */
const MAX_EDIT_TIME_MS = 5 * 60 * 1000;

/**
 * 메시지 편집
 * - 본인 메시지만 수정 가능
 * - 전송 후 5분 이내만 수정 가능
 */
export async function editMessage(
  userId: string,
  userType: ChatUserType,
  messageId: string,
  newContent: string
): Promise<ChatActionResult<ChatMessage>> {
  try {
    // 1. 메시지 조회
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "메시지를 찾을 수 없습니다" };
    }

    // 2. 본인 메시지인지 확인
    if (message.sender_id !== userId || message.sender_type !== userType) {
      return { success: false, error: "본인 메시지만 수정할 수 있습니다" };
    }

    // 3. 삭제된 메시지인지 확인
    if (message.is_deleted) {
      return { success: false, error: "삭제된 메시지는 수정할 수 없습니다" };
    }

    // 4. 시스템 메시지인지 확인
    if (message.message_type === "system") {
      return { success: false, error: "시스템 메시지는 수정할 수 없습니다" };
    }

    // 5. 수정 가능 시간 확인 (5분 이내)
    const createdAt = new Date(message.created_at).getTime();
    if (Date.now() - createdAt > MAX_EDIT_TIME_MS) {
      return { success: false, error: "메시지 수정 가능 시간(5분)이 지났습니다" };
    }

    // 6. 내용 검증
    const trimmedContent = newContent.trim();
    if (!trimmedContent) {
      return { success: false, error: "메시지 내용을 입력해주세요" };
    }
    if (trimmedContent.length > MAX_MESSAGE_LENGTH) {
      return {
        success: false,
        error: `메시지는 ${MAX_MESSAGE_LENGTH}자를 초과할 수 없습니다`,
      };
    }

    // 7. 수정 실행
    const updated = await repository.updateMessageContent(messageId, trimmedContent);

    return { success: true, data: updated };
  } catch (error) {
    console.error("[ChatService] editMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 수정 실패",
    };
  }
}

// ============================================
// 메시지 검색 서비스
// ============================================

/**
 * 메시지 검색
 * - 채팅방 멤버만 검색 가능
 * - 발신자 정보 포함
 */
export async function searchMessages(
  userId: string,
  userType: ChatUserType,
  options: SearchMessagesOptions
): Promise<ChatActionResult<SearchMessagesResult>> {
  try {
    const { roomId, query } = options;

    // 검색어 검증
    if (!query.trim()) {
      return { success: false, error: "검색어를 입력해주세요" };
    }

    // 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 검색 실행
    const { messages, total } = await repository.searchMessagesByRoom(options);

    // 발신자 정보 배치 조회
    const senderKeys = messages.map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // 메시지에 발신자 정보 매핑
    const messagesWithSender: ChatMessageWithSender[] = messages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "알 수 없음",
            },
      };
    });

    return {
      success: true,
      data: {
        messages: messagesWithSender,
        total,
        query: query.trim(),
      },
    };
  } catch (error) {
    console.error("[ChatService] searchMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 검색 실패",
    };
  }
}

// ============================================
// 읽음 표시 서비스
// ============================================

/**
 * 리액션 목록을 요약으로 변환
 */
function convertReactionsToSummaries(
  reactions: MessageReaction[],
  currentUserId: string,
  currentUserType: ChatUserType
): ReactionSummary[] {
  // 이모지별 그룹핑
  const emojiMap = new Map<string, { count: number; hasReacted: boolean }>();

  for (const reaction of reactions) {
    const existing = emojiMap.get(reaction.emoji) ?? { count: 0, hasReacted: false };
    existing.count += 1;
    if (reaction.user_id === currentUserId && reaction.user_type === currentUserType) {
      existing.hasReacted = true;
    }
    emojiMap.set(reaction.emoji, existing);
  }

  // ReactionSummary 배열로 변환
  const summaries: ReactionSummary[] = [];
  for (const [emoji, data] of emojiMap) {
    summaries.push({
      emoji: emoji as ReactionSummary["emoji"],
      count: data.count,
      hasReacted: data.hasReacted,
    });
  }

  return summaries;
}

/**
 * 메시지 목록 조회 (읽음 상태 + 리액션 + 답장 원본 포함)
 * - 본인 메시지에 대해서만 안 읽은 멤버 수 계산
 * - 차단한 사용자 메시지 필터링
 * - 각 메시지의 리액션 요약 포함
 * - 답장 메시지의 원본 정보 포함
 */
export async function getMessagesWithReadStatus(
  userId: string,
  userType: ChatUserType,
  options: GetMessagesOptions
): Promise<ChatActionResult<MessagesWithReadStatusResult>> {
  try {
    const { roomId, limit = 50 } = options;

    // 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 병렬로 차단 목록 + 메시지 + 읽음 상태 조회
    const [blocks, { messages, readCounts }] = await Promise.all([
      repository.findBlocksByUser(userId, userType),
      repository.findMessagesWithReadCounts(options, userId),
    ]);

    const blockedIds = new Set(blocks.map((b) => `${b.blocked_id}_${b.blocked_type}`));

    // 차단되지 않은 메시지만 필터링
    const filteredMessages = messages.filter(
      (m) => !blockedIds.has(`${m.sender_id}_${m.sender_type}`)
    );

    // 필터링된 메시지의 readCounts만 유지
    const filteredReadCounts: Record<string, number> = {};
    for (const msg of filteredMessages) {
      filteredReadCounts[msg.id] = readCounts[msg.id] ?? 0;
    }

    // 메시지 ID 목록 + 답장 원본 ID 수집
    const messageIds = filteredMessages.map((m) => m.id);
    const replyToIds = filteredMessages
      .map((m) => m.reply_to_id)
      .filter((id): id is string => id !== null);

    // 병렬로 발신자 + 리액션 + 답장 원본 조회
    const [senderMap, reactionsMap, replyTargetsMap] = await Promise.all([
      repository.findSendersByIds(
        filteredMessages.map((m) => ({ id: m.sender_id, type: m.sender_type }))
      ),
      repository.findReactionsByMessageIds(messageIds),
      repository.findReplyTargetsByIds(replyToIds),
    ]);

    // 답장 원본 발신자 정보도 배치 조회
    const replyTargetSenderKeys = Array.from(replyTargetsMap.values()).map((t) => ({
      id: t.sender_id,
      type: t.sender_type,
    }));
    const replyTargetSenderMap = await repository.findSendersByIds(replyTargetSenderKeys);

    // 메시지에 발신자 정보 + 리액션 + 답장 원본 매핑
    const messagesWithAll = filteredMessages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);
      const messageReactions = reactionsMap.get(message.id) ?? [];

      // 답장 원본 정보 매핑
      let replyTarget: { id: string; content: string; senderName: string; isDeleted: boolean } | null = null;
      if (message.reply_to_id) {
        const target = replyTargetsMap.get(message.reply_to_id);
        if (target) {
          const targetSenderInfo = replyTargetSenderMap.get(`${target.sender_id}_${target.sender_type}`);
          replyTarget = {
            id: target.id,
            content: target.is_deleted ? "삭제된 메시지입니다" : target.content,
            senderName: targetSenderInfo?.name ?? "알 수 없음",
            isDeleted: target.is_deleted,
          };
        }
      }

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "알 수 없음",
            },
        reactions: convertReactionsToSummaries(messageReactions, userId, userType),
        replyTarget,
      };
    });

    return {
      success: true,
      data: {
        messages: messagesWithAll,
        readCounts: filteredReadCounts,
        hasMore: messages.length === limit,
      },
    };
  } catch (error) {
    console.error("[ChatService] getMessagesWithReadStatus error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 조회 실패",
    };
  }
}

// ============================================
// 리액션 서비스
// ============================================

/**
 * 리액션 토글
 * - 리액션이 없으면 추가, 있으면 삭제
 * - 채팅방 멤버만 리액션 가능
 * - 삭제된 메시지에는 리액션 불가
 */
export async function toggleReaction(
  userId: string,
  userType: ChatUserType,
  input: ReactionToggleInput
): Promise<ChatActionResult<{ added: boolean }>> {
  try {
    const { messageId, emoji } = input;

    // 1. 메시지 조회
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "메시지를 찾을 수 없습니다" };
    }

    // 2. 삭제된 메시지인지 확인
    if (message.is_deleted) {
      return { success: false, error: "삭제된 메시지에는 리액션할 수 없습니다" };
    }

    // 3. 채팅방 멤버십 확인
    const membership = await repository.findMember(message.room_id, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 4. 기존 리액션 존재 여부 확인
    const hasExisting = await repository.hasReaction({
      messageId,
      userId,
      userType,
      emoji,
    });

    // 5. 토글 실행
    if (hasExisting) {
      // 기존 리액션 삭제
      await repository.deleteReaction({
        messageId,
        userId,
        userType,
        emoji,
      });
      return { success: true, data: { added: false } };
    } else {
      // 새 리액션 추가
      await repository.insertReaction({
        messageId,
        userId,
        userType,
        emoji,
      });
      return { success: true, data: { added: true } };
    }
  } catch (error) {
    console.error("[ChatService] toggleReaction error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "리액션 처리 실패",
    };
  }
}

// ============================================
// 고정 메시지 서비스
// ============================================

/** 최대 고정 메시지 개수 */
const MAX_PINNED_MESSAGES = 5;

/**
 * 메시지 고정
 * - 채팅방 멤버만 고정 가능
 * - owner/admin 역할만 고정 가능
 * - 삭제된 메시지는 고정 불가
 * - 최대 5개까지만 고정 가능
 */
export async function pinMessage(
  userId: string,
  userType: ChatUserType,
  input: PinMessageInput
): Promise<ChatActionResult<void>> {
  try {
    const { roomId, messageId } = input;

    // 1. 메시지 조회
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "메시지를 찾을 수 없습니다" };
    }

    // 2. 같은 채팅방 메시지인지 확인
    if (message.room_id !== roomId) {
      return { success: false, error: "해당 채팅방의 메시지가 아닙니다" };
    }

    // 3. 삭제된 메시지인지 확인
    if (message.is_deleted) {
      return { success: false, error: "삭제된 메시지는 고정할 수 없습니다" };
    }

    // 4. 채팅방 멤버십 및 역할 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "메시지를 고정할 권한이 없습니다" };
    }

    // 5. 이미 고정된 메시지인지 확인
    const alreadyPinned = await repository.isPinnedMessage(roomId, messageId);
    if (alreadyPinned) {
      return { success: false, error: "이미 고정된 메시지입니다" };
    }

    // 6. 최대 고정 개수 확인
    const pinnedCount = await repository.countPinnedMessages(roomId);
    if (pinnedCount >= MAX_PINNED_MESSAGES) {
      return {
        success: false,
        error: `최대 ${MAX_PINNED_MESSAGES}개까지만 고정할 수 있습니다`,
      };
    }

    // 7. 고정 메시지 추가
    await repository.insertPinnedMessage({
      room_id: roomId,
      message_id: messageId,
      pinned_by: userId,
      pinned_by_type: userType,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] pinMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 고정 실패",
    };
  }
}

/**
 * 메시지 고정 해제
 * - 채팅방 멤버만 해제 가능
 * - owner/admin 역할만 해제 가능
 */
export async function unpinMessage(
  userId: string,
  userType: ChatUserType,
  input: PinMessageInput
): Promise<ChatActionResult<void>> {
  try {
    const { roomId, messageId } = input;

    // 1. 채팅방 멤버십 및 역할 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "메시지 고정을 해제할 권한이 없습니다" };
    }

    // 2. 고정된 메시지인지 확인
    const isPinned = await repository.isPinnedMessage(roomId, messageId);
    if (!isPinned) {
      return { success: false, error: "고정되지 않은 메시지입니다" };
    }

    // 3. 고정 해제
    await repository.deletePinnedMessage(roomId, messageId);

    return { success: true };
  } catch (error) {
    console.error("[ChatService] unpinMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "메시지 고정 해제 실패",
    };
  }
}

/**
 * 채팅방의 고정 메시지 목록 조회
 * - 채팅방 멤버만 조회 가능
 * - 메시지 내용 + 발신자 이름 포함
 */
export async function getPinnedMessages(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<ChatActionResult<PinnedMessageWithContent[]>> {
  try {
    // 1. 채팅방 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 2. 고정 메시지 목록 조회
    const pinnedMessages = await repository.findPinnedMessagesByRoom(roomId);
    if (pinnedMessages.length === 0) {
      return { success: true, data: [] };
    }

    // 3. 메시지 내용 배치 조회
    const messageIds = pinnedMessages.map((p) => p.message_id);
    const messagesMap = await repository.findReplyTargetsByIds(messageIds);

    // 4. 발신자 정보 배치 조회
    const senderKeys = Array.from(messagesMap.values()).map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // 5. 결과 조합
    const result: PinnedMessageWithContent[] = pinnedMessages.map((pinned) => {
      const msg = messagesMap.get(pinned.message_id);
      const senderInfo = msg
        ? senderMap.get(`${msg.sender_id}_${msg.sender_type}`)
        : null;

      return {
        ...pinned,
        message: {
          content: msg?.is_deleted ? "삭제된 메시지입니다" : (msg?.content ?? ""),
          senderName: senderInfo?.name ?? "알 수 없음",
          isDeleted: msg?.is_deleted ?? true,
        },
      };
    });

    return { success: true, data: result };
  } catch (error) {
    console.error("[ChatService] getPinnedMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "고정 메시지 조회 실패",
    };
  }
}

/**
 * 메시지 고정 여부 확인 (단일 메시지)
 */
export async function checkMessagePinned(
  roomId: string,
  messageId: string
): Promise<boolean> {
  try {
    return await repository.isPinnedMessage(roomId, messageId);
  } catch {
    return false;
  }
}

/**
 * 사용자가 고정 권한을 가지고 있는지 확인
 */
export async function canUserPinMessages(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<boolean> {
  try {
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) return false;
    return membership.role === "owner" || membership.role === "admin";
  } catch {
    return false;
  }
}

// ============================================
// 공지 서비스
// ============================================

/**
 * 채팅방 공지 설정/삭제
 * - 채팅방 멤버만 설정 가능
 * - owner/admin 역할만 설정 가능
 * - content가 null이면 공지 삭제
 */
export async function setAnnouncement(
  userId: string,
  userType: ChatUserType,
  input: SetAnnouncementInput
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { roomId, content } = input;

    // 1. 채팅방 존재 확인
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "채팅방을 찾을 수 없습니다" };
    }

    // 2. 채팅방 멤버십 및 역할 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "공지를 설정할 권한이 없습니다" };
    }

    // 3. 공지 내용 검증 (설정하는 경우)
    if (content !== null) {
      const trimmedContent = content.trim();
      if (!trimmedContent) {
        return { success: false, error: "공지 내용을 입력해주세요" };
      }
      if (trimmedContent.length > 500) {
        return { success: false, error: "공지는 500자를 초과할 수 없습니다" };
      }
    }

    // 4. 공지 설정/삭제 실행
    const updatedRoom = await repository.setRoomAnnouncement(
      roomId,
      content !== null ? userId : null,
      content !== null ? userType : null,
      content !== null ? content.trim() : null
    );

    return { success: true, data: updatedRoom };
  } catch (error) {
    console.error("[ChatService] setAnnouncement error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "공지 설정 실패",
    };
  }
}

/**
 * 채팅방 공지 조회
 * - 채팅방 멤버만 조회 가능
 * - 공지가 없으면 null 반환
 */
export async function getAnnouncement(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<ChatActionResult<AnnouncementInfo | null>> {
  try {
    // 1. 채팅방 존재 확인
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "채팅방을 찾을 수 없습니다" };
    }

    // 2. 채팅방 멤버십 확인
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "채팅방에 참여하지 않았습니다" };
    }

    // 3. 공지가 없으면 null 반환
    if (!room.announcement || !room.announcement_by || !room.announcement_by_type) {
      return { success: true, data: null };
    }

    // 4. 공지 작성자 정보 조회
    const authorInfo = await getUserInfo(room.announcement_by, room.announcement_by_type);

    return {
      success: true,
      data: {
        content: room.announcement,
        authorName: authorInfo?.name ?? "알 수 없음",
        authorType: room.announcement_by_type,
        createdAt: room.announcement_at ?? new Date().toISOString(),
      },
    };
  } catch (error) {
    console.error("[ChatService] getAnnouncement error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "공지 조회 실패",
    };
  }
}

/**
 * 사용자가 공지 설정 권한을 가지고 있는지 확인
 */
export async function canUserSetAnnouncement(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<boolean> {
  try {
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) return false;
    return membership.role === "owner" || membership.role === "admin";
  } catch {
    return false;
  }
}
</file>

<file path="lib/domains/chat/types.ts">
/**
 * Chat 도메인 타입 정의
 *
 * 채팅 시스템의 핵심 타입들을 정의합니다.
 * 마이그레이션 후 Supabase CLI로 타입을 재생성하면 Tables<"chat_rooms"> 등으로 변경 가능합니다.
 */

// ============================================
// 기본 열거형 타입
// ============================================

/** 채팅방 유형 */
export type ChatRoomType = "direct" | "group";

/** 사용자 유형 */
export type ChatUserType = "student" | "admin";

/** 채팅방 멤버 역할 */
export type ChatMemberRole = "owner" | "admin" | "member";

/** 메시지 유형 */
export type ChatMessageType = "text" | "system";

/** 메시지 전송 상태 (클라이언트 전용) */
export type MessageStatus = "sending" | "sent" | "error";

/** 신고 사유 */
export type ReportReason =
  | "spam"
  | "harassment"
  | "inappropriate"
  | "hate_speech"
  | "other";

/** 신고 상태 */
export type ReportStatus = "pending" | "reviewed" | "resolved" | "dismissed";

// ============================================
// Presence 타입 (실시간 상태)
// ============================================

/** Presence 사용자 상태 */
export interface PresenceUser {
  userId: string;
  name: string;
  isTyping: boolean;
  lastSeen: string;
}

// ============================================
// 메시지 리액션 타입
// ============================================

/** 지원하는 리액션 이모지 목록 */
export const REACTION_EMOJIS = ["👍", "❤️", "😂", "🔥", "😮"] as const;
export type ReactionEmoji = (typeof REACTION_EMOJIS)[number];

/** 메시지 리액션 */
export interface MessageReaction {
  id: string;
  message_id: string;
  user_id: string;
  user_type: ChatUserType;
  emoji: ReactionEmoji;
  created_at: string;
}

/** 리액션 요약 (UI 표시용) */
export interface ReactionSummary {
  emoji: ReactionEmoji;
  count: number;
  hasReacted: boolean; // 현재 사용자가 리액션했는지
}

/** 리액션 토글 입력 */
export interface ReactionToggleInput {
  messageId: string;
  emoji: ReactionEmoji;
}

// ============================================
// 채팅방 타입
// ============================================

/** 채팅방 기본 타입 */
export interface ChatRoom {
  id: string;
  tenant_id: string;
  type: ChatRoomType;
  name: string | null;
  created_by: string;
  created_by_type: ChatUserType;
  is_active: boolean;
  /** 채팅방 공지 내용 */
  announcement: string | null;
  /** 공지 작성자 ID */
  announcement_by: string | null;
  /** 공지 작성자 유형 */
  announcement_by_type: ChatUserType | null;
  /** 공지 작성 시간 */
  announcement_at: string | null;
  created_at: string;
  updated_at: string;
}

/** 채팅방 생성 입력 타입 */
export interface ChatRoomInsert {
  tenant_id: string;
  type: ChatRoomType;
  name?: string | null;
  created_by: string;
  created_by_type: ChatUserType;
  is_active?: boolean;
}

/** 채팅방 수정 입력 타입 */
export interface ChatRoomUpdate {
  name?: string | null;
  is_active?: boolean;
  announcement?: string | null;
  announcement_by?: string | null;
  announcement_by_type?: ChatUserType | null;
  announcement_at?: string | null;
}

// ============================================
// 채팅방 멤버 타입
// ============================================

/** 채팅방 멤버 기본 타입 */
export interface ChatRoomMember {
  id: string;
  room_id: string;
  user_id: string;
  user_type: ChatUserType;
  role: ChatMemberRole;
  last_read_at: string;
  is_muted: boolean;
  left_at: string | null;
  created_at: string;
  updated_at: string;
}

/** 채팅방 멤버 생성 입력 타입 */
export interface ChatRoomMemberInsert {
  room_id: string;
  user_id: string;
  user_type: ChatUserType;
  role?: ChatMemberRole;
  last_read_at?: string;
  is_muted?: boolean;
}

/** 채팅방 멤버 수정 입력 타입 */
export interface ChatRoomMemberUpdate {
  role?: ChatMemberRole;
  last_read_at?: string;
  is_muted?: boolean;
  left_at?: string | null;
}

// ============================================
// 메시지 타입
// ============================================

/** 메시지 기본 타입 */
export interface ChatMessage {
  id: string;
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type: ChatMessageType;
  content: string;
  reply_to_id: string | null;
  is_deleted: boolean;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
}

/** 메시지 생성 입력 타입 */
export interface ChatMessageInsert {
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type?: ChatMessageType;
  content: string;
  reply_to_id?: string | null;
}

/** 메시지 수정 입력 타입 */
export interface ChatMessageUpdate {
  content?: string;
  is_deleted?: boolean;
  deleted_at?: string | null;
}

/** 메시지가 수정되었는지 확인하는 헬퍼 함수 */
export function isMessageEdited(message: ChatMessage): boolean {
  return message.created_at !== message.updated_at && !message.is_deleted;
}

// ============================================
// 차단 타입
// ============================================

/** 차단 기본 타입 */
export interface ChatBlock {
  id: string;
  blocker_id: string;
  blocker_type: ChatUserType;
  blocked_id: string;
  blocked_type: ChatUserType;
  created_at: string;
}

/** 차단 생성 입력 타입 */
export interface ChatBlockInsert {
  blocker_id: string;
  blocker_type: ChatUserType;
  blocked_id: string;
  blocked_type: ChatUserType;
}

// ============================================
// 신고 타입
// ============================================

/** 신고 기본 타입 */
export interface ChatReport {
  id: string;
  reporter_id: string;
  reporter_type: ChatUserType;
  reported_message_id: string | null;
  reported_user_id: string | null;
  reported_user_type: ChatUserType | null;
  reason: ReportReason;
  description: string | null;
  status: ReportStatus;
  reviewed_by: string | null;
  reviewed_at: string | null;
  resolution_notes: string | null;
  created_at: string;
  updated_at: string;
}

/** 신고 생성 입력 타입 */
export interface ChatReportInsert {
  reporter_id: string;
  reporter_type: ChatUserType;
  reported_message_id?: string | null;
  reported_user_id?: string | null;
  reported_user_type?: ChatUserType | null;
  reason: ReportReason;
  description?: string | null;
}

/** 신고 수정 입력 타입 (관리자용) */
export interface ChatReportUpdate {
  status?: ReportStatus;
  reviewed_by?: string | null;
  reviewed_at?: string | null;
  resolution_notes?: string | null;
}

/** 신고 + 상세 정보 (관리자 UI용) */
export interface ChatReportWithDetails extends ChatReport {
  /** 신고된 메시지 정보 */
  reportedMessage?: ChatMessage | null;
  /** 신고자 정보 */
  reporter?: ChatUser | null;
  /** 피신고자 정보 */
  reportedUser?: ChatUser | null;
}

/** 신고 목록 조회 필터 옵션 */
export interface GetReportsFilter {
  status?: ReportStatus | "all";
  reason?: ReportReason | "all";
}

// ============================================
// 복합 타입 (UI 렌더링용)
// ============================================

/** 사용자 정보 (메시지/멤버 표시용) */
export interface ChatUser {
  id: string;
  type: ChatUserType;
  name: string;
  profileImageUrl?: string | null;
}

/** 답장 원본 메시지 정보 (UI용) */
export interface ReplyTargetInfo {
  id: string;
  content: string;
  senderName: string;
  isDeleted: boolean;
}

/** 메시지 + 발신자 정보 */
export interface ChatMessageWithSender extends ChatMessage {
  sender: ChatUser;
  /** 메시지 리액션 요약 (옵션) */
  reactions?: ReactionSummary[];
  /** 답장 원본 메시지 정보 (옵션) */
  replyTarget?: ReplyTargetInfo | null;
}

/** 메시지 그룹핑 정보 (UI 렌더링용) */
export interface MessageGroupingInfo {
  /** 발신자 이름 표시 여부 (그룹 첫 메시지만 true) */
  showName: boolean;
  /** 시간 표시 여부 (그룹 마지막 메시지만 true) */
  showTime: boolean;
  /** 그룹의 일부인지 여부 (간격 축소용) */
  isGrouped: boolean;
  /** 날짜 구분선 표시 여부 */
  showDateDivider: boolean;
  /** 날짜 구분선 텍스트 (예: "2024년 1월 15일 월요일") */
  dateDividerText?: string;
}

/** 그룹핑 정보가 포함된 메시지 */
export interface ChatMessageWithGrouping extends ChatMessageWithSender {
  grouping: MessageGroupingInfo;
}

/** 채팅방 + 추가 정보 (목록 표시용) */
export interface ChatRoomWithDetails extends ChatRoom {
  members: ChatRoomMemberWithUser[];
  lastMessage: ChatMessage | null;
  unreadCount: number;
}

/** 채팅방 멤버 + 사용자 정보 */
export interface ChatRoomMemberWithUser extends ChatRoomMember {
  user: ChatUser;
}

/** 채팅방 목록 아이템 (간략 버전) */
export interface ChatRoomListItem {
  id: string;
  type: ChatRoomType;
  name: string | null;
  /** direct일 경우 상대방 정보, group일 경우 null */
  otherUser: ChatUser | null;
  /** group일 경우 멤버 수 */
  memberCount: number;
  lastMessage: {
    content: string;
    senderName: string;
    createdAt: string;
  } | null;
  unreadCount: number;
  updatedAt: string;
}

// ============================================
// API 응답/요청 타입
// ============================================

/** 채팅방 생성 요청 */
export interface CreateChatRoomRequest {
  type: ChatRoomType;
  name?: string; // group일 경우
  memberIds: string[]; // 초대할 멤버 user_id 목록
  memberTypes: ChatUserType[]; // 각 멤버의 타입 (memberIds와 같은 순서)
}

/** 메시지 전송 요청 */
export interface SendMessageRequest {
  roomId: string;
  content: string;
  messageType?: ChatMessageType;
  replyToId?: string | null;
}

/** 메시지 목록 조회 옵션 */
export interface GetMessagesOptions {
  roomId: string;
  limit?: number;
  before?: string; // cursor pagination: 이 시간 이전 메시지
}

/** 채팅방 목록 조회 옵션 */
export interface GetRoomsOptions {
  limit?: number;
  offset?: number;
}

// ============================================
// 액션 결과 타입
// ============================================

/** 기본 액션 결과 */
export interface ChatActionResult<T = void> {
  success: boolean;
  data?: T;
  error?: string;
}

/** 페이지네이션 결과 */
export interface PaginatedResult<T> {
  data: T[];
  hasMore: boolean;
  nextCursor?: string;
}

// ============================================
// 메시지 검색 타입
// ============================================

/** 메시지 검색 옵션 */
export interface SearchMessagesOptions {
  roomId: string;
  query: string;
  limit?: number;
  offset?: number;
}

/** 메시지 검색 결과 */
export interface SearchMessagesResult {
  messages: ChatMessageWithSender[];
  total: number;
  query: string;
}

// ============================================
// 읽음 표시 타입
// ============================================

/** 메시지 + 읽음 상태 결과 */
export interface MessagesWithReadStatusResult {
  messages: ChatMessageWithSender[];
  /** 메시지 ID별 안 읽은 멤버 수 */
  readCounts: Record<string, number>;
  hasMore: boolean;
}

// ============================================
// 고정 메시지 타입
// ============================================

/** 고정 메시지 기본 타입 */
export interface PinnedMessage {
  id: string;
  room_id: string;
  message_id: string;
  pinned_by: string;
  pinned_by_type: ChatUserType;
  pin_order: number;
  created_at: string;
}

/** 고정 메시지 + 내용 (UI 표시용) */
export interface PinnedMessageWithContent extends PinnedMessage {
  message: {
    content: string;
    senderName: string;
    isDeleted: boolean;
  };
}

/** 고정 메시지 입력 타입 */
export interface PinMessageInput {
  roomId: string;
  messageId: string;
}

/** 고정 메시지 삽입 타입 (Repository용) */
export interface PinnedMessageInsert {
  room_id: string;
  message_id: string;
  pinned_by: string;
  pinned_by_type: ChatUserType;
  pin_order?: number;
}

// ============================================
// 공지 타입
// ============================================

/** 공지 정보 (UI 표시용) */
export interface AnnouncementInfo {
  content: string;
  authorName: string;
  authorType: ChatUserType;
  createdAt: string;
}

/** 공지 설정 입력 타입 */
export interface SetAnnouncementInput {
  roomId: string;
  content: string | null; // null이면 공지 삭제
}
</file>

<file path="lib/realtime/useChatPresence.ts">
"use client";

/**
 * useChatPresence - 채팅방 Presence 상태 관리
 *
 * Supabase Presence API를 사용하여:
 * - 타이핑 인디케이터 (누가 입력 중인지)
 * - 온라인 상태 (누가 접속 중인지)
 */

import { useEffect, useState, useCallback, useRef } from "react";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimeChannel } from "@supabase/supabase-js";
import type { PresenceUser } from "@/lib/domains/chat/types";

interface UseChatPresenceOptions {
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID */
  userId: string;
  /** 현재 사용자 이름 */
  userName: string;
  /** 활성화 여부 */
  enabled?: boolean;
}

interface UseChatPresenceReturn {
  /** 온라인 사용자 목록 (자신 제외) */
  onlineUsers: PresenceUser[];
  /** 타이핑 중인 사용자 목록 (자신 제외) */
  typingUsers: PresenceUser[];
  /** 타이핑 상태 설정 */
  setTyping: (isTyping: boolean) => void;
}

/** 타이핑 자동 해제 타임아웃 (ms) */
const TYPING_TIMEOUT = 2000;

export function useChatPresence({
  roomId,
  userId,
  userName,
  enabled = true,
}: UseChatPresenceOptions): UseChatPresenceReturn {
  const [onlineUsers, setOnlineUsers] = useState<PresenceUser[]>([]);
  const [typingUsers, setTypingUsers] = useState<PresenceUser[]>([]);
  const channelRef = useRef<RealtimeChannel | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Presence 채널 구독
  useEffect(() => {
    if (!enabled || !roomId || !userId || !userName) return;

    const supabase = createSupabaseBrowserClient();
    const channel = supabase.channel(`presence-${roomId}`, {
      config: {
        presence: {
          key: userId,
        },
      },
    });

    channel
      .on("presence", { event: "sync" }, () => {
        const state = channel.presenceState<PresenceUser>();

        // 모든 사용자 목록 (자신 제외)
        const allUsers = Object.values(state)
          .flat()
          .filter((u) => u.userId !== userId);

        setOnlineUsers(allUsers);
        setTypingUsers(allUsers.filter((u) => u.isTyping));
      })
      .on("presence", { event: "join" }, ({ newPresences }) => {
        // 새 사용자 입장 시 로그 (디버깅용)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User joined:", newPresences);
        }
      })
      .on("presence", { event: "leave" }, ({ leftPresences }) => {
        // 사용자 퇴장 시 로그 (디버깅용)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User left:", leftPresences);
        }
      })
      .subscribe(async (status) => {
        if (status === "SUBSCRIBED") {
          // 초기 상태 등록
          await channel.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }
      });

    channelRef.current = channel;

    return () => {
      // 타이핑 타임아웃 정리
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      // 채널 정리
      channel.untrack();
      supabase.removeChannel(channel);
      channelRef.current = null;
    };
  }, [roomId, userId, userName, enabled]);

  // 타이핑 상태 업데이트
  const setTyping = useCallback(
    (isTyping: boolean) => {
      if (!channelRef.current) return;

      // 기존 타임아웃 클리어
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }

      // 상태 업데이트
      channelRef.current.track({
        userId,
        name: userName,
        isTyping,
        lastSeen: new Date().toISOString(),
      });

      // 타이핑 중이면 자동 해제 타이머 설정
      if (isTyping) {
        typingTimeoutRef.current = setTimeout(() => {
          channelRef.current?.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }, TYPING_TIMEOUT);
      }
    },
    [userId, userName]
  );

  return {
    onlineUsers,
    typingUsers,
    setTyping,
  };
}
</file>

<file path="lib/realtime/useChatRealtime.ts">
"use client";

/**
 * 채팅 메시지 실시간 구독 훅
 *
 * 특정 채팅방의 새 메시지를 실시간으로 수신합니다.
 * Supabase Realtime postgres_changes 사용.
 */

import { useEffect, useRef, useCallback } from "react";
import { useQueryClient, type InfiniteData } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";
import type {
  ChatUserType,
  ChatMessageType,
  ChatMessageWithSender,
  ChatUser,
  MessagesWithReadStatusResult,
} from "@/lib/domains/chat/types";
import { getSenderInfoAction } from "@/lib/domains/chat/actions";

// Supabase Realtime Payload 타입 (DB 컬럼과 1:1 매핑)
interface ChatMessagePayload {
  id: string;
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type: ChatMessageType;
  content: string;
  is_deleted: boolean;
  reply_to_id: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

// 리액션 Payload 타입
interface ChatReactionPayload {
  id: string;
  message_id: string;
  user_id: string;
  user_type: ChatUserType;
  emoji: string;
  created_at: string;
}

// 캐시 메시지 타입 (낙관적 업데이트 status 포함)
type CacheMessage = ChatMessageWithSender & {
  status?: "sending" | "sent" | "error";
};

// Infinite Query 캐시 구조 (MessagesWithReadStatusResult 기반)
type MessagesPage = Omit<MessagesWithReadStatusResult, "messages"> & {
  messages: CacheMessage[];
};

// InfiniteQuery 캐시 타입
type InfiniteMessagesCache = InfiniteData<MessagesPage, string | undefined>;

type UseChatRealtimeOptions = {
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID (본인 메시지 구분용) */
  userId: string;
  /** 구독 활성화 여부 */
  enabled?: boolean;
  /** 새 메시지 수신 콜백 */
  onNewMessage?: (message: ChatMessagePayload) => void;
  /** 메시지 삭제 콜백 */
  onMessageDeleted?: (messageId: string) => void;
};

/**
 * 채팅 메시지 실시간 구독 훅
 *
 * @example
 * ```tsx
 * useChatRealtime({
 *   roomId: "room-123",
 *   userId: "user-456",
 *   onNewMessage: (msg) => {
 *     // 스크롤 또는 알림 처리
 *   },
 * });
 * ```
 */
export function useChatRealtime({
  roomId,
  userId,
  enabled = true,
  onNewMessage,
  onMessageDeleted,
}: UseChatRealtimeOptions) {
  const queryClient = useQueryClient();

  // 콜백을 ref로 저장하여 의존성 변경 방지
  const callbacksRef = useRef({ onNewMessage, onMessageDeleted });
  useEffect(() => {
    callbacksRef.current = { onNewMessage, onMessageDeleted };
  }, [onNewMessage, onMessageDeleted]);

  // 발신자 정보 캐시 (세션 내 재사용)
  const senderCacheRef = useRef(new Map<string, ChatUser>());

  // 발신자 정보 조회 (캐시 우선)
  const fetchSenderInfo = useCallback(
    async (senderId: string, senderType: ChatUserType): Promise<ChatUser> => {
      const cacheKey = `${senderId}_${senderType}`;

      // 캐시 확인
      const cached = senderCacheRef.current.get(cacheKey);
      if (cached) return cached;

      // 서버에서 조회
      const result = await getSenderInfoAction(senderId, senderType);
      if (result.success && result.data) {
        senderCacheRef.current.set(cacheKey, result.data);
        return result.data;
      }

      // 기본값 반환
      return {
        id: senderId,
        type: senderType,
        name: "알 수 없음",
      };
    },
    []
  );

  // 쿼리 무효화 함수
  const invalidateMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-messages" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  const invalidatePinnedMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-pinned" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateAnnouncement = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-announcement" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  useEffect(() => {
    if (!enabled || !roomId || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-room-${roomId}`)
      // 새 메시지 INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] New message:", payload.new);
          const newMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryData로 캐시에 직접 추가 (서버 재요청 없음) - InfiniteQuery 구조
          queryClient.setQueryData<InfiniteMessagesCache>(
            ["chat-messages", roomId],
            (old) => {
              if (!old?.pages?.length || !newMessage) return old;

              // 첫 번째 페이지(최신 메시지들)에서 중복 체크 및 추가
              const firstPage = old.pages[0];
              const existingIndex = firstPage.messages.findIndex(
                (m) =>
                  m.id === newMessage.id ||
                  (m.id.startsWith("temp-") &&
                    m.content === newMessage.content &&
                    m.sender_id === newMessage.sender_id)
              );

              if (existingIndex !== -1) {
                // 낙관적 메시지 → 실제 메시지로 교체
                const updatedMessages = [...firstPage.messages];
                const existingMessage = updatedMessages[existingIndex];
                updatedMessages[existingIndex] = {
                  ...existingMessage,
                  ...newMessage,
                  sender: existingMessage.sender,
                  status: "sent" as const,
                };
                return {
                  ...old,
                  pages: [
                    { ...firstPage, messages: updatedMessages },
                    ...old.pages.slice(1),
                  ],
                };
              }

              // 타인의 새 메시지 추가 (sender 정보는 임시로 설정 후 비동기로 보강)
              const tempSender: ChatUser = {
                id: newMessage.sender_id,
                type: newMessage.sender_type,
                name: "로딩 중...",
              };

              const newCacheMessage: CacheMessage = {
                ...newMessage,
                sender: tempSender,
                reactions: [],
                replyTarget: null,
              };

              return {
                ...old,
                pages: [
                  {
                    ...firstPage,
                    messages: [...firstPage.messages, newCacheMessage],
                  },
                  ...old.pages.slice(1),
                ],
              };
            }
          );

          // 타인 메시지인 경우 sender 정보 비동기로 보강
          if (newMessage?.sender_id && newMessage.sender_id !== userId) {
            fetchSenderInfo(newMessage.sender_id, newMessage.sender_type).then(
              (senderInfo) => {
                // sender 정보로 캐시 업데이트
                queryClient.setQueryData<InfiniteMessagesCache>(
                  ["chat-messages", roomId],
                  (old) => {
                    if (!old?.pages?.length) return old;
                    return {
                      ...old,
                      pages: old.pages.map((page) => ({
                        ...page,
                        messages: page.messages.map((m) =>
                          m.id === newMessage.id
                            ? { ...m, sender: senderInfo }
                            : m
                        ),
                      })),
                    };
                  }
                );
              }
            );
          }

          // 채팅방 목록도 무효화 (마지막 메시지 업데이트)
          invalidateRoomList();

          // 콜백 호출 (타인의 메시지만)
          if (newMessage?.sender_id && newMessage.sender_id !== userId) {
            callbacksRef.current.onNewMessage?.(newMessage);
          }
        }
      )
      // 메시지 UPDATE (삭제/수정 등)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] Message updated:", payload.new);
          const updatedMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryData로 해당 메시지만 업데이트 (서버 재요청 없음) - InfiniteQuery 구조
          queryClient.setQueryData<InfiniteMessagesCache>(
            ["chat-messages", roomId],
            (old) => {
              if (!old?.pages?.length || !updatedMessage) return old;

              // 모든 페이지에서 해당 메시지 찾아서 업데이트
              return {
                ...old,
                pages: old.pages.map((page) => ({
                  ...page,
                  messages: page.messages.map((m) =>
                    m.id === updatedMessage.id
                      ? {
                          ...m,
                          content: updatedMessage.content,
                          is_deleted: updatedMessage.is_deleted,
                          updated_at: updatedMessage.updated_at,
                          deleted_at: updatedMessage.deleted_at,
                        }
                      : m
                  ),
                })),
              };
            }
          );

          // 삭제된 경우 콜백 호출
          if (updatedMessage?.is_deleted && updatedMessage.id) {
            callbacksRef.current.onMessageDeleted?.(updatedMessage.id);
          }
        }
      )
      // 리액션 INSERT (타겟 캐시 업데이트)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_message_reactions",
        },
        (payload: RealtimePostgresChangesPayload<ChatReactionPayload>) => {
          const reaction = payload.new as ChatReactionPayload | undefined;
          console.log("[ChatRealtime] Reaction added:", reaction?.message_id);

          if (reaction?.message_id) {
            // 해당 메시지에만 리액션 추가 (전체 무효화 대신)
            queryClient.setQueryData<InfiniteMessagesCache>(
              ["chat-messages", roomId],
              (old) => {
                if (!old?.pages?.length) return old;
                return {
                  ...old,
                  pages: old.pages.map((page) => ({
                    ...page,
                    messages: page.messages.map((m) => {
                      if (m.id !== reaction.message_id) return m;

                      // 기존 리액션에서 같은 이모지 찾기
                      const existingReactions = m.reactions ?? [];
                      const existingIdx = existingReactions.findIndex(
                        (r) => r.emoji === reaction.emoji
                      );

                      if (existingIdx >= 0) {
                        // 기존 이모지 카운트 증가
                        const updated = [...existingReactions];
                        updated[existingIdx] = {
                          ...updated[existingIdx],
                          count: updated[existingIdx].count + 1,
                          hasReacted:
                            updated[existingIdx].hasReacted ||
                            (reaction.user_id === userId),
                        };
                        return { ...m, reactions: updated };
                      } else {
                        // 새 이모지 추가
                        return {
                          ...m,
                          reactions: [
                            ...existingReactions,
                            {
                              emoji: reaction.emoji as "👍" | "❤️" | "😂" | "🔥" | "😮",
                              count: 1,
                              hasReacted: reaction.user_id === userId,
                            },
                          ],
                        };
                      }
                    }),
                  })),
                };
              }
            );
          }
        }
      )
      // 리액션 DELETE (타겟 캐시 업데이트)
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_message_reactions",
        },
        (payload: RealtimePostgresChangesPayload<ChatReactionPayload>) => {
          const reaction = payload.old as ChatReactionPayload | undefined;
          console.log("[ChatRealtime] Reaction removed:", reaction?.message_id);

          if (reaction?.message_id) {
            // 해당 메시지에서만 리액션 제거 (전체 무효화 대신)
            queryClient.setQueryData<InfiniteMessagesCache>(
              ["chat-messages", roomId],
              (old) => {
                if (!old?.pages?.length) return old;
                return {
                  ...old,
                  pages: old.pages.map((page) => ({
                    ...page,
                    messages: page.messages.map((m) => {
                      if (m.id !== reaction.message_id) return m;

                      const existingReactions = m.reactions ?? [];
                      const existingIdx = existingReactions.findIndex(
                        (r) => r.emoji === reaction.emoji
                      );

                      if (existingIdx >= 0) {
                        const updated = [...existingReactions];
                        const newCount = updated[existingIdx].count - 1;

                        if (newCount <= 0) {
                          // 카운트가 0이면 제거
                          updated.splice(existingIdx, 1);
                        } else {
                          // 카운트 감소
                          updated[existingIdx] = {
                            ...updated[existingIdx],
                            count: newCount,
                            hasReacted:
                              reaction.user_id === userId
                                ? false
                                : updated[existingIdx].hasReacted,
                          };
                        }
                        return { ...m, reactions: updated };
                      }
                      return m;
                    }),
                  })),
                };
              }
            );
          }
        }
      )
      // 고정 메시지 INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_pinned_messages",
          filter: `room_id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Message pinned");
          invalidatePinnedMessages();
        }
      )
      // 고정 메시지 DELETE
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_pinned_messages",
        },
        () => {
          console.log("[ChatRealtime] Message unpinned");
          invalidatePinnedMessages();
        }
      )
      // 채팅방 UPDATE (공지 변경)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_rooms",
          filter: `id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Room updated (announcement)");
          invalidateAnnouncement();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room ${roomId} subscription:`, status);

        if (status === "SUBSCRIBED") {
          // 연결 성공 또는 재연결(Recovery) 시 최신 데이터 동기화
          // 소켓 연결이 끊긴 동안 누락된 메시지나 변경사항을 불러옵니다.
          console.log("[ChatRealtime] Connected/Reconnected. Syncing data...");
          invalidateMessages();
          invalidateRoomList();
          invalidatePinnedMessages();
          invalidateAnnouncement();
        }

        if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
          console.error(`[ChatRealtime] Connection error: ${status}`);
        }
      });

    return () => {
      console.log(`[ChatRealtime] Unsubscribing from room ${roomId}`);
      supabase.removeChannel(channel);
    };
  }, [roomId, userId, enabled, queryClient, invalidateMessages, invalidateRoomList, invalidatePinnedMessages, invalidateAnnouncement, fetchSenderInfo]);
}

// ============================================
// 채팅방 목록 실시간 구독
// ============================================

type UseChatRoomListRealtimeOptions = {
  /** 현재 사용자 ID */
  userId: string;
  /** 사용자 유형 */
  userType: "student" | "admin";
  /** 구독 활성화 여부 */
  enabled?: boolean;
};

/**
 * 채팅방 목록 실시간 구독 훅
 *
 * 새 채팅방 생성, 멤버 변경 등을 실시간으로 반영합니다.
 */
export function useChatRoomListRealtime({
  userId,
  userType,
  enabled = true,
}: UseChatRoomListRealtimeOptions) {
  const queryClient = useQueryClient();

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  useEffect(() => {
    if (!enabled || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-rooms-${userId}`)
      // 내가 멤버로 추가된 경우
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Added to room:", payload);
          invalidateRoomList();
        }
      )
      // 멤버십 변경 (나가기 등)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Membership updated:", payload);
          invalidateRoomList();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room list subscription:`, status);

        if (status === "SUBSCRIBED") {
          console.log("[ChatRealtime] Room list connected/reconnected. Syncing...");
          invalidateRoomList();
        }

        if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
          console.error(`[ChatRealtime] Room list connection error: ${status}`);
        }
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, userType, enabled, invalidateRoomList]);
}
</file>

</files>
