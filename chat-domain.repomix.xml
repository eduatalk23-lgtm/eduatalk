This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
[chat]/
  actions/
    index.ts
    members.ts
    messages.ts
    pins.ts
    reactions.ts
    rooms.ts
    safety.ts
  index.ts
  messageGrouping.ts
  repository.ts
  service.ts
  types.ts

[chat]/
  atoms/
    AnnouncementBanner.tsx
    DateDivider.tsx
    MessageBubble.tsx
    OnlineStatus.tsx
    ReactionPicker.tsx
    ReactionPills.tsx
    TypingIndicator.tsx
    UnreadBadge.tsx
  molecules/
    AnnouncementDialog.tsx
    ChatInput.tsx
    ChatRoomCard.tsx
    MessageContextMenu.tsx
    MessageSearch.tsx
    PinnedMessagesBar.tsx
  organisms/
    ChatList.tsx
    ChatRoom.tsx
    ChatRoomInfo.tsx
  index.ts

[chat]/
  _components/
    ChatListPage.tsx
    CreateChatModal.tsx
  [roomId]/
    _components/
      ChatRoomPage.tsx
    page.tsx
  page.tsx

[chat]/
  _components/
    AdminChatListPage.tsx
    AdminCreateChatModal.tsx
  [roomId]/
    _components/
      AdminChatRoomPage.tsx
    page.tsx
  reports/
    _components/
      ReportDetailModal.tsx
      ReportFilter.tsx
      ReportListPage.tsx
      ReportTable.tsx
    page.tsx
  page.tsx

[realtime]/
  index.ts
  useAdminPlanRealtime.ts
  useAttendanceRealtime.ts
  useChatPresence.ts
  useChatRealtime.ts
  useNotificationRealtime.ts
  usePlanGroupRealtime.ts
  usePlanRealtimeUpdates.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="actions/index.ts">
/**
 * Chat Domain Actions
 *
 * Server Actions for chat functionality.
 */

// Room Actions
export {
  createChatRoomAction,
  getChatRoomsAction,
  getChatRoomDetailAction,
  leaveChatRoomAction,
  startDirectChatAction,
  setAnnouncementAction,
  getAnnouncementAction,
  canSetAnnouncementAction,
} from "./rooms";

// Message Actions
export {
  sendMessageAction,
  getMessagesAction,
  deleteMessageAction,
  markAsReadAction,
  editMessageAction,
  searchMessagesAction,
  getMessagesWithReadStatusAction,
} from "./messages";

// Member Actions
export { inviteMembersAction } from "./members";

// Safety Actions (Block & Report)
export {
  blockUserAction,
  unblockUserAction,
  getBlockedUsersAction,
  reportMessageAction,
  getPendingReportsAction,
  resolveReportAction,
} from "./safety";

// Reaction Actions
export { toggleReactionAction } from "./reactions";

// Pin Actions
export {
  pinMessageAction,
  unpinMessageAction,
  getPinnedMessagesAction,
  canPinMessagesAction,
} from "./pins";
</file>

<file path="actions/members.ts">
"use server";

/**
 * Chat Member Server Actions
 * ë©¤ë²„ ì´ˆëŒ€/ê´€ë¦¬
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type { ChatUserType, ChatActionResult } from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ê·¸ë£¹ ì±„íŒ…ë°©ì— ë©¤ë²„ ì´ˆëŒ€
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param memberIds ì´ˆëŒ€í•  ì‚¬ìš©ì ID ëª©ë¡
 * @param memberTypes ê° ì‚¬ìš©ìì˜ ìœ í˜•
 */
export async function inviteMembersAction(
  roomId: string,
  memberIds: string[],
  memberTypes: ChatUserType[]
): Promise<ChatActionResult<void>> {
  try {
    // ì…ë ¥ ê²€ì¦
    if (memberIds.length !== memberTypes.length) {
      return {
        success: false,
        error: "ë©¤ë²„ IDì™€ ìœ í˜•ì˜ ê°œìˆ˜ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
      };
    }

    if (memberIds.length === 0) {
      return {
        success: false,
        error: "ì´ˆëŒ€í•  ë©¤ë²„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”",
      };
    }

    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.inviteMembers(
      roomId,
      userId,
      userType,
      memberIds,
      memberTypes
    );
  } catch (error) {
    console.error("[inviteMembersAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©¤ë²„ ì´ˆëŒ€ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="actions/messages.ts">
"use server";

/**
 * Chat Message Server Actions
 * ë©”ì‹œì§€ ì „ì†¡/ì¡°íšŒ/ì‚­ì œ
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type {
  ChatMessage,
  ChatMessageWithSender,
  ChatUserType,
  ChatActionResult,
  PaginatedResult,
  GetMessagesOptions,
  SearchMessagesResult,
  MessagesWithReadStatusResult,
} from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ë©”ì‹œì§€ ì „ì†¡
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param content ë©”ì‹œì§€ ë‚´ìš© (ìµœëŒ€ 1000ì)
 * @param replyToId ë‹µì¥ ëŒ€ìƒ ë©”ì‹œì§€ ID (ì„ íƒ)
 * @returns ì „ì†¡ëœ ë©”ì‹œì§€
 */
export async function sendMessageAction(
  roomId: string,
  content: string,
  replyToId?: string | null
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.sendMessage(userId, userType, {
      roomId,
      content,
      replyToId,
    });
  } catch (error) {
    console.error("[sendMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (í˜ì´ì§€ë„¤ì´ì…˜)
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜ (limit, before)
 * @returns ë©”ì‹œì§€ ëª©ë¡ (ë°œì‹ ì ì •ë³´ í¬í•¨)
 */
export async function getMessagesAction(
  roomId: string,
  options: { limit?: number; before?: string } = {}
): Promise<ChatActionResult<PaginatedResult<ChatMessageWithSender>>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    const messageOptions: GetMessagesOptions = {
      roomId,
      limit: options.limit ?? 50,
      before: options.before,
    };

    return await chatService.getMessages(userId, userType, messageOptions);
  } catch (error) {
    console.error("[getMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ì‚­ì œ (ë³¸ì¸ ë©”ì‹œì§€ë§Œ)
 *
 * @param messageId ë©”ì‹œì§€ ID
 */
export async function deleteMessageAction(
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    return await chatService.deleteMessage(messageId, userId);
  } catch (error) {
    console.error("[deleteMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì½ìŒ ì²˜ë¦¬ (ì±„íŒ…ë°© ì…ì¥/ìŠ¤í¬ë¡¤ ì‹œ í˜¸ì¶œ)
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function markAsReadAction(
  roomId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.markRoomAsRead(roomId, userId, userType);
  } catch (error) {
    console.error("[markAsReadAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì½ìŒ ì²˜ë¦¬ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ í¸ì§‘ (ë³¸ì¸ ë©”ì‹œì§€, 5ë¶„ ì´ë‚´)
 *
 * @param messageId ë©”ì‹œì§€ ID
 * @param newContent ìƒˆ ë©”ì‹œì§€ ë‚´ìš©
 */
export async function editMessageAction(
  messageId: string,
  newContent: string
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.editMessage(userId, userType, messageId, newContent);
  } catch (error) {
    console.error("[editMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ìˆ˜ì • ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ê²€ìƒ‰
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param query ê²€ìƒ‰ì–´
 * @param options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜ (limit, offset)
 */
export async function searchMessagesAction(
  roomId: string,
  query: string,
  options: { limit?: number; offset?: number } = {}
): Promise<ChatActionResult<SearchMessagesResult>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.searchMessages(userId, userType, {
      roomId,
      query,
      limit: options.limit,
      offset: options.offset,
    });
  } catch (error) {
    console.error("[searchMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê²€ìƒ‰ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (ì½ìŒ ìƒíƒœ í¬í•¨)
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜ (limit, before)
 */
export async function getMessagesWithReadStatusAction(
  roomId: string,
  options: { limit?: number; before?: string } = {}
): Promise<ChatActionResult<MessagesWithReadStatusResult>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.getMessagesWithReadStatus(userId, userType, {
      roomId,
      limit: options.limit ?? 50,
      before: options.before,
    });
  } catch (error) {
    console.error("[getMessagesWithReadStatusAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="actions/pins.ts">
"use server";

/**
 * Chat Pin Server Actions
 * ë©”ì‹œì§€ ê³ ì •/í•´ì œ ê¸°ëŠ¥
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type {
  ChatActionResult,
  ChatUserType,
  PinnedMessageWithContent,
} from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ë©”ì‹œì§€ ê³ ì •
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param messageId ê³ ì •í•  ë©”ì‹œì§€ ID
 */
export async function pinMessageAction(
  roomId: string,
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.pinMessage(userId, userType, {
      roomId,
      messageId,
    });
  } catch (error) {
    console.error("[pinMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê³ ì • ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ê³ ì • í•´ì œ
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param messageId ê³ ì • í•´ì œí•  ë©”ì‹œì§€ ID
 */
export async function unpinMessageAction(
  roomId: string,
  messageId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.unpinMessage(userId, userType, {
      roomId,
      messageId,
    });
  } catch (error) {
    console.error("[unpinMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê³ ì • í•´ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°©ì˜ ê³ ì • ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function getPinnedMessagesAction(
  roomId: string
): Promise<ChatActionResult<PinnedMessageWithContent[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.getPinnedMessages(userId, userType, roomId);
  } catch (error) {
    console.error("[getPinnedMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³ ì • ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‚¬ìš©ìê°€ ê³ ì • ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function canPinMessagesAction(
  roomId: string
): Promise<ChatActionResult<{ canPin: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);
    const canPin = await chatService.canUserPinMessages(userId, userType, roomId);

    return { success: true, data: { canPin } };
  } catch (error) {
    console.error("[canPinMessagesAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="actions/reactions.ts">
"use server";

/**
 * Chat Reaction Server Actions
 * ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ í† ê¸€
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type { ChatActionResult, ChatUserType, ReactionEmoji } from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ í† ê¸€
 * - ë¦¬ì•¡ì…˜ì´ ì—†ìœ¼ë©´ ì¶”ê°€, ìˆìœ¼ë©´ ì‚­ì œ
 *
 * @param messageId ë©”ì‹œì§€ ID
 * @param emoji ë¦¬ì•¡ì…˜ ì´ëª¨ì§€ (ğŸ‘, â¤ï¸, ğŸ˜‚, ğŸ”¥, ğŸ˜®)
 * @returns { added: boolean } - trueë©´ ì¶”ê°€ë¨, falseë©´ ì‚­ì œë¨
 */
export async function toggleReactionAction(
  messageId: string,
  emoji: ReactionEmoji
): Promise<ChatActionResult<{ added: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.toggleReaction(userId, userType, {
      messageId,
      emoji,
    });
  } catch (error) {
    console.error("[toggleReactionAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë¦¬ì•¡ì…˜ ì²˜ë¦¬ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="actions/rooms.ts">
"use server";

/**
 * Chat Room Server Actions
 * ì±„íŒ…ë°© ìƒì„±/ì¡°íšŒ/ê´€ë¦¬
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import type {
  ChatRoom,
  ChatRoomListItem,
  ChatRoomMemberWithUser,
  ChatUserType,
  ChatActionResult,
  CreateChatRoomRequest,
  AnnouncementInfo,
} from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ì±„íŒ…ë°© ìƒì„± (1:1 ë˜ëŠ” ê·¸ë£¹)
 *
 * @param request ì±„íŒ…ë°© ìƒì„± ìš”ì²­
 * @returns ìƒì„±ëœ ì±„íŒ…ë°© ë˜ëŠ” ê¸°ì¡´ 1:1 ì±„íŒ…ë°©
 */
export async function createChatRoomAction(
  request: CreateChatRoomRequest
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role, tenantId } = await getCurrentUserRole();

    if (!userId || !role || !tenantId) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.createOrGetRoom(
      tenantId,
      userId,
      userType,
      request
    );
  } catch (error) {
    console.error("[createChatRoomAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ìƒì„± ì‹¤íŒ¨",
    };
  }
}

/**
 * ë‚´ ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ
 *
 * @param options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜
 * @returns ì±„íŒ…ë°© ëª©ë¡ (ë§ˆì§€ë§‰ ë©”ì‹œì§€, ì•ˆ ì½ì€ ìˆ˜ í¬í•¨)
 */
export async function getChatRoomsAction(
  options: { limit?: number; offset?: number } = {}
): Promise<ChatActionResult<ChatRoomListItem[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    const rooms = await chatService.getRoomList(userId, userType, options);

    return { success: true, data: rooms };
  } catch (error) {
    console.error("[getChatRoomsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°© ìƒì„¸ ì •ë³´ ì¡°íšŒ
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @returns ì±„íŒ…ë°© ì •ë³´ + ë©¤ë²„ ëª©ë¡
 */
export async function getChatRoomDetailAction(
  roomId: string
): Promise<ChatActionResult<{ room: ChatRoom; members: ChatRoomMemberWithUser[] }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.getRoomDetail(roomId, userId, userType);
  } catch (error) {
    console.error("[getChatRoomDetailAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°© ë‚˜ê°€ê¸°
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function leaveChatRoomAction(
  roomId: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.leaveRoom(roomId, userId, userType);
  } catch (error) {
    console.error("[leaveChatRoomAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì‹¤íŒ¨",
    };
  }
}

/**
 * 1:1 ì±„íŒ… ì‹œì‘ (ë˜ëŠ” ê¸°ì¡´ ë°© ì—´ê¸°)
 *
 * @param targetUserId ëŒ€í™” ìƒëŒ€ ID
 * @param targetUserType ëŒ€í™” ìƒëŒ€ ìœ í˜•
 * @returns 1:1 ì±„íŒ…ë°©
 */
export async function startDirectChatAction(
  targetUserId: string,
  targetUserType: ChatUserType
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role, tenantId } = await getCurrentUserRole();

    if (!userId || !role || !tenantId) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.createOrGetRoom(tenantId, userId, userType, {
      type: "direct",
      memberIds: [targetUserId],
      memberTypes: [targetUserType],
    });
  } catch (error) {
    console.error("[startDirectChatAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ… ì‹œì‘ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ê³µì§€ Actions
// ============================================

/**
 * ì±„íŒ…ë°© ê³µì§€ ì„¤ì •
 *
 * @param roomId ì±„íŒ…ë°© ID
 * @param content ê³µì§€ ë‚´ìš© (nullì´ë©´ ê³µì§€ ì‚­ì œ)
 */
export async function setAnnouncementAction(
  roomId: string,
  content: string | null
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.setAnnouncement(userId, userType, {
      roomId,
      content,
    });
  } catch (error) {
    console.error("[setAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³µì§€ ì„¤ì • ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°© ê³µì§€ ì¡°íšŒ
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function getAnnouncementAction(
  roomId: string
): Promise<ChatActionResult<AnnouncementInfo | null>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.getAnnouncement(userId, userType, roomId);
  } catch (error) {
    console.error("[getAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³µì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‚¬ìš©ìê°€ ê³µì§€ ì„¤ì • ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
 *
 * @param roomId ì±„íŒ…ë°© ID
 */
export async function canSetAnnouncementAction(
  roomId: string
): Promise<ChatActionResult<{ canSet: boolean }>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);
    const canSet = await chatService.canUserSetAnnouncement(userId, userType, roomId);

    return { success: true, data: { canSet } };
  } catch (error) {
    console.error("[canSetAnnouncementAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="actions/safety.ts">
"use server";

/**
 * Chat Safety Server Actions
 * ì°¨ë‹¨/ì‹ ê³  ê¸°ëŠ¥ (App Store í•„ìˆ˜)
 */

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import * as chatService from "../service";
import * as chatRepository from "../repository";
import type {
  ChatUserType,
  ChatActionResult,
  ChatBlock,
  ChatReport,
  ChatReportWithDetails,
  ReportReason,
  GetReportsFilter,
} from "../types";

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ userType ê²°ì •
 */
function getUserType(role: string | null): ChatUserType {
  if (role === "admin" || role === "consultant") return "admin";
  return "student";
}

/**
 * ê´€ë¦¬ì ì—­í•  í™•ì¸
 */
function isAdminRole(role: string | null): boolean {
  return role === "admin" || role === "consultant";
}

// ============================================
// ì°¨ë‹¨ ê¸°ëŠ¥
// ============================================

/**
 * ì‚¬ìš©ì ì°¨ë‹¨
 *
 * @param blockedId ì°¨ë‹¨í•  ì‚¬ìš©ì ID
 * @param blockedType ì°¨ë‹¨í•  ì‚¬ìš©ì ìœ í˜•
 */
export async function blockUserAction(
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    // ìê¸° ìì‹  ì°¨ë‹¨ ë°©ì§€
    if (blockedId === userId) {
      return {
        success: false,
        error: "ìê¸° ìì‹ ì„ ì°¨ë‹¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
      };
    }

    return await chatService.blockUser(
      userId,
      userType,
      blockedId,
      blockedType
    );
  } catch (error) {
    console.error("[blockUserAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì°¨ë‹¨ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì°¨ë‹¨ í•´ì œ
 *
 * @param blockedId ì°¨ë‹¨ í•´ì œí•  ì‚¬ìš©ì ID
 * @param blockedType ì°¨ë‹¨ í•´ì œí•  ì‚¬ìš©ì ìœ í˜•
 */
export async function unblockUserAction(
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.unblockUser(
      userId,
      userType,
      blockedId,
      blockedType
    );
  } catch (error) {
    console.error("[unblockUserAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì°¨ë‹¨ í•´ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë‚´ ì°¨ë‹¨ ëª©ë¡ ì¡°íšŒ
 */
export async function getBlockedUsersAction(): Promise<
  ChatActionResult<ChatBlock[]>
> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    const blocks = await chatRepository.findBlocksByUser(userId, userType);

    return { success: true, data: blocks };
  } catch (error) {
    console.error("[getBlockedUsersAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì°¨ë‹¨ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ì‹ ê³  ê¸°ëŠ¥
// ============================================

/**
 * ë©”ì‹œì§€ ì‹ ê³ 
 *
 * @param messageId ì‹ ê³ í•  ë©”ì‹œì§€ ID
 * @param reason ì‹ ê³  ì‚¬ìœ 
 * @param description ìƒì„¸ ì„¤ëª… (ì„ íƒ)
 */
export async function reportMessageAction(
  messageId: string,
  reason: ReportReason,
  description?: string
): Promise<ChatActionResult<void>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const userType = getUserType(role);

    return await chatService.reportMessage(
      userId,
      userType,
      messageId,
      reason,
      description
    );
  } catch (error) {
    console.error("[reportMessageAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ê´€ë¦¬ì ì „ìš© ê¸°ëŠ¥
// ============================================

/**
 * ëŒ€ê¸° ì¤‘ì¸ ì‹ ê³  ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 */
export async function getPendingReportsAction(): Promise<
  ChatActionResult<ChatReport[]>
> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
      };
    }

    const reports = await chatRepository.findPendingReports();

    return { success: true, data: reports };
  } catch (error) {
    console.error("[getPendingReportsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‹ ê³  ì²˜ë¦¬ (ê´€ë¦¬ì ì „ìš©)
 *
 * @param reportId ì‹ ê³  ID
 * @param status ì²˜ë¦¬ ìƒíƒœ (resolved, dismissed)
 * @param notes ì²˜ë¦¬ ë©”ëª¨
 */
export async function resolveReportAction(
  reportId: string,
  status: "resolved" | "dismissed",
  notes?: string
): Promise<ChatActionResult<ChatReport>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
      };
    }

    const report = await chatRepository.updateReport(reportId, {
      status,
      reviewed_by: userId,
      reviewed_at: new Date().toISOString(),
      resolution_notes: notes ?? null,
    });

    return { success: true, data: report };
  } catch (error) {
    console.error("[resolveReportAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ì²˜ë¦¬ ì‹¤íŒ¨",
    };
  }
}

/**
 * ëª¨ë“  ì‹ ê³  ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©, í•„í„° ì§€ì›)
 */
export async function getAllReportsAction(
  filters?: GetReportsFilter
): Promise<ChatActionResult<ChatReport[]>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
      };
    }

    const reports = await chatRepository.findAllReports(filters);

    return { success: true, data: reports };
  } catch (error) {
    console.error("[getAllReportsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‹ ê³  ìƒì„¸ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 * ì‹ ê³  ì •ë³´ + ì‹ ê³ ëœ ë©”ì‹œì§€ + ì‹ ê³ ì/í”¼ì‹ ê³ ì ì •ë³´
 */
export async function getReportDetailsAction(
  reportId: string
): Promise<ChatActionResult<ChatReportWithDetails>> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || !role) {
      return { success: false, error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
    if (!isAdminRole(role)) {
      return {
        success: false,
        error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤",
      };
    }

    // ì‹ ê³  ê¸°ë³¸ ì •ë³´ ì¡°íšŒ
    const report = await chatRepository.findReportById(reportId);
    if (!report) {
      return { success: false, error: "ì‹ ê³ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ì‹ ê³ ëœ ë©”ì‹œì§€ ì¡°íšŒ
    let reportedMessage = null;
    if (report.reported_message_id) {
      reportedMessage = await chatRepository.findMessageById(
        report.reported_message_id
      );
    }

    // ì‚¬ìš©ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ
    const senderKeys: Array<{ id: string; type: ChatUserType }> = [];

    // ì‹ ê³ ì ì •ë³´
    senderKeys.push({ id: report.reporter_id, type: report.reporter_type });

    // í”¼ì‹ ê³ ì ì •ë³´
    if (report.reported_user_id && report.reported_user_type) {
      senderKeys.push({
        id: report.reported_user_id,
        type: report.reported_user_type,
      });
    }

    const senderMap = await chatRepository.findSendersByIds(senderKeys);

    // ì‹ ê³ ì ì •ë³´ ë§¤í•‘
    const reporterInfo = senderMap.get(
      `${report.reporter_id}_${report.reporter_type}`
    );
    const reporter = reporterInfo
      ? {
          id: reporterInfo.id,
          type: report.reporter_type,
          name: reporterInfo.name,
          profileImageUrl: reporterInfo.profileImageUrl,
        }
      : null;

    // í”¼ì‹ ê³ ì ì •ë³´ ë§¤í•‘
    let reportedUser = null;
    if (report.reported_user_id && report.reported_user_type) {
      const reportedUserInfo = senderMap.get(
        `${report.reported_user_id}_${report.reported_user_type}`
      );
      if (reportedUserInfo) {
        reportedUser = {
          id: reportedUserInfo.id,
          type: report.reported_user_type,
          name: reportedUserInfo.name,
          profileImageUrl: reportedUserInfo.profileImageUrl,
        };
      }
    }

    const reportWithDetails: ChatReportWithDetails = {
      ...report,
      reportedMessage,
      reporter,
      reportedUser,
    };

    return { success: true, data: reportWithDetails };
  } catch (error) {
    console.error("[getReportDetailsAction] Error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ìƒì„¸ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}
</file>

<file path="index.ts">
/**
 * Chat ë„ë©”ì¸ Public API
 */

// Types
export type {
  // ê¸°ë³¸ íƒ€ì…
  ChatRoom,
  ChatRoomMember,
  ChatMessage,
  ChatBlock,
  ChatReport,
  // Insert/Update íƒ€ì…
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessageInsert,
  ChatMessageUpdate,
  ChatBlockInsert,
  ChatReportInsert,
  ChatReportUpdate,
  // ì—´ê±°í˜•
  ChatRoomType,
  ChatUserType,
  ChatMemberRole,
  ChatMessageType,
  ReportReason,
  ReportStatus,
  // ë³µí•© íƒ€ì…
  ChatUser,
  ChatMessageWithSender,
  ChatRoomWithDetails,
  ChatRoomMemberWithUser,
  ChatRoomListItem,
  // API íƒ€ì…
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
} from "./types";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export {
  createOrGetRoom,
  getRoomList,
  getRoomDetail,
  sendMessage,
  getMessages,
  deleteMessage,
  markRoomAsRead,
  inviteMembers,
  leaveRoom,
  blockUser,
  unblockUser,
  reportMessage,
} from "./service";

// Repository (ë°ì´í„° ì ‘ê·¼ - í•„ìš” ì‹œ ì§ì ‘ ì‚¬ìš©)
export * as chatRepository from "./repository";
</file>

<file path="index.ts">
/**
 * Chat ë„ë©”ì¸ Public API
 */

// Types
export type {
  // ê¸°ë³¸ íƒ€ì…
  ChatRoom,
  ChatRoomMember,
  ChatMessage,
  ChatBlock,
  ChatReport,
  // Insert/Update íƒ€ì…
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessageInsert,
  ChatMessageUpdate,
  ChatBlockInsert,
  ChatReportInsert,
  ChatReportUpdate,
  // ì—´ê±°í˜•
  ChatRoomType,
  ChatUserType,
  ChatMemberRole,
  ChatMessageType,
  ReportReason,
  ReportStatus,
  // ë³µí•© íƒ€ì…
  ChatUser,
  ChatMessageWithSender,
  ChatRoomWithDetails,
  ChatRoomMemberWithUser,
  ChatRoomListItem,
  // API íƒ€ì…
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
} from "./types";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export {
  createOrGetRoom,
  getRoomList,
  getRoomDetail,
  sendMessage,
  getMessages,
  deleteMessage,
  markRoomAsRead,
  inviteMembers,
  leaveRoom,
  blockUser,
  unblockUser,
  reportMessage,
} from "./service";

// Repository (ë°ì´í„° ì ‘ê·¼ - í•„ìš” ì‹œ ì§ì ‘ ì‚¬ìš©)
export * as chatRepository from "./repository";
</file>

<file path="index.ts">
/**
 * Chat ë„ë©”ì¸ Public API
 */

// Types
export type {
  // ê¸°ë³¸ íƒ€ì…
  ChatRoom,
  ChatRoomMember,
  ChatMessage,
  ChatBlock,
  ChatReport,
  // Insert/Update íƒ€ì…
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessageInsert,
  ChatMessageUpdate,
  ChatBlockInsert,
  ChatReportInsert,
  ChatReportUpdate,
  // ì—´ê±°í˜•
  ChatRoomType,
  ChatUserType,
  ChatMemberRole,
  ChatMessageType,
  ReportReason,
  ReportStatus,
  // ë³µí•© íƒ€ì…
  ChatUser,
  ChatMessageWithSender,
  ChatRoomWithDetails,
  ChatRoomMemberWithUser,
  ChatRoomListItem,
  // API íƒ€ì…
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
} from "./types";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export {
  createOrGetRoom,
  getRoomList,
  getRoomDetail,
  sendMessage,
  getMessages,
  deleteMessage,
  markRoomAsRead,
  inviteMembers,
  leaveRoom,
  blockUser,
  unblockUser,
  reportMessage,
} from "./service";

// Repository (ë°ì´í„° ì ‘ê·¼ - í•„ìš” ì‹œ ì§ì ‘ ì‚¬ìš©)
export * as chatRepository from "./repository";
</file>

<file path="messageGrouping.ts">
/**
 * ë©”ì‹œì§€ ê·¸ë£¹í•‘ ìœ í‹¸ë¦¬í‹°
 *
 * ì—°ì†ëœ ë©”ì‹œì§€ë¥¼ ê·¸ë£¹í•‘í•˜ê³  ë‚ ì§œ êµ¬ë¶„ì„ ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 */

import { isSameDay, differenceInSeconds, format } from "date-fns";
import { ko } from "date-fns/locale";
import type {
  ChatMessageWithSender,
  ChatMessageWithGrouping,
  MessageGroupingInfo,
} from "./types";

/** ê·¸ë£¹í•‘ ì‹œê°„ ì„ê³„ê°’ (ì´ˆ) - 1ë¶„ */
const GROUPING_THRESHOLD_SECONDS = 60;

/**
 * ë‘ ë©”ì‹œì§€ê°€ ê°™ì€ ë‚ ì¸ì§€ í™•ì¸
 */
export function isSameMessageDay(date1: string, date2: string): boolean {
  return isSameDay(new Date(date1), new Date(date2));
}

/**
 * ë‘ ë©”ì‹œì§€ê°€ ê·¸ë£¹í•‘ ì‹œê°„ ì„ê³„ê°’ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
 */
export function isWithinGroupingThreshold(
  date1: string,
  date2: string
): boolean {
  const diff = Math.abs(
    differenceInSeconds(new Date(date1), new Date(date2))
  );
  return diff <= GROUPING_THRESHOLD_SECONDS;
}

/**
 * ë‚ ì§œ êµ¬ë¶„ì„ ìš© í¬ë§· (ì˜ˆ: "2024ë…„ 1ì›” 15ì¼ ì›”ìš”ì¼")
 */
export function formatDateDivider(dateStr: string): string {
  return format(new Date(dateStr), "yyyyë…„ Mì›” dì¼ EEEE", { locale: ko });
}

/**
 * ë©”ì‹œì§€ ì‹œê°„ í¬ë§· (ì˜ˆ: "ì˜¤í›„ 3:45")
 */
export function formatMessageTime(dateStr: string): string {
  return format(new Date(dateStr), "a h:mm", { locale: ko });
}

/**
 * ë©”ì‹œì§€ ë°°ì—´ì— ê·¸ë£¹í•‘ ì •ë³´ë¥¼ ì¶”ê°€
 *
 * ê·¸ë£¹í•‘ ê·œì¹™:
 * - ê°™ì€ ë°œì‹ ì + 1ë¶„ ì´ë‚´ = ê·¸ë£¹í•‘
 * - ì‹œìŠ¤í…œ ë©”ì‹œì§€ = ê·¸ë£¹í•‘ ì¤‘ë‹¨
 * - ë‹µì¥ ë©”ì‹œì§€ = ê·¸ë£¹í•‘ ì¤‘ë‹¨
 * - ë‚ ì§œ ë³€ê²½ = ê·¸ë£¹í•‘ ì¤‘ë‹¨ + ë‚ ì§œ êµ¬ë¶„ì„ 
 *
 * @param messages ë©”ì‹œì§€ ë°°ì—´ (ì‹œê°„ìˆœ ì •ë ¬ë¨)
 * @returns ê·¸ë£¹í•‘ ì •ë³´ê°€ í¬í•¨ëœ ë©”ì‹œì§€ ë°°ì—´
 */
export function processMessagesWithGrouping(
  messages: ChatMessageWithSender[]
): ChatMessageWithGrouping[] {
  if (messages.length === 0) return [];

  const result: ChatMessageWithGrouping[] = [];

  for (let i = 0; i < messages.length; i++) {
    const current = messages[i];
    const prev = i > 0 ? messages[i - 1] : null;
    const next = i < messages.length - 1 ? messages[i + 1] : null;

    // ì´ì „ ë©”ì‹œì§€ì™€ ë‚ ì§œê°€ ë‹¤ë¥¸ì§€ í™•ì¸
    const showDateDivider =
      !prev || !isSameMessageDay(prev.created_at, current.created_at);
    const dateDividerText = showDateDivider
      ? formatDateDivider(current.created_at)
      : undefined;

    // í˜„ì¬ ë©”ì‹œì§€ê°€ ì´ì „ ë©”ì‹œì§€ì™€ ê·¸ë£¹í•‘ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
    const canGroupWithPrev =
      prev &&
      !showDateDivider && // ë‚ ì§œ ë³€ê²½ ì‹œ ê·¸ë£¹í•‘ ì•ˆ í•¨
      current.message_type !== "system" &&
      prev.message_type !== "system" &&
      current.sender_id === prev.sender_id &&
      isWithinGroupingThreshold(prev.created_at, current.created_at) &&
      !current.reply_to_id; // ë‹µì¥ ë©”ì‹œì§€ëŠ” ê·¸ë£¹í•‘ ì•ˆ í•¨

    // ë‹¤ìŒ ë©”ì‹œì§€ê°€ í˜„ì¬ ë©”ì‹œì§€ì™€ ê·¸ë£¹í•‘ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
    const nextIsGrouped =
      next &&
      isSameMessageDay(current.created_at, next.created_at) &&
      next.message_type !== "system" &&
      current.message_type !== "system" &&
      current.sender_id === next.sender_id &&
      isWithinGroupingThreshold(current.created_at, next.created_at) &&
      !next.reply_to_id;

    const grouping: MessageGroupingInfo = {
      // ê·¸ë£¹ ì²« ë©”ì‹œì§€ì—ë§Œ ì´ë¦„ í‘œì‹œ (ì´ì „ê³¼ ê·¸ë£¹í•‘ ì•ˆ ë¨)
      showName: !canGroupWithPrev,
      // ê·¸ë£¹ ë§ˆì§€ë§‰ ë©”ì‹œì§€ì—ë§Œ ì‹œê°„ í‘œì‹œ (ë‹¤ìŒê³¼ ê·¸ë£¹í•‘ ì•ˆ ë¨)
      showTime: !nextIsGrouped,
      // ì´ì „ ë©”ì‹œì§€ì™€ ê·¸ë£¹í•‘ë¨ (ê°„ê²© ì¶•ì†Œìš©)
      isGrouped: !!canGroupWithPrev,
      showDateDivider,
      dateDividerText,
    };

    result.push({
      ...current,
      grouping,
    });
  }

  return result;
}
</file>

<file path="repository.ts">
/**
 * Chat ë„ë©”ì¸ Repository
 * ì±„íŒ… ë°ì´í„° ì ‘ê·¼ ë ˆì´ì–´
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import type {
  ChatRoom,
  ChatRoomInsert,
  ChatRoomUpdate,
  ChatRoomMember,
  ChatRoomMemberInsert,
  ChatRoomMemberUpdate,
  ChatMessage,
  ChatMessageInsert,
  ChatBlock,
  ChatBlockInsert,
  ChatReport,
  ChatReportInsert,
  ChatReportUpdate,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatUserType,
  SearchMessagesOptions,
  MessageReaction,
  ReactionEmoji,
  PinnedMessage,
  PinnedMessageInsert,
} from "./types";

// ============================================
// ì»¬ëŸ¼ ì •ì˜
// ============================================

const CHAT_ROOM_COLUMNS = `
  id,
  tenant_id,
  type,
  name,
  created_by,
  created_by_type,
  is_active,
  announcement,
  announcement_by,
  announcement_by_type,
  announcement_at,
  created_at,
  updated_at
` as const;

const CHAT_MEMBER_COLUMNS = `
  id,
  room_id,
  user_id,
  user_type,
  role,
  last_read_at,
  is_muted,
  left_at,
  created_at,
  updated_at
` as const;

const CHAT_MESSAGE_COLUMNS = `
  id,
  room_id,
  sender_id,
  sender_type,
  message_type,
  content,
  reply_to_id,
  is_deleted,
  deleted_at,
  created_at,
  updated_at
` as const;

const CHAT_REACTION_COLUMNS = `
  id,
  message_id,
  user_id,
  user_type,
  emoji,
  created_at
` as const;

// ============================================
// ì±„íŒ…ë°© Repository
// ============================================

/**
 * ì±„íŒ…ë°© IDë¡œ ì¡°íšŒ
 */
export async function findRoomById(
  roomId: string
): Promise<ChatRoom | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .eq("id", roomId)
    .eq("is_active", true)
    .maybeSingle();

  if (error && error.code !== "PGRST116") {
    throw error;
  }

  return data as ChatRoom | null;
}

/**
 * ì‚¬ìš©ìì˜ ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ (ìµœì‹ ìˆœ)
 */
export async function findRoomsByUser(
  userId: string,
  userType: ChatUserType,
  options: GetRoomsOptions = {}
): Promise<ChatRoom[]> {
  const { limit = 20, offset = 0 } = options;
  const supabase = await createSupabaseServerClient();

  // ë©¤ë²„ë¡œ ì°¸ì—¬ ì¤‘ì¸ ë°© ID ëª©ë¡ ì¡°íšŒ
  const { data: memberData, error: memberError } = await supabase
    .from("chat_room_members")
    .select("room_id")
    .eq("user_id", userId)
    .eq("user_type", userType)
    .is("left_at", null);

  if (memberError) throw memberError;
  if (!memberData || memberData.length === 0) return [];

  const roomIds = memberData.map((m) => m.room_id);

  // ì±„íŒ…ë°© ì •ë³´ ì¡°íšŒ
  const { data, error } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .in("id", roomIds)
    .eq("is_active", true)
    .order("updated_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;

  return (data as ChatRoom[]) ?? [];
}

/**
 * ë‘ ì‚¬ìš©ì ê°„ì˜ 1:1 ì±„íŒ…ë°© ì°¾ê¸°
 */
export async function findDirectRoom(
  user1Id: string,
  user1Type: ChatUserType,
  user2Id: string,
  user2Type: ChatUserType
): Promise<ChatRoom | null> {
  const supabase = await createSupabaseServerClient();

  // user1ì´ ì†í•œ direct ë°© ì¡°íšŒ
  const { data: user1Rooms, error: error1 } = await supabase
    .from("chat_room_members")
    .select("room_id")
    .eq("user_id", user1Id)
    .eq("user_type", user1Type)
    .is("left_at", null);

  if (error1) throw error1;
  if (!user1Rooms || user1Rooms.length === 0) return null;

  const roomIds = user1Rooms.map((r) => r.room_id);

  // user2ë„ ì†í•œ direct ë°© ì°¾ê¸°
  const { data: matchingRoom, error: error2 } = await supabase
    .from("chat_rooms")
    .select(CHAT_ROOM_COLUMNS)
    .in("id", roomIds)
    .eq("type", "direct")
    .eq("is_active", true)
    .maybeSingle();

  if (error2 && error2.code !== "PGRST116") throw error2;
  if (!matchingRoom) return null;

  // user2ê°€ í•´ë‹¹ ë°©ì˜ ë©¤ë²„ì¸ì§€ í™•ì¸
  const { data: user2Member, error: error3 } = await supabase
    .from("chat_room_members")
    .select("id")
    .eq("room_id", matchingRoom.id)
    .eq("user_id", user2Id)
    .eq("user_type", user2Type)
    .is("left_at", null)
    .maybeSingle();

  if (error3 && error3.code !== "PGRST116") throw error3;

  return user2Member ? (matchingRoom as ChatRoom) : null;
}

/**
 * ì±„íŒ…ë°© ìƒì„±
 */
export async function insertRoom(
  input: ChatRoomInsert
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .insert(input)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}

/**
 * ì±„íŒ…ë°© ìˆ˜ì •
 */
export async function updateRoom(
  roomId: string,
  input: ChatRoomUpdate
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_rooms")
    .update(input)
    .eq("id", roomId)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}

// ============================================
// ì±„íŒ…ë°© ë©¤ë²„ Repository
// ============================================

/**
 * ì±„íŒ…ë°©ì˜ ë©¤ë²„ ëª©ë¡ ì¡°íšŒ
 * RLS ì •ì±… ìš°íšŒë¥¼ ìœ„í•´ Admin Client ì‚¬ìš©
 * (ê°™ì€ ë°©ì˜ ë‹¤ë¥¸ ë©¤ë²„ ì¡°íšŒ í—ˆìš©)
 */
export async function findMembersByRoom(
  roomId: string
): Promise<ChatRoomMember[]> {
  // Admin client ì‚¬ìš© (RLS ìš°íšŒ - ê°™ì€ ë°© ë©¤ë²„ ì¡°íšŒ í—ˆìš©)
  const supabase = createSupabaseAdminClient();

  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .eq("room_id", roomId)
    .is("left_at", null)
    .order("created_at", { ascending: true });

  if (error) throw error;

  return (data as ChatRoomMember[]) ?? [];
}

/**
 * ì—¬ëŸ¬ ì±„íŒ…ë°©ì˜ ë©¤ë²„ ëª©ë¡ ë°°ì¹˜ ì¡°íšŒ (N+1 ìµœì í™”)
 */
export async function findMembersByRoomIds(
  roomIds: string[]
): Promise<Map<string, ChatRoomMember[]>> {
  if (roomIds.length === 0) return new Map();

  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .in("room_id", roomIds)
    .is("left_at", null)
    .order("created_at", { ascending: true });

  if (error) throw error;

  // room_idë³„ë¡œ ê·¸ë£¹í•‘
  const result = new Map<string, ChatRoomMember[]>();
  for (const member of (data as ChatRoomMember[]) ?? []) {
    const existing = result.get(member.room_id) ?? [];
    existing.push(member);
    result.set(member.room_id, existing);
  }

  return result;
}

/**
 * íŠ¹ì • ë©¤ë²„ ì¡°íšŒ
 */
export async function findMember(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatRoomMember | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .select(CHAT_MEMBER_COLUMNS)
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType)
    .is("left_at", null)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatRoomMember | null;
}

/**
 * ë©¤ë²„ ì¶”ê°€
 */
export async function insertMember(
  input: ChatRoomMemberInsert
): Promise<ChatRoomMember> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .insert(input)
    .select(CHAT_MEMBER_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoomMember;
}

/**
 * ë©¤ë²„ ì •ë³´ ìˆ˜ì •
 */
export async function updateMember(
  roomId: string,
  userId: string,
  userType: ChatUserType,
  input: ChatRoomMemberUpdate
): Promise<ChatRoomMember> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_room_members")
    .update(input)
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType)
    .select(CHAT_MEMBER_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoomMember;
}

/**
 * ì½ìŒ ì²˜ë¦¬ (last_read_at ì—…ë°ì´íŠ¸)
 */
export async function markAsRead(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_room_members")
    .update({ last_read_at: new Date().toISOString() })
    .eq("room_id", roomId)
    .eq("user_id", userId)
    .eq("user_type", userType);

  if (error) throw error;
}

// ============================================
// ë©”ì‹œì§€ Repository
// ============================================

/**
 * ì±„íŒ…ë°©ì˜ ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (í˜ì´ì§€ë„¤ì´ì…˜)
 */
export async function findMessagesByRoom(
  options: GetMessagesOptions
): Promise<ChatMessage[]> {
  const { roomId, limit = 50, before } = options;
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS)
    .eq("room_id", roomId)
    .eq("is_deleted", false)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (before) {
    query = query.lt("created_at", before);
  }

  const { data, error } = await query;

  if (error) throw error;

  // ì˜¤ë˜ëœ ìˆœìœ¼ë¡œ ë°˜í™˜ (UIì—ì„œ ì—­ìˆœ í‘œì‹œ)
  return ((data as ChatMessage[]) ?? []).reverse();
}

/**
 * ì—¬ëŸ¬ ì±„íŒ…ë°©ì˜ ë§ˆì§€ë§‰ ë©”ì‹œì§€ ë°°ì¹˜ ì¡°íšŒ (N+1 ìµœì í™”)
 * SQL: DISTINCT ON (room_id) ORDER BY created_at DESC
 */
export async function findLastMessagesByRoomIds(
  roomIds: string[]
): Promise<Map<string, ChatMessage>> {
  if (roomIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // SupabaseëŠ” DISTINCT ONì„ ì§ì ‘ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ
  // ê° roomì˜ ìµœì‹  ë©”ì‹œì§€ë¥¼ ìœ„í•´ RPCë‚˜ ì„œë¸Œì¿¼ë¦¬ ëŒ€ì‹ 
  // ì „ì²´ ì¡°íšŒ í›„ JSì—ì„œ ì²˜ë¦¬ (room ìˆ˜ê°€ ì ì„ ë•Œ íš¨ìœ¨ì )
  const { data, error } = await supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS)
    .in("room_id", roomIds)
    .eq("is_deleted", false)
    .order("created_at", { ascending: false });

  if (error) throw error;

  // room_idë³„ ì²« ë²ˆì§¸(ìµœì‹ ) ë©”ì‹œì§€ë§Œ ì¶”ì¶œ
  const result = new Map<string, ChatMessage>();
  for (const message of (data as ChatMessage[]) ?? []) {
    if (!result.has(message.room_id)) {
      result.set(message.room_id, message);
    }
  }

  return result;
}

/**
 * ì—¬ëŸ¬ ì±„íŒ…ë°©ì˜ ì•ˆ ì½ì€ ë©”ì‹œì§€ ìˆ˜ ë°°ì¹˜ ì¡°íšŒ (N+1 ìµœì í™”)
 */
export async function countUnreadByRoomIds(
  roomIds: string[],
  userId: string,
  membershipMap: Map<string, { last_read_at: string }>
): Promise<Map<string, number>> {
  if (roomIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // ê° ë°©ì˜ last_read_at ì´í›„ ë©”ì‹œì§€ ìˆ˜ë¥¼ ê³„ì‚°
  // íš¨ìœ¨ì„±ì„ ìœ„í•´ í•œ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë©”ì‹œì§€ ì¡°íšŒ í›„ JSì—ì„œ ì¹´ìš´íŠ¸
  const { data, error } = await supabase
    .from("chat_messages")
    .select("room_id, sender_id, created_at")
    .in("room_id", roomIds)
    .neq("sender_id", userId)
    .eq("is_deleted", false);

  if (error) throw error;

  const result = new Map<string, number>();
  for (const roomId of roomIds) {
    result.set(roomId, 0);
  }

  for (const msg of data ?? []) {
    const membership = membershipMap.get(msg.room_id);
    if (membership && msg.created_at > membership.last_read_at) {
      result.set(msg.room_id, (result.get(msg.room_id) ?? 0) + 1);
    }
  }

  return result;
}

/**
 * ë©”ì‹œì§€ ìƒì„±
 */
export async function insertMessage(
  input: ChatMessageInsert
): Promise<ChatMessage> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .insert(input)
    .select(CHAT_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  // ì±„íŒ…ë°© updated_at ê°±ì‹ 
  await supabase
    .from("chat_rooms")
    .update({ updated_at: new Date().toISOString() })
    .eq("id", input.room_id);

  return data as ChatMessage;
}

/**
 * ë©”ì‹œì§€ ì‚­ì œ (soft delete)
 */
export async function deleteMessage(
  messageId: string,
  senderId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_messages")
    .update({
      is_deleted: true,
      deleted_at: new Date().toISOString(),
    })
    .eq("id", messageId)
    .eq("sender_id", senderId);

  if (error) throw error;
}

/**
 * ë°œì‹ ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ (N+1 ì¿¼ë¦¬ ìµœì í™”)
 * sender_id + sender_type ì¡°í•©ìœ¼ë¡œ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function findSendersByIds(
  senderKeys: Array<{ id: string; type: ChatUserType }>
): Promise<Map<string, { id: string; name: string; profileImageUrl?: string | null }>> {
  if (senderKeys.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();

  // ì¤‘ë³µ ì œê±°
  const uniqueKeys = Array.from(
    new Map(senderKeys.map((k) => [`${k.id}_${k.type}`, k])).values()
  );

  // studentì™€ admin ë¶„ë¦¬
  const studentIds = uniqueKeys.filter((k) => k.type === "student").map((k) => k.id);
  const adminIds = uniqueKeys.filter((k) => k.type === "admin").map((k) => k.id);

  const result = new Map<string, { id: string; name: string; profileImageUrl?: string | null }>();

  // í•™ìƒ ì •ë³´ ë°°ì¹˜ ì¡°íšŒ
  if (studentIds.length > 0) {
    const { data: students } = await supabase
      .from("students")
      .select("id, name")
      .in("id", studentIds);

    // í”„ë¡œí•„ ì´ë¯¸ì§€ ë°°ì¹˜ ì¡°íšŒ
    const { data: profiles } = await supabase
      .from("student_profiles")
      .select("id, profile_image_url")
      .in("id", studentIds);

    const profileMap = new Map(profiles?.map((p) => [p.id, p.profile_image_url]) ?? []);

    students?.forEach((s) => {
      result.set(`${s.id}_student`, {
        id: s.id,
        name: s.name,
        profileImageUrl: profileMap.get(s.id) ?? null,
      });
    });
  }

  // ê´€ë¦¬ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ
  if (adminIds.length > 0) {
    const { data: admins } = await supabase
      .from("admin_users")
      .select("id, name")
      .in("id", adminIds);

    admins?.forEach((a) => {
      result.set(`${a.id}_admin`, {
        id: a.id,
        name: a.name ?? "ê´€ë¦¬ì",
        profileImageUrl: null,
      });
    });
  }

  return result;
}

/**
 * ì•ˆ ì½ì€ ë©”ì‹œì§€ ìˆ˜ ê³„ì‚°
 */
export async function countUnreadMessages(
  roomId: string,
  userId: string,
  userType: ChatUserType,
  lastReadAt: string
): Promise<number> {
  const supabase = await createSupabaseServerClient();

  const { count, error } = await supabase
    .from("chat_messages")
    .select("*", { count: "exact", head: true })
    .eq("room_id", roomId)
    .neq("sender_id", userId)
    .eq("is_deleted", false)
    .gt("created_at", lastReadAt);

  if (error) throw error;

  return count ?? 0;
}

// ============================================
// ì°¨ë‹¨ Repository
// ============================================

/**
 * ì°¨ë‹¨ ëª©ë¡ ì¡°íšŒ
 */
export async function findBlocksByUser(
  userId: string,
  userType: ChatUserType
): Promise<ChatBlock[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .select("*")
    .eq("blocker_id", userId)
    .eq("blocker_type", userType);

  if (error) throw error;

  return (data as ChatBlock[]) ?? [];
}

/**
 * ì°¨ë‹¨ ì—¬ë¶€ í™•ì¸
 */
export async function isBlocked(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .select("id")
    .eq("blocker_id", blockerId)
    .eq("blocker_type", blockerType)
    .eq("blocked_id", blockedId)
    .eq("blocked_type", blockedType)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * ì°¨ë‹¨ ì¶”ê°€
 */
export async function insertBlock(
  input: ChatBlockInsert
): Promise<ChatBlock> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_blocks")
    .insert(input)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatBlock;
}

/**
 * ì°¨ë‹¨ í•´ì œ
 */
export async function deleteBlock(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_blocks")
    .delete()
    .eq("blocker_id", blockerId)
    .eq("blocker_type", blockerType)
    .eq("blocked_id", blockedId)
    .eq("blocked_type", blockedType);

  if (error) throw error;
}

// ============================================
// ì‹ ê³  Repository
// ============================================

/**
 * ì‹ ê³  ìƒì„±
 */
export async function insertReport(
  input: ChatReportInsert
): Promise<ChatReport> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .insert(input)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatReport;
}

/**
 * ëŒ€ê¸° ì¤‘ì¸ ì‹ ê³  ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ììš©)
 */
export async function findPendingReports(
  limit = 50
): Promise<ChatReport[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .select("*")
    .eq("status", "pending")
    .order("created_at", { ascending: true })
    .limit(limit);

  if (error) throw error;

  return (data as ChatReport[]) ?? [];
}

/**
 * ì‹ ê³  ìƒíƒœ ì—…ë°ì´íŠ¸ (ê´€ë¦¬ììš©)
 */
export async function updateReport(
  reportId: string,
  input: ChatReportUpdate
): Promise<ChatReport> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .update(input)
    .eq("id", reportId)
    .select("*")
    .single();

  if (error) throw error;

  return data as ChatReport;
}

/**
 * ëª¨ë“  ì‹ ê³  ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ììš©, í•„í„° ì§€ì›)
 */
export async function findAllReports(
  filters?: { status?: string; reason?: string },
  limit = 100
): Promise<ChatReport[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("chat_reports")
    .select("*")
    .order("created_at", { ascending: false })
    .limit(limit);

  // ìƒíƒœ í•„í„°
  if (filters?.status && filters.status !== "all") {
    query = query.eq("status", filters.status);
  }

  // ì‚¬ìœ  í•„í„°
  if (filters?.reason && filters.reason !== "all") {
    query = query.eq("reason", filters.reason);
  }

  const { data, error } = await query;

  if (error) throw error;

  return (data as ChatReport[]) ?? [];
}

/**
 * ì‹ ê³  IDë¡œ ì¡°íšŒ
 */
export async function findReportById(
  reportId: string
): Promise<ChatReport | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_reports")
    .select("*")
    .eq("id", reportId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatReport | null;
}

/**
 * ë©”ì‹œì§€ IDë¡œ ë‹¨ì¼ ë©”ì‹œì§€ ì¡°íšŒ (ì‹ ê³ ëœ ë©”ì‹œì§€ ìƒì„¸ìš©)
 */
export async function findMessageById(
  messageId: string
): Promise<ChatMessage | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS)
    .eq("id", messageId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return data as ChatMessage | null;
}

// ============================================
// ë©”ì‹œì§€ í¸ì§‘ Repository
// ============================================

/**
 * ë©”ì‹œì§€ ë‚´ìš© ìˆ˜ì •
 */
export async function updateMessageContent(
  messageId: string,
  content: string
): Promise<ChatMessage> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_messages")
    .update({ content })
    .eq("id", messageId)
    .select(CHAT_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatMessage;
}

// ============================================
// ë©”ì‹œì§€ ê²€ìƒ‰ Repository
// ============================================

/**
 * ì±„íŒ…ë°© ë‚´ ë©”ì‹œì§€ ê²€ìƒ‰ (ILIKE ê¸°ë°˜)
 */
export async function searchMessagesByRoom(
  options: SearchMessagesOptions
): Promise<{ messages: ChatMessage[]; total: number }> {
  const { roomId, query, limit = 20, offset = 0 } = options;
  const supabase = await createSupabaseServerClient();

  // ê²€ìƒ‰ì–´ ì´ìŠ¤ì¼€ì´í”„ (SQL ì™€ì¼ë“œì¹´ë“œ ì²˜ë¦¬)
  const escapedQuery = query.replace(/[%_]/g, "\\$&");

  const { data, error, count } = await supabase
    .from("chat_messages")
    .select(CHAT_MESSAGE_COLUMNS, { count: "exact" })
    .eq("room_id", roomId)
    .eq("is_deleted", false)
    .ilike("content", `%${escapedQuery}%`)
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;

  return {
    messages: (data as ChatMessage[]) ?? [],
    total: count ?? 0,
  };
}

// ============================================
// ì½ìŒ í‘œì‹œ Repository
// ============================================

/**
 * ì±„íŒ…ë°©ì˜ í™œì„± ë©¤ë²„ ëª©ë¡ê³¼ last_read_at ì¡°íšŒ (ì½ìŒ ìƒíƒœ ê³„ì‚°ìš©)
 */
export async function findActiveMembersWithReadStatus(
  roomId: string
): Promise<Array<{ user_id: string; user_type: ChatUserType; last_read_at: string }>> {
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_room_members")
    .select("user_id, user_type, last_read_at")
    .eq("room_id", roomId)
    .is("left_at", null);

  if (error) throw error;

  return (data ?? []) as Array<{ user_id: string; user_type: ChatUserType; last_read_at: string }>;
}

/**
 * ë©”ì‹œì§€ ëª©ë¡ê³¼ ê° ë©”ì‹œì§€ì˜ ì½ìŒ ìƒíƒœë¥¼ í•¨ê»˜ ì¡°íšŒ
 * ë³¸ì¸ ë©”ì‹œì§€ì— ëŒ€í•´ì„œë§Œ ì•ˆ ì½ì€ ë©¤ë²„ ìˆ˜ ê³„ì‚°
 */
export async function findMessagesWithReadCounts(
  options: GetMessagesOptions,
  currentUserId: string
): Promise<{ messages: ChatMessage[]; readCounts: Record<string, number> }> {
  const messages = await findMessagesByRoom(options);

  // ë°© ë©¤ë²„ë“¤ì˜ last_read_at ì¡°íšŒ
  const members = await findActiveMembersWithReadStatus(options.roomId);

  const readCounts: Record<string, number> = {};

  // ê° ë©”ì‹œì§€ì— ëŒ€í•´ ì•ˆ ì½ì€ ë©¤ë²„ ìˆ˜ ê³„ì‚° (ë³¸ì¸ ë©”ì‹œì§€ë§Œ)
  for (const msg of messages) {
    if (msg.sender_id === currentUserId) {
      // ë©”ì‹œì§€ ì‹œê°„ ì´í›„ì— ì½ì§€ ì•Šì€ ë©¤ë²„ ìˆ˜ (ë°œì‹ ì ì œì™¸)
      const unreadCount = members.filter(
        (m) =>
          m.user_id !== msg.sender_id &&
          new Date(m.last_read_at) < new Date(msg.created_at)
      ).length;

      readCounts[msg.id] = unreadCount;
    } else {
      readCounts[msg.id] = 0;
    }
  }

  return { messages, readCounts };
}

// ============================================
// ë¦¬ì•¡ì…˜ Repository
// ============================================

/**
 * ë¦¬ì•¡ì…˜ ì¶”ê°€
 */
export async function insertReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase.from("chat_message_reactions").insert({
    message_id: input.messageId,
    user_id: input.userId,
    user_type: input.userType,
    emoji: input.emoji,
  });

  if (error) throw error;
}

/**
 * ë¦¬ì•¡ì…˜ ì‚­ì œ
 */
export async function deleteReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_message_reactions")
    .delete()
    .eq("message_id", input.messageId)
    .eq("user_id", input.userId)
    .eq("user_type", input.userType)
    .eq("emoji", input.emoji);

  if (error) throw error;
}

/**
 * ë¦¬ì•¡ì…˜ ì¡´ì¬ í™•ì¸ (í† ê¸€ìš©)
 */
export async function hasReaction(input: {
  messageId: string;
  userId: string;
  userType: ChatUserType;
  emoji: ReactionEmoji;
}): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_message_reactions")
    .select("id")
    .eq("message_id", input.messageId)
    .eq("user_id", input.userId)
    .eq("user_type", input.userType)
    .eq("emoji", input.emoji)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * ë©”ì‹œì§€ë³„ ë¦¬ì•¡ì…˜ ì¡°íšŒ (ë°°ì¹˜)
 * N+1 ì¿¼ë¦¬ ìµœì í™”ë¥¼ ìœ„í•´ ì—¬ëŸ¬ ë©”ì‹œì§€ì˜ ë¦¬ì•¡ì…˜ì„ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function findReactionsByMessageIds(
  messageIds: string[]
): Promise<Map<string, MessageReaction[]>> {
  if (messageIds.length === 0) return new Map();

  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error("Admin client initialization failed");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from("chat_message_reactions")
    .select(CHAT_REACTION_COLUMNS)
    .in("message_id", messageIds)
    .order("created_at", { ascending: true });

  if (error) throw error;

  // message_idë³„ë¡œ ê·¸ë£¹í•‘
  const result = new Map<string, MessageReaction[]>();
  for (const reaction of (data as MessageReaction[]) ?? []) {
    const existing = result.get(reaction.message_id) ?? [];
    existing.push(reaction);
    result.set(reaction.message_id, existing);
  }

  return result;
}

// ============================================
// ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ Repository
// ============================================

/**
 * ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ ë°°ì¹˜ ì¡°íšŒ (N+1 ìµœì í™”)
 * ì—¬ëŸ¬ ë©”ì‹œì§€ì˜ ì›ë³¸ ë©”ì‹œì§€ë¥¼ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function findReplyTargetsByIds(
  replyToIds: string[]
): Promise<Map<string, { id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>> {
  if (replyToIds.length === 0) return new Map();

  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("chat_messages")
    .select("id, content, sender_id, sender_type, is_deleted")
    .in("id", replyToIds);

  if (error) throw error;

  const result = new Map<string, { id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>();
  for (const msg of (data ?? []) as Array<{ id: string; content: string; sender_id: string; sender_type: ChatUserType; is_deleted: boolean }>) {
    result.set(msg.id, msg);
  }
  return result;
}

// ============================================
// ê³ ì • ë©”ì‹œì§€ Repository
// ============================================

const PINNED_MESSAGE_COLUMNS = `
  id,
  room_id,
  message_id,
  pinned_by,
  pinned_by_type,
  pin_order,
  created_at
` as const;

/**
 * ì±„íŒ…ë°©ì˜ ê³ ì • ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (pin_order ìˆœ)
 */
export async function findPinnedMessagesByRoom(
  roomId: string
): Promise<PinnedMessage[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .select(PINNED_MESSAGE_COLUMNS)
    .eq("room_id", roomId)
    .order("pin_order", { ascending: true });

  if (error) throw error;

  return (data as PinnedMessage[]) ?? [];
}

/**
 * ê³ ì • ë©”ì‹œì§€ ì¶”ê°€
 */
export async function insertPinnedMessage(
  input: PinnedMessageInsert
): Promise<PinnedMessage> {
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ì±„íŒ…ë°©ì˜ ìµœëŒ€ pin_order ì¡°íšŒ
  const { data: existing } = await supabase
    .from("chat_pinned_messages")
    .select("pin_order")
    .eq("room_id", input.room_id)
    .order("pin_order", { ascending: false })
    .limit(1)
    .maybeSingle();

  const nextOrder = existing ? existing.pin_order + 1 : 0;

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .insert({
      ...input,
      pin_order: input.pin_order ?? nextOrder,
    })
    .select(PINNED_MESSAGE_COLUMNS)
    .single();

  if (error) throw error;

  return data as PinnedMessage;
}

/**
 * ê³ ì • ë©”ì‹œì§€ ì‚­ì œ
 */
export async function deletePinnedMessage(
  roomId: string,
  messageId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("chat_pinned_messages")
    .delete()
    .eq("room_id", roomId)
    .eq("message_id", messageId);

  if (error) throw error;
}

/**
 * ë©”ì‹œì§€ê°€ ê³ ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
 */
export async function isPinnedMessage(
  roomId: string,
  messageId: string
): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("chat_pinned_messages")
    .select("id")
    .eq("room_id", roomId)
    .eq("message_id", messageId)
    .maybeSingle();

  if (error && error.code !== "PGRST116") throw error;

  return !!data;
}

/**
 * ì±„íŒ…ë°©ì˜ ê³ ì • ë©”ì‹œì§€ ê°œìˆ˜ ì¡°íšŒ
 */
export async function countPinnedMessages(
  roomId: string
): Promise<number> {
  const supabase = await createSupabaseServerClient();

  const { count, error } = await supabase
    .from("chat_pinned_messages")
    .select("*", { count: "exact", head: true })
    .eq("room_id", roomId);

  if (error) throw error;

  return count ?? 0;
}

// ============================================
// ê³µì§€ Repository
// ============================================

/**
 * ì±„íŒ…ë°© ê³µì§€ ì„¤ì •
 * contentê°€ nullì´ë©´ ê³µì§€ ì‚­ì œ
 */
export async function setRoomAnnouncement(
  roomId: string,
  userId: string | null,
  userType: ChatUserType | null,
  content: string | null
): Promise<ChatRoom> {
  const supabase = await createSupabaseServerClient();

  const updateData: ChatRoomUpdate = content
    ? {
        announcement: content,
        announcement_by: userId,
        announcement_by_type: userType,
        announcement_at: new Date().toISOString(),
      }
    : {
        announcement: null,
        announcement_by: null,
        announcement_by_type: null,
        announcement_at: null,
      };

  const { data, error } = await supabase
    .from("chat_rooms")
    .update(updateData)
    .eq("id", roomId)
    .select(CHAT_ROOM_COLUMNS)
    .single();

  if (error) throw error;

  return data as ChatRoom;
}
</file>

<file path="service.ts">
/**
 * Chat ë„ë©”ì¸ Service
 * ì±„íŒ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
 */

import * as repository from "./repository";
import type {
  ChatRoom,
  ChatRoomMemberWithUser,
  ChatMessage,
  ChatRoomListItem,
  ChatMessageWithSender,
  ChatUser,
  ChatUserType,
  ChatRoomType,
  CreateChatRoomRequest,
  SendMessageRequest,
  GetMessagesOptions,
  GetRoomsOptions,
  ChatActionResult,
  PaginatedResult,
  SearchMessagesOptions,
  SearchMessagesResult,
  MessagesWithReadStatusResult,
  ReactionToggleInput,
  ReactionSummary,
  MessageReaction,
  PinMessageInput,
  PinnedMessageWithContent,
  AnnouncementInfo,
  SetAnnouncementInput,
} from "./types";

// ìµœëŒ€ ë©”ì‹œì§€ ê¸¸ì´
const MAX_MESSAGE_LENGTH = 1000;

// ============================================
// ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ í—¬í¼
// ============================================

/**
 * ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ (student ë˜ëŠ” admin)
 */
async function getUserInfo(
  userId: string,
  userType: ChatUserType
): Promise<ChatUser | null> {
  const { createSupabaseServerClient } = await import("@/lib/supabase/server");
  const supabase = await createSupabaseServerClient();

  if (userType === "student") {
    const { data } = await supabase
      .from("students")
      .select("id, name")
      .eq("id", userId)
      .maybeSingle();

    if (!data) return null;

    // í”„ë¡œí•„ ì´ë¯¸ì§€ ì¡°íšŒ
    const { data: profile } = await supabase
      .from("student_profiles")
      .select("profile_image_url")
      .eq("id", userId)
      .maybeSingle();

    return {
      id: data.id,
      type: "student",
      name: data.name,
      profileImageUrl: profile?.profile_image_url ?? null,
    };
  } else {
    // admin (admin_users í…Œì´ë¸”ì—ì„œ ì¡°íšŒ)
    const { data } = await supabase
      .from("admin_users")
      .select("id")
      .eq("id", userId)
      .maybeSingle();

    if (!data) return null;

    // auth.usersì—ì„œ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
    // ì°¸ê³ : admin ì´ë¦„ì€ user_metadataì—ì„œ ê°€ì ¸ì™€ì•¼ í•  ìˆ˜ ìˆìŒ
    return {
      id: data.id,
      type: "admin",
      name: "ê´€ë¦¬ì", // TODO: ì‹¤ì œ ì´ë¦„ ì¡°íšŒ ë¡œì§ ì¶”ê°€
      profileImageUrl: null,
    };
  }
}

// ============================================
// ì±„íŒ…ë°© ì„œë¹„ìŠ¤
// ============================================

/**
 * ì±„íŒ…ë°© ìƒì„± ë˜ëŠ” ê¸°ì¡´ ë°© ë°˜í™˜ (1:1ì˜ ê²½ìš°)
 */
export async function createOrGetRoom(
  tenantId: string,
  creatorId: string,
  creatorType: ChatUserType,
  request: CreateChatRoomRequest
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { type, name, memberIds, memberTypes } = request;

    // 1:1 ì±„íŒ…ì¸ ê²½ìš° ê¸°ì¡´ ë°© í™•ì¸
    if (type === "direct" && memberIds.length === 1) {
      const existingRoom = await repository.findDirectRoom(
        creatorId,
        creatorType,
        memberIds[0],
        memberTypes[0]
      );

      if (existingRoom) {
        return { success: true, data: existingRoom };
      }
    }

    // ìƒˆ ë°© ìƒì„±
    const room = await repository.insertRoom({
      tenant_id: tenantId,
      type,
      name: type === "group" ? name ?? null : null,
      created_by: creatorId,
      created_by_type: creatorType,
    });

    // ìƒì„±ìë¥¼ ë©¤ë²„ë¡œ ì¶”ê°€ (owner ì—­í• )
    await repository.insertMember({
      room_id: room.id,
      user_id: creatorId,
      user_type: creatorType,
      role: "owner",
    });

    // ë‹¤ë¥¸ ë©¤ë²„ë“¤ ì¶”ê°€
    for (let i = 0; i < memberIds.length; i++) {
      await repository.insertMember({
        room_id: room.id,
        user_id: memberIds[i],
        user_type: memberTypes[i],
        role: "member",
      });
    }

    return { success: true, data: room };
  } catch (error) {
    console.error("[ChatService] createOrGetRoom error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ìƒì„± ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‚¬ìš©ìì˜ ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ (UI í‘œì‹œìš© ì¶”ê°€ ì •ë³´ í¬í•¨)
 * ë°°ì¹˜ ì¿¼ë¦¬ë¡œ N+1 ë¬¸ì œ í•´ê²° (101ì¿¼ë¦¬ â†’ 5ì¿¼ë¦¬)
 */
export async function getRoomList(
  userId: string,
  userType: ChatUserType,
  options: GetRoomsOptions = {}
): Promise<ChatRoomListItem[]> {
  const rooms = await repository.findRoomsByUser(userId, userType, options);
  if (rooms.length === 0) return [];

  const roomIds = rooms.map((r) => r.id);

  // ë°°ì¹˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° í•œ ë²ˆì— ì¡°íšŒ
  const [membersMap, lastMessagesMap] = await Promise.all([
    repository.findMembersByRoomIds(roomIds),
    repository.findLastMessagesByRoomIds(roomIds),
  ]);

  // ë‚´ ë©¤ë²„ì‹­ ì •ë³´ë¡œ last_read_at ë§µ ìƒì„±
  const membershipMap = new Map<string, { last_read_at: string }>();
  for (const roomId of roomIds) {
    const members = membersMap.get(roomId) ?? [];
    const myMembership = members.find(
      (m) => m.user_id === userId && m.user_type === userType
    );
    if (myMembership) {
      membershipMap.set(roomId, { last_read_at: myMembership.last_read_at });
    }
  }

  // ì•ˆ ì½ì€ ë©”ì‹œì§€ ìˆ˜ ë°°ì¹˜ ì¡°íšŒ
  const unreadMap = await repository.countUnreadByRoomIds(roomIds, userId, membershipMap);

  // ë°œì‹ ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒë¥¼ ìœ„í•œ í‚¤ ìˆ˜ì§‘
  const senderKeys: Array<{ id: string; type: ChatUserType }> = [];

  // 1:1 ì±„íŒ… ìƒëŒ€ë°© + ë§ˆì§€ë§‰ ë©”ì‹œì§€ ë°œì‹ ì
  for (const room of rooms) {
    const members = membersMap.get(room.id) ?? [];
    if (room.type === "direct") {
      const otherMember = members.find(
        (m) => !(m.user_id === userId && m.user_type === userType)
      );
      if (otherMember) {
        senderKeys.push({ id: otherMember.user_id, type: otherMember.user_type });
      }
    }
    const lastMsg = lastMessagesMap.get(room.id);
    if (lastMsg) {
      senderKeys.push({ id: lastMsg.sender_id, type: lastMsg.sender_type });
    }
  }

  const senderMap = await repository.findSendersByIds(senderKeys);

  // ê²°ê³¼ ì¡°í•©
  const result: ChatRoomListItem[] = [];

  for (const room of rooms) {
    const members = membersMap.get(room.id) ?? [];
    const lastMessage = lastMessagesMap.get(room.id) ?? null;
    const unreadCount = unreadMap.get(room.id) ?? 0;

    // 1:1ì¸ ê²½ìš° ìƒëŒ€ë°© ì •ë³´
    let otherUser: ChatUser | null = null;
    if (room.type === "direct") {
      const otherMember = members.find(
        (m) => !(m.user_id === userId && m.user_type === userType)
      );
      if (otherMember) {
        const key = `${otherMember.user_id}_${otherMember.user_type}`;
        const senderInfo = senderMap.get(key);
        if (senderInfo) {
          otherUser = {
            id: senderInfo.id,
            type: otherMember.user_type,
            name: senderInfo.name,
            profileImageUrl: senderInfo.profileImageUrl,
          };
        }
      }
    }

    // ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì •ë³´
    let lastMessageInfo = null;
    if (lastMessage) {
      const key = `${lastMessage.sender_id}_${lastMessage.sender_type}`;
      const senderInfo = senderMap.get(key);
      lastMessageInfo = {
        content:
          lastMessage.message_type === "system"
            ? lastMessage.content
            : lastMessage.content.length > 50
            ? lastMessage.content.slice(0, 50) + "..."
            : lastMessage.content,
        senderName: senderInfo?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ",
        createdAt: lastMessage.created_at,
      };
    }

    result.push({
      id: room.id,
      type: room.type as ChatRoomType,
      name: room.name,
      otherUser,
      memberCount: members.length,
      lastMessage: lastMessageInfo,
      unreadCount,
      updatedAt: room.updated_at,
    });
  }

  return result;
}

/**
 * ì±„íŒ…ë°© ìƒì„¸ ì •ë³´ ì¡°íšŒ
 */
export async function getRoomDetail(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<{ room: ChatRoom; members: ChatRoomMemberWithUser[] }>> {
  try {
    // ë°© ì •ë³´ ì¡°íšŒ
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ë©¤ë²„ ëª©ë¡ + ì‚¬ìš©ì ì •ë³´
    const members = await repository.findMembersByRoom(roomId);
    const membersWithUser: ChatRoomMemberWithUser[] = await Promise.all(
      members.map(async (member) => ({
        ...member,
        user: await getUserInfo(member.user_id, member.user_type) ?? {
          id: member.user_id,
          type: member.user_type,
          name: "ì•Œ ìˆ˜ ì—†ìŒ",
          profileImageUrl: null,
        },
      }))
    );

    return { success: true, data: { room, members: membersWithUser } };
  } catch (error) {
    console.error("[ChatService] getRoomDetail error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ë©”ì‹œì§€ ì„œë¹„ìŠ¤
// ============================================

/**
 * ë©”ì‹œì§€ ì „ì†¡
 */
export async function sendMessage(
  senderId: string,
  senderType: ChatUserType,
  request: SendMessageRequest
): Promise<ChatActionResult<ChatMessage>> {
  try {
    const { roomId, content, messageType = "text", replyToId } = request;

    // ë©”ì‹œì§€ ê¸¸ì´ ê²€ì¦
    if (content.length > MAX_MESSAGE_LENGTH) {
      return {
        success: false,
        error: `ë©”ì‹œì§€ëŠ” ${MAX_MESSAGE_LENGTH}ìë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
      };
    }

    // ë¹ˆ ë©”ì‹œì§€ ê²€ì¦
    if (content.trim().length === 0) {
      return { success: false, error: "ë©”ì‹œì§€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" };
    }

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, senderId, senderType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ë‹µì¥ ëŒ€ìƒ ë©”ì‹œì§€ ê²€ì¦ (ìˆëŠ” ê²½ìš°)
    if (replyToId) {
      const targetMessage = await repository.findMessageById(replyToId);
      if (!targetMessage) {
        return { success: false, error: "ë‹µì¥ ëŒ€ìƒ ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
      }
      if (targetMessage.room_id !== roomId) {
        return { success: false, error: "ê°™ì€ ì±„íŒ…ë°©ì˜ ë©”ì‹œì§€ì—ë§Œ ë‹µì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" };
      }
    }

    // ë©”ì‹œì§€ ìƒì„±
    const message = await repository.insertMessage({
      room_id: roomId,
      sender_id: senderId,
      sender_type: senderType,
      message_type: messageType,
      content: content.trim(),
      reply_to_id: replyToId ?? null,
    });

    return { success: true, data: message };
  } catch (error) {
    console.error("[ChatService] sendMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (ë°œì‹ ì ì •ë³´ í¬í•¨)
 * ë°°ì¹˜ ì¿¼ë¦¬ë¡œ N+1 ë¬¸ì œ í•´ê²° (51ì¿¼ë¦¬ â†’ 4ì¿¼ë¦¬)
 */
export async function getMessages(
  userId: string,
  userType: ChatUserType,
  options: GetMessagesOptions
): Promise<ChatActionResult<PaginatedResult<ChatMessageWithSender>>> {
  try {
    const { roomId, limit = 50 } = options;

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ë³‘ë ¬ë¡œ ì°¨ë‹¨ ëª©ë¡ + ë©”ì‹œì§€ ì¡°íšŒ
    const [blocks, messages] = await Promise.all([
      repository.findBlocksByUser(userId, userType),
      repository.findMessagesByRoom(options),
    ]);

    const blockedIds = new Set(blocks.map((b) => `${b.blocked_id}_${b.blocked_type}`));

    // ì°¨ë‹¨ë˜ì§€ ì•Šì€ ë©”ì‹œì§€ë§Œ í•„í„°ë§
    const filteredMessages = messages.filter(
      (m) => !blockedIds.has(`${m.sender_id}_${m.sender_type}`)
    );

    // ë°œì‹ ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ (1-2 ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°œì‹ ì ì •ë³´ ê°€ì ¸ì˜´)
    const senderKeys = filteredMessages.map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // ë©”ì‹œì§€ì— ë°œì‹ ì ì •ë³´ ë§¤í•‘
    const messagesWithSender: ChatMessageWithSender[] = filteredMessages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "ì•Œ ìˆ˜ ì—†ìŒ",
            },
      };
    });

    return {
      success: true,
      data: {
        data: messagesWithSender,
        hasMore: messages.length === limit,
        nextCursor: messages.length > 0 ? messages[0].created_at : undefined,
      },
    };
  } catch (error) {
    console.error("[ChatService] getMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ì‚­ì œ
 */
export async function deleteMessage(
  messageId: string,
  userId: string
): Promise<ChatActionResult<void>> {
  try {
    await repository.deleteMessage(messageId, userId);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] deleteMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì‚­ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì½ìŒ ì²˜ë¦¬
 */
export async function markRoomAsRead(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    await repository.markAsRead(roomId, userId, userType);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] markRoomAsRead error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì½ìŒ ì²˜ë¦¬ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ë©¤ë²„ ì„œë¹„ìŠ¤
// ============================================

/**
 * ê·¸ë£¹ ì±„íŒ…ë°©ì— ë©¤ë²„ ì´ˆëŒ€
 */
export async function inviteMembers(
  roomId: string,
  inviterId: string,
  inviterType: ChatUserType,
  memberIds: string[],
  memberTypes: ChatUserType[]
): Promise<ChatActionResult<void>> {
  try {
    // ë°© ì •ë³´ í™•ì¸
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    if (room.type !== "group") {
      return { success: false, error: "ê·¸ë£¹ ì±„íŒ…ë°©ì—ì„œë§Œ ì´ˆëŒ€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" };
    }

    // ì´ˆëŒ€ì ë©¤ë²„ì‹­ í™•ì¸
    const inviterMembership = await repository.findMember(
      roomId,
      inviterId,
      inviterType
    );
    if (!inviterMembership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ë©¤ë²„ ì¶”ê°€
    for (let i = 0; i < memberIds.length; i++) {
      // ì´ë¯¸ ë©¤ë²„ì¸ì§€ í™•ì¸
      const existing = await repository.findMember(
        roomId,
        memberIds[i],
        memberTypes[i]
      );
      if (!existing) {
        await repository.insertMember({
          room_id: roomId,
          user_id: memberIds[i],
          user_type: memberTypes[i],
          role: "member",
          // ì´ì „ ëŒ€í™”ë¥¼ ë³¼ ìˆ˜ ìˆë„ë¡ last_read_atì„ epochìœ¼ë¡œ ì„¤ì •
          last_read_at: "1970-01-01T00:00:00Z",
        });
      }
    }

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì¶”ê°€
    const inviterInfo = await getUserInfo(inviterId, inviterType);
    await repository.insertMessage({
      room_id: roomId,
      sender_id: inviterId,
      sender_type: inviterType,
      message_type: "system",
      content: `${inviterInfo?.name ?? "ì‚¬ìš©ì"}ë‹˜ì´ ìƒˆ ë©¤ë²„ë¥¼ ì´ˆëŒ€í–ˆìŠµë‹ˆë‹¤`,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] inviteMembers error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©¤ë²„ ì´ˆëŒ€ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°© ë‚˜ê°€ê¸°
 */
export async function leaveRoom(
  roomId: string,
  userId: string,
  userType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // left_at ì„¤ì •
    await repository.updateMember(roomId, userId, userType, {
      left_at: new Date().toISOString(),
    });

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€
    const userInfo = await getUserInfo(userId, userType);
    await repository.insertMessage({
      room_id: roomId,
      sender_id: userId,
      sender_type: userType,
      message_type: "system",
      content: `${userInfo?.name ?? "ì‚¬ìš©ì"}ë‹˜ì´ ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤`,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] leaveRoom error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ì°¨ë‹¨/ì‹ ê³  ì„œë¹„ìŠ¤
// ============================================

/**
 * ì‚¬ìš©ì ì°¨ë‹¨
 */
export async function blockUser(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    // ì´ë¯¸ ì°¨ë‹¨í–ˆëŠ”ì§€ í™•ì¸
    const alreadyBlocked = await repository.isBlocked(
      blockerId,
      blockerType,
      blockedId,
      blockedType
    );

    if (alreadyBlocked) {
      return { success: false, error: "ì´ë¯¸ ì°¨ë‹¨í•œ ì‚¬ìš©ìì…ë‹ˆë‹¤" };
    }

    await repository.insertBlock({
      blocker_id: blockerId,
      blocker_type: blockerType,
      blocked_id: blockedId,
      blocked_type: blockedType,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] blockUser error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì°¨ë‹¨ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì°¨ë‹¨ í•´ì œ
 */
export async function unblockUser(
  blockerId: string,
  blockerType: ChatUserType,
  blockedId: string,
  blockedType: ChatUserType
): Promise<ChatActionResult<void>> {
  try {
    await repository.deleteBlock(blockerId, blockerType, blockedId, blockedType);
    return { success: true };
  } catch (error) {
    console.error("[ChatService] unblockUser error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì°¨ë‹¨ í•´ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ì‹ ê³ 
 */
export async function reportMessage(
  reporterId: string,
  reporterType: ChatUserType,
  messageId: string,
  reason: string,
  description?: string
): Promise<ChatActionResult<void>> {
  try {
    await repository.insertReport({
      reporter_id: reporterId,
      reporter_type: reporterType,
      reported_message_id: messageId,
      reason: reason as "spam" | "harassment" | "inappropriate" | "hate_speech" | "other",
      description: description ?? null,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] reportMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹ ê³  ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ë©”ì‹œì§€ í¸ì§‘ ì„œë¹„ìŠ¤
// ============================================

/** ë©”ì‹œì§€ ìˆ˜ì • ê°€ëŠ¥ ì‹œê°„ (5ë¶„) */
const MAX_EDIT_TIME_MS = 5 * 60 * 1000;

/**
 * ë©”ì‹œì§€ í¸ì§‘
 * - ë³¸ì¸ ë©”ì‹œì§€ë§Œ ìˆ˜ì • ê°€ëŠ¥
 * - ì „ì†¡ í›„ 5ë¶„ ì´ë‚´ë§Œ ìˆ˜ì • ê°€ëŠ¥
 */
export async function editMessage(
  userId: string,
  userType: ChatUserType,
  messageId: string,
  newContent: string
): Promise<ChatActionResult<ChatMessage>> {
  try {
    // 1. ë©”ì‹œì§€ ì¡°íšŒ
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ë³¸ì¸ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.sender_id !== userId || message.sender_type !== userType) {
      return { success: false, error: "ë³¸ì¸ ë©”ì‹œì§€ë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" };
    }

    // 3. ì‚­ì œëœ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.is_deleted) {
      return { success: false, error: "ì‚­ì œëœ ë©”ì‹œì§€ëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 4. ì‹œìŠ¤í…œ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.message_type === "system") {
      return { success: false, error: "ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 5. ìˆ˜ì • ê°€ëŠ¥ ì‹œê°„ í™•ì¸ (5ë¶„ ì´ë‚´)
    const createdAt = new Date(message.created_at).getTime();
    if (Date.now() - createdAt > MAX_EDIT_TIME_MS) {
      return { success: false, error: "ë©”ì‹œì§€ ìˆ˜ì • ê°€ëŠ¥ ì‹œê°„(5ë¶„)ì´ ì§€ë‚¬ìŠµë‹ˆë‹¤" };
    }

    // 6. ë‚´ìš© ê²€ì¦
    const trimmedContent = newContent.trim();
    if (!trimmedContent) {
      return { success: false, error: "ë©”ì‹œì§€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" };
    }
    if (trimmedContent.length > MAX_MESSAGE_LENGTH) {
      return {
        success: false,
        error: `ë©”ì‹œì§€ëŠ” ${MAX_MESSAGE_LENGTH}ìë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`,
      };
    }

    // 7. ìˆ˜ì • ì‹¤í–‰
    const updated = await repository.updateMessageContent(messageId, trimmedContent);

    return { success: true, data: updated };
  } catch (error) {
    console.error("[ChatService] editMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ìˆ˜ì • ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ë©”ì‹œì§€ ê²€ìƒ‰ ì„œë¹„ìŠ¤
// ============================================

/**
 * ë©”ì‹œì§€ ê²€ìƒ‰
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ê²€ìƒ‰ ê°€ëŠ¥
 * - ë°œì‹ ì ì •ë³´ í¬í•¨
 */
export async function searchMessages(
  userId: string,
  userType: ChatUserType,
  options: SearchMessagesOptions
): Promise<ChatActionResult<SearchMessagesResult>> {
  try {
    const { roomId, query } = options;

    // ê²€ìƒ‰ì–´ ê²€ì¦
    if (!query.trim()) {
      return { success: false, error: "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”" };
    }

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ê²€ìƒ‰ ì‹¤í–‰
    const { messages, total } = await repository.searchMessagesByRoom(options);

    // ë°œì‹ ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ
    const senderKeys = messages.map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // ë©”ì‹œì§€ì— ë°œì‹ ì ì •ë³´ ë§¤í•‘
    const messagesWithSender: ChatMessageWithSender[] = messages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "ì•Œ ìˆ˜ ì—†ìŒ",
            },
      };
    });

    return {
      success: true,
      data: {
        messages: messagesWithSender,
        total,
        query: query.trim(),
      },
    };
  } catch (error) {
    console.error("[ChatService] searchMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê²€ìƒ‰ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ì½ìŒ í‘œì‹œ ì„œë¹„ìŠ¤
// ============================================

/**
 * ë¦¬ì•¡ì…˜ ëª©ë¡ì„ ìš”ì•½ìœ¼ë¡œ ë³€í™˜
 */
function convertReactionsToSummaries(
  reactions: MessageReaction[],
  currentUserId: string,
  currentUserType: ChatUserType
): ReactionSummary[] {
  // ì´ëª¨ì§€ë³„ ê·¸ë£¹í•‘
  const emojiMap = new Map<string, { count: number; hasReacted: boolean }>();

  for (const reaction of reactions) {
    const existing = emojiMap.get(reaction.emoji) ?? { count: 0, hasReacted: false };
    existing.count += 1;
    if (reaction.user_id === currentUserId && reaction.user_type === currentUserType) {
      existing.hasReacted = true;
    }
    emojiMap.set(reaction.emoji, existing);
  }

  // ReactionSummary ë°°ì—´ë¡œ ë³€í™˜
  const summaries: ReactionSummary[] = [];
  for (const [emoji, data] of emojiMap) {
    summaries.push({
      emoji: emoji as ReactionSummary["emoji"],
      count: data.count,
      hasReacted: data.hasReacted,
    });
  }

  return summaries;
}

/**
 * ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (ì½ìŒ ìƒíƒœ + ë¦¬ì•¡ì…˜ + ë‹µì¥ ì›ë³¸ í¬í•¨)
 * - ë³¸ì¸ ë©”ì‹œì§€ì— ëŒ€í•´ì„œë§Œ ì•ˆ ì½ì€ ë©¤ë²„ ìˆ˜ ê³„ì‚°
 * - ì°¨ë‹¨í•œ ì‚¬ìš©ì ë©”ì‹œì§€ í•„í„°ë§
 * - ê° ë©”ì‹œì§€ì˜ ë¦¬ì•¡ì…˜ ìš”ì•½ í¬í•¨
 * - ë‹µì¥ ë©”ì‹œì§€ì˜ ì›ë³¸ ì •ë³´ í¬í•¨
 */
export async function getMessagesWithReadStatus(
  userId: string,
  userType: ChatUserType,
  options: GetMessagesOptions
): Promise<ChatActionResult<MessagesWithReadStatusResult>> {
  try {
    const { roomId, limit = 50 } = options;

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // ë³‘ë ¬ë¡œ ì°¨ë‹¨ ëª©ë¡ + ë©”ì‹œì§€ + ì½ìŒ ìƒíƒœ ì¡°íšŒ
    const [blocks, { messages, readCounts }] = await Promise.all([
      repository.findBlocksByUser(userId, userType),
      repository.findMessagesWithReadCounts(options, userId),
    ]);

    const blockedIds = new Set(blocks.map((b) => `${b.blocked_id}_${b.blocked_type}`));

    // ì°¨ë‹¨ë˜ì§€ ì•Šì€ ë©”ì‹œì§€ë§Œ í•„í„°ë§
    const filteredMessages = messages.filter(
      (m) => !blockedIds.has(`${m.sender_id}_${m.sender_type}`)
    );

    // í•„í„°ë§ëœ ë©”ì‹œì§€ì˜ readCountsë§Œ ìœ ì§€
    const filteredReadCounts: Record<string, number> = {};
    for (const msg of filteredMessages) {
      filteredReadCounts[msg.id] = readCounts[msg.id] ?? 0;
    }

    // ë©”ì‹œì§€ ID ëª©ë¡ + ë‹µì¥ ì›ë³¸ ID ìˆ˜ì§‘
    const messageIds = filteredMessages.map((m) => m.id);
    const replyToIds = filteredMessages
      .map((m) => m.reply_to_id)
      .filter((id): id is string => id !== null);

    // ë³‘ë ¬ë¡œ ë°œì‹ ì + ë¦¬ì•¡ì…˜ + ë‹µì¥ ì›ë³¸ ì¡°íšŒ
    const [senderMap, reactionsMap, replyTargetsMap] = await Promise.all([
      repository.findSendersByIds(
        filteredMessages.map((m) => ({ id: m.sender_id, type: m.sender_type }))
      ),
      repository.findReactionsByMessageIds(messageIds),
      repository.findReplyTargetsByIds(replyToIds),
    ]);

    // ë‹µì¥ ì›ë³¸ ë°œì‹ ì ì •ë³´ë„ ë°°ì¹˜ ì¡°íšŒ
    const replyTargetSenderKeys = Array.from(replyTargetsMap.values()).map((t) => ({
      id: t.sender_id,
      type: t.sender_type,
    }));
    const replyTargetSenderMap = await repository.findSendersByIds(replyTargetSenderKeys);

    // ë©”ì‹œì§€ì— ë°œì‹ ì ì •ë³´ + ë¦¬ì•¡ì…˜ + ë‹µì¥ ì›ë³¸ ë§¤í•‘
    const messagesWithAll = filteredMessages.map((message) => {
      const key = `${message.sender_id}_${message.sender_type}`;
      const senderInfo = senderMap.get(key);
      const messageReactions = reactionsMap.get(message.id) ?? [];

      // ë‹µì¥ ì›ë³¸ ì •ë³´ ë§¤í•‘
      let replyTarget: { id: string; content: string; senderName: string; isDeleted: boolean } | null = null;
      if (message.reply_to_id) {
        const target = replyTargetsMap.get(message.reply_to_id);
        if (target) {
          const targetSenderInfo = replyTargetSenderMap.get(`${target.sender_id}_${target.sender_type}`);
          replyTarget = {
            id: target.id,
            content: target.is_deleted ? "ì‚­ì œëœ ë©”ì‹œì§€ì…ë‹ˆë‹¤" : target.content,
            senderName: targetSenderInfo?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ",
            isDeleted: target.is_deleted,
          };
        }
      }

      return {
        ...message,
        sender: senderInfo
          ? {
              id: senderInfo.id,
              type: message.sender_type,
              name: senderInfo.name,
              profileImageUrl: senderInfo.profileImageUrl,
            }
          : {
              id: message.sender_id,
              type: message.sender_type,
              name: "ì•Œ ìˆ˜ ì—†ìŒ",
            },
        reactions: convertReactionsToSummaries(messageReactions, userId, userType),
        replyTarget,
      };
    });

    return {
      success: true,
      data: {
        messages: messagesWithAll,
        readCounts: filteredReadCounts,
        hasMore: messages.length === limit,
      },
    };
  } catch (error) {
    console.error("[ChatService] getMessagesWithReadStatus error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ë¦¬ì•¡ì…˜ ì„œë¹„ìŠ¤
// ============================================

/**
 * ë¦¬ì•¡ì…˜ í† ê¸€
 * - ë¦¬ì•¡ì…˜ì´ ì—†ìœ¼ë©´ ì¶”ê°€, ìˆìœ¼ë©´ ì‚­ì œ
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ë¦¬ì•¡ì…˜ ê°€ëŠ¥
 * - ì‚­ì œëœ ë©”ì‹œì§€ì—ëŠ” ë¦¬ì•¡ì…˜ ë¶ˆê°€
 */
export async function toggleReaction(
  userId: string,
  userType: ChatUserType,
  input: ReactionToggleInput
): Promise<ChatActionResult<{ added: boolean }>> {
  try {
    const { messageId, emoji } = input;

    // 1. ë©”ì‹œì§€ ì¡°íšŒ
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ì‚­ì œëœ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.is_deleted) {
      return { success: false, error: "ì‚­ì œëœ ë©”ì‹œì§€ì—ëŠ” ë¦¬ì•¡ì…˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 3. ì±„íŒ…ë°© ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(message.room_id, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // 4. ê¸°ì¡´ ë¦¬ì•¡ì…˜ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const hasExisting = await repository.hasReaction({
      messageId,
      userId,
      userType,
      emoji,
    });

    // 5. í† ê¸€ ì‹¤í–‰
    if (hasExisting) {
      // ê¸°ì¡´ ë¦¬ì•¡ì…˜ ì‚­ì œ
      await repository.deleteReaction({
        messageId,
        userId,
        userType,
        emoji,
      });
      return { success: true, data: { added: false } };
    } else {
      // ìƒˆ ë¦¬ì•¡ì…˜ ì¶”ê°€
      await repository.insertReaction({
        messageId,
        userId,
        userType,
        emoji,
      });
      return { success: true, data: { added: true } };
    }
  } catch (error) {
    console.error("[ChatService] toggleReaction error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë¦¬ì•¡ì…˜ ì²˜ë¦¬ ì‹¤íŒ¨",
    };
  }
}

// ============================================
// ê³ ì • ë©”ì‹œì§€ ì„œë¹„ìŠ¤
// ============================================

/** ìµœëŒ€ ê³ ì • ë©”ì‹œì§€ ê°œìˆ˜ */
const MAX_PINNED_MESSAGES = 5;

/**
 * ë©”ì‹œì§€ ê³ ì •
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ê³ ì • ê°€ëŠ¥
 * - owner/admin ì—­í• ë§Œ ê³ ì • ê°€ëŠ¥
 * - ì‚­ì œëœ ë©”ì‹œì§€ëŠ” ê³ ì • ë¶ˆê°€
 * - ìµœëŒ€ 5ê°œê¹Œì§€ë§Œ ê³ ì • ê°€ëŠ¥
 */
export async function pinMessage(
  userId: string,
  userType: ChatUserType,
  input: PinMessageInput
): Promise<ChatActionResult<void>> {
  try {
    const { roomId, messageId } = input;

    // 1. ë©”ì‹œì§€ ì¡°íšŒ
    const message = await repository.findMessageById(messageId);
    if (!message) {
      return { success: false, error: "ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ê°™ì€ ì±„íŒ…ë°© ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.room_id !== roomId) {
      return { success: false, error: "í•´ë‹¹ ì±„íŒ…ë°©ì˜ ë©”ì‹œì§€ê°€ ì•„ë‹™ë‹ˆë‹¤" };
    }

    // 3. ì‚­ì œëœ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    if (message.is_deleted) {
      return { success: false, error: "ì‚­ì œëœ ë©”ì‹œì§€ëŠ” ê³ ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 4. ì±„íŒ…ë°© ë©¤ë²„ì‹­ ë° ì—­í•  í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "ë©”ì‹œì§€ë¥¼ ê³ ì •í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 5. ì´ë¯¸ ê³ ì •ëœ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    const alreadyPinned = await repository.isPinnedMessage(roomId, messageId);
    if (alreadyPinned) {
      return { success: false, error: "ì´ë¯¸ ê³ ì •ëœ ë©”ì‹œì§€ì…ë‹ˆë‹¤" };
    }

    // 6. ìµœëŒ€ ê³ ì • ê°œìˆ˜ í™•ì¸
    const pinnedCount = await repository.countPinnedMessages(roomId);
    if (pinnedCount >= MAX_PINNED_MESSAGES) {
      return {
        success: false,
        error: `ìµœëŒ€ ${MAX_PINNED_MESSAGES}ê°œê¹Œì§€ë§Œ ê³ ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤`,
      };
    }

    // 7. ê³ ì • ë©”ì‹œì§€ ì¶”ê°€
    await repository.insertPinnedMessage({
      room_id: roomId,
      message_id: messageId,
      pinned_by: userId,
      pinned_by_type: userType,
    });

    return { success: true };
  } catch (error) {
    console.error("[ChatService] pinMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê³ ì • ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ê³ ì • í•´ì œ
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ í•´ì œ ê°€ëŠ¥
 * - owner/admin ì—­í• ë§Œ í•´ì œ ê°€ëŠ¥
 */
export async function unpinMessage(
  userId: string,
  userType: ChatUserType,
  input: PinMessageInput
): Promise<ChatActionResult<void>> {
  try {
    const { roomId, messageId } = input;

    // 1. ì±„íŒ…ë°© ë©¤ë²„ì‹­ ë° ì—­í•  í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "ë©”ì‹œì§€ ê³ ì •ì„ í•´ì œí•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ê³ ì •ëœ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
    const isPinned = await repository.isPinnedMessage(roomId, messageId);
    if (!isPinned) {
      return { success: false, error: "ê³ ì •ë˜ì§€ ì•Šì€ ë©”ì‹œì§€ì…ë‹ˆë‹¤" };
    }

    // 3. ê³ ì • í•´ì œ
    await repository.deletePinnedMessage(roomId, messageId);

    return { success: true };
  } catch (error) {
    console.error("[ChatService] unpinMessage error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ì‹œì§€ ê³ ì • í•´ì œ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°©ì˜ ê³ ì • ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ì¡°íšŒ ê°€ëŠ¥
 * - ë©”ì‹œì§€ ë‚´ìš© + ë°œì‹ ì ì´ë¦„ í¬í•¨
 */
export async function getPinnedMessages(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<ChatActionResult<PinnedMessageWithContent[]>> {
  try {
    // 1. ì±„íŒ…ë°© ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // 2. ê³ ì • ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
    const pinnedMessages = await repository.findPinnedMessagesByRoom(roomId);
    if (pinnedMessages.length === 0) {
      return { success: true, data: [] };
    }

    // 3. ë©”ì‹œì§€ ë‚´ìš© ë°°ì¹˜ ì¡°íšŒ
    const messageIds = pinnedMessages.map((p) => p.message_id);
    const messagesMap = await repository.findReplyTargetsByIds(messageIds);

    // 4. ë°œì‹ ì ì •ë³´ ë°°ì¹˜ ì¡°íšŒ
    const senderKeys = Array.from(messagesMap.values()).map((m) => ({
      id: m.sender_id,
      type: m.sender_type,
    }));
    const senderMap = await repository.findSendersByIds(senderKeys);

    // 5. ê²°ê³¼ ì¡°í•©
    const result: PinnedMessageWithContent[] = pinnedMessages.map((pinned) => {
      const msg = messagesMap.get(pinned.message_id);
      const senderInfo = msg
        ? senderMap.get(`${msg.sender_id}_${msg.sender_type}`)
        : null;

      return {
        ...pinned,
        message: {
          content: msg?.is_deleted ? "ì‚­ì œëœ ë©”ì‹œì§€ì…ë‹ˆë‹¤" : (msg?.content ?? ""),
          senderName: senderInfo?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ",
          isDeleted: msg?.is_deleted ?? true,
        },
      };
    });

    return { success: true, data: result };
  } catch (error) {
    console.error("[ChatService] getPinnedMessages error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³ ì • ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ë©”ì‹œì§€ ê³ ì • ì—¬ë¶€ í™•ì¸ (ë‹¨ì¼ ë©”ì‹œì§€)
 */
export async function checkMessagePinned(
  roomId: string,
  messageId: string
): Promise<boolean> {
  try {
    return await repository.isPinnedMessage(roomId, messageId);
  } catch {
    return false;
  }
}

/**
 * ì‚¬ìš©ìê°€ ê³ ì • ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
 */
export async function canUserPinMessages(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<boolean> {
  try {
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) return false;
    return membership.role === "owner" || membership.role === "admin";
  } catch {
    return false;
  }
}

// ============================================
// ê³µì§€ ì„œë¹„ìŠ¤
// ============================================

/**
 * ì±„íŒ…ë°© ê³µì§€ ì„¤ì •/ì‚­ì œ
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ì„¤ì • ê°€ëŠ¥
 * - owner/admin ì—­í• ë§Œ ì„¤ì • ê°€ëŠ¥
 * - contentê°€ nullì´ë©´ ê³µì§€ ì‚­ì œ
 */
export async function setAnnouncement(
  userId: string,
  userType: ChatUserType,
  input: SetAnnouncementInput
): Promise<ChatActionResult<ChatRoom>> {
  try {
    const { roomId, content } = input;

    // 1. ì±„íŒ…ë°© ì¡´ì¬ í™•ì¸
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ì±„íŒ…ë°© ë©¤ë²„ì‹­ ë° ì—­í•  í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    if (membership.role !== "owner" && membership.role !== "admin") {
      return { success: false, error: "ê³µì§€ë¥¼ ì„¤ì •í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 3. ê³µì§€ ë‚´ìš© ê²€ì¦ (ì„¤ì •í•˜ëŠ” ê²½ìš°)
    if (content !== null) {
      const trimmedContent = content.trim();
      if (!trimmedContent) {
        return { success: false, error: "ê³µì§€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" };
      }
      if (trimmedContent.length > 500) {
        return { success: false, error: "ê³µì§€ëŠ” 500ìë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
      }
    }

    // 4. ê³µì§€ ì„¤ì •/ì‚­ì œ ì‹¤í–‰
    const updatedRoom = await repository.setRoomAnnouncement(
      roomId,
      content !== null ? userId : null,
      content !== null ? userType : null,
      content !== null ? content.trim() : null
    );

    return { success: true, data: updatedRoom };
  } catch (error) {
    console.error("[ChatService] setAnnouncement error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³µì§€ ì„¤ì • ì‹¤íŒ¨",
    };
  }
}

/**
 * ì±„íŒ…ë°© ê³µì§€ ì¡°íšŒ
 * - ì±„íŒ…ë°© ë©¤ë²„ë§Œ ì¡°íšŒ ê°€ëŠ¥
 * - ê³µì§€ê°€ ì—†ìœ¼ë©´ null ë°˜í™˜
 */
export async function getAnnouncement(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<ChatActionResult<AnnouncementInfo | null>> {
  try {
    // 1. ì±„íŒ…ë°© ì¡´ì¬ í™•ì¸
    const room = await repository.findRoomById(roomId);
    if (!room) {
      return { success: false, error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" };
    }

    // 2. ì±„íŒ…ë°© ë©¤ë²„ì‹­ í™•ì¸
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) {
      return { success: false, error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" };
    }

    // 3. ê³µì§€ê°€ ì—†ìœ¼ë©´ null ë°˜í™˜
    if (!room.announcement || !room.announcement_by || !room.announcement_by_type) {
      return { success: true, data: null };
    }

    // 4. ê³µì§€ ì‘ì„±ì ì •ë³´ ì¡°íšŒ
    const authorInfo = await getUserInfo(room.announcement_by, room.announcement_by_type);

    return {
      success: true,
      data: {
        content: room.announcement,
        authorName: authorInfo?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ",
        authorType: room.announcement_by_type,
        createdAt: room.announcement_at ?? new Date().toISOString(),
      },
    };
  } catch (error) {
    console.error("[ChatService] getAnnouncement error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ê³µì§€ ì¡°íšŒ ì‹¤íŒ¨",
    };
  }
}

/**
 * ì‚¬ìš©ìê°€ ê³µì§€ ì„¤ì • ê¶Œí•œì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
 */
export async function canUserSetAnnouncement(
  userId: string,
  userType: ChatUserType,
  roomId: string
): Promise<boolean> {
  try {
    const membership = await repository.findMember(roomId, userId, userType);
    if (!membership) return false;
    return membership.role === "owner" || membership.role === "admin";
  } catch {
    return false;
  }
}
</file>

<file path="types.ts">
/**
 * Chat ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * ì±„íŒ… ì‹œìŠ¤í…œì˜ í•µì‹¬ íƒ€ì…ë“¤ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ Supabase CLIë¡œ íƒ€ì…ì„ ì¬ìƒì„±í•˜ë©´ Tables<"chat_rooms"> ë“±ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 */

// ============================================
// ê¸°ë³¸ ì—´ê±°í˜• íƒ€ì…
// ============================================

/** ì±„íŒ…ë°© ìœ í˜• */
export type ChatRoomType = "direct" | "group";

/** ì‚¬ìš©ì ìœ í˜• */
export type ChatUserType = "student" | "admin";

/** ì±„íŒ…ë°© ë©¤ë²„ ì—­í•  */
export type ChatMemberRole = "owner" | "admin" | "member";

/** ë©”ì‹œì§€ ìœ í˜• */
export type ChatMessageType = "text" | "system";

/** ë©”ì‹œì§€ ì „ì†¡ ìƒíƒœ (í´ë¼ì´ì–¸íŠ¸ ì „ìš©) */
export type MessageStatus = "sending" | "sent" | "error";

/** ì‹ ê³  ì‚¬ìœ  */
export type ReportReason =
  | "spam"
  | "harassment"
  | "inappropriate"
  | "hate_speech"
  | "other";

/** ì‹ ê³  ìƒíƒœ */
export type ReportStatus = "pending" | "reviewed" | "resolved" | "dismissed";

// ============================================
// Presence íƒ€ì… (ì‹¤ì‹œê°„ ìƒíƒœ)
// ============================================

/** Presence ì‚¬ìš©ì ìƒíƒœ */
export interface PresenceUser {
  userId: string;
  name: string;
  isTyping: boolean;
  lastSeen: string;
}

// ============================================
// ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ íƒ€ì…
// ============================================

/** ì§€ì›í•˜ëŠ” ë¦¬ì•¡ì…˜ ì´ëª¨ì§€ ëª©ë¡ */
export const REACTION_EMOJIS = ["ğŸ‘", "â¤ï¸", "ğŸ˜‚", "ğŸ”¥", "ğŸ˜®"] as const;
export type ReactionEmoji = (typeof REACTION_EMOJIS)[number];

/** ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ */
export interface MessageReaction {
  id: string;
  message_id: string;
  user_id: string;
  user_type: ChatUserType;
  emoji: ReactionEmoji;
  created_at: string;
}

/** ë¦¬ì•¡ì…˜ ìš”ì•½ (UI í‘œì‹œìš©) */
export interface ReactionSummary {
  emoji: ReactionEmoji;
  count: number;
  hasReacted: boolean; // í˜„ì¬ ì‚¬ìš©ìê°€ ë¦¬ì•¡ì…˜í–ˆëŠ”ì§€
}

/** ë¦¬ì•¡ì…˜ í† ê¸€ ì…ë ¥ */
export interface ReactionToggleInput {
  messageId: string;
  emoji: ReactionEmoji;
}

// ============================================
// ì±„íŒ…ë°© íƒ€ì…
// ============================================

/** ì±„íŒ…ë°© ê¸°ë³¸ íƒ€ì… */
export interface ChatRoom {
  id: string;
  tenant_id: string;
  type: ChatRoomType;
  name: string | null;
  created_by: string;
  created_by_type: ChatUserType;
  is_active: boolean;
  /** ì±„íŒ…ë°© ê³µì§€ ë‚´ìš© */
  announcement: string | null;
  /** ê³µì§€ ì‘ì„±ì ID */
  announcement_by: string | null;
  /** ê³µì§€ ì‘ì„±ì ìœ í˜• */
  announcement_by_type: ChatUserType | null;
  /** ê³µì§€ ì‘ì„± ì‹œê°„ */
  announcement_at: string | null;
  created_at: string;
  updated_at: string;
}

/** ì±„íŒ…ë°© ìƒì„± ì…ë ¥ íƒ€ì… */
export interface ChatRoomInsert {
  tenant_id: string;
  type: ChatRoomType;
  name?: string | null;
  created_by: string;
  created_by_type: ChatUserType;
  is_active?: boolean;
}

/** ì±„íŒ…ë°© ìˆ˜ì • ì…ë ¥ íƒ€ì… */
export interface ChatRoomUpdate {
  name?: string | null;
  is_active?: boolean;
  announcement?: string | null;
  announcement_by?: string | null;
  announcement_by_type?: ChatUserType | null;
  announcement_at?: string | null;
}

// ============================================
// ì±„íŒ…ë°© ë©¤ë²„ íƒ€ì…
// ============================================

/** ì±„íŒ…ë°© ë©¤ë²„ ê¸°ë³¸ íƒ€ì… */
export interface ChatRoomMember {
  id: string;
  room_id: string;
  user_id: string;
  user_type: ChatUserType;
  role: ChatMemberRole;
  last_read_at: string;
  is_muted: boolean;
  left_at: string | null;
  created_at: string;
  updated_at: string;
}

/** ì±„íŒ…ë°© ë©¤ë²„ ìƒì„± ì…ë ¥ íƒ€ì… */
export interface ChatRoomMemberInsert {
  room_id: string;
  user_id: string;
  user_type: ChatUserType;
  role?: ChatMemberRole;
  last_read_at?: string;
  is_muted?: boolean;
}

/** ì±„íŒ…ë°© ë©¤ë²„ ìˆ˜ì • ì…ë ¥ íƒ€ì… */
export interface ChatRoomMemberUpdate {
  role?: ChatMemberRole;
  last_read_at?: string;
  is_muted?: boolean;
  left_at?: string | null;
}

// ============================================
// ë©”ì‹œì§€ íƒ€ì…
// ============================================

/** ë©”ì‹œì§€ ê¸°ë³¸ íƒ€ì… */
export interface ChatMessage {
  id: string;
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type: ChatMessageType;
  content: string;
  reply_to_id: string | null;
  is_deleted: boolean;
  deleted_at: string | null;
  created_at: string;
  updated_at: string;
}

/** ë©”ì‹œì§€ ìƒì„± ì…ë ¥ íƒ€ì… */
export interface ChatMessageInsert {
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type?: ChatMessageType;
  content: string;
  reply_to_id?: string | null;
}

/** ë©”ì‹œì§€ ìˆ˜ì • ì…ë ¥ íƒ€ì… */
export interface ChatMessageUpdate {
  content?: string;
  is_deleted?: boolean;
  deleted_at?: string | null;
}

/** ë©”ì‹œì§€ê°€ ìˆ˜ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í—¬í¼ í•¨ìˆ˜ */
export function isMessageEdited(message: ChatMessage): boolean {
  return message.created_at !== message.updated_at && !message.is_deleted;
}

// ============================================
// ì°¨ë‹¨ íƒ€ì…
// ============================================

/** ì°¨ë‹¨ ê¸°ë³¸ íƒ€ì… */
export interface ChatBlock {
  id: string;
  blocker_id: string;
  blocker_type: ChatUserType;
  blocked_id: string;
  blocked_type: ChatUserType;
  created_at: string;
}

/** ì°¨ë‹¨ ìƒì„± ì…ë ¥ íƒ€ì… */
export interface ChatBlockInsert {
  blocker_id: string;
  blocker_type: ChatUserType;
  blocked_id: string;
  blocked_type: ChatUserType;
}

// ============================================
// ì‹ ê³  íƒ€ì…
// ============================================

/** ì‹ ê³  ê¸°ë³¸ íƒ€ì… */
export interface ChatReport {
  id: string;
  reporter_id: string;
  reporter_type: ChatUserType;
  reported_message_id: string | null;
  reported_user_id: string | null;
  reported_user_type: ChatUserType | null;
  reason: ReportReason;
  description: string | null;
  status: ReportStatus;
  reviewed_by: string | null;
  reviewed_at: string | null;
  resolution_notes: string | null;
  created_at: string;
  updated_at: string;
}

/** ì‹ ê³  ìƒì„± ì…ë ¥ íƒ€ì… */
export interface ChatReportInsert {
  reporter_id: string;
  reporter_type: ChatUserType;
  reported_message_id?: string | null;
  reported_user_id?: string | null;
  reported_user_type?: ChatUserType | null;
  reason: ReportReason;
  description?: string | null;
}

/** ì‹ ê³  ìˆ˜ì • ì…ë ¥ íƒ€ì… (ê´€ë¦¬ììš©) */
export interface ChatReportUpdate {
  status?: ReportStatus;
  reviewed_by?: string | null;
  reviewed_at?: string | null;
  resolution_notes?: string | null;
}

/** ì‹ ê³  + ìƒì„¸ ì •ë³´ (ê´€ë¦¬ì UIìš©) */
export interface ChatReportWithDetails extends ChatReport {
  /** ì‹ ê³ ëœ ë©”ì‹œì§€ ì •ë³´ */
  reportedMessage?: ChatMessage | null;
  /** ì‹ ê³ ì ì •ë³´ */
  reporter?: ChatUser | null;
  /** í”¼ì‹ ê³ ì ì •ë³´ */
  reportedUser?: ChatUser | null;
}

/** ì‹ ê³  ëª©ë¡ ì¡°íšŒ í•„í„° ì˜µì…˜ */
export interface GetReportsFilter {
  status?: ReportStatus | "all";
  reason?: ReportReason | "all";
}

// ============================================
// ë³µí•© íƒ€ì… (UI ë Œë”ë§ìš©)
// ============================================

/** ì‚¬ìš©ì ì •ë³´ (ë©”ì‹œì§€/ë©¤ë²„ í‘œì‹œìš©) */
export interface ChatUser {
  id: string;
  type: ChatUserType;
  name: string;
  profileImageUrl?: string | null;
}

/** ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ ì •ë³´ (UIìš©) */
export interface ReplyTargetInfo {
  id: string;
  content: string;
  senderName: string;
  isDeleted: boolean;
}

/** ë©”ì‹œì§€ + ë°œì‹ ì ì •ë³´ */
export interface ChatMessageWithSender extends ChatMessage {
  sender: ChatUser;
  /** ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ ìš”ì•½ (ì˜µì…˜) */
  reactions?: ReactionSummary[];
  /** ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ ì •ë³´ (ì˜µì…˜) */
  replyTarget?: ReplyTargetInfo | null;
}

/** ë©”ì‹œì§€ ê·¸ë£¹í•‘ ì •ë³´ (UI ë Œë”ë§ìš©) */
export interface MessageGroupingInfo {
  /** ë°œì‹ ì ì´ë¦„ í‘œì‹œ ì—¬ë¶€ (ê·¸ë£¹ ì²« ë©”ì‹œì§€ë§Œ true) */
  showName: boolean;
  /** ì‹œê°„ í‘œì‹œ ì—¬ë¶€ (ê·¸ë£¹ ë§ˆì§€ë§‰ ë©”ì‹œì§€ë§Œ true) */
  showTime: boolean;
  /** ê·¸ë£¹ì˜ ì¼ë¶€ì¸ì§€ ì—¬ë¶€ (ê°„ê²© ì¶•ì†Œìš©) */
  isGrouped: boolean;
  /** ë‚ ì§œ êµ¬ë¶„ì„  í‘œì‹œ ì—¬ë¶€ */
  showDateDivider: boolean;
  /** ë‚ ì§œ êµ¬ë¶„ì„  í…ìŠ¤íŠ¸ (ì˜ˆ: "2024ë…„ 1ì›” 15ì¼ ì›”ìš”ì¼") */
  dateDividerText?: string;
}

/** ê·¸ë£¹í•‘ ì •ë³´ê°€ í¬í•¨ëœ ë©”ì‹œì§€ */
export interface ChatMessageWithGrouping extends ChatMessageWithSender {
  grouping: MessageGroupingInfo;
}

/** ì±„íŒ…ë°© + ì¶”ê°€ ì •ë³´ (ëª©ë¡ í‘œì‹œìš©) */
export interface ChatRoomWithDetails extends ChatRoom {
  members: ChatRoomMemberWithUser[];
  lastMessage: ChatMessage | null;
  unreadCount: number;
}

/** ì±„íŒ…ë°© ë©¤ë²„ + ì‚¬ìš©ì ì •ë³´ */
export interface ChatRoomMemberWithUser extends ChatRoomMember {
  user: ChatUser;
}

/** ì±„íŒ…ë°© ëª©ë¡ ì•„ì´í…œ (ê°„ëµ ë²„ì „) */
export interface ChatRoomListItem {
  id: string;
  type: ChatRoomType;
  name: string | null;
  /** directì¼ ê²½ìš° ìƒëŒ€ë°© ì •ë³´, groupì¼ ê²½ìš° null */
  otherUser: ChatUser | null;
  /** groupì¼ ê²½ìš° ë©¤ë²„ ìˆ˜ */
  memberCount: number;
  lastMessage: {
    content: string;
    senderName: string;
    createdAt: string;
  } | null;
  unreadCount: number;
  updatedAt: string;
}

// ============================================
// API ì‘ë‹µ/ìš”ì²­ íƒ€ì…
// ============================================

/** ì±„íŒ…ë°© ìƒì„± ìš”ì²­ */
export interface CreateChatRoomRequest {
  type: ChatRoomType;
  name?: string; // groupì¼ ê²½ìš°
  memberIds: string[]; // ì´ˆëŒ€í•  ë©¤ë²„ user_id ëª©ë¡
  memberTypes: ChatUserType[]; // ê° ë©¤ë²„ì˜ íƒ€ì… (memberIdsì™€ ê°™ì€ ìˆœì„œ)
}

/** ë©”ì‹œì§€ ì „ì†¡ ìš”ì²­ */
export interface SendMessageRequest {
  roomId: string;
  content: string;
  messageType?: ChatMessageType;
  replyToId?: string | null;
}

/** ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ ì˜µì…˜ */
export interface GetMessagesOptions {
  roomId: string;
  limit?: number;
  before?: string; // cursor pagination: ì´ ì‹œê°„ ì´ì „ ë©”ì‹œì§€
}

/** ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ ì˜µì…˜ */
export interface GetRoomsOptions {
  limit?: number;
  offset?: number;
}

// ============================================
// ì•¡ì…˜ ê²°ê³¼ íƒ€ì…
// ============================================

/** ê¸°ë³¸ ì•¡ì…˜ ê²°ê³¼ */
export interface ChatActionResult<T = void> {
  success: boolean;
  data?: T;
  error?: string;
}

/** í˜ì´ì§€ë„¤ì´ì…˜ ê²°ê³¼ */
export interface PaginatedResult<T> {
  data: T[];
  hasMore: boolean;
  nextCursor?: string;
}

// ============================================
// ë©”ì‹œì§€ ê²€ìƒ‰ íƒ€ì…
// ============================================

/** ë©”ì‹œì§€ ê²€ìƒ‰ ì˜µì…˜ */
export interface SearchMessagesOptions {
  roomId: string;
  query: string;
  limit?: number;
  offset?: number;
}

/** ë©”ì‹œì§€ ê²€ìƒ‰ ê²°ê³¼ */
export interface SearchMessagesResult {
  messages: ChatMessageWithSender[];
  total: number;
  query: string;
}

// ============================================
// ì½ìŒ í‘œì‹œ íƒ€ì…
// ============================================

/** ë©”ì‹œì§€ + ì½ìŒ ìƒíƒœ ê²°ê³¼ */
export interface MessagesWithReadStatusResult {
  messages: ChatMessageWithSender[];
  /** ë©”ì‹œì§€ IDë³„ ì•ˆ ì½ì€ ë©¤ë²„ ìˆ˜ */
  readCounts: Record<string, number>;
  hasMore: boolean;
}

// ============================================
// ê³ ì • ë©”ì‹œì§€ íƒ€ì…
// ============================================

/** ê³ ì • ë©”ì‹œì§€ ê¸°ë³¸ íƒ€ì… */
export interface PinnedMessage {
  id: string;
  room_id: string;
  message_id: string;
  pinned_by: string;
  pinned_by_type: ChatUserType;
  pin_order: number;
  created_at: string;
}

/** ê³ ì • ë©”ì‹œì§€ + ë‚´ìš© (UI í‘œì‹œìš©) */
export interface PinnedMessageWithContent extends PinnedMessage {
  message: {
    content: string;
    senderName: string;
    isDeleted: boolean;
  };
}

/** ê³ ì • ë©”ì‹œì§€ ì…ë ¥ íƒ€ì… */
export interface PinMessageInput {
  roomId: string;
  messageId: string;
}

/** ê³ ì • ë©”ì‹œì§€ ì‚½ì… íƒ€ì… (Repositoryìš©) */
export interface PinnedMessageInsert {
  room_id: string;
  message_id: string;
  pinned_by: string;
  pinned_by_type: ChatUserType;
  pin_order?: number;
}

// ============================================
// ê³µì§€ íƒ€ì…
// ============================================

/** ê³µì§€ ì •ë³´ (UI í‘œì‹œìš©) */
export interface AnnouncementInfo {
  content: string;
  authorName: string;
  authorType: ChatUserType;
  createdAt: string;
}

/** ê³µì§€ ì„¤ì • ì…ë ¥ íƒ€ì… */
export interface SetAnnouncementInput {
  roomId: string;
  content: string | null; // nullì´ë©´ ê³µì§€ ì‚­ì œ
}
</file>

<file path="atoms/AnnouncementBanner.tsx">
"use client";

/**
 * AnnouncementBanner - ì±„íŒ…ë°© ê³µì§€ ë°°ë„ˆ
 *
 * ì±„íŒ…ë°© ìƒë‹¨ì— ê³µì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 * í´ë¦­í•˜ë©´ ì „ì²´ ê³µì§€ë¥¼ ë³¼ ìˆ˜ ìˆê³ , ê¶Œí•œì´ ìˆìœ¼ë©´ í¸ì§‘/ì‚­ì œ ê°€ëŠ¥.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { Megaphone, X, ChevronDown, ChevronUp, Edit2 } from "lucide-react";
import type { AnnouncementInfo } from "@/lib/domains/chat/types";

interface AnnouncementBannerProps {
  /** ê³µì§€ ì •ë³´ */
  announcement: AnnouncementInfo;
  /** ê³µì§€ ì„¤ì •/ì‚­ì œ ê¶Œí•œ ì—¬ë¶€ */
  canEdit: boolean;
  /** ê³µì§€ í¸ì§‘ ë²„íŠ¼ í´ë¦­ */
  onEdit?: () => void;
  /** ê³µì§€ ì‚­ì œ ë²„íŠ¼ í´ë¦­ */
  onDelete?: () => void;
}

function AnnouncementBannerComponent({
  announcement,
  canEdit,
  onEdit,
  onDelete,
}: AnnouncementBannerProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  // ê³µì§€ ë‚´ìš©ì´ ê¸¸ë©´ ì¶•ì•½ í‘œì‹œ
  const isLongContent = announcement.content.length > 100;
  const displayContent = isExpanded
    ? announcement.content
    : announcement.content.slice(0, 100) + (isLongContent ? "..." : "");

  return (
    <div className="bg-warning-50 dark:bg-warning-900/20 border-b border-warning-200 dark:border-warning-900/30">
      <div className="flex items-start gap-2 px-4 py-2">
        <Megaphone className="w-4 h-4 text-warning-600 dark:text-warning-400 flex-shrink-0 mt-0.5" />

        <div className="flex-1 min-w-0">
          {/* ê³µì§€ ë‚´ìš© */}
          <div
            className={cn(
              "text-sm text-text-primary whitespace-pre-wrap break-words",
              !isExpanded && isLongContent && "cursor-pointer"
            )}
            onClick={() => isLongContent && setIsExpanded(!isExpanded)}
          >
            {displayContent}
          </div>

          {/* ì‘ì„±ì + ì‹œê°„ */}
          <div className="flex items-center gap-2 mt-1 text-xs text-text-tertiary">
            <span>{announcement.authorName}</span>
            <span>Â·</span>
            <span>
              {new Date(announcement.createdAt).toLocaleDateString("ko-KR", {
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })}
            </span>
          </div>
        </div>

        {/* ì•¡ì…˜ ë²„íŠ¼ë“¤ */}
        <div className="flex items-center gap-1 flex-shrink-0">
          {/* í¼ì¹¨/ì ‘ê¸° ë²„íŠ¼ (ê¸´ ë‚´ìš©ì¼ ë•Œë§Œ) */}
          {isLongContent && (
            <button
              type="button"
              onClick={() => setIsExpanded(!isExpanded)}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label={isExpanded ? "ì ‘ê¸°" : "í¼ì¹˜ê¸°"}
            >
              {isExpanded ? (
                <ChevronUp className="w-4 h-4 text-text-tertiary" />
              ) : (
                <ChevronDown className="w-4 h-4 text-text-tertiary" />
              )}
            </button>
          )}

          {/* í¸ì§‘ ë²„íŠ¼ (ê¶Œí•œ ìˆì„ ë•Œ) */}
          {canEdit && onEdit && (
            <button
              type="button"
              onClick={onEdit}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label="ê³µì§€ í¸ì§‘"
            >
              <Edit2 className="w-3.5 h-3.5 text-text-tertiary hover:text-primary" />
            </button>
          )}

          {/* ì‚­ì œ ë²„íŠ¼ (ê¶Œí•œ ìˆì„ ë•Œ) */}
          {canEdit && onDelete && (
            <button
              type="button"
              onClick={onDelete}
              className="p-1 hover:bg-warning-100 dark:hover:bg-warning-900/30 rounded transition-colors"
              aria-label="ê³µì§€ ì‚­ì œ"
            >
              <X className="w-3.5 h-3.5 text-text-tertiary hover:text-error" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export const AnnouncementBanner = memo(AnnouncementBannerComponent);
</file>

<file path="atoms/DateDivider.tsx">
"use client";

/**
 * DateDivider - ë‚ ì§œ êµ¬ë¶„ì„  ì»´í¬ë„ŒíŠ¸
 *
 * ì±„íŒ… ë©”ì‹œì§€ ëª©ë¡ì—ì„œ ë‚ ì§œê°€ ë°”ë€ŒëŠ” ì§€ì ì— í‘œì‹œë©ë‹ˆë‹¤.
 */

import { memo } from "react";

interface DateDividerProps {
  /** í¬ë§·ëœ ë‚ ì§œ í…ìŠ¤íŠ¸ (ì˜ˆ: "2024ë…„ 1ì›” 15ì¼ ì›”ìš”ì¼") */
  date: string;
}

function DateDividerComponent({ date }: DateDividerProps) {
  return (
    <div className="flex items-center justify-center py-4">
      <div className="flex items-center gap-3 w-full max-w-md">
        {/* ì™¼ìª½ ì„  */}
        <div className="flex-1 h-px bg-secondary-200 dark:bg-secondary-700" />

        {/* ë‚ ì§œ í…ìŠ¤íŠ¸ */}
        <span className="text-xs text-text-tertiary font-medium px-2 whitespace-nowrap">
          {date}
        </span>

        {/* ì˜¤ë¥¸ìª½ ì„  */}
        <div className="flex-1 h-px bg-secondary-200 dark:bg-secondary-700" />
      </div>
    </div>
  );
}

export const DateDivider = memo(DateDividerComponent);
</file>

<file path="atoms/MessageBubble.tsx">
"use client";

/**
 * MessageBubble - ì±„íŒ… ë©”ì‹œì§€ ë²„ë¸”
 *
 * ë‹¨ì¼ ì±„íŒ… ë©”ì‹œì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
 * ë³¸ì¸/íƒ€ì¸ ë©”ì‹œì§€ì— ë”°ë¼ ìŠ¤íƒ€ì¼ì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { format } from "date-fns";
import { ko } from "date-fns/locale";
import { AlertCircle, Loader2 } from "lucide-react";
import type { ReactionSummary, ReactionEmoji, ReplyTargetInfo } from "@/lib/domains/chat/types";
import { ReactionPills } from "./ReactionPills";
import { ReactionPicker } from "./ReactionPicker";
import { useLongPress } from "@/lib/hooks/useLongPress";

interface MessageBubbleProps {
  /** ë©”ì‹œì§€ ë‚´ìš© */
  content: string;
  /** ë³¸ì¸ ë©”ì‹œì§€ ì—¬ë¶€ */
  isOwn: boolean;
  /** ë°œì‹ ì ì´ë¦„ (íƒ€ì¸ ë©”ì‹œì§€ì¼ ë•Œ í‘œì‹œ) */
  senderName?: string;
  /** ë©”ì‹œì§€ ìƒì„± ì‹œê°„ */
  createdAt: string;
  /** ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì—¬ë¶€ */
  isSystem?: boolean;
  /** ìˆ˜ì •ëœ ë©”ì‹œì§€ ì—¬ë¶€ */
  isEdited?: boolean;
  /** ì½ì§€ ì•Šì€ ì‚¬ëŒ ìˆ˜ (ë³¸ì¸ ë©”ì‹œì§€ì—ë§Œ í‘œì‹œ) */
  unreadCount?: number;
  /** í¸ì§‘ ê°€ëŠ¥ ì—¬ë¶€ (5ë¶„ ì´ë‚´ ë³¸ì¸ ë©”ì‹œì§€) */
  canEdit?: boolean;
  /** ë¦¬ì•¡ì…˜ ìš”ì•½ ëª©ë¡ */
  reactions?: ReactionSummary[];
  /** ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ ì •ë³´ */
  replyTarget?: ReplyTargetInfo | null;
  /** ê³ ì •ëœ ë©”ì‹œì§€ ì—¬ë¶€ */
  isPinned?: boolean;
  /** ê³ ì • ê¶Œí•œ ì—¬ë¶€ */
  canPin?: boolean;
  /** ë°œì‹ ì ì´ë¦„ í‘œì‹œ ì—¬ë¶€ (ê·¸ë£¹í•‘ìš©, ê¸°ë³¸ê°’: true) */
  showName?: boolean;
  /** ì‹œê°„ í‘œì‹œ ì—¬ë¶€ (ê·¸ë£¹í•‘ìš©, ê¸°ë³¸ê°’: true) */
  showTime?: boolean;
  /** ê·¸ë£¹í•‘ëœ ë©”ì‹œì§€ ì—¬ë¶€ (ê°„ê²© ì¶•ì†Œìš©) */
  isGrouped?: boolean;
  /** ë¦¬ì•¡ì…˜ í† ê¸€ ì½œë°± */
  onToggleReaction?: (emoji: ReactionEmoji) => void;
  /** ë‹µì¥ í´ë¦­ ì½œë°± */
  onReply?: () => void;
  /** ë‹µì¥ ì›ë³¸ í´ë¦­ ì½œë°± (í•´ë‹¹ ë©”ì‹œì§€ë¡œ ìŠ¤í¬ë¡¤) */
  onReplyTargetClick?: () => void;
  /** í¸ì§‘ í´ë¦­ ì½œë°± */
  onEdit?: () => void;
  /** ì‚­ì œ í´ë¦­ ì½œë°± */
  onDelete?: () => void;
  /** ì‹ ê³  í´ë¦­ ì½œë°± (íƒ€ì¸ ë©”ì‹œì§€) */
  onReport?: () => void;
  /** ê³ ì •/í•´ì œ í´ë¦­ ì½œë°± */
  onTogglePin?: () => void;
  /** í´ë¦­ ì‹œ ì½œë°± (ê¸¸ê²Œ ëˆŒëŸ¬ ì‹ ê³  ë“±) */
  onLongPress?: () => void;
  /** ì „ì†¡ ì‹¤íŒ¨ ìƒíƒœ */
  isError?: boolean;
  /** ì¬ì „ì†¡ ì¤‘ ìƒíƒœ */
  isRetrying?: boolean;
  /** ì¬ì „ì†¡ ì½œë°± */
  onRetry?: () => void;
}

function MessageBubbleComponent({
  content,
  isOwn,
  senderName,
  createdAt,
  isSystem = false,
  isEdited = false,
  unreadCount,
  canEdit = false,
  reactions = [],
  replyTarget,
  isPinned = false,
  canPin = false,
  showName = true,
  showTime = true,
  isGrouped = false,
  onToggleReaction,
  onReply,
  onReplyTargetClick,
  onEdit,
  onDelete,
  onReport,
  onTogglePin,
  onLongPress,
  isError = false,
  isRetrying = false,
  onRetry,
}: MessageBubbleProps) {
  const [showPicker, setShowPicker] = useState(false);

  // Long press í•¸ë“¤ëŸ¬ (ëª¨ë°”ì¼ í„°ì¹˜ + ë°ìŠ¤í¬í†± ìš°í´ë¦­)
  const longPressHandlers = useLongPress({
    onLongPress: () => onLongPress?.(),
    disabled: isSystem,
  });

  // ì‹œìŠ¤í…œ ë©”ì‹œì§€ (ì…ì¥/í‡´ì¥ ë“±)
  if (isSystem) {
    return (
      <div className="flex justify-center py-2">
        <span className="text-xs text-text-tertiary bg-secondary-100 dark:bg-secondary-800 px-3 py-1 rounded-full">
          {content}
        </span>
      </div>
    );
  }

  // ì‹œê°„ í¬ë§· (ì ˆëŒ€ ì‹œê°„: "ì˜¤í›„ 3:45")
  const formattedTime = format(new Date(createdAt), "a h:mm", { locale: ko });

  const handleReactionSelect = (emoji: ReactionEmoji) => {
    onToggleReaction?.(emoji);
    setShowPicker(false);
  };

  return (
    <div
      {...longPressHandlers}
      className={cn(
        "group flex flex-col gap-1 max-w-[80%]",
        isOwn ? "items-end ml-auto" : "items-start mr-auto"
      )}
    >
      {/* ë°œì‹ ì ì´ë¦„ (íƒ€ì¸ ë©”ì‹œì§€, ê·¸ë£¹í•‘ ì‹œ ì²« ë©”ì‹œì§€ë§Œ) */}
      {!isOwn && showName && senderName && (
        <span className="text-xs text-text-secondary pl-1">{senderName}</span>
      )}

      {/* ë©”ì‹œì§€ ë²„ë¸” + ë¦¬ì•¡ì…˜ ì˜ì—­ */}
      <div className="relative flex flex-col gap-1">
        {/* ë‹µì¥ ì›ë³¸ ë©”ì‹œì§€ í‘œì‹œ */}
        {replyTarget && (
          <button
            type="button"
            onClick={onReplyTargetClick}
            className={cn(
              "px-3 py-1.5 rounded-t-lg text-xs text-left cursor-pointer",
              "bg-secondary-50 dark:bg-secondary-900/50",
              "border-l-2 border-primary",
              "hover:bg-secondary-100 dark:hover:bg-secondary-900 transition-colors"
            )}
          >
            <p className="font-medium text-primary">{replyTarget.senderName}</p>
            <p className="text-text-secondary truncate max-w-[200px]">
              {replyTarget.isDeleted ? "ì‚­ì œëœ ë©”ì‹œì§€" : replyTarget.content}
            </p>
          </button>
        )}

        {/* ë©”ì‹œì§€ ë²„ë¸” */}
        <div
          className={cn(
            "px-4 py-2 rounded-2xl break-words whitespace-pre-wrap",
            isOwn
              ? "bg-primary-500 text-white rounded-br-sm"
              : "bg-secondary-100 dark:bg-secondary-800 text-text-primary rounded-bl-sm",
            replyTarget && "rounded-t-none",
            isError && "opacity-60"
          )}
        >
          {content}
        </div>

        {/* ì „ì†¡ ì‹¤íŒ¨ í‘œì‹œ (ë³¸ì¸ ë©”ì‹œì§€ + ì—ëŸ¬ ìƒíƒœ) */}
        {isOwn && isError && (
          <button
            type="button"
            onClick={onRetry}
            disabled={isRetrying}
            className={cn(
              "flex items-center gap-1 text-xs text-error",
              "hover:underline transition-opacity",
              isRetrying && "opacity-50 cursor-not-allowed"
            )}
          >
            {isRetrying ? (
              <>
                <Loader2 className="w-3 h-3 animate-spin" />
                <span>ì¬ì „ì†¡ ì¤‘...</span>
              </>
            ) : (
              <>
                <AlertCircle className="w-3 h-3" />
                <span>ì „ì†¡ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„</span>
              </>
            )}
          </button>
        )}

        {/* ë¦¬ì•¡ì…˜ í‘œì‹œ */}
        {reactions.length > 0 && (
          <div className={cn(isOwn ? "flex justify-end" : "flex justify-start")}>
            <ReactionPills
              reactions={reactions}
              onToggle={(emoji) => onToggleReaction?.(emoji)}
              disabled={!onToggleReaction}
            />
          </div>
        )}

        {/* ë¦¬ì•¡ì…˜ í”¼ì»¤ (í˜¸ë²„ ì‹œ + ë²„íŠ¼) */}
        {onToggleReaction && (
          <div
            className={cn(
              "absolute top-0 opacity-0 group-hover:opacity-100 transition-opacity",
              isOwn ? "-left-8" : "-right-8"
            )}
          >
            <button
              type="button"
              onClick={() => setShowPicker(!showPicker)}
              className={cn(
                "w-6 h-6 flex items-center justify-center",
                "rounded-full bg-bg-secondary hover:bg-bg-tertiary",
                "text-text-tertiary hover:text-text-secondary",
                "transition-colors text-sm"
              )}
              aria-label="ë¦¬ì•¡ì…˜ ì¶”ê°€"
            >
              +
            </button>
          </div>
        )}

        {/* ë¦¬ì•¡ì…˜ í”¼ì»¤ íŒì—… */}
        {showPicker && onToggleReaction && (
          <ReactionPicker
            onSelect={handleReactionSelect}
            onClose={() => setShowPicker(false)}
            className={cn(
              "bottom-full pb-1",
              isOwn ? "right-0" : "left-0"
            )}
          />
        )}
      </div>

      {/* í•˜ë‹¨ ì •ë³´ (ì‹œê°„, ìˆ˜ì •ë¨, ì½ìŒ ìˆ˜) - ê·¸ë£¹í•‘ ì‹œ ë§ˆì§€ë§‰ ë©”ì‹œì§€ë§Œ í‘œì‹œ */}
      {showTime && (
        <div
          className={cn(
            "flex items-center gap-2 text-xs text-text-tertiary",
            isOwn ? "flex-row-reverse" : "flex-row"
          )}
        >
          <span>{formattedTime}</span>
          {isEdited && (
            <span className="text-text-tertiary">(ìˆ˜ì •ë¨)</span>
          )}
          {isOwn && unreadCount !== undefined && unreadCount > 0 && (
            <span className="text-primary font-medium">{unreadCount}</span>
          )}
        </div>
      )}

      {/* ì•¡ì…˜ ë©”ë‰´ (ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ í‘œì‹œ) */}
      <div
        className={cn(
          "flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity",
          isOwn ? "flex-row-reverse" : "flex-row"
        )}
      >
        {onReply && (
          <button
            type="button"
            onClick={onReply}
            className="text-xs text-text-tertiary hover:text-primary px-1"
          >
            ë‹µì¥
          </button>
        )}
        {canPin && onTogglePin && (
          <button
            type="button"
            onClick={onTogglePin}
            className={cn(
              "text-xs px-1",
              isPinned
                ? "text-primary hover:text-text-tertiary"
                : "text-text-tertiary hover:text-primary"
            )}
          >
            {isPinned ? "ê³ ì • í•´ì œ" : "ê³ ì •"}
          </button>
        )}
        {isOwn && canEdit && onEdit && (
          <button
            type="button"
            onClick={onEdit}
            className="text-xs text-text-tertiary hover:text-text-secondary px-1"
          >
            í¸ì§‘
          </button>
        )}
        {isOwn && onDelete && (
          <button
            type="button"
            onClick={onDelete}
            className="text-xs text-text-tertiary hover:text-error px-1"
          >
            ì‚­ì œ
          </button>
        )}
        {!isOwn && onReport && (
          <button
            type="button"
            onClick={onReport}
            className="text-xs text-text-tertiary hover:text-error px-1"
          >
            ì‹ ê³ 
          </button>
        )}
      </div>
    </div>
  );
}

export const MessageBubble = memo(MessageBubbleComponent);
</file>

<file path="atoms/OnlineStatus.tsx">
"use client";

/**
 * OnlineStatus - ì˜¨ë¼ì¸ ìƒíƒœ í‘œì‹œ
 *
 * ì‚¬ìš©ìì˜ ì ‘ì† ìƒíƒœë¥¼ ë…¹ìƒ‰ ì ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";

interface OnlineStatusProps {
  /** ì˜¨ë¼ì¸ ì—¬ë¶€ */
  isOnline: boolean;
  /** í¬ê¸° */
  size?: "sm" | "md";
  /** ì¶”ê°€ í´ë˜ìŠ¤ */
  className?: string;
}

function OnlineStatusComponent({
  isOnline,
  size = "sm",
  className,
}: OnlineStatusProps) {
  return (
    <span
      className={cn(
        "inline-block rounded-full flex-shrink-0",
        size === "sm" ? "w-2 h-2" : "w-3 h-3",
        isOnline ? "bg-success" : "bg-text-tertiary",
        className
      )}
      aria-label={isOnline ? "ì˜¨ë¼ì¸" : "ì˜¤í”„ë¼ì¸"}
    />
  );
}

export const OnlineStatus = memo(OnlineStatusComponent);
</file>

<file path="atoms/ReactionPicker.tsx">
"use client";

/**
 * ReactionPicker - ë¦¬ì•¡ì…˜ ì´ëª¨ì§€ ì„ íƒ íŒì—…
 *
 * ë©”ì‹œì§€ì— ì¶”ê°€í•  ë¦¬ì•¡ì…˜ ì´ëª¨ì§€ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import { useClickOutside, useEscapeKey } from "@/lib/accessibility/hooks";
import { REACTION_EMOJIS, type ReactionEmoji } from "@/lib/domains/chat/types";

interface ReactionPickerProps {
  /** ì´ëª¨ì§€ ì„ íƒ ì½œë°± */
  onSelect: (emoji: ReactionEmoji) => void;
  /** ë‹«ê¸° ì½œë°± */
  onClose: () => void;
  /** ì¶”ê°€ í´ë˜ìŠ¤ */
  className?: string;
}

function ReactionPickerComponent({
  onSelect,
  onClose,
  className,
}: ReactionPickerProps) {
  // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
  const containerRef = useClickOutside<HTMLDivElement>(onClose);

  // ESC í‚¤ë¡œ ë‹«ê¸°
  useEscapeKey(onClose);

  const handleSelect = (emoji: ReactionEmoji) => {
    onSelect(emoji);
    onClose();
  };

  return (
    <div
      ref={containerRef}
      className={cn(
        "absolute z-50",
        "flex items-center gap-1 p-1.5",
        "bg-bg-primary rounded-lg shadow-lg",
        "border border-border",
        "animate-in fade-in-0 zoom-in-95 duration-150",
        className
      )}
      role="menu"
      aria-label="ë¦¬ì•¡ì…˜ ì„ íƒ"
    >
      {REACTION_EMOJIS.map((emoji) => (
        <button
          key={emoji}
          type="button"
          onClick={() => handleSelect(emoji)}
          className={cn(
            "w-8 h-8 flex items-center justify-center",
            "rounded-md text-lg",
            "hover:bg-bg-secondary hover:scale-110",
            "active:scale-95",
            "transition-all duration-100"
          )}
          role="menuitem"
          aria-label={`${emoji} ë¦¬ì•¡ì…˜ ì¶”ê°€`}
        >
          {emoji}
        </button>
      ))}
    </div>
  );
}

export const ReactionPicker = memo(ReactionPickerComponent);
</file>

<file path="atoms/ReactionPills.tsx">
"use client";

/**
 * ReactionPills - ë©”ì‹œì§€ ë¦¬ì•¡ì…˜ í‘œì‹œ
 *
 * ë©”ì‹œì§€ í•˜ë‹¨ì— ë¦¬ì•¡ì…˜ ìš”ì•½ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * í´ë¦­ ì‹œ í•´ë‹¹ ë¦¬ì•¡ì…˜ì„ í† ê¸€í•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import type { ReactionSummary, ReactionEmoji } from "@/lib/domains/chat/types";

interface ReactionPillsProps {
  /** ë¦¬ì•¡ì…˜ ìš”ì•½ ëª©ë¡ */
  reactions: ReactionSummary[];
  /** ë¦¬ì•¡ì…˜ í† ê¸€ ì½œë°± */
  onToggle: (emoji: ReactionEmoji) => void;
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  /** ì¶”ê°€ í´ë˜ìŠ¤ */
  className?: string;
}

function ReactionPillsComponent({
  reactions,
  onToggle,
  disabled = false,
  className,
}: ReactionPillsProps) {
  // ë¦¬ì•¡ì…˜ì´ ì—†ìœ¼ë©´ ë Œë”ë§í•˜ì§€ ì•ŠìŒ
  if (reactions.length === 0) {
    return null;
  }

  return (
    <div className={cn("flex flex-wrap items-center gap-1", className)}>
      {reactions.map((reaction) => (
        <button
          key={reaction.emoji}
          type="button"
          onClick={() => onToggle(reaction.emoji)}
          disabled={disabled}
          className={cn(
            "inline-flex items-center gap-1 px-2 py-0.5 rounded-full",
            "text-sm transition-colors",
            "hover:bg-bg-tertiary active:scale-95",
            "disabled:opacity-50 disabled:cursor-not-allowed",
            reaction.hasReacted
              ? "bg-primary/10 border border-primary/30"
              : "bg-bg-secondary border border-transparent"
          )}
          aria-label={`${reaction.emoji} ${reaction.count}ëª…ì´ ë¦¬ì•¡ì…˜í•¨${
            reaction.hasReacted ? ", ë‚´ ë¦¬ì•¡ì…˜" : ""
          }`}
        >
          <span className="text-sm leading-none">{reaction.emoji}</span>
          <span
            className={cn(
              "text-xs font-medium",
              reaction.hasReacted ? "text-primary" : "text-text-secondary"
            )}
          >
            {reaction.count}
          </span>
        </button>
      ))}
    </div>
  );
}

export const ReactionPills = memo(ReactionPillsComponent);
</file>

<file path="atoms/TypingIndicator.tsx">
"use client";

/**
 * TypingIndicator - íƒ€ì´í•‘ ì¤‘ í‘œì‹œ
 *
 * ë‹¤ë¥¸ ì‚¬ìš©ìê°€ ë©”ì‹œì§€ë¥¼ ì…ë ¥ ì¤‘ì¼ ë•Œ í‘œì‹œí•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import type { PresenceUser } from "@/lib/domains/chat/types";

interface TypingIndicatorProps {
  /** íƒ€ì´í•‘ ì¤‘ì¸ ì‚¬ìš©ì ëª©ë¡ */
  users: PresenceUser[];
}

function TypingIndicatorComponent({ users }: TypingIndicatorProps) {
  if (users.length === 0) return null;

  // ìµœëŒ€ 2ëª…ê¹Œì§€ ì´ë¦„ í‘œì‹œ
  const displayNames =
    users.length <= 2
      ? users.map((u) => u.name).join(", ")
      : `${users[0].name} ì™¸ ${users.length - 1}ëª…`;

  return (
    <div className="flex items-center gap-2 px-4 py-2 text-sm text-text-tertiary">
      {/* ì• ë‹ˆë©”ì´ì…˜ ì  */}
      <div className="flex items-center gap-0.5">
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:0ms]" />
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:150ms]" />
        <span className="w-1.5 h-1.5 rounded-full bg-text-tertiary animate-bounce [animation-delay:300ms]" />
      </div>

      {/* í…ìŠ¤íŠ¸ */}
      <span>{displayNames}ë‹˜ì´ ì…ë ¥ ì¤‘...</span>
    </div>
  );
}

export const TypingIndicator = memo(TypingIndicatorComponent);
</file>

<file path="atoms/UnreadBadge.tsx">
"use client";

/**
 * UnreadBadge - ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ìˆ˜ ë°°ì§€
 */

import { memo } from "react";
import { cn } from "@/lib/cn";

interface UnreadBadgeProps {
  /** ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ìˆ˜ */
  count: number;
  /** í¬ê¸° */
  size?: "sm" | "md";
  /** ì¶”ê°€ í´ë˜ìŠ¤ */
  className?: string;
}

function UnreadBadgeComponent({
  count,
  size = "md",
  className,
}: UnreadBadgeProps) {
  if (count <= 0) return null;

  const displayCount = count > 99 ? "99+" : count.toString();

  return (
    <span
      className={cn(
        "inline-flex items-center justify-center rounded-full bg-primary text-white font-medium",
        size === "sm" ? "min-w-[18px] h-[18px] text-[10px] px-1" : "min-w-[22px] h-[22px] text-xs px-1.5",
        className
      )}
    >
      {displayCount}
    </span>
  );
}

export const UnreadBadge = memo(UnreadBadgeComponent);
</file>

<file path="molecules/AnnouncementDialog.tsx">
"use client";

/**
 * AnnouncementDialog - ì±„íŒ…ë°© ê³µì§€ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸
 *
 * ê³µì§€ ì‘ì„±/í¸ì§‘ì„ ìœ„í•œ ëª¨ë‹¬ ë‹¤ì´ì–¼ë¡œê·¸ì…ë‹ˆë‹¤.
 */

import { memo, useState, useEffect } from "react";
import { Dialog } from "@/components/ui/Dialog";
import Button from "@/components/atoms/Button";

interface AnnouncementDialogProps {
  /** ë‹¤ì´ì–¼ë¡œê·¸ ì—´ë¦¼ ì—¬ë¶€ */
  open: boolean;
  /** ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸° */
  onOpenChange: (open: boolean) => void;
  /** í˜„ì¬ ê³µì§€ ë‚´ìš© (í¸ì§‘ ì‹œ) */
  currentContent?: string | null;
  /** ì €ì¥ ì½œë°± */
  onSave: (content: string) => void;
  /** ì €ì¥ ì¤‘ ì—¬ë¶€ */
  isSaving?: boolean;
}

function AnnouncementDialogComponent({
  open,
  onOpenChange,
  currentContent,
  onSave,
  isSaving = false,
}: AnnouncementDialogProps) {
  const [content, setContent] = useState(currentContent ?? "");

  // ë‹¤ì´ì–¼ë¡œê·¸ê°€ ì—´ë¦´ ë•Œ í˜„ì¬ ê³µì§€ ë‚´ìš©ìœ¼ë¡œ ì´ˆê¸°í™”
  useEffect(() => {
    if (open) {
      setContent(currentContent ?? "");
    }
  }, [open, currentContent]);

  const handleSave = () => {
    const trimmedContent = content.trim();
    if (trimmedContent) {
      onSave(trimmedContent);
    }
  };

  const isValidContent = content.trim().length > 0 && content.trim().length <= 500;
  const characterCount = content.length;

  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title={currentContent ? "ê³µì§€ í¸ì§‘" : "ê³µì§€ ì„¤ì •"}
      size="md"
    >
      <div className="space-y-4">
        {/* ì…ë ¥ ì˜ì—­ */}
        <div>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="ì±„íŒ…ë°© ê³µì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
            className="w-full h-32 p-3 text-sm border border-border rounded-lg resize-none
              focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent
              bg-background text-text-primary placeholder:text-text-tertiary"
            maxLength={500}
            disabled={isSaving}
          />
          <div className="flex justify-end mt-1">
            <span
              className={`text-xs ${
                characterCount > 500 ? "text-error" : "text-text-tertiary"
              }`}
            >
              {characterCount}/500
            </span>
          </div>
        </div>

        {/* ë²„íŠ¼ ì˜ì—­ */}
        <div className="flex justify-end gap-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={() => onOpenChange(false)}
            disabled={isSaving}
          >
            ì·¨ì†Œ
          </Button>
          <Button
            variant="primary"
            size="sm"
            onClick={handleSave}
            disabled={!isValidContent || isSaving}
          >
            {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
          </Button>
        </div>
      </div>
    </Dialog>
  );
}

export const AnnouncementDialog = memo(AnnouncementDialogComponent);
</file>

<file path="molecules/ChatInput.tsx">
"use client";

/**
 * ChatInput - ë©”ì‹œì§€ ì…ë ¥ ì»´í¬ë„ŒíŠ¸
 *
 * í…ìŠ¤íŠ¸ ì…ë ¥ + ì „ì†¡ ë²„íŠ¼ + ë‹µì¥ í‘œì‹œ
 */

import { memo, useState, useCallback, useRef, useEffect } from "react";
import { cn } from "@/lib/cn";
import { Send, X } from "lucide-react";
import type { ReplyTargetInfo } from "@/lib/domains/chat/types";

interface ChatInputProps {
  /** ë©”ì‹œì§€ ì „ì†¡ í•¸ë“¤ëŸ¬ */
  onSend: (content: string) => void;
  /** ì „ì†¡ ì¤‘ ìƒíƒœ */
  isSending?: boolean;
  /** ë¹„í™œì„±í™” */
  disabled?: boolean;
  /** í”Œë ˆì´ìŠ¤í™€ë” */
  placeholder?: string;
  /** ìµœëŒ€ ê¸€ì ìˆ˜ */
  maxLength?: number;
  /** íƒ€ì´í•‘ ìƒíƒœ ë³€ê²½ í•¸ë“¤ëŸ¬ */
  onTypingChange?: (isTyping: boolean) => void;
  /** ë‹µì¥ ëŒ€ìƒ ë©”ì‹œì§€ ì •ë³´ */
  replyTarget?: ReplyTargetInfo | null;
  /** ë‹µì¥ ì·¨ì†Œ í•¸ë“¤ëŸ¬ */
  onCancelReply?: () => void;
}

function ChatInputComponent({
  onSend,
  isSending = false,
  disabled = false,
  placeholder = "ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”...",
  maxLength = 1000,
  onTypingChange,
  replyTarget,
  onCancelReply,
}: ChatInputProps) {
  const [value, setValue] = useState("");
  const [isComposing, setIsComposing] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // ìë™ ë†’ì´ ì¡°ì ˆ
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${Math.min(textarea.scrollHeight, 120)}px`;
    }
  }, [value]);

  const handleSubmit = useCallback(() => {
    const trimmed = value.trim();
    if (!trimmed || isSending || disabled) return;

    onSend(trimmed);
    setValue("");
    onTypingChange?.(false);

    // ë†’ì´ ì´ˆê¸°í™”
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
    }
  }, [value, isSending, disabled, onSend, onTypingChange]);

  // í•œê¸€ IME ì¡°í•© ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleCompositionStart = useCallback(() => {
    setIsComposing(true);
  }, []);

  const handleCompositionEnd = useCallback(() => {
    setIsComposing(false);
  }, []);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      // Enterë¡œ ì „ì†¡ (Shift+EnterëŠ” ì¤„ë°”ê¿ˆ, í•œê¸€ ì¡°í•© ì¤‘ì—ëŠ” ì „ì†¡ ë°©ì§€)
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        handleSubmit();
      }
    },
    [handleSubmit, isComposing]
  );

  const canSend = value.trim().length > 0 && !isSending && !disabled;

  return (
    <div className="flex flex-col bg-bg-primary border-t border-border">
      {/* ë‹µì¥ ëŒ€ìƒ í‘œì‹œ */}
      {replyTarget && (
        <div className="flex items-center gap-2 px-3 py-2 bg-bg-secondary border-b border-border">
          <div className="w-1 h-8 bg-primary rounded-full flex-shrink-0" />
          <div className="flex-1 min-w-0">
            <p className="text-xs text-primary font-medium">{replyTarget.senderName}ì—ê²Œ ë‹µì¥</p>
            <p className="text-xs text-text-secondary truncate">
              {replyTarget.isDeleted ? "ì‚­ì œëœ ë©”ì‹œì§€" : replyTarget.content}
            </p>
          </div>
          {onCancelReply && (
            <button
              type="button"
              onClick={onCancelReply}
              className="p-1 hover:bg-bg-tertiary rounded-full transition-colors"
              aria-label="ë‹µì¥ ì·¨ì†Œ"
            >
              <X className="w-4 h-4 text-text-tertiary" />
            </button>
          )}
        </div>
      )}

      <div className="flex items-end gap-2 p-3">
        {/* í…ìŠ¤íŠ¸ ì…ë ¥ */}
        <div className="flex-1 relative">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={(e) => {
              const newValue = e.target.value.slice(0, maxLength);
              setValue(newValue);
              onTypingChange?.(newValue.length > 0);
            }}
            onKeyDown={handleKeyDown}
            onCompositionStart={handleCompositionStart}
            onCompositionEnd={handleCompositionEnd}
            placeholder={placeholder}
            disabled={disabled}
            rows={1}
            className={cn(
              "w-full resize-none rounded-2xl px-4 py-2.5 text-sm",
              "bg-bg-secondary text-text-primary placeholder:text-text-tertiary",
              "border border-transparent focus:border-primary focus:outline-none",
              "transition-colors",
              disabled && "opacity-50 cursor-not-allowed"
            )}
          />
          {/* ê¸€ì ìˆ˜ í‘œì‹œ (ì„ê³„ì¹˜ ê·¼ì²˜) */}
          {value.length > maxLength * 0.8 && (
            <span
              className={cn(
                "absolute right-3 bottom-1 text-[10px]",
                value.length >= maxLength ? "text-error" : "text-text-tertiary"
              )}
            >
              {value.length}/{maxLength}
            </span>
          )}
        </div>

        {/* ì „ì†¡ ë²„íŠ¼ */}
        <button
          type="button"
          onClick={handleSubmit}
          disabled={!canSend}
          className={cn(
            "flex items-center justify-center w-10 h-10 rounded-full",
            "transition-colors",
            canSend
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          <Send className="w-5 h-5" />
        </button>
      </div>
    </div>
  );
}

export const ChatInput = memo(ChatInputComponent);
</file>

<file path="molecules/ChatRoomCard.tsx">
"use client";

/**
 * ChatRoomCard - ì±„íŒ…ë°© ëª©ë¡ ì¹´ë“œ
 *
 * ì±„íŒ…ë°© ëª©ë¡ì—ì„œ ê° ë°©ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import { cn } from "@/lib/cn";
import { formatDistanceToNow } from "date-fns";
import { ko } from "date-fns/locale";
import { Avatar } from "@/components/atoms/Avatar";
import { UnreadBadge } from "../atoms/UnreadBadge";
import { Users } from "lucide-react";
import type { ChatRoomListItem } from "@/lib/domains/chat/types";

interface ChatRoomCardProps {
  /** ì±„íŒ…ë°© ì •ë³´ */
  room: ChatRoomListItem;
  /** í´ë¦­ í•¸ë“¤ëŸ¬ */
  onClick: () => void;
  /** ì„ íƒ ìƒíƒœ */
  isSelected?: boolean;
}

function ChatRoomCardComponent({
  room,
  onClick,
  isSelected = false,
}: ChatRoomCardProps) {
  // í‘œì‹œí•  ì´ë¦„ ê²°ì •
  const displayName =
    room.type === "direct"
      ? room.otherUser?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ"
      : room.name ?? `ê·¸ë£¹ (${room.memberCount}ëª…)`;

  // ì‹œê°„ í¬ë§·
  const timeDisplay = room.lastMessage
    ? formatDistanceToNow(new Date(room.lastMessage.createdAt), {
        addSuffix: true,
        locale: ko,
      })
    : "";

  return (
    <button
      type="button"
      onClick={onClick}
      className={cn(
        "w-full flex items-center gap-3 p-3 rounded-xl",
        "transition-colors text-left",
        isSelected ? "bg-primary/10" : "hover:bg-bg-secondary"
      )}
    >
      {/* ì•„ë°”íƒ€ */}
      <div className="relative flex-shrink-0">
        {room.type === "direct" && room.otherUser ? (
          <Avatar
            name={room.otherUser.name}
            src={room.otherUser.profileImageUrl}
            size="md"
          />
        ) : (
          <div className="w-11 h-11 rounded-full bg-bg-tertiary flex items-center justify-center">
            <Users className="w-5 h-5 text-text-secondary" />
          </div>
        )}
      </div>

      {/* ì •ë³´ */}
      <div className="flex-1 min-w-0 flex flex-col gap-0.5">
        <div className="flex items-center justify-between gap-2">
          <span className="font-medium text-text-primary truncate">
            {displayName}
          </span>
          {timeDisplay && (
            <span className="text-xs text-text-tertiary flex-shrink-0">
              {timeDisplay}
            </span>
          )}
        </div>

        <div className="flex items-center justify-between gap-2">
          <span className="text-sm text-text-secondary truncate">
            {room.lastMessage ? (
              <>
                {room.type === "group" && (
                  <span className="text-text-tertiary">
                    {room.lastMessage.senderName}:{" "}
                  </span>
                )}
                {room.lastMessage.content}
              </>
            ) : (
              <span className="text-text-tertiary">ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤</span>
            )}
          </span>

          {room.unreadCount > 0 && (
            <UnreadBadge count={room.unreadCount} size="sm" />
          )}
        </div>
      </div>
    </button>
  );
}

export const ChatRoomCard = memo(ChatRoomCardComponent);
</file>

<file path="molecules/MessageContextMenu.tsx">
"use client";

/**
 * MessageContextMenu - ë©”ì‹œì§€ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
 *
 * ë©”ì‹œì§€ë¥¼ ê¸¸ê²Œ ëˆ„ë¥´ê±°ë‚˜ ìš°í´ë¦­ ì‹œ ë‚˜íƒ€ë‚˜ëŠ” í•˜ë‹¨ ì‹œíŠ¸ ë©”ë‰´ì…ë‹ˆë‹¤.
 * ë¦¬ì•¡ì…˜ ì¶”ê°€, ë³µì‚¬, ë‹µì¥, í¸ì§‘, ì‚­ì œ, ì‹ ê³  ë“±ì˜ ì•¡ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.
 */

import { memo, useEffect } from "react";
import { createPortal } from "react-dom";
import { cn } from "@/lib/cn";
import { useClickOutside, useEscapeKey } from "@/lib/accessibility/hooks";
import { REACTION_EMOJIS, type ReactionEmoji } from "@/lib/domains/chat/types";
import { Copy, Reply, Edit2, Trash2, Flag, Pin, PinOff } from "lucide-react";

/** ë©”ì‹œì§€ ë©”ë‰´ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ */
export interface MessageMenuContext {
  /** ë©”ì‹œì§€ ID */
  messageId: string;
  /** ë©”ì‹œì§€ ë‚´ìš© */
  content: string;
  /** ë³¸ì¸ ë©”ì‹œì§€ ì—¬ë¶€ */
  isOwn: boolean;
  /** í¸ì§‘ ê°€ëŠ¥ ì—¬ë¶€ */
  canEdit: boolean;
  /** ê³ ì • ê¶Œí•œ ì—¬ë¶€ */
  canPin: boolean;
  /** í˜„ì¬ ê³ ì • ìƒíƒœ */
  isPinned: boolean;
}

interface MessageContextMenuProps {
  /** ë©”ë‰´ ì—´ë¦¼ ìƒíƒœ */
  isOpen: boolean;
  /** ë©”ë‰´ ë‹«ê¸° ì½œë°± */
  onClose: () => void;
  /** ë©”ì‹œì§€ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ */
  context: MessageMenuContext | null;
  /** ë³µì‚¬ í´ë¦­ ì½œë°± */
  onCopy: () => void;
  /** ë‹µì¥ í´ë¦­ ì½œë°± */
  onReply: () => void;
  /** í¸ì§‘ í´ë¦­ ì½œë°± (ë³¸ì¸ ë©”ì‹œì§€ + í¸ì§‘ ê°€ëŠ¥ ì‹œ) */
  onEdit?: () => void;
  /** ì‚­ì œ í´ë¦­ ì½œë°± (ë³¸ì¸ ë©”ì‹œì§€) */
  onDelete?: () => void;
  /** ì‹ ê³  í´ë¦­ ì½œë°± (íƒ€ì¸ ë©”ì‹œì§€) */
  onReport?: () => void;
  /** ê³ ì •/í•´ì œ í´ë¦­ ì½œë°± (ê³ ì • ê¶Œí•œ ìˆì„ ë•Œ) */
  onTogglePin?: () => void;
  /** ë¦¬ì•¡ì…˜ í† ê¸€ ì½œë°± */
  onToggleReaction: (emoji: ReactionEmoji) => void;
}

function MessageContextMenuComponent({
  isOpen,
  onClose,
  context,
  onCopy,
  onReply,
  onEdit,
  onDelete,
  onReport,
  onTogglePin,
  onToggleReaction,
}: MessageContextMenuProps) {
  // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
  const sheetRef = useClickOutside<HTMLDivElement>(onClose, isOpen);

  // ESC í‚¤ë¡œ ë‹«ê¸°
  useEscapeKey(onClose, isOpen);

  // ë©”ë‰´ ì—´ë ¸ì„ ë•Œ body ìŠ¤í¬ë¡¤ ë°©ì§€
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
      return () => {
        document.body.style.overflow = "";
      };
    }
  }, [isOpen]);

  if (!isOpen || !context) return null;

  const handleReactionClick = (emoji: ReactionEmoji) => {
    onToggleReaction(emoji);
  };

  const menuContent = (
    <>
      {/* ë”¤ ë°°ê²½ */}
      <div
        className={cn(
          "fixed inset-0 z-40 bg-black/50",
          "animate-in fade-in-0 duration-200"
        )}
        aria-hidden="true"
      />

      {/* í•˜ë‹¨ ì‹œíŠ¸ */}
      <div
        ref={sheetRef}
        className={cn(
          "fixed inset-x-0 bottom-0 z-50",
          "bg-bg-primary rounded-t-2xl",
          "animate-in slide-in-from-bottom duration-200",
          "pb-safe max-h-[80vh] overflow-y-auto"
        )}
        role="dialog"
        aria-modal="true"
        aria-label="ë©”ì‹œì§€ ë©”ë‰´"
      >
        {/* ë“œë˜ê·¸ í•¸ë“¤ ë°” */}
        <div className="flex justify-center pt-3 pb-2">
          <div className="w-10 h-1 bg-secondary-300 dark:bg-secondary-600 rounded-full" />
        </div>

        {/* ë¹ ë¥¸ ë¦¬ì•¡ì…˜ ë°” */}
        <div className="flex justify-center gap-2 px-4 py-3">
          {REACTION_EMOJIS.map((emoji) => (
            <button
              key={emoji}
              type="button"
              onClick={() => handleReactionClick(emoji)}
              className={cn(
                "w-11 h-11 flex items-center justify-center",
                "rounded-full text-2xl",
                "bg-secondary-100 dark:bg-secondary-800",
                "hover:bg-secondary-200 dark:hover:bg-secondary-700",
                "active:scale-95",
                "transition-all duration-100"
              )}
              aria-label={`${emoji} ë¦¬ì•¡ì…˜ ì¶”ê°€`}
            >
              {emoji}
            </button>
          ))}
        </div>

        {/* êµ¬ë¶„ì„  */}
        <div className="px-4">
          <div className="h-px bg-border" />
        </div>

        {/* ì•¡ì…˜ ëª©ë¡ */}
        <div className="py-2">
          {/* ë³µì‚¬ - í•­ìƒ í‘œì‹œ */}
          <button
            type="button"
            onClick={onCopy}
            className={cn(
              "w-full flex items-center gap-3 px-4 py-3",
              "hover:bg-bg-secondary active:bg-bg-tertiary",
              "transition-colors text-text-primary"
            )}
          >
            <Copy className="w-5 h-5 text-text-secondary" />
            <span>ë³µì‚¬</span>
          </button>

          {/* ë‹µì¥ - í•­ìƒ í‘œì‹œ */}
          <button
            type="button"
            onClick={onReply}
            className={cn(
              "w-full flex items-center gap-3 px-4 py-3",
              "hover:bg-bg-secondary active:bg-bg-tertiary",
              "transition-colors text-text-primary"
            )}
          >
            <Reply className="w-5 h-5 text-text-secondary" />
            <span>ë‹µì¥</span>
          </button>

          {/* í¸ì§‘ - ë³¸ì¸ ë©”ì‹œì§€ + í¸ì§‘ ê°€ëŠ¥ ì‹œ */}
          {context.isOwn && context.canEdit && onEdit && (
            <button
              type="button"
              onClick={onEdit}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-text-primary"
              )}
            >
              <Edit2 className="w-5 h-5 text-text-secondary" />
              <span>í¸ì§‘</span>
            </button>
          )}

          {/* ê³ ì •/í•´ì œ - ê³ ì • ê¶Œí•œ ìˆì„ ë•Œ */}
          {context.canPin && onTogglePin && (
            <button
              type="button"
              onClick={onTogglePin}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-text-primary"
              )}
            >
              {context.isPinned ? (
                <>
                  <PinOff className="w-5 h-5 text-text-secondary" />
                  <span>ê³ ì • í•´ì œ</span>
                </>
              ) : (
                <>
                  <Pin className="w-5 h-5 text-text-secondary" />
                  <span>ê³ ì •</span>
                </>
              )}
            </button>
          )}

          {/* ì‚­ì œ - ë³¸ì¸ ë©”ì‹œì§€ (ìœ„í—˜ ìŠ¤íƒ€ì¼) */}
          {context.isOwn && onDelete && (
            <button
              type="button"
              onClick={onDelete}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-error"
              )}
            >
              <Trash2 className="w-5 h-5" />
              <span>ì‚­ì œ</span>
            </button>
          )}

          {/* ì‹ ê³  - íƒ€ì¸ ë©”ì‹œì§€ (ìœ„í—˜ ìŠ¤íƒ€ì¼) */}
          {!context.isOwn && onReport && (
            <button
              type="button"
              onClick={onReport}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3",
                "hover:bg-bg-secondary active:bg-bg-tertiary",
                "transition-colors text-error"
              )}
            >
              <Flag className="w-5 h-5" />
              <span>ì‹ ê³ </span>
            </button>
          )}
        </div>

        {/* ì·¨ì†Œ ë²„íŠ¼ */}
        <div className="px-4 pb-4">
          <button
            type="button"
            onClick={onClose}
            className={cn(
              "w-full py-3 rounded-xl",
              "bg-secondary-100 dark:bg-secondary-800",
              "hover:bg-secondary-200 dark:hover:bg-secondary-700",
              "text-text-primary font-medium",
              "transition-colors"
            )}
          >
            ì·¨ì†Œ
          </button>
        </div>
      </div>
    </>
  );

  // Portalë¡œ bodyì— ì§ì ‘ ë Œë”ë§
  if (typeof window === "undefined") return null;
  return createPortal(menuContent, document.body);
}

export const MessageContextMenu = memo(MessageContextMenuComponent);
</file>

<file path="molecules/MessageSearch.tsx">
"use client";

/**
 * MessageSearch - ì±„íŒ…ë°© ë‚´ ë©”ì‹œì§€ ê²€ìƒ‰ ì»´í¬ë„ŒíŠ¸
 *
 * ê²€ìƒ‰ì–´ ì…ë ¥ ë° ê²°ê³¼ í‘œì‹œ
 * ê²€ìƒ‰ ê²°ê³¼ í´ë¦­ ì‹œ í•´ë‹¹ ë©”ì‹œì§€ë¡œ ìŠ¤í¬ë¡¤
 */

import { useState, useCallback, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { cn } from "@/lib/cn";
import { Search, X, Loader2 } from "lucide-react";
import { searchMessagesAction } from "@/lib/domains/chat/actions/messages";
import type { ChatMessageWithSender } from "@/lib/domains/chat/types";
import { formatDistanceToNow } from "date-fns";
import { ko } from "date-fns/locale";

interface MessageSearchProps {
  /** ì±„íŒ…ë°© ID */
  roomId: string;
  /** ê²€ìƒ‰ ëª¨ë“œ ì¢…ë£Œ */
  onClose: () => void;
  /** ê²€ìƒ‰ ê²°ê³¼ ë©”ì‹œì§€ í´ë¦­ */
  onSelectMessage: (messageId: string) => void;
}

export function MessageSearch({
  roomId,
  onClose,
  onSelectMessage,
}: MessageSearchProps) {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);

  // ìë™ í¬ì»¤ìŠ¤
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  // Debounce ê²€ìƒ‰ì–´
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query.trim());
    }, 300);

    return () => clearTimeout(timer);
  }, [query]);

  // ê²€ìƒ‰ ì¿¼ë¦¬
  const { data, isLoading, error } = useQuery({
    queryKey: ["chat-search", roomId, debouncedQuery],
    queryFn: async () => {
      if (!debouncedQuery) return null;
      const result = await searchMessagesAction(roomId, debouncedQuery, {
        limit: 20,
      });
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    enabled: debouncedQuery.length > 0,
  });

  // ê²€ìƒ‰ì–´ í•˜ì´ë¼ì´íŠ¸
  const highlightText = useCallback(
    (text: string, searchQuery: string) => {
      if (!searchQuery) return text;

      const parts = text.split(new RegExp(`(${searchQuery})`, "gi"));
      return parts.map((part, i) =>
        part.toLowerCase() === searchQuery.toLowerCase() ? (
          <mark key={i} className="bg-warning/30 text-text-primary rounded px-0.5">
            {part}
          </mark>
        ) : (
          part
        )
      );
    },
    []
  );

  return (
    <div className="flex flex-col h-full bg-bg-primary">
      {/* ê²€ìƒ‰ ì…ë ¥ì°½ */}
      <div className="flex items-center gap-2 p-3 border-b border-border">
        <Search className="w-5 h-5 text-text-tertiary flex-shrink-0" />
        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="ë©”ì‹œì§€ ê²€ìƒ‰..."
          className={cn(
            "flex-1 bg-transparent text-text-primary",
            "placeholder:text-text-tertiary",
            "focus:outline-none"
          )}
        />
        {query && (
          <button
            type="button"
            onClick={() => setQuery("")}
            className="p-1 text-text-tertiary hover:text-text-secondary"
          >
            <X className="w-4 h-4" />
          </button>
        )}
        <button
          type="button"
          onClick={onClose}
          className="text-sm text-text-secondary hover:text-text-primary"
        >
          ì·¨ì†Œ
        </button>
      </div>

      {/* ê²€ìƒ‰ ê²°ê³¼ */}
      <div className="flex-1 overflow-y-auto">
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
          </div>
        ) : error ? (
          <div className="flex items-center justify-center py-8 text-error">
            ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
          </div>
        ) : !debouncedQuery ? (
          <div className="flex items-center justify-center py-8 text-text-tertiary">
            ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”
          </div>
        ) : data?.messages.length === 0 ? (
          <div className="flex items-center justify-center py-8 text-text-tertiary">
            &ldquo;{debouncedQuery}&rdquo; ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
          </div>
        ) : (
          <div className="divide-y divide-border">
            {/* ê²€ìƒ‰ ê²°ê³¼ í—¤ë” */}
            {data && (
              <div className="px-4 py-2 text-xs text-text-tertiary bg-bg-secondary">
                {data.total}ê°œì˜ ê²°ê³¼
              </div>
            )}

            {/* ê²°ê³¼ ëª©ë¡ */}
            {data?.messages.map((message) => (
              <SearchResultItem
                key={message.id}
                message={message}
                query={debouncedQuery}
                highlightText={highlightText}
                onSelect={() => onSelectMessage(message.id)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

interface SearchResultItemProps {
  message: ChatMessageWithSender;
  query: string;
  highlightText: (text: string, query: string) => React.ReactNode;
  onSelect: () => void;
}

function SearchResultItem({
  message,
  query,
  highlightText,
  onSelect,
}: SearchResultItemProps) {
  const timeAgo = formatDistanceToNow(new Date(message.created_at), {
    addSuffix: true,
    locale: ko,
  });

  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        "w-full px-4 py-3 text-left",
        "hover:bg-bg-secondary transition-colors"
      )}
    >
      <div className="flex items-center justify-between gap-2">
        <span className="text-sm font-medium text-text-primary">
          {message.sender.name}
        </span>
        <span className="text-xs text-text-tertiary flex-shrink-0">
          {timeAgo}
        </span>
      </div>
      <p className="text-sm text-text-secondary line-clamp-2">
        {highlightText(message.content, query)}
      </p>
    </button>
  );
}
</file>

<file path="molecules/PinnedMessagesBar.tsx">
"use client";

/**
 * PinnedMessagesBar - ê³ ì • ë©”ì‹œì§€ ë°”
 *
 * ì±„íŒ…ë°© ìƒë‹¨ì— ê³ ì •ëœ ë©”ì‹œì§€ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 * í´ë¦­ ì‹œ í•´ë‹¹ ë©”ì‹œì§€ë¡œ ìŠ¤í¬ë¡¤, ê´€ë¦¬ìëŠ” ê³ ì • í•´ì œ ê°€ëŠ¥.
 */

import { memo, useState } from "react";
import { cn } from "@/lib/cn";
import { Pin, ChevronDown, ChevronUp, X } from "lucide-react";
import type { PinnedMessageWithContent } from "@/lib/domains/chat/types";

interface PinnedMessagesBarProps {
  /** ê³ ì •ëœ ë©”ì‹œì§€ ëª©ë¡ */
  pinnedMessages: PinnedMessageWithContent[];
  /** ê³ ì • í•´ì œ ê¶Œí•œ ì—¬ë¶€ */
  canUnpin: boolean;
  /** ë©”ì‹œì§€ í´ë¦­ ì‹œ ìŠ¤í¬ë¡¤ */
  onMessageClick: (messageId: string) => void;
  /** ê³ ì • í•´ì œ ì½œë°± */
  onUnpin?: (messageId: string) => void;
}

function PinnedMessagesBarComponent({
  pinnedMessages,
  canUnpin,
  onMessageClick,
  onUnpin,
}: PinnedMessagesBarProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);

  if (pinnedMessages.length === 0) {
    return null;
  }

  // ë‹¨ì¼ ë©”ì‹œì§€ ëª¨ë“œ (í¼ì¹¨ ë²„íŠ¼ í‘œì‹œ)
  if (!isExpanded && pinnedMessages.length === 1) {
    const pinned = pinnedMessages[0];
    return (
      <div className="flex items-center gap-2 px-4 py-2 bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
        <Pin className="w-4 h-4 text-primary flex-shrink-0" />
        <button
          type="button"
          onClick={() => onMessageClick(pinned.message_id)}
          className="flex-1 text-left text-sm truncate hover:text-primary transition-colors"
        >
          <span className="font-medium text-primary">
            {pinned.message.senderName}:
          </span>{" "}
          <span className="text-text-secondary">
            {pinned.message.isDeleted ? "ì‚­ì œëœ ë©”ì‹œì§€" : pinned.message.content}
          </span>
        </button>
        {canUnpin && onUnpin && (
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              onUnpin(pinned.message_id);
            }}
            className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
            aria-label="ê³ ì • í•´ì œ"
          >
            <X className="w-3 h-3 text-text-tertiary hover:text-error" />
          </button>
        )}
      </div>
    );
  }

  // ì¶•ì†Œ ëª¨ë“œ (ì—¬ëŸ¬ ê°œ - ìºëŸ¬ì…€ í˜•íƒœ)
  if (!isExpanded && pinnedMessages.length > 1) {
    const pinned = pinnedMessages[currentIndex];
    return (
      <div className="flex items-center gap-2 px-4 py-2 bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
        <Pin className="w-4 h-4 text-primary flex-shrink-0" />
        <button
          type="button"
          onClick={() => onMessageClick(pinned.message_id)}
          className="flex-1 text-left text-sm truncate hover:text-primary transition-colors"
        >
          <span className="font-medium text-primary">
            {pinned.message.senderName}:
          </span>{" "}
          <span className="text-text-secondary">
            {pinned.message.isDeleted ? "ì‚­ì œëœ ë©”ì‹œì§€" : pinned.message.content}
          </span>
        </button>
        <span className="text-xs text-text-tertiary">
          {currentIndex + 1}/{pinnedMessages.length}
        </span>
        <button
          type="button"
          onClick={() => setCurrentIndex((i) => (i + 1) % pinnedMessages.length)}
          className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
          aria-label="ë‹¤ìŒ ê³ ì • ë©”ì‹œì§€"
        >
          <ChevronDown className="w-4 h-4 text-text-tertiary" />
        </button>
        <button
          type="button"
          onClick={() => setIsExpanded(true)}
          className="text-xs text-primary hover:underline"
        >
          ì „ì²´ ë³´ê¸°
        </button>
      </div>
    );
  }

  // í™•ì¥ ëª¨ë“œ (ì „ì²´ ëª©ë¡)
  return (
    <div className="bg-primary-50 dark:bg-primary-900/20 border-b border-primary-100 dark:border-primary-900/30">
      <div className="flex items-center justify-between px-4 py-2">
        <div className="flex items-center gap-2">
          <Pin className="w-4 h-4 text-primary" />
          <span className="text-sm font-medium text-primary">
            ê³ ì •ëœ ë©”ì‹œì§€ ({pinnedMessages.length})
          </span>
        </div>
        <button
          type="button"
          onClick={() => setIsExpanded(false)}
          className="p-1 hover:bg-primary-100 dark:hover:bg-primary-900/30 rounded transition-colors"
          aria-label="ì ‘ê¸°"
        >
          <ChevronUp className="w-4 h-4 text-text-tertiary" />
        </button>
      </div>
      <div className="max-h-40 overflow-y-auto">
        {pinnedMessages.map((pinned) => (
          <div
            key={pinned.id}
            className={cn(
              "flex items-center gap-2 px-4 py-2",
              "hover:bg-primary-100/50 dark:hover:bg-primary-900/40 transition-colors cursor-pointer"
            )}
          >
            <button
              type="button"
              onClick={() => onMessageClick(pinned.message_id)}
              className="flex-1 text-left text-sm truncate"
            >
              <span className="font-medium text-primary">
                {pinned.message.senderName}:
              </span>{" "}
              <span className="text-text-secondary">
                {pinned.message.isDeleted ? "ì‚­ì œëœ ë©”ì‹œì§€" : pinned.message.content}
              </span>
            </button>
            {canUnpin && onUnpin && (
              <button
                type="button"
                onClick={(e) => {
                  e.stopPropagation();
                  onUnpin(pinned.message_id);
                }}
                className="p-1 hover:bg-primary-200 dark:hover:bg-primary-800 rounded transition-colors"
                aria-label="ê³ ì • í•´ì œ"
              >
                <X className="w-3 h-3 text-text-tertiary hover:text-error" />
              </button>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}

export const PinnedMessagesBar = memo(PinnedMessagesBarComponent);
</file>

<file path="organisms/ChatList.tsx">
"use client";

/**
 * ChatList - ì±„íŒ…ë°© ëª©ë¡
 *
 * ì‚¬ìš©ìì˜ ì±„íŒ…ë°© ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 */

import { memo } from "react";
import { useQuery } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { getChatRoomsAction } from "@/lib/domains/chat/actions";
import { ChatRoomCard } from "../molecules/ChatRoomCard";
import { MessageSquarePlus, Loader2 } from "lucide-react";

interface ChatListProps {
  /** í˜„ì¬ ì„ íƒëœ ì±„íŒ…ë°© ID */
  selectedRoomId?: string;
  /** ì±„íŒ…ë°© í´ë¦­ í•¸ë“¤ëŸ¬ */
  onRoomClick?: (roomId: string) => void;
  /** ìƒˆ ì±„íŒ… ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬ */
  onNewChat?: () => void;
  /** ë¼ìš°íŠ¸ ê¸°ë³¸ ê²½ë¡œ (ì˜ˆ: /chat ë˜ëŠ” /admin/chat) */
  basePath?: string;
}

function ChatListComponent({
  selectedRoomId,
  onRoomClick,
  onNewChat,
  basePath = "/chat",
}: ChatListProps) {
  const router = useRouter();

  // ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ
  const { data, isLoading, error } = useQuery({
    queryKey: ["chat-rooms"],
    queryFn: async () => {
      const result = await getChatRoomsAction();
      if (!result.success) {
        throw new Error(result.error);
      }
      return result.data;
    },
    staleTime: 30 * 1000, // 30ì´ˆ
  });

  const handleRoomClick = (roomId: string) => {
    if (onRoomClick) {
      onRoomClick(roomId);
    } else {
      router.push(`${basePath}/${roomId}`);
    }
  };

  // ë¡œë”© ìƒíƒœ
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-40">
        <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
      </div>
    );
  }

  // ì—ëŸ¬ ìƒíƒœ
  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-40 text-center px-4 gap-1">
        <p className="text-text-secondary text-sm">
          ì±„íŒ… ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
        </p>
        <p className="text-text-tertiary text-xs">
          {error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}
        </p>
      </div>
    );
  }

  const rooms = data ?? [];

  return (
    <div className="flex flex-col h-full">
      {/* í—¤ë” */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-border">
        <h2 className="font-semibold text-lg text-text-primary">ì±„íŒ…</h2>
        {onNewChat && (
          <button
            type="button"
            onClick={onNewChat}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
            title="ìƒˆ ì±„íŒ…"
          >
            <MessageSquarePlus className="w-5 h-5 text-text-secondary" />
          </button>
        )}
      </div>

      {/* ì±„íŒ…ë°© ëª©ë¡ */}
      <div className="flex-1 overflow-y-auto px-2 py-2">
        {rooms.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-center px-4 gap-3">
            <p className="text-text-secondary text-sm">ì•„ì§ ì±„íŒ…ì´ ì—†ìŠµë‹ˆë‹¤</p>
            {onNewChat && (
              <button
                type="button"
                onClick={onNewChat}
                className="text-primary text-sm font-medium hover:underline"
              >
                ìƒˆ ì±„íŒ… ì‹œì‘í•˜ê¸°
              </button>
            )}
          </div>
        ) : (
          <div className="space-y-1">
            {rooms.map((room) => (
              <ChatRoomCard
                key={room.id}
                room={room}
                onClick={() => handleRoomClick(room.id)}
                isSelected={room.id === selectedRoomId}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

export const ChatList = memo(ChatListComponent);
</file>

<file path="organisms/ChatRoom.tsx">
"use client";

/**
 * ChatRoom - ì±„íŒ…ë°© ì „ì²´ ë·°
 *
 * ë©”ì‹œì§€ ëª©ë¡ + ì…ë ¥ì°½ì„ í¬í•¨í•©ë‹ˆë‹¤.
 */

import { memo, useEffect, useRef, useCallback, useState, useMemo } from "react";
import { useInfiniteQuery, useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  getMessagesWithReadStatusAction,
  sendMessageAction,
  markAsReadAction,
  getChatRoomDetailAction,
  editMessageAction,
  deleteMessageAction,
  toggleReactionAction,
  getPinnedMessagesAction,
  pinMessageAction,
  unpinMessageAction,
  canPinMessagesAction,
  getAnnouncementAction,
  setAnnouncementAction,
  canSetAnnouncementAction,
} from "@/lib/domains/chat/actions";
import { isMessageEdited, type ReactionEmoji, type ReplyTargetInfo, type PinnedMessageWithContent, type AnnouncementInfo } from "@/lib/domains/chat/types";
import { processMessagesWithGrouping } from "@/lib/domains/chat/messageGrouping";
import { useChatRealtime, useChatPresence } from "@/lib/realtime";
import { useDebouncedCallback } from "@/lib/hooks/useDebounce";
import { cn } from "@/lib/cn";
import { MessageBubble } from "../atoms/MessageBubble";
import { DateDivider } from "../atoms/DateDivider";
import { TypingIndicator } from "../atoms/TypingIndicator";
import { OnlineStatus } from "../atoms/OnlineStatus";
import { ChatInput } from "../molecules/ChatInput";
import { MessageSearch } from "../molecules/MessageSearch";
import { PinnedMessagesBar } from "../molecules/PinnedMessagesBar";
import { AnnouncementBanner } from "../atoms/AnnouncementBanner";
import { AnnouncementDialog } from "../molecules/AnnouncementDialog";
import { MessageContextMenu, type MessageMenuContext } from "../molecules/MessageContextMenu";
import { ChatRoomInfo } from "./ChatRoomInfo";
import { Loader2, ArrowLeft, MoreVertical, Search, Megaphone, ChevronDown } from "lucide-react";
import { Virtuoso, type VirtuosoHandle } from "react-virtuoso";

interface ChatRoomProps {
  /** ì±„íŒ…ë°© ID */
  roomId: string;
  /** í˜„ì¬ ì‚¬ìš©ì ID */
  userId: string;
  /** ë’¤ë¡œ ê°€ê¸° í•¸ë“¤ëŸ¬ */
  onBack?: () => void;
  /** ë©”ë‰´ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬ */
  onMenuClick?: () => void;
}

function ChatRoomComponent({
  roomId,
  userId,
  onBack,
  onMenuClick,
}: ChatRoomProps) {
  const queryClient = useQueryClient();
  const virtuosoRef = useRef<VirtuosoHandle>(null);
  const messageRefs = useRef<Map<string, HTMLDivElement>>(new Map());
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [isSearchMode, setIsSearchMode] = useState(false);
  const [replyTarget, setReplyTarget] = useState<ReplyTargetInfo | null>(null);
  const [isAnnouncementDialogOpen, setIsAnnouncementDialogOpen] = useState(false);
  const [firstItemIndex, setFirstItemIndex] = useState(10000); // ì—­ë°©í–¥ ìŠ¤í¬ë¡¤ìš©
  const [hasNewMessages, setHasNewMessages] = useState(false); // ìƒˆ ë©”ì‹œì§€ ë°°ì§€ìš©
  const [menuContext, setMenuContext] = useState<MessageMenuContext | null>(null); // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
  const [isMenuOpen, setIsMenuOpen] = useState(false); // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì—´ë¦¼ ìƒíƒœ
  const [isInfoOpen, setIsInfoOpen] = useState(false); // ì±„íŒ…ë°© ì •ë³´ ì‚¬ì´ë“œë°”

  // ìŠ¤í¬ë¡¤ ë§¨ ì•„ë˜ë¡œ (Virtuoso ë°©ì‹)
  const scrollToBottom = useCallback(() => {
    virtuosoRef.current?.scrollToIndex({
      index: "LAST",
      behavior: "smooth",
    });
  }, []);

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³€ê²½ í•¸ë“¤ëŸ¬ (ë°°ì§€ ì´ˆê¸°í™” í¬í•¨)
  const handleAtBottomChange = useCallback((atBottom: boolean) => {
    setIsAtBottom(atBottom);
    if (atBottom) {
      setHasNewMessages(false); // ë§¨ ì•„ë˜ ë„ë‹¬ ì‹œ ë°°ì§€ ì´ˆê¸°í™”
    }
  }, []);

  // ì±„íŒ…ë°© ì •ë³´ ì‚¬ì´ë“œë°” ì—´ê¸°/ë‹«ê¸°
  const handleInfoOpen = useCallback(() => {
    setIsInfoOpen(true);
  }, []);

  const handleInfoClose = useCallback(() => {
    setIsInfoOpen(false);
  }, []);

  // ì±„íŒ…ë°© ì •ë³´ ì¡°íšŒ
  const { data: roomData } = useQuery({
    queryKey: ["chat-room", roomId],
    queryFn: async () => {
      const result = await getChatRoomDetailAction(roomId);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
  });

  // ê³ ì • ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
  const { data: pinnedMessages = [] } = useQuery({
    queryKey: ["chat-pinned", roomId],
    queryFn: async () => {
      const result = await getPinnedMessagesAction(roomId);
      if (!result.success) return [];
      return result.data ?? [];
    },
  });

  // ê³ ì • ê¶Œí•œ í™•ì¸
  const { data: canPinData } = useQuery({
    queryKey: ["chat-can-pin", roomId],
    queryFn: async () => {
      const result = await canPinMessagesAction(roomId);
      if (!result.success) return { canPin: false };
      return result.data ?? { canPin: false };
    },
  });

  const canPin = canPinData?.canPin ?? false;

  // ê³µì§€ ì¡°íšŒ
  const { data: announcementData } = useQuery({
    queryKey: ["chat-announcement", roomId],
    queryFn: async () => {
      const result = await getAnnouncementAction(roomId);
      if (!result.success) return null;
      return result.data;
    },
  });

  // ê³µì§€ ì„¤ì • ê¶Œí•œ í™•ì¸
  const { data: canSetAnnouncementData } = useQuery({
    queryKey: ["chat-can-set-announcement", roomId],
    queryFn: async () => {
      const result = await canSetAnnouncementAction(roomId);
      if (!result.success) return { canSet: false };
      return result.data ?? { canSet: false };
    },
  });

  const canSetAnnouncement = canSetAnnouncementData?.canSet ?? false;

  // ê³ ì •ëœ ë©”ì‹œì§€ ID Set (ë¹ ë¥¸ ì¡°íšŒìš©) - useMemoë¡œ ì•ˆì •ì ì¸ ì°¸ì¡° ì œê³µ
  const pinnedMessageIds = useMemo(
    () => new Set(pinnedMessages.map((p: PinnedMessageWithContent) => p.message_id)),
    [pinnedMessages]
  );

  // ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ (ì½ìŒ ìƒíƒœ í¬í•¨, ë¬´í•œ ìŠ¤í¬ë¡¤)
  const {
    data: messagesData,
    isLoading,
    error,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["chat-messages", roomId],
    queryFn: async ({ pageParam }) => {
      const result = await getMessagesWithReadStatusAction(roomId, {
        limit: 50,
        before: pageParam,
      });
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    initialPageParam: undefined as string | undefined,
    getNextPageParam: (lastPage) => {
      if (!lastPage?.hasMore || !lastPage?.messages?.length) return undefined;
      return lastPage.messages[0].id; // ê°€ì¥ ì˜¤ë˜ëœ ë©”ì‹œì§€ ID
    },
    staleTime: 10 * 1000, // 10ì´ˆ
  });

  // ëª¨ë“  í˜ì´ì§€ì˜ ë©”ì‹œì§€ë¥¼ ì‹œê°„ìˆœ ì •ë ¬ë¡œ ë³‘í•©
  const allMessages = useMemo(() => {
    if (!messagesData?.pages) return [];

    // ê³¼ê±° â†’ í˜„ì¬ ìˆœì„œë¡œ ë³‘í•© (pagesëŠ” ì—­ìˆœìœ¼ë¡œ ìŒ“ì„)
    return messagesData.pages
      .slice()
      .reverse()
      .flatMap((page) => page?.messages ?? []);
  }, [messagesData?.pages]);

  // ë©”ì‹œì§€ì— ê·¸ë£¹í•‘ ì •ë³´ ì¶”ê°€ (ë‚ ì§œ êµ¬ë¶„ì„ , ì´ë¦„/ì‹œê°„ í‘œì‹œ ì—¬ë¶€)
  const messagesWithGrouping = useMemo(() => {
    return processMessagesWithGrouping(allMessages);
  }, [allMessages]);

  // readCounts ë³‘í•©
  const allReadCounts = useMemo(() => {
    if (!messagesData?.pages) return {};

    return messagesData.pages.reduce((acc, page) => ({
      ...acc,
      ...(page?.readCounts ?? {}),
    }), {} as Record<string, number>);
  }, [messagesData?.pages]);

  // ë©”ì‹œì§€ ì „ì†¡ (Optimistic Updates ì ìš© - ì¦‰ê°ì ì¸ UI ë°˜ì˜, InfiniteQuery êµ¬ì¡°)
  const sendMutation = useMutation({
    mutationFn: async ({ content, replyToId }: { content: string; replyToId?: string | null }) => {
      const result = await sendMessageAction(roomId, content, replyToId);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onMutate: async ({ content, replyToId }) => {
      // 1. ì§„í–‰ ì¤‘ì¸ ì¿¼ë¦¬ ì·¨ì†Œ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸ì™€ ì¶©ëŒ ë°©ì§€)
      await queryClient.cancelQueries({ queryKey: ["chat-messages", roomId] });

      // 2. ì´ì „ ë°ì´í„° ìŠ¤ëƒ…ìƒ· ì €ì¥ (ë¡¤ë°±ìš©)
      const previousMessages = queryClient.getQueryData(["chat-messages", roomId]);

      // ì´ì „ ë‹µì¥ ìƒíƒœ ì €ì¥ (ë³µì›ìš©)
      const previousReplyTarget = replyTarget;

      // 3. ë‚™ê´€ì  ì—…ë°ì´íŠ¸ (ì¦‰ì‹œ UI ë°˜ì˜) - InfiniteQuery êµ¬ì¡°
      const tempId = `temp-${Date.now()}`; // tempId ë³„ë„ ì €ì¥
      const optimisticMessage = {
        id: tempId,
        content,
        sender_id: userId,
        sender_type: "student" as const,
        message_type: "text" as const,
        created_at: new Date().toISOString(),
        room_id: roomId,
        is_deleted: false,
        reply_to_id: replyToId ?? null,
        replyTarget: replyTarget,
        sender: { name: "ë‚˜", type: "student" as const, id: userId },
        status: "sending" as const, // ì „ì†¡ ì¤‘ ìƒíƒœ
      };

      queryClient.setQueryData(
        ["chat-messages", roomId],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (old: any) => {
          if (!old?.pages?.length) return old;

          // ì²« ë²ˆì§¸ í˜ì´ì§€(ìµœì‹ )ì— ë©”ì‹œì§€ ì¶”ê°€
          const firstPage = old.pages[0];
          return {
            ...old,
            pages: [
              { ...firstPage, messages: [...firstPage.messages, optimisticMessage] },
              ...old.pages.slice(1),
            ],
          };
        }
      );

      // ë‹µì¥ ìƒíƒœ ì´ˆê¸°í™”
      setReplyTarget(null);

      // 4. ì¦‰ì‹œ ìŠ¤í¬ë¡¤
      setTimeout(scrollToBottom, 0);

      return { previousMessages, previousReplyTarget, tempId }; // tempId ë°˜í™˜
    },
    onError: (_err, _variables, context) => {
      // 5. ì‹¤íŒ¨ ì‹œ ë¡¤ë°± ëŒ€ì‹  statusë¥¼ errorë¡œ ë³€ê²½
      const tempId = context?.tempId;
      if (tempId) {
        queryClient.setQueryData(
          ["chat-messages", roomId],
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (old: any) => {
            if (!old?.pages?.length) return old;
            return {
              ...old,
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              pages: old.pages.map((page: any) => ({
                ...page,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                messages: page.messages.map((m: any) =>
                  m.id === tempId ? { ...m, status: "error" } : m
                ),
              })),
            };
          }
        );
      }

      // ë‹µì¥ ìƒíƒœ ë³µì›
      if (context?.previousReplyTarget) {
        setReplyTarget(context.previousReplyTarget);
      }
    },
    onSettled: (_data, error) => {
      // 6. ì„±ê³µ ì‹œì—ë§Œ ì„œë²„ ë°ì´í„°ì™€ ë™ê¸°í™” (ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ ìœ ì§€)
      if (!error) {
        queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
      }
    },
  });

  // ë©”ì‹œì§€ í¸ì§‘
  const editMutation = useMutation({
    mutationFn: async ({ messageId, content }: { messageId: string; content: string }) => {
      const result = await editMessageAction(messageId, content);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // ë©”ì‹œì§€ ì‚­ì œ
  const deleteMutation = useMutation({
    mutationFn: async (messageId: string) => {
      const result = await deleteMessageAction(messageId);
      if (!result.success) throw new Error(result.error);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // ë¦¬ì•¡ì…˜ í† ê¸€
  const reactionMutation = useMutation({
    mutationFn: async ({ messageId, emoji }: { messageId: string; emoji: ReactionEmoji }) => {
      const result = await toggleReactionAction(messageId, emoji);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-messages", roomId] });
    },
  });

  // ë©”ì‹œì§€ ê³ ì •/í•´ì œ
  const pinMutation = useMutation({
    mutationFn: async ({ messageId, isPinned }: { messageId: string; isPinned: boolean }) => {
      if (isPinned) {
        const result = await unpinMessageAction(roomId, messageId);
        if (!result.success) throw new Error(result.error);
      } else {
        const result = await pinMessageAction(roomId, messageId);
        if (!result.success) throw new Error(result.error);
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-pinned", roomId] });
    },
  });

  // ê³µì§€ ì„¤ì •/ì‚­ì œ
  const announcementMutation = useMutation({
    mutationFn: async (content: string | null) => {
      const result = await setAnnouncementAction(roomId, content);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat-announcement", roomId] });
      setIsAnnouncementDialogOpen(false);
    },
  });

  // ì½ìŒ ì²˜ë¦¬
  const markAsReadMutation = useMutation({
    mutationFn: async () => {
      await markAsReadAction(roomId);
    },
    onSuccess: () => {
      // ì±„íŒ…ë°© ëª©ë¡ì˜ unread count ì—…ë°ì´íŠ¸
      queryClient.invalidateQueries({ queryKey: ["chat-rooms"] });
    },
  });

  // ì½ìŒ ì²˜ë¦¬ Debounce (500ms) - ë¬´ì œí•œ DB ì“°ê¸° ë°©ì§€
  const debouncedMarkAsRead = useDebouncedCallback(() => {
    markAsReadMutation.mutate();
  }, 500);

  // ì‹¤ì‹œê°„ êµ¬ë…
  useChatRealtime({
    roomId,
    userId,
    onNewMessage: useCallback(() => {
      // ìŠ¤í¬ë¡¤ì´ ë§¨ ì•„ë˜ì— ìˆìœ¼ë©´ ìë™ ìŠ¤í¬ë¡¤
      if (isAtBottom) {
        scrollToBottom();
      } else {
        // ìŠ¤í¬ë¡¤ ì˜¬ë¦° ìƒíƒœì—ì„œ ìƒˆ ë©”ì‹œì§€ ë„ì°© ì‹œ ë°°ì§€ í‘œì‹œ
        setHasNewMessages(true);
      }
      // ì½ìŒ ì²˜ë¦¬ (Debounce ì ìš©)
      debouncedMarkAsRead();
    }, [isAtBottom, scrollToBottom, debouncedMarkAsRead]),
  });

  // í˜„ì¬ ì‚¬ìš©ì ì´ë¦„ (Presenceìš©)
  const currentUserName =
    roomData?.members.find((m) => m.user_id === userId)?.user?.name ?? "ì‚¬ìš©ì";

  // Presence (íƒ€ì´í•‘/ì˜¨ë¼ì¸ ìƒíƒœ)
  const { onlineUsers, typingUsers, setTyping } = useChatPresence({
    roomId,
    userId,
    userName: currentUserName,
    enabled: !!roomData,
  });

  // ì…ì¥ ì‹œ ì½ìŒ ì²˜ë¦¬ (Virtuosoê°€ initialTopMostItemIndexë¡œ ìŠ¤í¬ë¡¤ ìë™ ì²˜ë¦¬)
  useEffect(() => {
    markAsReadMutation.mutate();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  // ë§¨ ìœ„ ë„ë‹¬ ì‹œ ê³¼ê±° ë©”ì‹œì§€ ë¡œë“œ (Virtuoso startReached)
  const handleStartReached = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage().then(() => {
        // ë¡œë“œëœ ë©”ì‹œì§€ ìˆ˜ë§Œí¼ firstItemIndex ê°ì†Œ
        const newMessages = messagesData?.pages?.at(-1)?.messages?.length ?? 0;
        setFirstItemIndex((prev) => prev - newMessages);
      });
    }
  }, [hasNextPage, isFetchingNextPage, fetchNextPage, messagesData]);

  // ë©”ì‹œì§€ë¡œ ìŠ¤í¬ë¡¤ (ê²€ìƒ‰ ê²°ê³¼ í´ë¦­ ì‹œ, Virtuoso ë°©ì‹)
  const scrollToMessage = useCallback((messageId: string) => {
    setIsSearchMode(false);
    const index = messagesWithGrouping.findIndex((m) => m.id === messageId);
    if (index !== -1) {
      virtuosoRef.current?.scrollToIndex({
        index: firstItemIndex + index,
        behavior: "smooth",
        align: "center",
      });
      // í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼
      setTimeout(() => {
        const element = messageRefs.current.get(messageId);
        if (element) {
          element.classList.add("bg-warning/20");
          setTimeout(() => element.classList.remove("bg-warning/20"), 2000);
        }
      }, 300);
    }
  }, [messagesWithGrouping, firstItemIndex]);

  // í¸ì§‘ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ (5ë¶„ ì´ë‚´)
  const canEditMessage = useCallback((createdAt: string) => {
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
    return new Date(createdAt).getTime() > fiveMinutesAgo;
  }, []);

  // ë‹µì¥ ëª¨ë“œ ì‹œì‘
  const handleReply = useCallback((message: { id: string; content: string; sender?: { name: string } | null; is_deleted?: boolean }) => {
    setReplyTarget({
      id: message.id,
      content: message.content,
      senderName: message.sender?.name ?? "ì•Œ ìˆ˜ ì—†ìŒ",
      isDeleted: message.is_deleted ?? false,
    });
  }, []);

  // ì•ˆì •í™”ëœ ì½œë°± í•¸ë“¤ëŸ¬ë“¤ (MessageBubble ì¬ë Œë”ë§ ë°©ì§€)
  const handleToggleReaction = useCallback((messageId: string, emoji: ReactionEmoji) => {
    reactionMutation.mutate({ messageId, emoji });
  }, [reactionMutation]);

  const handleTogglePin = useCallback((messageId: string, isPinned: boolean) => {
    pinMutation.mutate({ messageId, isPinned });
  }, [pinMutation]);

  const handleEdit = useCallback((messageId: string, currentContent: string) => {
    const newContent = prompt("ë©”ì‹œì§€ ìˆ˜ì •:", currentContent);
    if (newContent && newContent !== currentContent) {
      editMutation.mutate({ messageId, content: newContent });
    }
  }, [editMutation]);

  const handleDelete = useCallback((messageId: string) => {
    if (confirm("ë©”ì‹œì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      deleteMutation.mutate(messageId);
    }
  }, [deleteMutation]);

  // ë©”ì‹œì§€ ì¬ì „ì†¡ í•¸ë“¤ëŸ¬
  const handleRetry = useCallback((message: (typeof messagesWithGrouping)[number]) => {
    // 1. statusë¥¼ sendingìœ¼ë¡œ ë³€ê²½
    queryClient.setQueryData(
      ["chat-messages", roomId],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (old: any) => {
        if (!old?.pages?.length) return old;
        return {
          ...old,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          pages: old.pages.map((page: any) => ({
            ...page,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            messages: page.messages.map((m: any) =>
              m.id === message.id ? { ...m, status: "sending" } : m
            ),
          })),
        };
      }
    );

    // 2. ì¬ì „ì†¡ (ê¸°ì¡´ ë©”ì‹œì§€ ì œê±° í›„ ìƒˆ ë©”ì‹œì§€ ì¶”ê°€)
    const replyToId = (message as { reply_to_id?: string | null }).reply_to_id;
    sendMutation.mutate(
      { content: message.content, replyToId },
      {
        onSuccess: () => {
          // ê¸°ì¡´ ì‹¤íŒ¨ ë©”ì‹œì§€ ì œê±° (ìƒˆ ë©”ì‹œì§€ê°€ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¡œ ì¶”ê°€ë¨)
          queryClient.setQueryData(
            ["chat-messages", roomId],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (old: any) => {
              if (!old?.pages?.length) return old;
              return {
                ...old,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                pages: old.pages.map((page: any) => ({
                  ...page,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  messages: page.messages.filter((m: any) => m.id !== message.id),
                })),
              };
            }
          );
        },
        onError: () => {
          // ë‹¤ì‹œ error ìƒíƒœë¡œ
          queryClient.setQueryData(
            ["chat-messages", roomId],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (old: any) => {
              if (!old?.pages?.length) return old;
              return {
                ...old,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                pages: old.pages.map((page: any) => ({
                  ...page,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  messages: page.messages.map((m: any) =>
                    m.id === message.id ? { ...m, status: "error" } : m
                  ),
                })),
              };
            }
          );
        },
      }
    );
  }, [roomId, queryClient, sendMutation]);

  // ë©”ì‹œì§€ Long Press í•¸ë“¤ëŸ¬ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì—´ê¸°)
  const handleMessageLongPress = useCallback((message: (typeof messagesWithGrouping)[number]) => {
    const isOwn = message.sender_id === userId;
    setMenuContext({
      messageId: message.id,
      content: message.content,
      isOwn,
      canEdit: isOwn && canEditMessage(message.created_at),
      canPin: canPin && message.message_type !== "system",
      isPinned: pinnedMessageIds.has(message.id),
    });
    setIsMenuOpen(true);
  }, [userId, canEditMessage, canPin, pinnedMessageIds]);

  // ë©”ì‹œì§€ ë³µì‚¬ í•¸ë“¤ëŸ¬
  const handleCopy = useCallback(async () => {
    if (menuContext) {
      await navigator.clipboard.writeText(menuContext.content);
    }
    setIsMenuOpen(false);
  }, [menuContext]);

  // ë©”ë‰´ì—ì„œ ë‹µì¥ í•¸ë“¤ëŸ¬
  const handleMenuReply = useCallback(() => {
    if (menuContext) {
      const message = allMessages.find((m) => m.id === menuContext.messageId);
      if (message) handleReply(message);
    }
    setIsMenuOpen(false);
  }, [menuContext, allMessages, handleReply]);

  // ë©”ë‰´ì—ì„œ í¸ì§‘ í•¸ë“¤ëŸ¬
  const handleMenuEdit = useCallback(() => {
    if (menuContext?.canEdit) {
      handleEdit(menuContext.messageId, menuContext.content);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleEdit]);

  // ë©”ë‰´ì—ì„œ ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleMenuDelete = useCallback(() => {
    if (menuContext?.isOwn) {
      handleDelete(menuContext.messageId);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleDelete]);

  // ë©”ë‰´ì—ì„œ ê³ ì •/í•´ì œ í•¸ë“¤ëŸ¬
  const handleMenuTogglePin = useCallback(() => {
    if (menuContext?.canPin) {
      handleTogglePin(menuContext.messageId, menuContext.isPinned);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleTogglePin]);

  // ë©”ë‰´ì—ì„œ ë¦¬ì•¡ì…˜ í† ê¸€ í•¸ë“¤ëŸ¬
  const handleMenuReaction = useCallback((emoji: ReactionEmoji) => {
    if (menuContext) {
      handleToggleReaction(menuContext.messageId, emoji);
    }
    setIsMenuOpen(false);
  }, [menuContext, handleToggleReaction]);

  // ref ì½œë°± ìƒì„± (ì•ˆì •ì ì¸ ì°¸ì¡°)
  const getRefCallback = useCallback((messageId: string) => (el: HTMLDivElement | null) => {
    if (el) messageRefs.current.set(messageId, el);
    else messageRefs.current.delete(messageId);
  }, []);

  // ë©”ì‹œì§€ ë Œë”ë§ í•¨ìˆ˜ (ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ì¬ë Œë”ë§ ë°©ì§€)
  const renderMessage = useCallback((_index: number, message: (typeof messagesWithGrouping)[number]) => {
    const isOwn = message.sender_id === userId;
    const messageReplyTarget = (message as { replyTarget?: ReplyTargetInfo | null }).replyTarget;
    const messageStatus = (message as { status?: string }).status;
    const { grouping } = message;

    return (
      <div
        ref={getRefCallback(message.id)}
        className="transition-colors duration-300"
      >
        {/* ë‚ ì§œ êµ¬ë¶„ì„  */}
        {grouping.showDateDivider && grouping.dateDividerText && (
          <DateDivider date={grouping.dateDividerText} />
        )}

        {/* ë©”ì‹œì§€ (ê·¸ë£¹í•‘ ì‹œ ê°„ê²© ì¶•ì†Œ) */}
        <div className={cn("px-4", grouping.isGrouped ? "py-0.5" : "py-1.5")}>
          <MessageBubble
            content={message.content}
            isOwn={isOwn}
            senderName={message.sender?.name}
            createdAt={message.created_at}
            isSystem={message.message_type === "system"}
            isEdited={isMessageEdited(message)}
            unreadCount={isOwn ? allReadCounts[message.id] : undefined}
            canEdit={isOwn && canEditMessage(message.created_at)}
            reactions={(message as { reactions?: Array<{ emoji: ReactionEmoji; count: number; hasReacted: boolean }> }).reactions ?? []}
            replyTarget={messageReplyTarget}
            isPinned={pinnedMessageIds.has(message.id)}
            canPin={canPin && message.message_type !== "system"}
            showName={grouping.showName}
            showTime={grouping.showTime}
            isGrouped={grouping.isGrouped}
            isError={messageStatus === "error"}
            isRetrying={messageStatus === "sending" && message.id.startsWith("temp-")}
            onRetry={messageStatus === "error" ? () => handleRetry(message) : undefined}
            onToggleReaction={(emoji) => handleToggleReaction(message.id, emoji)}
            onReply={message.message_type !== "system" ? () => handleReply(message) : undefined}
            onReplyTargetClick={messageReplyTarget ? () => scrollToMessage(messageReplyTarget.id) : undefined}
            onTogglePin={() => handleTogglePin(message.id, pinnedMessageIds.has(message.id))}
            onEdit={() => handleEdit(message.id, message.content)}
            onDelete={() => handleDelete(message.id)}
            onLongPress={() => handleMessageLongPress(message)}
          />
        </div>
      </div>
    );
  }, [
    userId,
    allReadCounts,
    pinnedMessageIds,
    canPin,
    canEditMessage,
    getRefCallback,
    handleRetry,
    handleToggleReaction,
    handleReply,
    scrollToMessage,
    handleTogglePin,
    handleEdit,
    handleDelete,
    handleMessageLongPress,
  ]);

  // ë©”ì‹œì§€ í‚¤ ìƒì„± (ì•ˆì •ì ì¸ ì•„ì´í…œ ì‹ë³„)
  const computeItemKey = useCallback((_index: number, message: (typeof messagesWithGrouping)[number]) => message.id, []);

  // ë¹ ë¥¸ ìŠ¤í¬ë¡¤ ì‹œ í”Œë ˆì´ìŠ¤í™€ë” (ì„±ëŠ¥ ìµœì í™”)
  const ScrollSeekPlaceholder = useCallback(({ height }: { height: number }) => (
    <div style={{ height }} className="px-4 py-1.5">
      <div className="bg-bg-secondary rounded-2xl animate-pulse" style={{ height: Math.max(height - 12, 40) }} />
    </div>
  ), []);

  // ë°© ì´ë¦„ ê²°ì •
  const roomName = roomData?.room
    ? roomData.room.type === "direct"
      ? roomData.members.find((m) => m.user_id !== userId)?.user?.name ?? "ì±„íŒ…"
      : roomData.room.name ?? `ê·¸ë£¹ (${roomData.members.length}ëª…)`
    : "ì±„íŒ…";

  // allMessages, messagesWithGrouping, allReadCountsëŠ” ìœ„ì—ì„œ useMemoë¡œ ê³„ì‚°ë¨

  return (
    <div className="relative flex flex-col h-full bg-bg-primary">
      {/* í—¤ë” */}
      <div className="flex items-center gap-3 px-4 py-3 border-b border-border bg-bg-primary">
        {onBack && (
          <button
            type="button"
            onClick={onBack}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
          >
            <ArrowLeft className="w-5 h-5 text-text-primary" />
          </button>
        )}

        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <h2 className="font-semibold text-text-primary truncate">
              {roomName}
            </h2>
            {/* 1:1 ì±„íŒ… ì˜¨ë¼ì¸ ìƒíƒœ */}
            {roomData?.room.type === "direct" && (
              <OnlineStatus isOnline={onlineUsers.length > 0} />
            )}
          </div>
          {roomData?.room.type === "group" && (
            <p className="text-xs text-text-tertiary">
              {onlineUsers.length > 0
                ? `${onlineUsers.length + 1}ëª… ì˜¨ë¼ì¸`
                : `${roomData.members.length}ëª… ì°¸ì—¬ ì¤‘`}
            </p>
          )}
        </div>

        <button
          type="button"
          onClick={() => setIsSearchMode(true)}
          className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
        >
          <Search className="w-5 h-5 text-text-secondary" />
        </button>

        {/* ê³µì§€ ì„¤ì • ë²„íŠ¼ (ê¶Œí•œ ìˆì„ ë•Œë§Œ) */}
        {canSetAnnouncement && (
          <button
            type="button"
            onClick={() => setIsAnnouncementDialogOpen(true)}
            className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
            aria-label="ê³µì§€ ì„¤ì •"
          >
            <Megaphone className="w-5 h-5 text-text-secondary" />
          </button>
        )}

        <button
          type="button"
          onClick={handleInfoOpen}
          className="p-2 rounded-lg hover:bg-bg-secondary transition-colors"
          aria-label="ì±„íŒ…ë°© ì •ë³´"
        >
          <MoreVertical className="w-5 h-5 text-text-secondary" />
        </button>
      </div>

      {/* ê³µì§€ ë°°ë„ˆ */}
      {announcementData && (
        <AnnouncementBanner
          announcement={announcementData}
          canEdit={canSetAnnouncement}
          onEdit={() => setIsAnnouncementDialogOpen(true)}
          onDelete={() => {
            if (confirm("ê³µì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
              announcementMutation.mutate(null);
            }
          }}
        />
      )}

      {/* ê³ ì • ë©”ì‹œì§€ ë°” */}
      {pinnedMessages.length > 0 && (
        <PinnedMessagesBar
          pinnedMessages={pinnedMessages}
          canUnpin={canPin}
          onMessageClick={scrollToMessage}
          onUnpin={(messageId) => {
            pinMutation.mutate({ messageId, isPinned: true });
          }}
        />
      )}

      {/* ê²€ìƒ‰ ëª¨ë“œ */}
      {isSearchMode && (
        <div className="absolute inset-0 z-10">
          <MessageSearch
            roomId={roomId}
            onClose={() => setIsSearchMode(false)}
            onSelectMessage={scrollToMessage}
          />
        </div>
      )}

      {/* ë©”ì‹œì§€ ëª©ë¡ - Virtuosoë¡œ ê°€ìƒí™” */}
      {isLoading ? (
        <div className="flex-1 flex items-center justify-center">
          <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
        </div>
      ) : error ? (
        <div className="flex-1 flex flex-col items-center justify-center text-center">
          <p className="text-text-secondary text-sm">
            ë©”ì‹œì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
          </p>
        </div>
      ) : messagesWithGrouping.length === 0 ? (
        <div className="flex-1 flex flex-col items-center justify-center text-center gap-1">
          <p className="text-text-secondary text-sm">
            ì•„ì§ ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤
          </p>
          <p className="text-text-tertiary text-xs">
            ì²« ë©”ì‹œì§€ë¥¼ ë³´ë‚´ë³´ì„¸ìš”!
          </p>
        </div>
      ) : (
        <Virtuoso
          ref={virtuosoRef}
          className="flex-1"
          data={messagesWithGrouping}
          firstItemIndex={firstItemIndex}
          initialTopMostItemIndex={messagesWithGrouping.length - 1}
          followOutput="smooth"
          atBottomStateChange={handleAtBottomChange}
          startReached={handleStartReached}
          // ì„±ëŠ¥ ìµœì í™”: ì•ˆì •ì ì¸ í‚¤ ìƒì„±
          computeItemKey={computeItemKey}
          // ì„±ëŠ¥ ìµœì í™”: viewport í™•ì¥ìœ¼ë¡œ ìŠ¤í¬ë¡¤ ëŠê¹€ ë°©ì§€
          increaseViewportBy={{ top: 200, bottom: 200 }}
          // ì„±ëŠ¥ ìµœì í™”: ë¹ ë¥¸ ìŠ¤í¬ë¡¤ ì‹œ í”Œë ˆì´ìŠ¤í™€ë” í‘œì‹œ
          scrollSeekConfiguration={{
            enter: (velocity) => Math.abs(velocity) > 800,
            exit: (velocity) => Math.abs(velocity) < 100,
          }}
          components={{
            Header: () => (
              isFetchingNextPage ? (
                <div className="flex justify-center py-2">
                  <Loader2 className="w-5 h-5 animate-spin text-text-tertiary" />
                </div>
              ) : null
            ),
            ScrollSeekPlaceholder,
          }}
          // ë©”ëª¨ì´ì œì´ì…˜ëœ ë Œë”ë§ í•¨ìˆ˜ ì‚¬ìš©
          itemContent={renderMessage}
        />
      )}

      {/* ë§¨ ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤ ë²„íŠ¼ */}
      <div
        className={cn(
          "absolute bottom-28 right-4 z-10",
          "transition-all duration-300 ease-out",
          isAtBottom
            ? "opacity-0 translate-y-4 pointer-events-none"
            : "opacity-100 translate-y-0"
        )}
      >
        <button
          type="button"
          onClick={scrollToBottom}
          className={cn(
            "relative flex items-center justify-center",
            "w-10 h-10 rounded-full",
            "bg-bg-primary border border-border shadow-lg",
            "hover:bg-bg-secondary transition-colors duration-200",
            "hover:scale-105 active:scale-95"
          )}
          aria-label="ë§¨ ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤"
        >
          <ChevronDown className="w-5 h-5 text-text-secondary" />

          {/* ìƒˆ ë©”ì‹œì§€ ë°°ì§€ */}
          {hasNewMessages && (
            <span className="absolute -top-1 -right-1 flex items-center justify-center w-5 h-5 text-[10px] font-medium text-white bg-primary rounded-full">
              N
            </span>
          )}
        </button>
      </div>

      {/* íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° */}
      <TypingIndicator users={typingUsers} />

      {/* ì…ë ¥ì°½ */}
      <ChatInput
        onSend={(content) => sendMutation.mutate({ content, replyToId: replyTarget?.id })}
        onTypingChange={setTyping}
        replyTarget={replyTarget}
        onCancelReply={() => setReplyTarget(null)}
      />

      {/* ê³µì§€ ì„¤ì • ë‹¤ì´ì–¼ë¡œê·¸ */}
      <AnnouncementDialog
        open={isAnnouncementDialogOpen}
        onOpenChange={setIsAnnouncementDialogOpen}
        currentContent={announcementData?.content}
        onSave={(content) => announcementMutation.mutate(content)}
        isSaving={announcementMutation.isPending}
      />

      {/* ë©”ì‹œì§€ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ */}
      <MessageContextMenu
        isOpen={isMenuOpen}
        onClose={() => setIsMenuOpen(false)}
        context={menuContext}
        onCopy={handleCopy}
        onReply={handleMenuReply}
        onEdit={menuContext?.canEdit ? handleMenuEdit : undefined}
        onDelete={menuContext?.isOwn ? handleMenuDelete : undefined}
        onTogglePin={menuContext?.canPin ? handleMenuTogglePin : undefined}
        onToggleReaction={handleMenuReaction}
      />

      {/* ì±„íŒ…ë°© ì •ë³´ ì‚¬ì´ë“œë°” */}
      <ChatRoomInfo
        isOpen={isInfoOpen}
        onClose={handleInfoClose}
        roomId={roomId}
        userId={userId}
        room={roomData?.room}
        members={roomData?.members}
        isLoading={!roomData}
      />
    </div>
  );
}

export const ChatRoom = memo(ChatRoomComponent);
</file>

<file path="organisms/ChatRoomInfo.tsx">
"use client";

/**
 * ChatRoomInfo - ì±„íŒ…ë°© ì •ë³´ ì‚¬ì´ë“œë°”
 *
 * ì±„íŒ…ë°© ì°¸ì—¬ì ëª©ë¡, ì´ˆëŒ€, ë‚˜ê°€ê¸° ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */

import { memo, useCallback } from "react";
import { useRouter } from "next/navigation";
import { SlideOverPanel } from "@/components/layouts/SlideOver";
import { Avatar } from "@/components/atoms/Avatar";
import { Skeleton } from "@/components/atoms/Skeleton";
import { leaveChatRoomAction } from "@/lib/domains/chat/actions";
import type { ChatRoom, ChatRoomMemberWithUser, ChatMemberRole } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { UserPlus, LogOut, Crown, Shield } from "lucide-react";
import { useToast } from "@/components/ui/ToastProvider";

interface ChatRoomInfoProps {
  /** ì‚¬ì´ë“œë°” ì—´ë¦¼ ìƒíƒœ */
  isOpen: boolean;
  /** ë‹«ê¸° í•¸ë“¤ëŸ¬ */
  onClose: () => void;
  /** ì±„íŒ…ë°© ID */
  roomId: string;
  /** í˜„ì¬ ì‚¬ìš©ì ID */
  userId: string;
  /** ì±„íŒ…ë°© ì •ë³´ */
  room?: ChatRoom;
  /** ë©¤ë²„ ëª©ë¡ */
  members?: ChatRoomMemberWithUser[];
  /** ë¡œë”© ìƒíƒœ */
  isLoading?: boolean;
}

/** ì—­í• ë³„ ë°°ì§€ í…ìŠ¤íŠ¸ */
const roleBadges: Record<ChatMemberRole, { text: string; icon: typeof Crown }> = {
  owner: { text: "ë°©ì¥", icon: Crown },
  admin: { text: "ê´€ë¦¬ì", icon: Shield },
  member: { text: "", icon: Crown },
};

function ChatRoomInfoComponent({
  isOpen,
  onClose,
  roomId,
  userId,
  room,
  members,
  isLoading = false,
}: ChatRoomInfoProps) {
  const router = useRouter();
  const { showSuccess, showError, showInfo } = useToast();

  // í™œì„± ë©¤ë²„ë§Œ í•„í„°ë§ (left_at === null)
  const activeMembers = members?.filter((m) => m.left_at === null) ?? [];
  const memberCount = activeMembers.length;

  // ì±„íŒ…ë°© ë‚˜ê°€ê¸° í•¸ë“¤ëŸ¬
  const handleLeaveRoom = useCallback(async () => {
    const confirmed = window.confirm("ì±„íŒ…ë°©ì„ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?");
    if (!confirmed) return;

    const result = await leaveChatRoomAction(roomId);
    if (result.success) {
      onClose();
      showSuccess("ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.");
      router.push("/chat");
    } else {
      showError(result.error ?? "ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì‹¤íŒ¨");
    }
  }, [roomId, onClose, router, showSuccess, showError]);

  // ì´ˆëŒ€ ë²„íŠ¼ í•¸ë“¤ëŸ¬ (MVP: í† ìŠ¤íŠ¸ë§Œ)
  const handleInvite = useCallback(() => {
    showInfo("ì´ˆëŒ€ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.");
  }, [showInfo]);

  // ì‚¬ì´ë“œë°” Footer
  const footer = (
    <button
      type="button"
      onClick={handleLeaveRoom}
      className={cn(
        "flex items-center justify-center gap-2 w-full",
        "py-3 rounded-lg",
        "text-red-600 dark:text-red-400",
        "hover:bg-red-50 dark:hover:bg-red-950/30",
        "transition-colors"
      )}
    >
      <LogOut className="w-5 h-5" />
      <span className="font-medium">ì±„íŒ…ë°© ë‚˜ê°€ê¸°</span>
    </button>
  );

  return (
    <SlideOverPanel
      isOpen={isOpen}
      onClose={onClose}
      id="chat-room-info"
      title="ì±„íŒ…ë°© ì •ë³´"
      size="sm"
      footer={footer}
    >
      {/* ë¡œë”© ìƒíƒœ */}
      {isLoading ? (
        <div className="space-y-4">
          {/* ì„¹ì…˜ í—¤ë” ìŠ¤ì¼ˆë ˆí†¤ */}
          <Skeleton variant="text" className="h-5 w-24" />

          {/* ë©¤ë²„ ìŠ¤ì¼ˆë ˆí†¤ */}
          <div className="space-y-2">
            {[1, 2, 3].map((i) => (
              <div key={i} className="flex items-center gap-3 py-2">
                <Skeleton variant="circular" width={40} height={40} />
                <Skeleton variant="text" className="h-4 w-24" />
              </div>
            ))}
          </div>
        </div>
      ) : (
        <div className="space-y-6">
          {/* ì°¸ì—¬ì ì„¹ì…˜ */}
          <section>
            <h3 className="text-sm font-medium text-text-secondary mb-3">
              ì°¸ì—¬ì ({memberCount}ëª…)
            </h3>

            <ul className="space-y-1">
              {activeMembers.map((member) => {
                const isMe = member.user_id === userId;
                const roleInfo = roleBadges[member.role];

                return (
                  <li
                    key={member.id}
                    className={cn(
                      "flex items-center gap-3 py-2 px-2 rounded-lg",
                      "hover:bg-bg-secondary transition-colors"
                    )}
                  >
                    <Avatar
                      src={member.user.profileImageUrl}
                      name={member.user.name}
                      size="md"
                    />

                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <span className="font-medium text-text-primary truncate">
                          {member.user.name}
                        </span>

                        {/* ë‚˜ ë°°ì§€ */}
                        {isMe && (
                          <span className="text-xs text-text-tertiary">(ë‚˜)</span>
                        )}
                      </div>
                    </div>

                    {/* ì—­í•  ë°°ì§€ */}
                    {member.role !== "member" && (
                      <div
                        className={cn(
                          "flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium",
                          member.role === "owner"
                            ? "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-400"
                            : "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400"
                        )}
                      >
                        <roleInfo.icon className="w-3 h-3" />
                        <span>{roleInfo.text}</span>
                      </div>
                    )}
                  </li>
                );
              })}
            </ul>
          </section>

          {/* ì´ˆëŒ€ ë²„íŠ¼ (ê·¸ë£¹ì±„íŒ…ë§Œ) */}
          {room?.type === "group" && (
            <button
              type="button"
              onClick={handleInvite}
              className={cn(
                "flex items-center justify-center gap-2 w-full",
                "py-3 rounded-lg border border-border",
                "text-text-secondary",
                "hover:bg-bg-secondary hover:text-text-primary",
                "transition-colors"
              )}
            >
              <UserPlus className="w-5 h-5" />
              <span className="font-medium">ì´ˆëŒ€í•˜ê¸°</span>
            </button>
          )}
        </div>
      )}
    </SlideOverPanel>
  );
}

export const ChatRoomInfo = memo(ChatRoomInfoComponent);
export default ChatRoomInfo;
</file>

<file path="index.ts">
/**
 * Chat Components
 *
 * ì±„íŒ… ê´€ë ¨ ì»´í¬ë„ŒíŠ¸ ëª¨ìŒ
 */

// Atoms
export { MessageBubble } from "./atoms/MessageBubble";
export { UnreadBadge } from "./atoms/UnreadBadge";

// Molecules
export { ChatInput } from "./molecules/ChatInput";
export { ChatRoomCard } from "./molecules/ChatRoomCard";

// Organisms
export { ChatList } from "./organisms/ChatList";
export { ChatRoom } from "./organisms/ChatRoom";
</file>

<file path="index.ts">
/**
 * Chat Components
 *
 * ì±„íŒ… ê´€ë ¨ ì»´í¬ë„ŒíŠ¸ ëª¨ìŒ
 */

// Atoms
export { MessageBubble } from "./atoms/MessageBubble";
export { UnreadBadge } from "./atoms/UnreadBadge";

// Molecules
export { ChatInput } from "./molecules/ChatInput";
export { ChatRoomCard } from "./molecules/ChatRoomCard";

// Organisms
export { ChatList } from "./organisms/ChatList";
export { ChatRoom } from "./organisms/ChatRoom";
</file>

<file path="index.ts">
/**
 * Chat Components
 *
 * ì±„íŒ… ê´€ë ¨ ì»´í¬ë„ŒíŠ¸ ëª¨ìŒ
 */

// Atoms
export { MessageBubble } from "./atoms/MessageBubble";
export { UnreadBadge } from "./atoms/UnreadBadge";

// Molecules
export { ChatInput } from "./molecules/ChatInput";
export { ChatRoomCard } from "./molecules/ChatRoomCard";

// Organisms
export { ChatList } from "./organisms/ChatList";
export { ChatRoom } from "./organisms/ChatRoom";
</file>

<file path="_components/ChatListPage.tsx">
"use client";

/**
 * ChatListPage - ì±„íŒ… ëª©ë¡ í˜ì´ì§€ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸
 */

import { useState } from "react";
import { ChatList } from "@/components/chat";
import { useChatRoomListRealtime } from "@/lib/realtime";
import { CreateChatModal } from "./CreateChatModal";

interface ChatListPageProps {
  userId: string;
  basePath: string;
}

export function ChatListPage({ userId, basePath }: ChatListPageProps) {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  // ì±„íŒ…ë°© ëª©ë¡ ì‹¤ì‹œê°„ êµ¬ë…
  useChatRoomListRealtime({
    userId,
    userType: "student",
  });

  return (
    <div className="h-full">
      <ChatList
        basePath={basePath}
        onNewChat={() => setIsCreateModalOpen(true)}
      />

      <CreateChatModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        basePath={basePath}
      />
    </div>
  );
}
</file>

<file path="_components/CreateChatModal.tsx">
"use client";

/**
 * CreateChatModal - ìƒˆ ì±„íŒ… ì‹œì‘ ëª¨ë‹¬
 *
 * ê´€ë¦¬ì ëª©ë¡ì—ì„œ ì„ íƒí•˜ì—¬ 1:1 ì±„íŒ…ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 */

import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { Avatar } from "@/components/atoms/Avatar";
import { startDirectChatAction } from "@/lib/domains/chat/actions";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { Loader2, MessageSquare } from "lucide-react";
import { cn } from "@/lib/cn";

interface CreateChatModalProps {
  isOpen: boolean;
  onClose: () => void;
  basePath: string;
}

interface AdminUser {
  id: string;
  role: string;
  // Note: admin_users í…Œì´ë¸”ì— name ì»¬ëŸ¼ì´ ì—†ì–´ ì—­í• ë¡œë§Œ í‘œì‹œ
}

export function CreateChatModal({
  isOpen,
  onClose,
  basePath,
}: CreateChatModalProps) {
  const router = useRouter();
  const [selectedAdminId, setSelectedAdminId] = useState<string | null>(null);

  // ê´€ë¦¬ì ëª©ë¡ ì¡°íšŒ (ê°™ì€ tenantì˜ admin/consultant)
  const { data: admins, isLoading } = useQuery({
    queryKey: ["chat-available-admins"],
    queryFn: async () => {
      const supabase = createSupabaseBrowserClient();
      const { data, error } = await supabase
        .from("admin_users")
        .select("id, role")
        .in("role", ["admin", "consultant"]);

      if (error) throw error;
      return data as AdminUser[];
    },
    enabled: isOpen,
  });

  // ì±„íŒ… ì‹œì‘
  const startChatMutation = useMutation({
    mutationFn: async (adminId: string) => {
      const result = await startDirectChatAction(adminId, "admin");
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: (room) => {
      onClose();
      router.push(`${basePath}/${room?.id}`);
    },
  });

  const handleStartChat = () => {
    if (selectedAdminId) {
      startChatMutation.mutate(selectedAdminId);
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && onClose()}
      title="ìƒˆ ì±„íŒ… ì‹œì‘"
      description="ëŒ€í™”í•  ìƒë‹´ì‚¬/ê´€ë¦¬ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
      size="md"
    >
      <DialogContent>
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
          </div>
        ) : admins && admins.length > 0 ? (
          <div className="space-y-2 max-h-60 overflow-y-auto">
            {admins.map((admin) => (
              <button
                key={admin.id}
                type="button"
                onClick={() => setSelectedAdminId(admin.id)}
                className={cn(
                  "w-full flex items-center gap-3 p-3 rounded-lg transition-colors",
                  selectedAdminId === admin.id
                    ? "bg-primary/10 border-2 border-primary"
                    : "hover:bg-bg-secondary border-2 border-transparent"
                )}
              >
                <Avatar name={admin.role} size="md" />
                <div className="flex-1 text-left">
                  <p className="font-medium text-text-primary">
                    {admin.role === "admin" ? "ê´€ë¦¬ì" : "ìƒë‹´ì‚¬"}
                  </p>
                  <p className="text-xs text-text-tertiary">
                    {admin.role === "admin" ? "í•™ì› ê´€ë¦¬ì" : "í•™ìŠµ ìƒë‹´ì‚¬"}
                  </p>
                </div>
              </button>
            ))}
          </div>
        ) : (
          <div className="text-center py-8 text-text-secondary text-sm">
            ëŒ€í™”í•  ìˆ˜ ìˆëŠ” ê´€ë¦¬ìê°€ ì—†ìŠµë‹ˆë‹¤
          </div>
        )}
      </DialogContent>

      <DialogFooter>
        <button
          type="button"
          onClick={onClose}
          className="flex-1 px-4 py-2 rounded-lg border border-border text-text-secondary hover:bg-bg-secondary transition-colors"
        >
          ì·¨ì†Œ
        </button>
        <button
          type="button"
          onClick={handleStartChat}
          disabled={!selectedAdminId || startChatMutation.isPending}
          className={cn(
            "flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors",
            selectedAdminId && !startChatMutation.isPending
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          {startChatMutation.isPending ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <MessageSquare className="w-4 h-4" />
          )}
          ì±„íŒ… ì‹œì‘
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="[roomId]/_components/ChatRoomPage.tsx">
"use client";

/**
 * ChatRoomPage - ì±„íŒ…ë°© í˜ì´ì§€ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸
 */

import { useRouter } from "next/navigation";
import { ChatRoom } from "@/components/chat";

interface ChatRoomPageProps {
  roomId: string;
  userId: string;
  basePath: string;
}

export function ChatRoomPage({ roomId, userId, basePath }: ChatRoomPageProps) {
  const router = useRouter();

  const handleBack = () => {
    router.push(basePath);
  };

  return (
    <div className="h-full">
      <ChatRoom
        roomId={roomId}
        userId={userId}
        onBack={handleBack}
      />
    </div>
  );
}
</file>

<file path="[roomId]/page.tsx">
/**
 * í•™ìƒ ì±„íŒ…ë°© í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatRoomPage } from "./_components/ChatRoomPage";

export const metadata = {
  title: "ì±„íŒ… | TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function StudentChatRoomPage({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatRoomPage roomId={roomId} userId={user.userId} basePath="/chat" />;
}
</file>

<file path="[roomId]/page.tsx">
/**
 * í•™ìƒ ì±„íŒ…ë°© í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatRoomPage } from "./_components/ChatRoomPage";

export const metadata = {
  title: "ì±„íŒ… | TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function StudentChatRoomPage({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatRoomPage roomId={roomId} userId={user.userId} basePath="/chat" />;
}
</file>

<file path="page.tsx">
/**
 * í•™ìƒ ì±„íŒ… ëª©ë¡ í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatListPage } from "./_components/ChatListPage";

export const metadata = {
  title: "ì±„íŒ… | TimeLevelUp",
};

export default async function StudentChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatListPage userId={user.userId} basePath="/chat" />;
}
</file>

<file path="page.tsx">
/**
 * í•™ìƒ ì±„íŒ… ëª©ë¡ í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ChatListPage } from "./_components/ChatListPage";

export const metadata = {
  title: "ì±„íŒ… | TimeLevelUp",
};

export default async function StudentChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ChatListPage userId={user.userId} basePath="/chat" />;
}
</file>

<file path="_components/AdminChatListPage.tsx">
"use client";

/**
 * AdminChatListPage - ê´€ë¦¬ì ì±„íŒ… ëª©ë¡ í˜ì´ì§€
 */

import { useState } from "react";
import { ChatList } from "@/components/chat";
import { useChatRoomListRealtime } from "@/lib/realtime";
import { AdminCreateChatModal } from "./AdminCreateChatModal";

interface AdminChatListPageProps {
  userId: string;
}

export function AdminChatListPage({ userId }: AdminChatListPageProps) {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  // ì±„íŒ…ë°© ëª©ë¡ ì‹¤ì‹œê°„ êµ¬ë…
  useChatRoomListRealtime({
    userId,
    userType: "admin",
  });

  return (
    <div className="h-full">
      <ChatList
        basePath="/admin/chat"
        onNewChat={() => setIsCreateModalOpen(true)}
      />

      <AdminCreateChatModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
      />
    </div>
  );
}
</file>

<file path="_components/AdminCreateChatModal.tsx">
"use client";

/**
 * AdminCreateChatModal - ê´€ë¦¬ììš© ìƒˆ ì±„íŒ… ì‹œì‘ ëª¨ë‹¬
 *
 * í•™ìƒ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì—¬ 1:1 ì±„íŒ…ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 */

import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { Avatar } from "@/components/atoms/Avatar";
import { startDirectChatAction } from "@/lib/domains/chat/actions";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { Loader2, MessageSquare, Search } from "lucide-react";
import { cn } from "@/lib/cn";

interface AdminCreateChatModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface Student {
  id: string;
  name: string;
}

export function AdminCreateChatModal({
  isOpen,
  onClose,
}: AdminCreateChatModalProps) {
  const router = useRouter();
  const [selectedStudentId, setSelectedStudentId] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");

  // í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const { data: students, isLoading } = useQuery({
    queryKey: ["chat-available-students"],
    queryFn: async () => {
      const supabase = createSupabaseBrowserClient();
      const { data, error } = await supabase
        .from("students")
        .select("id, name")
        .order("name");

      if (error) throw error;
      return data as Student[];
    },
    enabled: isOpen,
  });

  // ê²€ìƒ‰ í•„í„°ë§
  const filteredStudents = students?.filter((student) =>
    student.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // ì±„íŒ… ì‹œì‘
  const startChatMutation = useMutation({
    mutationFn: async (studentId: string) => {
      const result = await startDirectChatAction(studentId, "student");
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: (room) => {
      onClose();
      router.push(`/admin/chat/${room?.id}`);
    },
  });

  const handleStartChat = () => {
    if (selectedStudentId) {
      startChatMutation.mutate(selectedStudentId);
    }
  };

  const handleClose = () => {
    setSearchQuery("");
    setSelectedStudentId(null);
    onClose();
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && handleClose()}
      title="í•™ìƒê³¼ ì±„íŒ… ì‹œì‘"
      size="md"
    >
      <DialogContent>
        {/* ê²€ìƒ‰ */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-text-tertiary" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="í•™ìƒ ì´ë¦„ ê²€ìƒ‰..."
            className="w-full pl-10 pr-4 py-2 rounded-lg bg-bg-secondary text-sm text-text-primary placeholder:text-text-tertiary border border-transparent focus:border-primary focus:outline-none"
          />
        </div>

        <div className="pt-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="w-6 h-6 animate-spin text-text-tertiary" />
            </div>
          ) : filteredStudents && filteredStudents.length > 0 ? (
            <div className="space-y-2 max-h-60 overflow-y-auto">
              {filteredStudents.map((student) => (
                <button
                  key={student.id}
                  type="button"
                  onClick={() => setSelectedStudentId(student.id)}
                  className={cn(
                    "w-full flex items-center gap-3 p-3 rounded-lg transition-colors",
                    selectedStudentId === student.id
                      ? "bg-primary/10 border-2 border-primary"
                      : "hover:bg-bg-secondary border-2 border-transparent"
                  )}
                >
                  <Avatar name={student.name} size="md" />
                  <div className="flex-1 text-left">
                    <p className="font-medium text-text-primary">
                      {student.name}
                    </p>
                  </div>
                </button>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-text-secondary text-sm">
              {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤" : "í•™ìƒì´ ì—†ìŠµë‹ˆë‹¤"}
            </div>
          )}
        </div>
      </DialogContent>

      <DialogFooter>
        <button
          type="button"
          onClick={handleClose}
          className="flex-1 px-4 py-2 rounded-lg border border-border text-text-secondary hover:bg-bg-secondary transition-colors"
        >
          ì·¨ì†Œ
        </button>
        <button
          type="button"
          onClick={handleStartChat}
          disabled={!selectedStudentId || startChatMutation.isPending}
          className={cn(
            "flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-colors",
            selectedStudentId && !startChatMutation.isPending
              ? "bg-primary text-white hover:bg-primary-hover"
              : "bg-bg-tertiary text-text-tertiary cursor-not-allowed"
          )}
        >
          {startChatMutation.isPending ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <MessageSquare className="w-4 h-4" />
          )}
          ì±„íŒ… ì‹œì‘
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="[roomId]/_components/AdminChatRoomPage.tsx">
"use client";

/**
 * AdminChatRoomPage - ê´€ë¦¬ì ì±„íŒ…ë°© í˜ì´ì§€
 */

import { useRouter } from "next/navigation";
import { ChatRoom } from "@/components/chat";

interface AdminChatRoomPageProps {
  roomId: string;
  userId: string;
}

export function AdminChatRoomPage({ roomId, userId }: AdminChatRoomPageProps) {
  const router = useRouter();

  const handleBack = () => {
    router.push("/admin/chat");
  };

  return (
    <div className="h-full">
      <ChatRoom
        roomId={roomId}
        userId={userId}
        onBack={handleBack}
      />
    </div>
  );
}
</file>

<file path="[roomId]/page.tsx">
/**
 * ê´€ë¦¬ì ì±„íŒ…ë°© í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatRoomPage } from "./_components/AdminChatRoomPage";

export const metadata = {
  title: "ì±„íŒ… | ê´€ë¦¬ì - TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function AdminChatRoomPageRoute({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatRoomPage roomId={roomId} userId={user.userId} />;
}
</file>

<file path="[roomId]/page.tsx">
/**
 * ê´€ë¦¬ì ì±„íŒ…ë°© í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatRoomPage } from "./_components/AdminChatRoomPage";

export const metadata = {
  title: "ì±„íŒ… | ê´€ë¦¬ì - TimeLevelUp",
};

interface PageProps {
  params: Promise<{ roomId: string }>;
}

export default async function AdminChatRoomPageRoute({ params }: PageProps) {
  const { roomId } = await params;
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatRoomPage roomId={roomId} userId={user.userId} />;
}
</file>

<file path="reports/_components/ReportDetailModal.tsx">
"use client";

/**
 * ì‹ ê³  ìƒì„¸ ëª¨ë‹¬ ì»´í¬ë„ŒíŠ¸
 */

import { useState } from "react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import type { ChatReportWithDetails, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { Loader2, User, MessageSquare, Clock, FileText } from "lucide-react";

interface ReportDetailModalProps {
  isOpen: boolean;
  onClose: () => void;
  report: ChatReportWithDetails;
  onResolve: (
    reportId: string,
    status: "resolved" | "dismissed",
    notes?: string
  ) => void;
  isResolving: boolean;
}

// ì‚¬ìœ  ë¼ë²¨
const REASON_LABELS: Record<ReportReason, string> = {
  spam: "ìŠ¤íŒ¸",
  harassment: "ê´´ë¡­í˜",
  inappropriate: "ë¶€ì ì ˆí•œ ë‚´ìš©",
  hate_speech: "í˜ì˜¤ ë°œì–¸",
  other: "ê¸°íƒ€",
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export function ReportDetailModal({
  isOpen,
  onClose,
  report,
  onResolve,
  isResolving,
}: ReportDetailModalProps) {
  const [notes, setNotes] = useState("");

  const handleResolve = (status: "resolved" | "dismissed") => {
    onResolve(report.id, status, notes || undefined);
  };

  const isPending = report.status === "pending";

  return (
    <Dialog
      open={isOpen}
      onOpenChange={onClose}
      title="ì‹ ê³  ìƒì„¸"
      size="lg"
    >
      <DialogContent className="space-y-6 overflow-y-auto max-h-[60vh]">
        {/* ì‹ ê³  ì •ë³´ */}
        <section className="space-y-3">
          <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
            <FileText className="w-4 h-4" />
            ì‹ ê³  ì •ë³´
          </h3>
          <div className="bg-bg-secondary rounded-lg p-4 space-y-2">
            <div className="flex items-center justify-between">
              <span className="text-sm text-text-secondary">ì‚¬ìœ </span>
              <span className="text-sm font-medium text-text-primary">
                {REASON_LABELS[report.reason]}
              </span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-sm text-text-secondary">ì‹ ê³  ì¼ì‹œ</span>
              <span className="text-sm text-text-primary">
                {formatDate(report.created_at)}
              </span>
            </div>
            {report.description && (
              <div className="pt-2 border-t border-border space-y-1">
                <span className="text-sm text-text-secondary block">
                  ìƒì„¸ ì„¤ëª…
                </span>
                <p className="text-sm text-text-primary">
                  {report.description}
                </p>
              </div>
            )}
          </div>
        </section>

        {/* ì‹ ê³ ì ì •ë³´ */}
        {report.reporter && (
          <section className="space-y-3">
            <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
              <User className="w-4 h-4" />
              ì‹ ê³ ì
            </h3>
            <div className="bg-bg-secondary rounded-lg p-4">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center">
                  <User className="w-5 h-5 text-primary" />
                </div>
                <div>
                  <p className="text-sm font-medium text-text-primary">
                    {report.reporter.name}
                  </p>
                  <p className="text-xs text-text-tertiary">
                    {report.reporter.type === "admin" ? "ê´€ë¦¬ì" : "í•™ìƒ"}
                  </p>
                </div>
              </div>
            </div>
          </section>
        )}

        {/* ì‹ ê³ ëœ ë©”ì‹œì§€ */}
        {report.reportedMessage && (
          <section className="space-y-3">
            <h3 className="text-sm font-medium text-text-primary flex items-center gap-2">
              <MessageSquare className="w-4 h-4" />
              ì‹ ê³ ëœ ë©”ì‹œì§€
            </h3>
            <div className="bg-error/5 border border-error/20 rounded-lg p-4 space-y-3">
              <p className="text-sm text-text-primary whitespace-pre-wrap">
                {report.reportedMessage.content}
              </p>
              <div className="flex items-center gap-2 pt-3 border-t border-error/10">
                <Clock className="w-3 h-3 text-text-tertiary" />
                <span className="text-xs text-text-tertiary">
                  {formatDate(report.reportedMessage.created_at)}
                </span>
              </div>
            </div>
          </section>
        )}

        {/* ì²˜ë¦¬ ì˜ì—­ (ëŒ€ê¸° ì¤‘ì¸ ì‹ ê³ ë§Œ) */}
        {isPending && (
          <section className="space-y-3 pt-3 border-t border-border">
            <h3 className="text-sm font-medium text-text-primary">ì²˜ë¦¬</h3>
            <textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="ì²˜ë¦¬ ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì„ íƒ)"
              rows={3}
              className={cn(
                "w-full px-3 py-2 text-sm rounded-lg",
                "bg-bg-secondary text-text-primary",
                "border border-border focus:border-primary focus:outline-none",
                "placeholder:text-text-tertiary resize-none"
              )}
            />
          </section>
        )}

        {/* ì´ë¯¸ ì²˜ë¦¬ëœ ì‹ ê³  */}
        {!isPending && report.resolution_notes && (
          <section className="space-y-3 pt-3 border-t border-border">
            <h3 className="text-sm font-medium text-text-primary">ì²˜ë¦¬ ë‚´ì—­</h3>
            <div className="bg-bg-secondary rounded-lg p-4 space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-sm text-text-secondary">ì²˜ë¦¬ ìƒíƒœ</span>
                <span
                  className={cn(
                    "text-sm font-medium",
                    report.status === "resolved"
                      ? "text-success"
                      : "text-text-tertiary"
                  )}
                >
                  {report.status === "resolved" ? "ìŠ¹ì¸ë¨" : "ê¸°ê°ë¨"}
                </span>
              </div>
              {report.reviewed_at && (
                <div className="flex items-center justify-between">
                  <span className="text-sm text-text-secondary">ì²˜ë¦¬ ì¼ì‹œ</span>
                  <span className="text-sm text-text-primary">
                    {formatDate(report.reviewed_at)}
                  </span>
                </div>
              )}
              {report.resolution_notes && (
                <div className="pt-2 border-t border-border space-y-1">
                  <span className="text-sm text-text-secondary block">
                    ì²˜ë¦¬ ë©”ëª¨
                  </span>
                  <p className="text-sm text-text-primary">
                    {report.resolution_notes}
                  </p>
                </div>
              )}
            </div>
          </section>
        )}
      </DialogContent>

      {/* í‘¸í„° (ëŒ€ê¸° ì¤‘ì¸ ì‹ ê³ ë§Œ) */}
      {isPending && (
        <DialogFooter>
          <button
            type="button"
            onClick={() => handleResolve("dismissed")}
            disabled={isResolving}
            className={cn(
              "px-4 py-2 text-sm font-medium rounded-lg",
              "bg-bg-tertiary text-text-primary hover:bg-bg-secondary",
              "transition-colors disabled:opacity-50"
            )}
          >
            ê¸°ê°
          </button>
          <button
            type="button"
            onClick={() => handleResolve("resolved")}
            disabled={isResolving}
            className={cn(
              "px-4 py-2 text-sm font-medium rounded-lg",
              "bg-primary text-white hover:bg-primary-hover",
              "transition-colors disabled:opacity-50",
              "flex items-center justify-center gap-2"
            )}
          >
            {isResolving && <Loader2 className="w-4 h-4 animate-spin" />}
            ìŠ¹ì¸ ì²˜ë¦¬
          </button>
        </DialogFooter>
      )}
    </Dialog>
  );
}
</file>

<file path="reports/_components/ReportFilter.tsx">
"use client";

/**
 * ì‹ ê³  í•„í„° ì»´í¬ë„ŒíŠ¸
 */

import type { ReportStatus, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";

interface ReportFilterProps {
  statusFilter: ReportStatus | "all";
  reasonFilter: ReportReason | "all";
  onStatusChange: (status: ReportStatus | "all") => void;
  onReasonChange: (reason: ReportReason | "all") => void;
  onReset: () => void;
}

const STATUS_OPTIONS: Array<{ value: ReportStatus | "all"; label: string }> = [
  { value: "all", label: "ì „ì²´ ìƒíƒœ" },
  { value: "pending", label: "ëŒ€ê¸°ì¤‘" },
  { value: "reviewed", label: "ê²€í† ì¤‘" },
  { value: "resolved", label: "ìŠ¹ì¸ë¨" },
  { value: "dismissed", label: "ê¸°ê°ë¨" },
];

const REASON_OPTIONS: Array<{ value: ReportReason | "all"; label: string }> = [
  { value: "all", label: "ì „ì²´ ì‚¬ìœ " },
  { value: "spam", label: "ìŠ¤íŒ¸" },
  { value: "harassment", label: "ê´´ë¡­í˜" },
  { value: "inappropriate", label: "ë¶€ì ì ˆí•œ ë‚´ìš©" },
  { value: "hate_speech", label: "í˜ì˜¤ ë°œì–¸" },
  { value: "other", label: "ê¸°íƒ€" },
];

export function ReportFilter({
  statusFilter,
  reasonFilter,
  onStatusChange,
  onReasonChange,
  onReset,
}: ReportFilterProps) {
  const hasActiveFilter = statusFilter !== "all" || reasonFilter !== "all";

  return (
    <div className="flex flex-wrap items-center gap-3 p-4 bg-bg-secondary rounded-lg">
      {/* ìƒíƒœ í•„í„° */}
      <div className="flex items-center gap-2">
        <label
          htmlFor="status-filter"
          className="text-sm text-text-secondary whitespace-nowrap"
        >
          ìƒíƒœ
        </label>
        <select
          id="status-filter"
          value={statusFilter}
          onChange={(e) =>
            onStatusChange(e.target.value as ReportStatus | "all")
          }
          className={cn(
            "px-3 py-1.5 text-sm rounded-lg border border-border",
            "bg-bg-primary text-text-primary",
            "focus:outline-none focus:ring-2 focus:ring-primary/20"
          )}
        >
          {STATUS_OPTIONS.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>

      {/* ì‚¬ìœ  í•„í„° */}
      <div className="flex items-center gap-2">
        <label
          htmlFor="reason-filter"
          className="text-sm text-text-secondary whitespace-nowrap"
        >
          ì‚¬ìœ 
        </label>
        <select
          id="reason-filter"
          value={reasonFilter}
          onChange={(e) =>
            onReasonChange(e.target.value as ReportReason | "all")
          }
          className={cn(
            "px-3 py-1.5 text-sm rounded-lg border border-border",
            "bg-bg-primary text-text-primary",
            "focus:outline-none focus:ring-2 focus:ring-primary/20"
          )}
        >
          {REASON_OPTIONS.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>

      {/* í•„í„° ì´ˆê¸°í™” */}
      {hasActiveFilter && (
        <button
          type="button"
          onClick={onReset}
          className="px-3 py-1.5 text-sm text-text-secondary hover:text-text-primary transition-colors"
        >
          í•„í„° ì´ˆê¸°í™”
        </button>
      )}
    </div>
  );
}
</file>

<file path="reports/_components/ReportListPage.tsx">
"use client";

/**
 * ê´€ë¦¬ì ì‹ ê³  ê´€ë¦¬ í˜ì´ì§€ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸
 */

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  getAllReportsAction,
  resolveReportAction,
  getReportDetailsAction,
} from "@/lib/domains/chat/actions/safety";
import type {
  ChatReport,
  ChatReportWithDetails,
  ReportStatus,
  ReportReason,
} from "@/lib/domains/chat/types";
import { useToast } from "@/components/ui/ToastProvider";
import { ReportTable } from "./ReportTable";
import { ReportFilter } from "./ReportFilter";
import { ReportDetailModal } from "./ReportDetailModal";
import { Loader2, AlertTriangle } from "lucide-react";

export function ReportListPage() {
  const queryClient = useQueryClient();
  const { showToast } = useToast();

  // í•„í„° ìƒíƒœ
  const [statusFilter, setStatusFilter] = useState<ReportStatus | "all">("all");
  const [reasonFilter, setReasonFilter] = useState<ReportReason | "all">("all");

  // ëª¨ë‹¬ ìƒíƒœ
  const [selectedReport, setSelectedReport] =
    useState<ChatReportWithDetails | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isLoadingDetails, setIsLoadingDetails] = useState(false);

  // ì‹ ê³  ëª©ë¡ ì¡°íšŒ
  const {
    data: reports,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["admin-chat-reports", statusFilter, reasonFilter],
    queryFn: async () => {
      const result = await getAllReportsAction({
        status: statusFilter,
        reason: reasonFilter,
      });
      if (!result.success) throw new Error(result.error);
      return result.data ?? [];
    },
  });

  // ì‹ ê³  ì²˜ë¦¬ ë®¤í…Œì´ì…˜
  const resolveMutation = useMutation({
    mutationFn: async ({
      reportId,
      status,
      notes,
    }: {
      reportId: string;
      status: "resolved" | "dismissed";
      notes?: string;
    }) => {
      const result = await resolveReportAction(reportId, status, notes);
      if (!result.success) throw new Error(result.error);
      return result.data;
    },
    onSuccess: () => {
      showToast("ì‹ ê³ ê°€ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.", "success");
      queryClient.invalidateQueries({ queryKey: ["admin-chat-reports"] });
      setIsModalOpen(false);
      setSelectedReport(null);
    },
    onError: (error: Error) => {
      showToast(error.message || "ì‹ ê³  ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", "error");
    },
  });

  // ì‹ ê³  ìƒì„¸ ì¡°íšŒ
  const handleViewDetails = async (report: ChatReport) => {
    setIsLoadingDetails(true);
    try {
      const result = await getReportDetailsAction(report.id);
      if (result.success && result.data) {
        setSelectedReport(result.data);
        setIsModalOpen(true);
      } else {
        showToast(result.error || "ìƒì„¸ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", "error");
      }
    } catch {
      showToast("ìƒì„¸ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", "error");
    } finally {
      setIsLoadingDetails(false);
    }
  };

  // ì‹ ê³  ì²˜ë¦¬ í•¸ë“¤ëŸ¬
  const handleResolve = (
    reportId: string,
    status: "resolved" | "dismissed",
    notes?: string
  ) => {
    resolveMutation.mutate({ reportId, status, notes });
  };

  // í•„í„° ì´ˆê¸°í™”
  const handleResetFilters = () => {
    setStatusFilter("all");
    setReasonFilter("all");
  };

  return (
    <div className="p-6 space-y-6">
      {/* í—¤ë” */}
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <h1 className="text-2xl font-bold text-text-primary">ì‹ ê³  ê´€ë¦¬</h1>
          <p className="text-sm text-text-secondary">
            ì‚¬ìš©ì ì‹ ê³ ë¥¼ ê²€í† í•˜ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤
          </p>
        </div>
        <button
          type="button"
          onClick={() => refetch()}
          className="px-4 py-2 text-sm bg-bg-secondary hover:bg-bg-tertiary rounded-lg transition-colors"
        >
          ìƒˆë¡œê³ ì¹¨
        </button>
      </div>

      {/* í•„í„° */}
      <ReportFilter
        statusFilter={statusFilter}
        reasonFilter={reasonFilter}
        onStatusChange={setStatusFilter}
        onReasonChange={setReasonFilter}
        onReset={handleResetFilters}
      />

      {/* í…Œì´ë¸” ë˜ëŠ” ë¡œë”©/ì—ëŸ¬ ìƒíƒœ */}
      {isLoading ? (
        <div className="flex items-center justify-center py-12">
          <Loader2 className="w-8 h-8 animate-spin text-text-tertiary" />
        </div>
      ) : error ? (
        <div className="flex flex-col items-center justify-center py-12 text-center gap-4">
          <AlertTriangle className="w-12 h-12 text-warning" />
          <p className="text-text-secondary">ì‹ ê³  ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤</p>
          <button
            type="button"
            onClick={() => refetch()}
            className="px-4 py-2 text-sm bg-primary text-white rounded-lg hover:bg-primary-hover"
          >
            ë‹¤ì‹œ ì‹œë„
          </button>
        </div>
      ) : reports && reports.length > 0 ? (
        <ReportTable
          reports={reports}
          onViewDetails={handleViewDetails}
          isLoadingDetails={isLoadingDetails}
        />
      ) : (
        <div className="flex flex-col items-center justify-center py-12 text-center bg-bg-secondary rounded-lg">
          <p className="text-text-secondary">ì‹ ê³  ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤</p>
        </div>
      )}

      {/* ìƒì„¸ ëª¨ë‹¬ */}
      {selectedReport && (
        <ReportDetailModal
          isOpen={isModalOpen}
          onClose={() => {
            setIsModalOpen(false);
            setSelectedReport(null);
          }}
          report={selectedReport}
          onResolve={handleResolve}
          isResolving={resolveMutation.isPending}
        />
      )}
    </div>
  );
}
</file>

<file path="reports/_components/ReportTable.tsx">
"use client";

/**
 * ì‹ ê³  ëª©ë¡ í…Œì´ë¸” ì»´í¬ë„ŒíŠ¸
 */

import type { ChatReport, ReportStatus, ReportReason } from "@/lib/domains/chat/types";
import { cn } from "@/lib/cn";
import { Eye, Loader2 } from "lucide-react";

interface ReportTableProps {
  reports: ChatReport[];
  onViewDetails: (report: ChatReport) => void;
  isLoadingDetails: boolean;
}

// ìƒíƒœë³„ ìŠ¤íƒ€ì¼
const STATUS_STYLES: Record<ReportStatus, { bg: string; text: string; label: string }> = {
  pending: { bg: "bg-warning/10", text: "text-warning", label: "ëŒ€ê¸°ì¤‘" },
  reviewed: { bg: "bg-info/10", text: "text-info", label: "ê²€í† ì¤‘" },
  resolved: { bg: "bg-success/10", text: "text-success", label: "ìŠ¹ì¸ë¨" },
  dismissed: { bg: "bg-text-tertiary/10", text: "text-text-tertiary", label: "ê¸°ê°ë¨" },
};

// ì‚¬ìœ ë³„ ìŠ¤íƒ€ì¼
const REASON_STYLES: Record<ReportReason, { bg: string; text: string; label: string }> = {
  spam: { bg: "bg-error/10", text: "text-error", label: "ìŠ¤íŒ¸" },
  harassment: { bg: "bg-warning/10", text: "text-warning", label: "ê´´ë¡­í˜" },
  inappropriate: { bg: "bg-warning/10", text: "text-warning", label: "ë¶€ì ì ˆ" },
  hate_speech: { bg: "bg-error/10", text: "text-error", label: "í˜ì˜¤ ë°œì–¸" },
  other: { bg: "bg-text-tertiary/10", text: "text-text-tertiary", label: "ê¸°íƒ€" },
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

export function ReportTable({
  reports,
  onViewDetails,
  isLoadingDetails,
}: ReportTableProps) {
  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          <tr className="border-b border-border">
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              ì‹ ê³ ì¼ì‹œ
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              ì‚¬ìœ 
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              ìƒíƒœ
            </th>
            <th className="px-4 py-3 text-left text-sm font-medium text-text-secondary">
              ì„¤ëª…
            </th>
            <th className="px-4 py-3 text-center text-sm font-medium text-text-secondary">
              ì•¡ì…˜
            </th>
          </tr>
        </thead>
        <tbody>
          {reports.map((report) => {
            const statusStyle = STATUS_STYLES[report.status];
            const reasonStyle = REASON_STYLES[report.reason];

            return (
              <tr
                key={report.id}
                className="border-b border-border hover:bg-bg-secondary/50 transition-colors"
              >
                {/* ì‹ ê³ ì¼ì‹œ */}
                <td className="px-4 py-3 text-sm text-text-primary whitespace-nowrap">
                  {formatDate(report.created_at)}
                </td>

                {/* ì‚¬ìœ  */}
                <td className="px-4 py-3">
                  <span
                    className={cn(
                      "inline-flex px-2 py-0.5 text-xs font-medium rounded-full",
                      reasonStyle.bg,
                      reasonStyle.text
                    )}
                  >
                    {reasonStyle.label}
                  </span>
                </td>

                {/* ìƒíƒœ */}
                <td className="px-4 py-3">
                  <span
                    className={cn(
                      "inline-flex px-2 py-0.5 text-xs font-medium rounded-full",
                      statusStyle.bg,
                      statusStyle.text
                    )}
                  >
                    {statusStyle.label}
                  </span>
                </td>

                {/* ì„¤ëª… */}
                <td className="px-4 py-3 text-sm text-text-secondary max-w-xs truncate">
                  {report.description || "-"}
                </td>

                {/* ì•¡ì…˜ */}
                <td className="px-4 py-3 text-center">
                  <button
                    type="button"
                    onClick={() => onViewDetails(report)}
                    disabled={isLoadingDetails}
                    className={cn(
                      "inline-flex items-center gap-1 px-3 py-1.5 text-sm",
                      "bg-primary text-white rounded-lg",
                      "hover:bg-primary-hover transition-colors",
                      "disabled:opacity-50 disabled:cursor-not-allowed"
                    )}
                  >
                    {isLoadingDetails ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Eye className="w-4 h-4" />
                    )}
                    ìƒì„¸
                  </button>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="reports/page.tsx">
/**
 * ê´€ë¦¬ì ì±„íŒ… ì‹ ê³  ê´€ë¦¬ í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { ReportListPage } from "./_components/ReportListPage";

export const metadata = {
  title: "ì‹ ê³  ê´€ë¦¬ | ê´€ë¦¬ì - TimeLevelUp",
};

export default async function AdminChatReportsPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <ReportListPage />;
}
</file>

<file path="page.tsx">
/**
 * ê´€ë¦¬ì ì±„íŒ… ëª©ë¡ í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatListPage } from "./_components/AdminChatListPage";

export const metadata = {
  title: "ì±„íŒ… | ê´€ë¦¬ì - TimeLevelUp",
};

export default async function AdminChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatListPage userId={user.userId} />;
}
</file>

<file path="page.tsx">
/**
 * ê´€ë¦¬ì ì±„íŒ… ëª©ë¡ í˜ì´ì§€
 */

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { redirect } from "next/navigation";
import { AdminChatListPage } from "./_components/AdminChatListPage";

export const metadata = {
  title: "ì±„íŒ… | ê´€ë¦¬ì - TimeLevelUp",
};

export default async function AdminChatPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  return <AdminChatListPage userId={user.userId} />;
}
</file>

<file path="index.ts">
/**
 * Supabase Realtime í›… ëª¨ìŒ
 * P2 ê°œì„ : ì‹¤ì‹œê°„ ê¸°ëŠ¥ í™•ëŒ€
 */

// í”Œëœ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { usePlanRealtimeUpdates } from "./usePlanRealtimeUpdates";
export {
  usePlanGroupRealtime,
  usePlanProgressRealtime,
} from "./usePlanGroupRealtime";

// ì¶œì„ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useAttendanceRealtime,
  useAdminAttendanceRealtime,
} from "./useAttendanceRealtime";

// ê´€ë¦¬ì í”Œëœ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { useAdminPlanRealtime } from "./useAdminPlanRealtime";

// ì•Œë¦¼ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useNotificationRealtime,
  useNotificationPermission,
  requestNotificationPermission,
  type NotificationPayload,
  type NotificationRealtimeEvent,
  type NotificationEventHandler,
  type UseNotificationRealtimeOptions,
} from "./useNotificationRealtime";

// ì±„íŒ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useChatRealtime,
  useChatRoomListRealtime,
} from "./useChatRealtime";

// ì±„íŒ… Presence (íƒ€ì´í•‘/ì˜¨ë¼ì¸ ìƒíƒœ)
export { useChatPresence } from "./useChatPresence";
</file>

<file path="index.ts">
/**
 * Supabase Realtime í›… ëª¨ìŒ
 * P2 ê°œì„ : ì‹¤ì‹œê°„ ê¸°ëŠ¥ í™•ëŒ€
 */

// í”Œëœ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { usePlanRealtimeUpdates } from "./usePlanRealtimeUpdates";
export {
  usePlanGroupRealtime,
  usePlanProgressRealtime,
} from "./usePlanGroupRealtime";

// ì¶œì„ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useAttendanceRealtime,
  useAdminAttendanceRealtime,
} from "./useAttendanceRealtime";

// ê´€ë¦¬ì í”Œëœ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { useAdminPlanRealtime } from "./useAdminPlanRealtime";

// ì•Œë¦¼ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useNotificationRealtime,
  useNotificationPermission,
  requestNotificationPermission,
  type NotificationPayload,
  type NotificationRealtimeEvent,
  type NotificationEventHandler,
  type UseNotificationRealtimeOptions,
} from "./useNotificationRealtime";

// ì±„íŒ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useChatRealtime,
  useChatRoomListRealtime,
} from "./useChatRealtime";

// ì±„íŒ… Presence (íƒ€ì´í•‘/ì˜¨ë¼ì¸ ìƒíƒœ)
export { useChatPresence } from "./useChatPresence";
</file>

<file path="index.ts">
/**
 * Supabase Realtime í›… ëª¨ìŒ
 * P2 ê°œì„ : ì‹¤ì‹œê°„ ê¸°ëŠ¥ í™•ëŒ€
 */

// í”Œëœ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { usePlanRealtimeUpdates } from "./usePlanRealtimeUpdates";
export {
  usePlanGroupRealtime,
  usePlanProgressRealtime,
} from "./usePlanGroupRealtime";

// ì¶œì„ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useAttendanceRealtime,
  useAdminAttendanceRealtime,
} from "./useAttendanceRealtime";

// ê´€ë¦¬ì í”Œëœ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export { useAdminPlanRealtime } from "./useAdminPlanRealtime";

// ì•Œë¦¼ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useNotificationRealtime,
  useNotificationPermission,
  requestNotificationPermission,
  type NotificationPayload,
  type NotificationRealtimeEvent,
  type NotificationEventHandler,
  type UseNotificationRealtimeOptions,
} from "./useNotificationRealtime";

// ì±„íŒ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
export {
  useChatRealtime,
  useChatRoomListRealtime,
} from "./useChatRealtime";

// ì±„íŒ… Presence (íƒ€ì´í•‘/ì˜¨ë¼ì¸ ìƒíƒœ)
export { useChatPresence } from "./useChatPresence";
</file>

<file path="useAdminPlanRealtime.ts">
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { createSupabaseBrowserClient } from '@/lib/supabase/client';

type UseAdminPlanRealtimeOptions = {
  studentId: string;
  enabled?: boolean;
  onRefresh: () => void;
  /** Debounce delay in ms (default: 500) */
  debounceMs?: number;
};

/**
 * ê´€ë¦¬ììš© í”Œëœ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 * íŠ¹ì • í•™ìƒì˜ í”Œëœ ë³€ê²½ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•˜ì—¬ ìƒˆë¡œê³ ì¹¨ íŠ¸ë¦¬ê±°
 */
export function useAdminPlanRealtime({
  studentId,
  enabled = true,
  onRefresh,
  debounceMs = 500,
}: UseAdminPlanRealtimeOptions) {
  const debounceTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastRefreshTime = useRef<number>(0);

  // Debounced refresh to prevent too many refreshes
  const debouncedRefresh = useCallback(() => {
    const now = Date.now();

    // Skip if refreshed within last debounceMs
    if (now - lastRefreshTime.current < debounceMs) {
      return;
    }

    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }

    debounceTimer.current = setTimeout(() => {
      lastRefreshTime.current = Date.now();
      onRefresh();
    }, debounceMs);
  }, [onRefresh, debounceMs]);

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // student_plan í…Œì´ë¸” ë³€ê²½ êµ¬ë…
    const planChannel = supabase
      .channel(`admin-plan-${studentId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'student_plan',
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log('[Admin Realtime] Plan updated:', payload.eventType);
          debouncedRefresh();
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[Admin Realtime] Subscribed to plan updates for student:', studentId);
        }
      });

    // ad_hoc_plans í…Œì´ë¸” ë³€ê²½ êµ¬ë…
    const adHocChannel = supabase
      .channel(`admin-adhoc-${studentId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'ad_hoc_plans',
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log('[Admin Realtime] Ad-hoc plan updated:', payload.eventType);
          debouncedRefresh();
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[Admin Realtime] Subscribed to ad-hoc updates for student:', studentId);
        }
      });

    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      supabase.removeChannel(planChannel);
      supabase.removeChannel(adHocChannel);
    };
  }, [studentId, enabled, debouncedRefresh]);
}
</file>

<file path="useAttendanceRealtime.ts">
"use client";

/**
 * P2 ê°œì„ : ì¶œì„ ê¸°ë¡ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ êµ¬ë…
 */

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UseAttendanceRealtimeOptions = {
  studentId: string;
  tenantId?: string;
  enabled?: boolean;
};

/**
 * ì¶œì„ ê¸°ë¡ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 * - í•™ìƒì˜ ì¶œì„ ê¸°ë¡ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ì¿¼ë¦¬ ë¬´íš¨í™”
 */
export function useAttendanceRealtime({
  studentId,
  tenantId,
  enabled = true,
}: UseAttendanceRealtimeOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`attendance-${studentId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "attendance_records",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Attendance updated:", payload);
          // ì¶œì„ ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
          queryClient.invalidateQueries({ queryKey: ["attendance", studentId] });
          queryClient.invalidateQueries({ queryKey: ["attendance", "stats"] });
          queryClient.invalidateQueries({ queryKey: ["dashboard", "attendance"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, tenantId, enabled, queryClient]);
}

/**
 * ê´€ë¦¬ììš© í…Œë„ŒíŠ¸ ì „ì²´ ì¶œì„ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 */
export function useAdminAttendanceRealtime({
  tenantId,
  enabled = true,
}: {
  tenantId: string;
  enabled?: boolean;
}) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !tenantId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`admin-attendance-${tenantId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "attendance_records",
          filter: `tenant_id=eq.${tenantId}`,
        },
        (payload) => {
          console.log("[Realtime] Admin attendance updated:", payload);
          queryClient.invalidateQueries({ queryKey: ["admin", "attendance"] });
          queryClient.invalidateQueries({ queryKey: ["admin", "dashboard"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [tenantId, enabled, queryClient]);
}
</file>

<file path="useChatPresence.ts">
"use client";

/**
 * useChatPresence - ì±„íŒ…ë°© Presence ìƒíƒœ ê´€ë¦¬
 *
 * Supabase Presence APIë¥¼ ì‚¬ìš©í•˜ì—¬:
 * - íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° (ëˆ„ê°€ ì…ë ¥ ì¤‘ì¸ì§€)
 * - ì˜¨ë¼ì¸ ìƒíƒœ (ëˆ„ê°€ ì ‘ì† ì¤‘ì¸ì§€)
 */

import { useEffect, useState, useCallback, useRef } from "react";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimeChannel } from "@supabase/supabase-js";
import type { PresenceUser } from "@/lib/domains/chat/types";

interface UseChatPresenceOptions {
  /** ì±„íŒ…ë°© ID */
  roomId: string;
  /** í˜„ì¬ ì‚¬ìš©ì ID */
  userId: string;
  /** í˜„ì¬ ì‚¬ìš©ì ì´ë¦„ */
  userName: string;
  /** í™œì„±í™” ì—¬ë¶€ */
  enabled?: boolean;
}

interface UseChatPresenceReturn {
  /** ì˜¨ë¼ì¸ ì‚¬ìš©ì ëª©ë¡ (ìì‹  ì œì™¸) */
  onlineUsers: PresenceUser[];
  /** íƒ€ì´í•‘ ì¤‘ì¸ ì‚¬ìš©ì ëª©ë¡ (ìì‹  ì œì™¸) */
  typingUsers: PresenceUser[];
  /** íƒ€ì´í•‘ ìƒíƒœ ì„¤ì • */
  setTyping: (isTyping: boolean) => void;
}

/** íƒ€ì´í•‘ ìë™ í•´ì œ íƒ€ì„ì•„ì›ƒ (ms) */
const TYPING_TIMEOUT = 2000;

export function useChatPresence({
  roomId,
  userId,
  userName,
  enabled = true,
}: UseChatPresenceOptions): UseChatPresenceReturn {
  const [onlineUsers, setOnlineUsers] = useState<PresenceUser[]>([]);
  const [typingUsers, setTypingUsers] = useState<PresenceUser[]>([]);
  const channelRef = useRef<RealtimeChannel | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Presence ì±„ë„ êµ¬ë…
  useEffect(() => {
    if (!enabled || !roomId || !userId || !userName) return;

    const supabase = createSupabaseBrowserClient();
    const channel = supabase.channel(`presence-${roomId}`, {
      config: {
        presence: {
          key: userId,
        },
      },
    });

    channel
      .on("presence", { event: "sync" }, () => {
        const state = channel.presenceState<PresenceUser>();

        // ëª¨ë“  ì‚¬ìš©ì ëª©ë¡ (ìì‹  ì œì™¸)
        const allUsers = Object.values(state)
          .flat()
          .filter((u) => u.userId !== userId);

        setOnlineUsers(allUsers);
        setTypingUsers(allUsers.filter((u) => u.isTyping));
      })
      .on("presence", { event: "join" }, ({ newPresences }) => {
        // ìƒˆ ì‚¬ìš©ì ì…ì¥ ì‹œ ë¡œê·¸ (ë””ë²„ê¹…ìš©)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User joined:", newPresences);
        }
      })
      .on("presence", { event: "leave" }, ({ leftPresences }) => {
        // ì‚¬ìš©ì í‡´ì¥ ì‹œ ë¡œê·¸ (ë””ë²„ê¹…ìš©)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User left:", leftPresences);
        }
      })
      .subscribe(async (status) => {
        if (status === "SUBSCRIBED") {
          // ì´ˆê¸° ìƒíƒœ ë“±ë¡
          await channel.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }
      });

    channelRef.current = channel;

    return () => {
      // íƒ€ì´í•‘ íƒ€ì„ì•„ì›ƒ ì •ë¦¬
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      // ì±„ë„ ì •ë¦¬
      channel.untrack();
      supabase.removeChannel(channel);
      channelRef.current = null;
    };
  }, [roomId, userId, userName, enabled]);

  // íƒ€ì´í•‘ ìƒíƒœ ì—…ë°ì´íŠ¸
  const setTyping = useCallback(
    (isTyping: boolean) => {
      if (!channelRef.current) return;

      // ê¸°ì¡´ íƒ€ì„ì•„ì›ƒ í´ë¦¬ì–´
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      channelRef.current.track({
        userId,
        name: userName,
        isTyping,
        lastSeen: new Date().toISOString(),
      });

      // íƒ€ì´í•‘ ì¤‘ì´ë©´ ìë™ í•´ì œ íƒ€ì´ë¨¸ ì„¤ì •
      if (isTyping) {
        typingTimeoutRef.current = setTimeout(() => {
          channelRef.current?.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }, TYPING_TIMEOUT);
      }
    },
    [userId, userName]
  );

  return {
    onlineUsers,
    typingUsers,
    setTyping,
  };
}
</file>

<file path="useChatRealtime.ts">
"use client";

/**
 * ì±„íŒ… ë©”ì‹œì§€ ì‹¤ì‹œê°„ êµ¬ë… í›…
 *
 * íŠ¹ì • ì±„íŒ…ë°©ì˜ ìƒˆ ë©”ì‹œì§€ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
 * Supabase Realtime postgres_changes ì‚¬ìš©.
 */

import { useEffect, useRef, useCallback } from "react";
import { useQueryClient, type InfiniteData } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";

// ë©”ì‹œì§€ í˜ì´ë¡œë“œ íƒ€ì…
interface ChatMessagePayload {
  id: string;
  room_id: string;
  sender_id: string;
  sender_type: "student" | "admin";
  message_type: "text" | "system";
  content: string;
  is_deleted: boolean;
  created_at: string;
}

// ë‹¨ì¼ í˜ì´ì§€ ìºì‹œ ë°ì´í„° íƒ€ì…
interface MessagesPage {
  messages: Array<ChatMessagePayload & {
    sender?: { name?: string; type?: string; id?: string };
    reply_to_id?: string | null;
    replyTarget?: unknown;
    reactions?: unknown[];
  }>;
  readCounts: Record<string, number>;
  hasMore: boolean;
}

// InfiniteQuery ìºì‹œ íƒ€ì…
type InfiniteMessagesCache = InfiniteData<MessagesPage, string | undefined>;

type UseChatRealtimeOptions = {
  /** ì±„íŒ…ë°© ID */
  roomId: string;
  /** í˜„ì¬ ì‚¬ìš©ì ID (ë³¸ì¸ ë©”ì‹œì§€ êµ¬ë¶„ìš©) */
  userId: string;
  /** êµ¬ë… í™œì„±í™” ì—¬ë¶€ */
  enabled?: boolean;
  /** ìƒˆ ë©”ì‹œì§€ ìˆ˜ì‹  ì½œë°± */
  onNewMessage?: (message: ChatMessagePayload) => void;
  /** ë©”ì‹œì§€ ì‚­ì œ ì½œë°± */
  onMessageDeleted?: (messageId: string) => void;
};

/**
 * ì±„íŒ… ë©”ì‹œì§€ ì‹¤ì‹œê°„ êµ¬ë… í›…
 *
 * @example
 * ```tsx
 * useChatRealtime({
 *   roomId: "room-123",
 *   userId: "user-456",
 *   onNewMessage: (msg) => {
 *     // ìŠ¤í¬ë¡¤ ë˜ëŠ” ì•Œë¦¼ ì²˜ë¦¬
 *   },
 * });
 * ```
 */
export function useChatRealtime({
  roomId,
  userId,
  enabled = true,
  onNewMessage,
  onMessageDeleted,
}: UseChatRealtimeOptions) {
  const queryClient = useQueryClient();

  // ì½œë°±ì„ refë¡œ ì €ì¥í•˜ì—¬ ì˜ì¡´ì„± ë³€ê²½ ë°©ì§€
  const callbacksRef = useRef({ onNewMessage, onMessageDeleted });
  useEffect(() => {
    callbacksRef.current = { onNewMessage, onMessageDeleted };
  }, [onNewMessage, onMessageDeleted]);

  // ì¿¼ë¦¬ ë¬´íš¨í™” í•¨ìˆ˜
  const invalidateMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-messages" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  const invalidatePinnedMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-pinned" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateAnnouncement = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-announcement" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  useEffect(() => {
    if (!enabled || !roomId || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-room-${roomId}`)
      // ìƒˆ ë©”ì‹œì§€ INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] New message:", payload.new);
          const newMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryDataë¡œ ìºì‹œì— ì§ì ‘ ì¶”ê°€ (ì„œë²„ ì¬ìš”ì²­ ì—†ìŒ) - InfiniteQuery êµ¬ì¡°
          queryClient.setQueryData(
            ["chat-messages", roomId],
            (old: InfiniteMessagesCache | undefined) => {
              if (!old?.pages?.length || !newMessage) return old;

              // ì²« ë²ˆì§¸ í˜ì´ì§€(ìµœì‹  ë©”ì‹œì§€ë“¤)ì—ì„œ ì¤‘ë³µ ì²´í¬ ë° ì¶”ê°€
              const firstPage = old.pages[0];
              const existingIndex = firstPage.messages.findIndex(
                (m) => m.id === newMessage.id ||
                       (m.id.startsWith("temp-") && m.content === newMessage.content && m.sender_id === newMessage.sender_id)
              );

              if (existingIndex !== -1) {
                // ì„ì‹œ IDë¥¼ ì‹¤ì œ IDë¡œ êµì²´ (status í•„ë“œ ì œê±°)
                const updatedMessages = [...firstPage.messages];
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { status: _status, ...existingMessage } = updatedMessages[existingIndex] as typeof updatedMessages[number] & { status?: string };
                updatedMessages[existingIndex] = {
                  ...existingMessage,
                  ...newMessage,
                  sender: firstPage.messages[existingIndex].sender, // ê¸°ì¡´ sender ì •ë³´ ìœ ì§€
                };
                return {
                  ...old,
                  pages: [{ ...firstPage, messages: updatedMessages }, ...old.pages.slice(1)],
                };
              }

              // ìƒˆ ë©”ì‹œì§€ë¥¼ ì²« ë²ˆì§¸ í˜ì´ì§€ ëì— ì¶”ê°€
              return {
                ...old,
                pages: [
                  {
                    ...firstPage,
                    messages: [...firstPage.messages, {
                      ...newMessage,
                      sender: { name: "ì•Œ ìˆ˜ ì—†ìŒ", type: newMessage.sender_type, id: newMessage.sender_id },
                    }],
                  },
                  ...old.pages.slice(1),
                ],
              };
            }
          );

          // ì±„íŒ…ë°© ëª©ë¡ë„ ë¬´íš¨í™” (ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸)
          invalidateRoomList();

          // ì½œë°± í˜¸ì¶œ (íƒ€ì¸ì˜ ë©”ì‹œì§€ë§Œ)
          if (newMessage?.sender_id && newMessage.sender_id !== userId) {
            callbacksRef.current.onNewMessage?.(newMessage);
          }
        }
      )
      // ë©”ì‹œì§€ UPDATE (ì‚­ì œ/ìˆ˜ì • ë“±)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] Message updated:", payload.new);
          const updatedMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryDataë¡œ í•´ë‹¹ ë©”ì‹œì§€ë§Œ ì—…ë°ì´íŠ¸ (ì„œë²„ ì¬ìš”ì²­ ì—†ìŒ) - InfiniteQuery êµ¬ì¡°
          queryClient.setQueryData(
            ["chat-messages", roomId],
            (old: InfiniteMessagesCache | undefined) => {
              if (!old?.pages?.length || !updatedMessage) return old;

              // ëª¨ë“  í˜ì´ì§€ì—ì„œ í•´ë‹¹ ë©”ì‹œì§€ ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸
              return {
                ...old,
                pages: old.pages.map((page) => ({
                  ...page,
                  messages: page.messages.map((m) =>
                    m.id === updatedMessage.id
                      ? { ...m, ...updatedMessage }
                      : m
                  ),
                })),
              };
            }
          );

          // ì‚­ì œëœ ê²½ìš° ì½œë°± í˜¸ì¶œ
          if (updatedMessage?.is_deleted && updatedMessage.id) {
            callbacksRef.current.onMessageDeleted?.(updatedMessage.id);
          }
        }
      )
      // ë¦¬ì•¡ì…˜ INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_message_reactions",
        },
        () => {
          console.log("[ChatRealtime] Reaction added");
          invalidateMessages();
        }
      )
      // ë¦¬ì•¡ì…˜ DELETE
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_message_reactions",
        },
        () => {
          console.log("[ChatRealtime] Reaction removed");
          invalidateMessages();
        }
      )
      // ê³ ì • ë©”ì‹œì§€ INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_pinned_messages",
          filter: `room_id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Message pinned");
          invalidatePinnedMessages();
        }
      )
      // ê³ ì • ë©”ì‹œì§€ DELETE
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_pinned_messages",
        },
        () => {
          console.log("[ChatRealtime] Message unpinned");
          invalidatePinnedMessages();
        }
      )
      // ì±„íŒ…ë°© UPDATE (ê³µì§€ ë³€ê²½)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_rooms",
          filter: `id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Room updated (announcement)");
          invalidateAnnouncement();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room ${roomId} subscription:`, status);
      });

    return () => {
      console.log(`[ChatRealtime] Unsubscribing from room ${roomId}`);
      supabase.removeChannel(channel);
    };
  }, [roomId, userId, enabled, invalidateMessages, invalidateRoomList, invalidatePinnedMessages, invalidateAnnouncement]);
}

// ============================================
// ì±„íŒ…ë°© ëª©ë¡ ì‹¤ì‹œê°„ êµ¬ë…
// ============================================

type UseChatRoomListRealtimeOptions = {
  /** í˜„ì¬ ì‚¬ìš©ì ID */
  userId: string;
  /** ì‚¬ìš©ì ìœ í˜• */
  userType: "student" | "admin";
  /** êµ¬ë… í™œì„±í™” ì—¬ë¶€ */
  enabled?: boolean;
};

/**
 * ì±„íŒ…ë°© ëª©ë¡ ì‹¤ì‹œê°„ êµ¬ë… í›…
 *
 * ìƒˆ ì±„íŒ…ë°© ìƒì„±, ë©¤ë²„ ë³€ê²½ ë“±ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°˜ì˜í•©ë‹ˆë‹¤.
 */
export function useChatRoomListRealtime({
  userId,
  userType,
  enabled = true,
}: UseChatRoomListRealtimeOptions) {
  const queryClient = useQueryClient();

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  useEffect(() => {
    if (!enabled || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-rooms-${userId}`)
      // ë‚´ê°€ ë©¤ë²„ë¡œ ì¶”ê°€ëœ ê²½ìš°
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Added to room:", payload);
          invalidateRoomList();
        }
      )
      // ë©¤ë²„ì‹­ ë³€ê²½ (ë‚˜ê°€ê¸° ë“±)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Membership updated:", payload);
          invalidateRoomList();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room list subscription:`, status);
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, userType, enabled, invalidateRoomList]);
}
</file>

<file path="useNotificationRealtime.ts">
"use client";

/**
 * ì‹¤ì‹œê°„ ì•Œë¦¼ êµ¬ë… í›…
 *
 * Supabase Realtimeì„ ì‚¬ìš©í•˜ì—¬ ì•Œë¦¼ í…Œì´ë¸”ì˜ ë³€ê²½ì‚¬í•­ì„ êµ¬ë…í•©ë‹ˆë‹¤.
 * ìƒˆ ì•Œë¦¼ì´ ìƒì„±ë˜ë©´ ì½œë°±ì„ í˜¸ì¶œí•˜ê³  React Query ìºì‹œë¥¼ ë¬´íš¨í™”í•©ë‹ˆë‹¤.
 *
 * @module lib/realtime/useNotificationRealtime
 */

import { useEffect, useCallback, useRef } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

export type NotificationPayload = {
  id: string;
  user_id: string;
  type: string;
  title: string;
  message: string;
  metadata: Record<string, unknown> | null;
  is_read: boolean;
  created_at: string;
  read_at: string | null;
  tenant_id: string | null;
};

export type NotificationRealtimeEvent = "INSERT" | "UPDATE" | "DELETE";

export type NotificationEventHandler = (
  event: NotificationRealtimeEvent,
  notification: NotificationPayload
) => void;

export type UseNotificationRealtimeOptions = {
  /** ì‚¬ìš©ì ID */
  userId: string;
  /** í™œì„±í™” ì—¬ë¶€ (ê¸°ë³¸ê°’: true) */
  enabled?: boolean;
  /** ìƒˆ ì•Œë¦¼ ìƒì„± ì‹œ ì½œë°± */
  onNewNotification?: (notification: NotificationPayload) => void;
  /** ì•Œë¦¼ ì—…ë°ì´íŠ¸ ì‹œ ì½œë°± (ì½ìŒ ì²˜ë¦¬ ë“±) */
  onNotificationUpdate?: (notification: NotificationPayload) => void;
  /** ì•Œë¦¼ ì‚­ì œ ì‹œ ì½œë°± */
  onNotificationDelete?: (notification: NotificationPayload) => void;
  /** ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ ì—¬ë¶€ (ê¸°ë³¸ê°’: true) */
  showBrowserNotification?: boolean;
};

// ============================================
// ë¸Œë¼ìš°ì € ì•Œë¦¼ ìœ í‹¸ë¦¬í‹°
// ============================================

/**
 * ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
 */
export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!("Notification" in window)) {
    console.warn("[Notification] ì´ ë¸Œë¼ìš°ì €ëŠ” ì•Œë¦¼ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return "denied";
  }

  if (Notification.permission === "granted") {
    return "granted";
  }

  if (Notification.permission !== "denied") {
    const permission = await Notification.requestPermission();
    return permission;
  }

  return Notification.permission;
}

/**
 * ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ
 */
function showBrowserNotification(
  title: string,
  body: string,
  options?: NotificationOptions
): void {
  if (!("Notification" in window)) {
    return;
  }

  if (Notification.permission !== "granted") {
    return;
  }

  try {
    // renotifyëŠ” ì¼ë¶€ ë¸Œë¼ìš°ì €ì—ì„œ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
    const notificationOptions: NotificationOptions = {
      body,
      icon: "/icons/icon-192x192.png",
      badge: "/icons/icon-192x192.png",
      tag: "notification",
      ...options,
    };

    const notification = new Notification(title, notificationOptions);

    // í´ë¦­ ì‹œ ì•±ìœ¼ë¡œ í¬ì»¤ìŠ¤
    notification.onclick = () => {
      window.focus();
      notification.close();
    };

    // 5ì´ˆ í›„ ìë™ ë‹«ê¸°
    setTimeout(() => {
      notification.close();
    }, 5000);
  } catch (error) {
    console.error("[Notification] ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ ì‹¤íŒ¨:", error);
  }
}

// ============================================
// ë©”ì¸ í›…
// ============================================

/**
 * ì‹¤ì‹œê°„ ì•Œë¦¼ êµ¬ë… í›…
 *
 * @example
 * ```tsx
 * function NotificationBell() {
 *   const { unreadCount, setUnreadCount } = useNotificationState();
 *
 *   useNotificationRealtime({
 *     userId: currentUser.id,
 *     onNewNotification: (notification) => {
 *       setUnreadCount((prev) => prev + 1);
 *       toast.info(notification.title);
 *     },
 *     onNotificationUpdate: (notification) => {
 *       if (notification.is_read) {
 *         setUnreadCount((prev) => Math.max(0, prev - 1));
 *       }
 *     },
 *   });
 *
 *   return <Badge count={unreadCount}>ì•Œë¦¼</Badge>;
 * }
 * ```
 */
export function useNotificationRealtime({
  userId,
  enabled = true,
  onNewNotification,
  onNotificationUpdate,
  onNotificationDelete,
  showBrowserNotification: showBrowserNotif = true,
}: UseNotificationRealtimeOptions) {
  const queryClient = useQueryClient();
  const callbacksRef = useRef({
    onNewNotification,
    onNotificationUpdate,
    onNotificationDelete,
  });

  // ì½œë°± ë ˆí¼ëŸ°ìŠ¤ ì—…ë°ì´íŠ¸ (ë¦¬ë Œë”ë§ ì‹œì—ë„ ìµœì‹  ì½œë°± ì‚¬ìš©)
  useEffect(() => {
    callbacksRef.current = {
      onNewNotification,
      onNotificationUpdate,
      onNotificationDelete,
    };
  }, [onNewNotification, onNotificationUpdate, onNotificationDelete]);

  // React Query ìºì‹œ ë¬´íš¨í™”
  const invalidateNotificationQueries = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        (query.queryKey[0] === "notifications" ||
          query.queryKey[0] === "unreadNotifications" ||
          query.queryKey[0] === "notificationCount"),
    });
  }, [queryClient]);

  // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleRealtimeEvent = useCallback(
    (payload: RealtimePostgresChangesPayload<NotificationPayload>) => {
      const event = payload.eventType as NotificationRealtimeEvent;
      const newRecord = payload.new as NotificationPayload | undefined;
      const oldRecord = payload.old as NotificationPayload | undefined;

      console.log("[Notification Realtime] Event:", event, payload);

      // React Query ìºì‹œ ë¬´íš¨í™”
      invalidateNotificationQueries();

      switch (event) {
        case "INSERT":
          if (newRecord) {
            // ìƒˆ ì•Œë¦¼ ì½œë°± í˜¸ì¶œ
            callbacksRef.current.onNewNotification?.(newRecord);

            // ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ
            if (showBrowserNotif && !newRecord.is_read) {
              showBrowserNotification(newRecord.title, newRecord.message, {
                data: { notificationId: newRecord.id, type: newRecord.type },
              });
            }
          }
          break;

        case "UPDATE":
          if (newRecord) {
            callbacksRef.current.onNotificationUpdate?.(newRecord);
          }
          break;

        case "DELETE":
          if (oldRecord) {
            callbacksRef.current.onNotificationDelete?.(oldRecord);
          }
          break;
      }
    },
    [invalidateNotificationQueries, showBrowserNotif]
  );

  // ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ì¼ì‹œì  ì•Œë¦¼ìš©)
  const handleBroadcastEvent = useCallback(
    (payload: { payload: NotificationPayload }) => {
      const notification = payload.payload;
      console.log("[Notification Realtime] Broadcast received:", notification);

      // ìƒˆ ì•Œë¦¼ ì½œë°± í˜¸ì¶œ
      callbacksRef.current.onNewNotification?.(notification);

      // ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ
      if (showBrowserNotif && !notification.is_read) {
        showBrowserNotification(notification.title, notification.message, {
          data: { notificationId: notification.id, type: notification.type },
        });
      }
    },
    [showBrowserNotif]
  );

  // Supabase Realtime êµ¬ë…
  useEffect(() => {
    if (!enabled || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // ì•Œë¦¼ í…Œì´ë¸” ë³€ê²½ ë° ë¸Œë¡œë“œìºìŠ¤íŠ¸ êµ¬ë…
    const channel = supabase
      .channel(`notifications-${userId}`)
      // DB ë³€ê²½ êµ¬ë… (ì˜êµ¬ ì•Œë¦¼)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "notifications",
          filter: `user_id=eq.${userId}`,
        },
        handleRealtimeEvent
      )
      // ë¸Œë¡œë“œìºìŠ¤íŠ¸ êµ¬ë… (ì¼ì‹œì  ì•Œë¦¼)
      .on("broadcast", { event: "notification" }, handleBroadcastEvent)
      .subscribe((status) => {
        console.log("[Notification Realtime] Subscription status:", status);
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, enabled, handleRealtimeEvent, handleBroadcastEvent]);
}

// ============================================
// ìœ í‹¸ë¦¬í‹° í›…
// ============================================

/**
 * ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ ìƒíƒœ í›…
 */
export function useNotificationPermission() {
  const getPermission = useCallback((): NotificationPermission => {
    if (!("Notification" in window)) {
      return "denied";
    }
    return Notification.permission;
  }, []);

  const requestPermission = useCallback(async () => {
    return requestNotificationPermission();
  }, []);

  return {
    permission: typeof window !== "undefined" ? getPermission() : "default",
    requestPermission,
    isSupported: typeof window !== "undefined" && "Notification" in window,
  };
}
</file>

<file path="usePlanGroupRealtime.ts">
"use client";

/**
 * P2 ê°œì„ : í”Œëœ ê·¸ë£¹ ìƒíƒœ ë³€ê²½ ì‹¤ì‹œê°„ êµ¬ë…
 */

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UsePlanGroupRealtimeOptions = {
  studentId: string;
  enabled?: boolean;
};

/**
 * í”Œëœ ê·¸ë£¹ ìƒíƒœ ë³€ê²½ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 * - í”Œëœ ê·¸ë£¹ ìƒíƒœ ë³€ê²½(active, paused, completed ë“±) ì‹œ ìë™ ë°˜ì˜
 */
export function usePlanGroupRealtime({
  studentId,
  enabled = true,
}: UsePlanGroupRealtimeOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`plan-groups-${studentId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group updated:", payload);
          // í”Œëœ ê·¸ë£¹ ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
          queryClient.invalidateQueries({ queryKey: ["dashboard", "planGroups"] });
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group created:", payload);
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
        }
      )
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group deleted:", payload);
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, enabled, queryClient]);
}

/**
 * í”Œëœ ì§„í–‰ë¥  ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 * - student_plan í…Œì´ë¸”ì˜ completed_amount, progress ë³€ê²½ ì‹œ ìë™ ë°˜ì˜
 */
export function usePlanProgressRealtime({
  studentId,
  planGroupId,
  enabled = true,
}: {
  studentId: string;
  planGroupId?: string;
  enabled?: boolean;
}) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channelName = planGroupId
      ? `plan-progress-${studentId}-${planGroupId}`
      : `plan-progress-${studentId}`;

    const channel = supabase
      .channel(channelName)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "student_plan",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          const newRecord = payload.new as {
            completed_amount?: number;
            progress?: number;
            plan_group_id?: string;
          };

          // completed_amount ë˜ëŠ” progressê°€ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì²˜ë¦¬
          if (
            newRecord.completed_amount !== undefined ||
            newRecord.progress !== undefined
          ) {
            console.log("[Realtime] Plan progress updated:", payload);

            // ì§„í–‰ë¥  ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
            queryClient.invalidateQueries({ queryKey: ["plans", studentId] });
            queryClient.invalidateQueries({ queryKey: ["today", "progress"] });
            queryClient.invalidateQueries({ queryKey: ["dashboard", "progress"] });

            if (planGroupId) {
              queryClient.invalidateQueries({
                queryKey: ["planGroup", planGroupId, "progress"],
              });
            }
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, planGroupId, enabled, queryClient]);
}
</file>

<file path="usePlanRealtimeUpdates.ts">
"use client";

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UsePlanRealtimeUpdatesOptions = {
  planDate: string;
  userId: string;
  enabled?: boolean;
};

export function usePlanRealtimeUpdates({
  planDate,
  userId,
  enabled = true,
}: UsePlanRealtimeUpdatesOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !planDate || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // í”Œëœ ë³€ê²½ êµ¬ë…
    const planChannel = supabase
      .channel(`plan-updates-${userId}-${planDate}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "student_plan",
          filter: `student_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan updated:", payload);
          // predicate ê¸°ë°˜ ë¬´íš¨í™”ë¡œ ëª¨ë“  ê´€ë ¨ ì¿¼ë¦¬ ì²˜ë¦¬
          queryClient.invalidateQueries({
            predicate: (query) =>
              Array.isArray(query.queryKey) &&
              (query.queryKey[0] === "todayPlans" ||
                query.queryKey[0] === "todayContainerPlans" ||
                query.queryKey[0] === "today" ||
                query.queryKey[0] === "plans"),
          });
        }
      )
      .subscribe();

    // í•™ìŠµ ì„¸ì…˜ ë³€ê²½ êµ¬ë…
    const sessionChannel = supabase
      .channel(`session-updates-${userId}-${planDate}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "student_study_sessions",
          filter: `student_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[Realtime] Session updated:", payload);
          // predicate ê¸°ë°˜ ë¬´íš¨í™”ë¡œ ëª¨ë“  ê´€ë ¨ ì¿¼ë¦¬ ì²˜ë¦¬
          queryClient.invalidateQueries({
            predicate: (query) =>
              Array.isArray(query.queryKey) &&
              (query.queryKey[0] === "todayPlans" ||
                query.queryKey[0] === "today" ||
                query.queryKey[0] === "sessions"),
          });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(planChannel);
      supabase.removeChannel(sessionChannel);
    };
  }, [planDate, userId, enabled, queryClient]);
}
</file>

</files>
