This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
[notifications]/
  NotificationCenter.tsx

[notifications]/
  _components/
    NotificationSettingsView.tsx
  actions/
    notificationActions.ts
  page.tsx

[services]/
  attendanceSMSService.ts
  campInvitationExpiryService.ts
  campNotificationService.ts
  campReminderService.ts
  emailService.ts
  inAppNotificationService.ts
  locationService.ts
  planReminderService.ts
  qrCodeService.ts
  smsService.ts
  smsTemplates.ts

[realtime]/
  index.ts
  useAdminPlanRealtime.ts
  useAttendanceRealtime.ts
  useChatPresence.ts
  useChatRealtime.ts
  useNotificationRealtime.ts
  usePlanGroupRealtime.ts
  usePlanRealtimeUpdates.ts

[actions]/
  consulting.ts
  divisions.ts
  index.ts
  management.ts
  notifications.ts
  parentLinks.ts
  profile.ts
  sessions.ts

[hooks]/
  useActivePlan.ts
  useActivePlanDetails.ts
  useAdminDockQueries.ts
  useAdminFormSubmit.ts
  useAttendance.ts
  useBeforeUnload.ts
  useBlockSet.ts
  useBlockSets.ts
  useBookMetadata.ts
  useCalendarTimeSelection.ts
  useCampLearning.ts
  useCampStats.ts
  useCampTemplates.ts
  useContainerDragDrop.ts
  useContainerMoveActions.ts
  useDebounce.ts
  useDeviceConflict.ts
  useDifficultyOptions.ts
  useGlobalShortcuts.ts
  useIdempotencyKey.ts
  useInstallPrompt.ts
  useInterval.ts
  useInvalidationHandler.ts
  useKeyboardShortcuts.ts
  useLectureEpisodesCalculation.ts
  useLongPress.ts
  useMasterBooksRefresh.ts
  useMasterContentSearch.ts
  useMilestoneNotification.ts
  useNetworkStatus.ts
  usePagination.ts
  usePlanCardActions.ts
  usePlanDragDrop.ts
  usePlanGenerationProgress.ts
  usePlanGroups.ts
  usePlanPeriod.ts
  usePlanReminder.ts
  usePlanReorder.ts
  usePlans.ts
  usePlanTimer.ts
  usePlanViewState.ts
  useReducedMotion.ts
  useSchoolSearch.ts
  useScoreFilter.ts
  useServerAction.ts
  useServerForm.ts
  useStudentContents.ts
  useSubjectSelection.ts
  useTodayPlans.ts
  useTypedQuery.ts
  useUndoRedo.ts
  useWeeklyOptimization.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="NotificationCenter.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { Bell, X, Check } from "lucide-react";
import { useToast } from "@/components/ui/ToastProvider";
import type { Notification } from "@/lib/services/inAppNotificationService";

type NotificationCenterProps = {
  userId: string;
};

export function NotificationCenter({ userId }: NotificationCenterProps) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const toast = useToast();

  // 알림 조회
  const fetchNotifications = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/notifications");
      if (!response.ok) {
        throw new Error("알림 조회에 실패했습니다.");
      }
      const data = await response.json();
      setNotifications(data.notifications || []);
    } catch (error) {
      console.error("[NotificationCenter] 알림 조회 실패:", error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // SSE 연결 설정
  useEffect(() => {
    if (!userId) return;

    const eventSource = new EventSource("/api/notifications/stream");

    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "initial" || data.type === "update") {
          setNotifications(data.notifications || []);
          
          // 새 알림이 있으면 토스트 표시
          if (data.type === "update" && data.notifications.length > 0) {
            const unreadCount = data.notifications.filter(
              (n: Notification) => !n.read
            ).length;
            if (unreadCount > 0) {
              toast.showInfo(`새 알림 ${unreadCount}개가 도착했습니다.`);
            }
          }
        }
      } catch (error) {
        console.error("[NotificationCenter] SSE 메시지 파싱 실패:", error);
      }
    };

    eventSource.onerror = (error) => {
      console.error("[NotificationCenter] SSE 연결 오류:", error);
      eventSource.close();
      // 재연결 시도
      setTimeout(() => {
        if (userId) {
          fetchNotifications();
        }
      }, 5000);
    };

    return () => {
      eventSource.close();
    };
  }, [userId, toast, fetchNotifications]);

  // 초기 로드
  useEffect(() => {
    if (userId) {
      fetchNotifications();
    }
  }, [userId, fetchNotifications]);

  // 알림 읽음 처리
  const markAsRead = async (notificationId: string) => {
    try {
      const response = await fetch(`/api/notifications/${notificationId}/read`, {
        method: "POST",
      });
      if (!response.ok) {
        throw new Error("알림 읽음 처리에 실패했습니다.");
      }
      setNotifications((prev) =>
        prev.map((n) =>
          n.id === notificationId ? { ...n, read: true } : n
        )
      );
    } catch (error) {
      console.error("[NotificationCenter] 알림 읽음 처리 실패:", error);
      toast.showError("알림 읽음 처리에 실패했습니다.");
    }
  };

  // 모든 알림 읽음 처리
  const markAllAsRead = async () => {
    try {
      const response = await fetch("/api/notifications/read-all", {
        method: "POST",
      });
      if (!response.ok) {
        throw new Error("전체 알림 읽음 처리에 실패했습니다.");
      }
      setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
    } catch (error) {
      console.error("[NotificationCenter] 전체 알림 읽음 처리 실패:", error);
      toast.showError("전체 알림 읽음 처리에 실패했습니다.");
    }
  };

  // 알림 삭제
  const deleteNotification = async (notificationId: string) => {
    try {
      const response = await fetch(`/api/notifications/${notificationId}`, {
        method: "DELETE",
      });
      if (!response.ok) {
        throw new Error("알림 삭제에 실패했습니다.");
      }
      setNotifications((prev) => prev.filter((n) => n.id !== notificationId));
    } catch (error) {
      console.error("[NotificationCenter] 알림 삭제 실패:", error);
      toast.showError("알림 삭제에 실패했습니다.");
    }
  };

  const unreadCount = notifications.filter((n) => !n.read).length;

  return (
    <div className="relative">
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-900 transition"
        aria-label="알림"
      >
        <Bell className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-semibold text-white">
            {unreadCount > 9 ? "9+" : unreadCount}
          </span>
        )}
      </button>

      {isOpen && (
        <>
          <div
            className="fixed inset-0 z-40"
            onClick={() => setIsOpen(false)}
          />
          <div className="absolute right-0 top-12 z-50 w-96 rounded-lg border border-gray-200 bg-white shadow-lg">
            <div className="flex items-center justify-between border-b border-gray-200 p-4">
              <h3 className="text-lg font-semibold text-gray-900">알림</h3>
              <div className="flex items-center gap-2">
                {unreadCount > 0 && (
                  <button
                    type="button"
                    onClick={markAllAsRead}
                    className="text-sm text-indigo-600 hover:text-indigo-800"
                  >
                    모두 읽음
                  </button>
                )}
                <button
                  type="button"
                  onClick={() => setIsOpen(false)}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="h-5 w-5" />
                </button>
              </div>
            </div>

            <div className="max-h-96 overflow-y-auto">
              {isLoading ? (
                <div className="p-4 text-center text-sm text-gray-500">
                  알림을 불러오는 중...
                </div>
              ) : notifications.length === 0 ? (
                <div className="p-4 text-center text-sm text-gray-500">
                  알림이 없습니다.
                </div>
              ) : (
                <div className="divide-y divide-gray-100">
                  {notifications.map((notification) => (
                    <div
                      key={notification.id}
                      className={`p-4 hover:bg-gray-50 ${
                        !notification.read ? "bg-blue-50" : ""
                      }`}
                    >
                      <div className="flex items-start justify-between gap-2">
                        <div className="flex-1">
                          <h4 className="text-sm font-semibold text-gray-900">
                            {notification.title}
                          </h4>
                          <p className="mt-1 text-sm text-gray-600">
                            {notification.message}
                          </p>
                          <p className="mt-1 text-xs text-gray-400">
                            {new Date(notification.createdAt).toLocaleString(
                              "ko-KR"
                            )}
                          </p>
                        </div>
                        <div className="flex items-center gap-1">
                          {!notification.read && (
                            <button
                              type="button"
                              onClick={() => markAsRead(notification.id)}
                              className="p-1 text-gray-400 hover:text-indigo-600"
                              title="읽음 처리"
                            >
                              <Check className="h-4 w-4" />
                            </button>
                          )}
                          <button
                            type="button"
                            onClick={() => deleteNotification(notification.id)}
                            className="p-1 text-gray-400 hover:text-red-600"
                            title="삭제"
                          >
                            <X className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="_components/NotificationSettingsView.tsx">
"use client";

import { useState, useTransition } from "react";
import { updateNotificationSettings } from "../actions/notificationActions";
import { cn } from "@/lib/cn";
import { SectionCard } from "@/components/ui/SectionCard";
import {
  getFormLabelClasses,
  getFormInputClasses,
  textPrimaryVar,
} from "@/lib/utils/darkMode";

type NotificationSettings = {
  plan_start_enabled: boolean;
  plan_complete_enabled: boolean;
  daily_goal_achieved_enabled: boolean;
  weekly_report_enabled: boolean;
  plan_delay_enabled: boolean;
  plan_delay_threshold_minutes: number;
  notification_time_start: string;
  notification_time_end: string;
  quiet_hours_enabled: boolean;
  quiet_hours_start: string;
  quiet_hours_end: string;
  attendance_check_in_enabled?: boolean | null;
  attendance_check_out_enabled?: boolean | null;
  attendance_absent_enabled?: boolean | null;
  attendance_late_enabled?: boolean | null;
};

type NotificationSettingsViewProps = {
  initialSettings: NotificationSettings;
};

export function NotificationSettingsView({
  initialSettings,
}: NotificationSettingsViewProps) {
  const [settings, setSettings] = useState<NotificationSettings>(initialSettings);
  const [isPending, startTransition] = useTransition();
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleToggle = (key: keyof NotificationSettings) => {
    if (typeof settings[key] === "boolean" || settings[key] === null || settings[key] === undefined) {
      const currentValue = settings[key];
      const newValue = currentValue === true ? false : currentValue === false ? null : true;
      setSettings((prev) => ({ ...prev, [key]: newValue }));
      setSuccess(false);
      setError(null);
    }
  };

  const handleChange = (
    key: keyof NotificationSettings,
    value: string | number
  ) => {
    setSettings((prev) => ({ ...prev, [key]: value }));
    setSuccess(false);
    setError(null);
  };

  const handleSave = () => {
    startTransition(async () => {
      try {
        const result = await updateNotificationSettings(settings);
        if (result.success) {
          setSuccess(true);
          setError(null);
          setTimeout(() => setSuccess(false), 3000);
        } else {
          setError(result.error || "저장에 실패했습니다.");
        }
      } catch (err: any) {
        setError(err.message || "저장 중 오류가 발생했습니다.");
      }
    });
  };

  const hasChanges =
    JSON.stringify(settings) !== JSON.stringify(initialSettings);

  return (
    <div className="flex flex-col gap-6">
      {/* 저장 성공/에러 메시지 */}
      {success && (
        <div className="rounded-lg border border-green-200 bg-green-50 p-4 text-sm text-green-800">
          설정이 저장되었습니다.
        </div>
      )}
      {error && (
        <div className="rounded-lg border border-red-200 bg-red-50 p-4 text-sm text-red-800">
          {error}
        </div>
      )}

      {/* 알림 유형 설정 */}
      <SectionCard title="알림 유형">
        <div className="flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className={cn("font-medium", textPrimaryVar)}>학습 시작 알림</div>
                <div className="text-sm text-gray-500 dark:text-gray-400">
                  플랜을 시작할 때 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("plan_start_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.plan_start_enabled ? "bg-indigo-600" : "bg-gray-200 dark:bg-gray-700"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.plan_start_enabled ? "translate-x-6" : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">학습 완료 알림</div>
                <div className="text-sm text-gray-500">
                  플랜을 완료할 때 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("plan_complete_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.plan_complete_enabled ? "bg-indigo-600" : "bg-gray-200"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.plan_complete_enabled
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">일일 목표 달성 알림</div>
                <div className="text-sm text-gray-500">
                  일일 학습 목표를 달성했을 때 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("daily_goal_achieved_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.daily_goal_achieved_enabled
                  ? "bg-indigo-600"
                  : "bg-gray-200"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.daily_goal_achieved_enabled
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">주간 리포트 알림</div>
                <div className="text-sm text-gray-500">
                  주간 학습 리포트를 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("weekly_report_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.weekly_report_enabled ? "bg-indigo-600" : "bg-gray-200"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.weekly_report_enabled
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">플랜 지연 알림</div>
                <div className="text-sm text-gray-500">
                  예정된 시간보다 늦게 시작할 때 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("plan_delay_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.plan_delay_enabled ? "bg-indigo-600" : "bg-gray-200"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.plan_delay_enabled
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            {settings.plan_delay_enabled && (
              <div className="rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900/30 p-4">
                <div className="flex flex-col gap-2">
                  <label className={getFormLabelClasses()}>
                    지연 임계값 (분)
                  </label>
                  <input
                    type="number"
                    min="5"
                    max="120"
                    step="5"
                    value={settings.plan_delay_threshold_minutes}
                    onChange={(e) =>
                      handleChange(
                        "plan_delay_threshold_minutes",
                        parseInt(e.target.value) || 30
                      )
                    }
                    className={cn(getFormInputClasses(false, false, false), "w-32")}
                  />
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    예정 시간보다 이 시간만큼 늦으면 알림을 받습니다
                  </p>
                </div>
              </div>
            )}
        </div>
      </SectionCard>

      {/* 알림 시간 설정 */}
      <SectionCard title="알림 시간">
        <div className="flex flex-col gap-4">
          <div className="flex items-center gap-4">
            <label className={cn("w-32", getFormLabelClasses())}>
              알림 시작 시간
            </label>
            <input
              type="time"
              value={settings.notification_time_start}
              onChange={(e) =>
                handleChange("notification_time_start", e.target.value)
              }
              className={cn(getFormInputClasses(false, false, false), "text-sm")}
            />
            <span className="text-sm text-gray-500 dark:text-gray-400">부터</span>
          </div>

          <div className="flex items-center gap-4">
            <label className={cn("w-32", getFormLabelClasses())}>
              알림 종료 시간
            </label>
            <input
              type="time"
              value={settings.notification_time_end}
              onChange={(e) =>
                handleChange("notification_time_end", e.target.value)
              }
              className={cn(getFormInputClasses(false, false, false), "text-sm")}
            />
            <span className="text-sm text-gray-500 dark:text-gray-400">까지</span>
          </div>
        </div>
      </SectionCard>

      {/* 방해 금지 시간 설정 */}
      <SectionCard
        title="방해 금지 시간"
        headerAction={
          <button
            type="button"
            onClick={() => handleToggle("quiet_hours_enabled")}
            className={cn(
              "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
              settings.quiet_hours_enabled ? "bg-indigo-600" : "bg-gray-200"
            )}
          >
            <span
              className={cn(
                "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                settings.quiet_hours_enabled
                  ? "translate-x-6"
                  : "translate-x-1"
              )}
            />
          </button>
        }
        description="방해 금지 시간 동안에는 알림을 받지 않습니다"
      >

        {settings.quiet_hours_enabled && (
          <div className="flex flex-col gap-4">
            <div className="flex items-center gap-4">
              <label className={cn("w-32", getFormLabelClasses())}>
                시작 시간
              </label>
              <input
                type="time"
                value={settings.quiet_hours_start}
                onChange={(e) =>
                  handleChange("quiet_hours_start", e.target.value)
                }
                className={cn(getFormInputClasses(false, false, false), "text-sm")}
              />
            </div>

            <div className="flex items-center gap-4">
              <label className={cn("w-32", getFormLabelClasses())}>
                종료 시간
              </label>
              <input
                type="time"
                value={settings.quiet_hours_end}
                onChange={(e) =>
                  handleChange("quiet_hours_end", e.target.value)
                }
                className={cn(getFormInputClasses(false, false, false), "text-sm")}
              />
            </div>
            </div>
          )}
      </SectionCard>

      {/* 출석 알림 설정 */}
      <SectionCard
        title="출석 알림 설정"
        description="출석 관련 SMS 알림을 받을 항목을 선택하세요. 설정하지 않으면 학원 기본 설정을 따릅니다."
      >
        <div className="flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">입실 알림</div>
                <div className="text-sm text-gray-500">
                  입실 시 SMS 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("attendance_check_in_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.attendance_check_in_enabled === true
                  ? "bg-indigo-600"
                  : settings.attendance_check_in_enabled === false
                  ? "bg-gray-200"
                  : "bg-gray-100 dark:bg-gray-800"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_check_in_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">퇴실 알림</div>
                <div className="text-sm text-gray-500">
                  퇴실 시 SMS 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("attendance_check_out_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.attendance_check_out_enabled === true
                  ? "bg-indigo-600"
                  : settings.attendance_check_out_enabled === false
                  ? "bg-gray-200"
                  : "bg-gray-100 dark:bg-gray-800"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_check_out_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">결석 알림</div>
                <div className="text-sm text-gray-500">
                  결석 시 SMS 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("attendance_absent_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.attendance_absent_enabled === true
                  ? "bg-indigo-600"
                  : settings.attendance_absent_enabled === false
                  ? "bg-gray-200"
                  : "bg-gray-100 dark:bg-gray-800"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_absent_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>

            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <div className="font-medium text-gray-900">지각 알림</div>
                <div className="text-sm text-gray-500">
                  지각 시 SMS 알림을 받습니다
                </div>
              </div>
            <button
              type="button"
              onClick={() => handleToggle("attendance_late_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                settings.attendance_late_enabled === true
                  ? "bg-indigo-600"
                  : settings.attendance_late_enabled === false
                  ? "bg-gray-200"
                  : "bg-gray-100 dark:bg-gray-800"
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_late_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
            </div>
        </div>
      </SectionCard>

      {/* 저장 버튼 */}
      <div className="flex items-center justify-end gap-3 border-t border-gray-200 dark:border-gray-700 pt-6">
        {hasChanges && (
          <p className="flex-1 text-sm text-gray-500 dark:text-gray-400">
            변경사항이 있습니다. 저장하지 않으면 변경사항이 사라집니다.
          </p>
        )}
        <button
          type="button"
          onClick={handleSave}
          disabled={isPending || !hasChanges}
          className={cn(
            "rounded-lg px-4 py-2 text-sm font-medium text-white transition",
            isPending || !hasChanges
              ? "bg-gray-400 cursor-not-allowed"
              : "bg-indigo-600 hover:bg-indigo-700"
          )}
        >
          {isPending ? "저장 중..." : "저장하기"}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="actions/notificationActions.ts">
/**
 * notificationActions.ts - 알림 설정 관련 Server Actions
 *
 * 이 파일은 lib/domains/student의 Server Actions를 re-export합니다.
 * 하위 호환성을 위해 유지됩니다.
 *
 * @deprecated lib/domains/student에서 직접 import 사용을 권장합니다.
 */

export type { NotificationSettings } from "@/lib/domains/student";

export { updateNotificationSettings } from "@/lib/domains/student";
</file>

<file path="page.tsx">
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { NotificationSettingsView } from "./_components/NotificationSettingsView";
import PageContainer from "@/components/layout/PageContainer";
import { PageHeader } from "@/components/layout/PageHeader";

export default async function NotificationSettingsPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // 알림 설정 조회 (없으면 기본값 사용)
  const { data: notificationSettings } = await supabase
    .from("student_notification_preferences")
    .select("*")
    .eq("student_id", user.id)
    .single();

  // 기본값 설정
  const defaultSettings = {
    plan_start_enabled: true,
    plan_complete_enabled: true,
    daily_goal_achieved_enabled: true,
    weekly_report_enabled: true,
    plan_delay_enabled: true,
    plan_delay_threshold_minutes: 30,
    notification_time_start: "09:00",
    notification_time_end: "22:00",
    quiet_hours_enabled: false,
    quiet_hours_start: "22:00",
    quiet_hours_end: "08:00",
  };

  const settings = notificationSettings || defaultSettings;

  return (
    <PageContainer widthType="FORM">
      <div className="flex flex-col gap-6">
        <PageHeader
          title="알림 설정"
          description="학습 관련 알림을 받을 항목과 시간을 설정하세요"
        />

        <NotificationSettingsView initialSettings={settings} />
      </div>
    </PageContainer>
  );
}
</file>

<file path="attendanceSMSService.ts">
/**
 * 출석 SMS 발송 서비스
 * 학원 설정 및 학생별 설정을 확인하여 SMS 발송 여부를 결정하고 발송합니다.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { sendAttendanceSMSInternal } from "@/lib/domains/sms";
import type { AttendanceSMSSettings } from "@/lib/types/attendance";

/**
 * 출석 SMS 발송 여부 확인 결과
 */
export type ShouldSendAttendanceSMSResult = {
  shouldSend: boolean;
  reason?: string;
  details?: {
    tenantContextExists: boolean;
    tenantSettings?: {
      checkInEnabled?: boolean;
      checkOutEnabled?: boolean;
      absentEnabled?: boolean;
      lateEnabled?: boolean;
      studentCheckInEnabled?: boolean;
    };
    studentSettings?: {
      checkInEnabled?: boolean | null;
      checkOutEnabled?: boolean | null;
      absentEnabled?: boolean | null;
      lateEnabled?: boolean | null;
    };
    finalDecision?: string;
  };
};

/**
 * 출석 SMS 발송 여부 확인
 * 우선순위: 학생별 설정 > 학원 기본 설정
 */
export async function shouldSendAttendanceSMS(
  studentId: string,
  smsType: "check_in" | "check_out" | "absent" | "late",
  isStudentCheckIn: boolean = false
): Promise<ShouldSendAttendanceSMSResult> {
  const tenantContext = await getTenantContext();
  
  // 테넌트 컨텍스트 확인
  if (!tenantContext?.tenantId) {
    return {
      shouldSend: false,
      reason: "테넌트 컨텍스트를 찾을 수 없습니다.",
      details: {
        tenantContextExists: false,
      },
    };
  }

  const supabase = await createSupabaseServerClient();

  // 1. 학원 기본 설정 조회
  const { data: tenant, error: tenantError } = await supabase
    .from("tenants")
    .select(
      "attendance_sms_check_in_enabled, attendance_sms_check_out_enabled, attendance_sms_absent_enabled, attendance_sms_late_enabled, attendance_sms_student_checkin_enabled"
    )
    .eq("id", tenantContext.tenantId)
    .single();

  if (tenantError || !tenant) {
    return {
      shouldSend: false,
      reason: tenantError
        ? `테넌트 설정 조회 실패: ${tenantError.message}`
        : "테넌트 설정을 찾을 수 없습니다.",
      details: {
        tenantContextExists: true,
      },
    };
  }

  const tenantSettings = {
    checkInEnabled: tenant.attendance_sms_check_in_enabled ?? true,
    checkOutEnabled: tenant.attendance_sms_check_out_enabled ?? true,
    absentEnabled: tenant.attendance_sms_absent_enabled ?? true,
    lateEnabled: tenant.attendance_sms_late_enabled ?? true,
    studentCheckInEnabled: tenant.attendance_sms_student_checkin_enabled ?? false,
  };

  // 학생 직접 체크인인 경우 별도 설정 확인
  if (isStudentCheckIn) {
    if (!tenantSettings.studentCheckInEnabled) {
      return {
        shouldSend: false,
        reason: "학생 직접 체크인 시 SMS 발송 설정이 비활성화되어 있습니다.",
        details: {
          tenantContextExists: true,
          tenantSettings,
          finalDecision: "student_checkin_disabled",
        },
      };
    }
  }

  // 2. 학생별 설정 조회
  const { data: studentSettings, error: studentSettingsError } = await supabase
    .from("student_notification_preferences")
    .select(
      "attendance_check_in_enabled, attendance_check_out_enabled, attendance_absent_enabled, attendance_late_enabled"
    )
    .eq("student_id", studentId)
    .maybeSingle();

  if (studentSettingsError) {
    // 학생별 설정 조회 실패는 로그만 남기고 학원 기본 설정 사용
    console.warn(
      `[AttendanceSMS] 학생별 설정 조회 실패 (studentId: ${studentId}):`,
      studentSettingsError
    );
  }

  const studentSettingsData = studentSettings
    ? {
        checkInEnabled: studentSettings.attendance_check_in_enabled ?? null,
        checkOutEnabled: studentSettings.attendance_check_out_enabled ?? null,
        absentEnabled: studentSettings.attendance_absent_enabled ?? null,
        lateEnabled: studentSettings.attendance_late_enabled ?? null,
      }
    : undefined;

  // 3. SMS 타입별 설정 확인
  let studentSetting: boolean | null = null;
  let tenantSetting: boolean = true;
  let finalDecision: string;

  switch (smsType) {
    case "check_in":
      studentSetting = studentSettingsData?.checkInEnabled ?? null;
      tenantSetting = tenantSettings.checkInEnabled;
      break;
    case "check_out":
      studentSetting = studentSettingsData?.checkOutEnabled ?? null;
      tenantSetting = tenantSettings.checkOutEnabled;
      break;
    case "absent":
      studentSetting = studentSettingsData?.absentEnabled ?? null;
      tenantSetting = tenantSettings.absentEnabled;
      break;
    case "late":
      studentSetting = studentSettingsData?.lateEnabled ?? null;
      tenantSetting = tenantSettings.lateEnabled;
      break;
  }

  // 학생별 설정이 있으면 학생별 설정 사용, 없으면 학원 기본 설정 사용
  const shouldSend = studentSetting !== null ? studentSetting : tenantSetting;
  
  if (studentSetting !== null) {
    finalDecision = shouldSend
      ? "student_setting_enabled"
      : "student_setting_disabled";
  } else {
    finalDecision = shouldSend
      ? "tenant_setting_enabled"
      : "tenant_setting_disabled";
  }

  return {
    shouldSend,
    reason: shouldSend
      ? undefined
      : studentSetting !== null
      ? "학생별 설정에 의해 SMS 발송이 비활성화되어 있습니다."
      : "학원 기본 설정에 의해 SMS 발송이 비활성화되어 있습니다.",
    details: {
      tenantContextExists: true,
      tenantSettings,
      studentSettings: studentSettingsData,
      finalDecision,
    },
  };
}

/**
 * 설정 확인 후 출석 SMS 발송 결과
 */
export type SendAttendanceSMSResult = {
  success: boolean;
  skipped?: boolean; // 설정에 의해 건너뛴 경우
  error?: string;
  errorType?: "settings_disabled" | "send_failed" | "unknown";
  details?: Record<string, unknown>;
};

/**
 * 설정 확인 후 출석 SMS 발송
 */
export async function sendAttendanceSMSIfEnabled(
  studentId: string,
  smsType: "attendance_check_in" | "attendance_check_out" | "attendance_absent" | "attendance_late",
  variables: Record<string, string>,
  isStudentCheckIn: boolean = false
): Promise<SendAttendanceSMSResult> {
  try {
    // SMS 타입 매핑
    const smsTypeMap: Record<
      typeof smsType,
      "check_in" | "check_out" | "absent" | "late"
    > = {
      attendance_check_in: "check_in",
      attendance_check_out: "check_out",
      attendance_absent: "absent",
      attendance_late: "late",
    };

    const mappedType = smsTypeMap[smsType];

    // SMS 발송 여부 확인
    const checkResult = await shouldSendAttendanceSMS(
      studentId,
      mappedType,
      isStudentCheckIn
    );

    if (!checkResult.shouldSend) {
      // 설정에 의해 발송하지 않음 (에러 아님)
      return {
        success: true,
        skipped: true,
        error: checkResult.reason,
        errorType: "settings_disabled",
        details: checkResult.details,
      };
    }

    // SMS 발송 (내부 함수 사용, 권한 체크 없음)
    const result = await sendAttendanceSMSInternal(studentId, smsType, variables);

    if (!result.success) {
      console.error(
        `[AttendanceSMS] ${smsType} 발송 실패:`,
        result.error
      );
      // SMS 발송 실패는 로그만 남기고 출석 기록 저장은 정상 처리
      return {
        success: true, // 출석 기록 저장은 성공으로 처리
        error: result.error,
        errorType: "send_failed",
        details: {
          smsType,
          studentId,
          isStudentCheckIn,
        },
      };
    }

    return {
      success: true,
      details: {
        smsType,
        studentId,
        isStudentCheckIn,
        msgId: result.data?.msgId,
      },
    };
  } catch (error: unknown) {
    console.error(`[AttendanceSMS] ${smsType} 발송 중 오류:`, error);
    // SMS 발송 실패는 로그만 남기고 출석 기록 저장은 정상 처리
    const errorMessage = error instanceof Error 
      ? error.message 
      : "알 수 없는 오류가 발생했습니다.";
    
    return {
      success: true, // 출석 기록 저장은 성공으로 처리
      error: errorMessage,
      errorType: "unknown",
      details: {
        smsType,
        studentId,
        isStudentCheckIn,
      },
    };
  }
}
</file>

<file path="campInvitationExpiryService.ts">
/**
 * 캠프 초대 만료 처리 서비스
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { sendInAppNotification } from "./inAppNotificationService";
import { sendCampReminderNotification } from "./campNotificationService";
import { logActionDebug, logActionError } from "@/lib/utils/serverActionLogger";

/**
 * 만료된 초대를 찾아 상태를 'expired'로 변경
 * @returns 처리된 초대 개수
 */
export async function processExpiredInvitations(): Promise<{
  success: boolean;
  count: number;
  error?: string;
}> {
  try {
    const supabase = await createSupabaseServerClient();
    const now = new Date().toISOString();

    // 만료된 초대 조회 (expires_at이 현재 시간보다 이전이고, status가 'pending'인 경우)
    const { data: expiredInvitations, error: selectError } = await supabase
      .from("camp_invitations")
      .select("id, student_id, camp_template_id, tenant_id")
      .eq("status", "pending")
      .not("expires_at", "is", null)
      .lt("expires_at", now);

    if (selectError) {
      logActionError("campInvitationExpiryService.processExpiredInvitations", `만료된 초대 조회 실패: ${selectError.message}`);
      return {
        success: false,
        count: 0,
        error: selectError.message,
      };
    }

    if (!expiredInvitations || expiredInvitations.length === 0) {
      return {
        success: true,
        count: 0,
      };
    }

    // 만료된 초대 ID 목록
    const expiredIds = expiredInvitations.map((inv) => inv.id);

    // 상태를 'expired'로 업데이트
    const { error: updateError } = await supabase
      .from("camp_invitations")
      .update({ status: "expired", updated_at: now })
      .in("id", expiredIds);

    if (updateError) {
      logActionError("campInvitationExpiryService.processExpiredInvitations", `만료 상태 업데이트 실패: ${updateError.message}`);
      return {
        success: false,
        count: 0,
        error: updateError.message,
      };
    }

    // 각 학생에게 인앱 알림 발송 (비동기, 실패해도 만료 처리는 성공으로 처리)
    expiredInvitations.forEach((invitation) => {
      sendInAppNotification(
        invitation.student_id,
        "camp_invitation_expired" as any,
        "캠프 초대가 만료되었습니다",
        "캠프 초대가 만료되었습니다. 관리자에게 문의해주세요.",
        {
          invitationId: invitation.id,
          templateId: invitation.camp_template_id,
        }
      ).catch((err) => {
        logActionError("campInvitationExpiryService.processExpiredInvitations", `초대 ${invitation.id} 알림 발송 실패: ${err instanceof Error ? err.message : String(err)}`);
      });
    });

    logActionDebug("campInvitationExpiryService.processExpiredInvitations", `${expiredInvitations.length}개의 초대를 만료 처리했습니다.`);

    return {
      success: true,
      count: expiredInvitations.length,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError("campInvitationExpiryService.processExpiredInvitations", `만료 처리 중 예외 발생: ${errorMessage}`);
    return {
      success: false,
      count: 0,
      error: errorMessage,
    };
  }
}

/**
 * 만료 1일 전 알림 발송
 * @returns 발송된 알림 개수
 */
export async function sendExpiryReminderNotifications(): Promise<{
  success: boolean;
  count: number;
  error?: string;
}> {
  try {
    const supabase = await createSupabaseServerClient();
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // 만료 1일 전인 초대 조회 (expires_at이 내일이고, status가 'pending'인 경우)
    const { data: expiringInvitations, error: selectError } = await supabase
      .from("camp_invitations")
      .select("id, student_id, camp_template_id, expires_at")
      .eq("status", "pending")
      .not("expires_at", "is", null)
      .gte("expires_at", now.toISOString())
      .lt("expires_at", tomorrow.toISOString());

    if (selectError) {
      logActionError("campInvitationExpiryService.sendExpiryReminderNotifications", `만료 예정 초대 조회 실패: ${selectError.message}`);
      return {
        success: false,
        count: 0,
        error: selectError.message,
      };
    }

    if (!expiringInvitations || expiringInvitations.length === 0) {
      return {
        success: true,
        count: 0,
      };
    }

    // 각 초대에 대해 리마인더 알림 발송
    const results = await Promise.allSettled(
      expiringInvitations.map((invitation) =>
        sendCampReminderNotification(invitation.id)
      )
    );

    const successCount = results.filter(
      (result) => result.status === "fulfilled"
    ).length;

    logActionDebug("campInvitationExpiryService.sendExpiryReminderNotifications", `${successCount}/${expiringInvitations.length}개의 만료 예정 알림을 발송했습니다.`);

    return {
      success: true,
      count: successCount,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError("campInvitationExpiryService.sendExpiryReminderNotifications", `만료 예정 알림 발송 중 예외 발생: ${errorMessage}`);
    return {
      success: false,
      count: 0,
      error: errorMessage,
    };
  }
}

/**
 * 곧 만료될 초대 조회 (1일 이내)
 * @param days 만료까지 남은 일수 (기본값: 1)
 * @returns 만료 예정 초대 목록
 */
export async function getExpiringInvitations(days: number = 1): Promise<{
  success: boolean;
  invitations: Array<{
    id: string;
    student_id: string;
    camp_template_id: string;
    expires_at: string;
  }>;
  error?: string;
}> {
  try {
    const supabase = await createSupabaseServerClient();
    const now = new Date();
    const futureDate = new Date(now);
    futureDate.setDate(futureDate.getDate() + days);

    const { data: invitations, error } = await supabase
      .from("camp_invitations")
      .select("id, student_id, camp_template_id, expires_at")
      .eq("status", "pending")
      .not("expires_at", "is", null)
      .gte("expires_at", now.toISOString())
      .lt("expires_at", futureDate.toISOString())
      .order("expires_at", { ascending: true });

    if (error) {
      logActionError("campInvitationExpiryService.getExpiringInvitations", `만료 예정 초대 조회 실패: ${error.message}`);
      return {
        success: false,
        invitations: [],
        error: error.message,
      };
    }

    return {
      success: true,
      invitations: (invitations || []) as Array<{
        id: string;
        student_id: string;
        camp_template_id: string;
        expires_at: string;
      }>,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError("campInvitationExpiryService.getExpiringInvitations", `만료 예정 초대 조회 중 예외 발생: ${errorMessage}`);
    return {
      success: false,
      invitations: [],
      error: errorMessage,
    };
  }
}
</file>

<file path="campNotificationService.ts">
/**
 * 캠프 관련 알림 발송 통합 서비스
 */

import { sendEmail } from "./emailService";
import { CampInvitationEmail } from "@/lib/emails/campInvitationEmail";
import { getCampInvitation, getCampTemplate } from "@/lib/data/campTemplates";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { env } from "@/lib/env";
import { sendInAppNotification } from "./inAppNotificationService";
import { logActionError, logActionDebug } from "@/lib/logging/actionLogger";

/**
 * 캠프 초대 알림 발송
 */
export async function sendCampInvitationNotification(
  invitationId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // 초대 정보 조회
    const invitation = await getCampInvitation(invitationId);
    if (!invitation) {
      return {
        success: false,
        error: "초대를 찾을 수 없습니다.",
      };
    }

    // 템플릿 정보 조회
    const template = await getCampTemplate(invitation.camp_template_id);
    if (!template) {
      return {
        success: false,
        error: "템플릿을 찾을 수 없습니다.",
      };
    }

    // 학생 정보 조회
    const supabase = await createSupabaseServerClient();
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("name")
      .eq("id", invitation.student_id)
      .maybeSingle();

    if (studentError || !student) {
      logActionError(
        { domain: "service", action: "sendCampInvitationNotification" },
        studentError,
        { invitationId }
      );
      return {
        success: false,
        error: "학생 정보를 찾을 수 없습니다.",
      };
    }

    // Supabase Auth에서 사용자 이메일 조회
    const { createSupabaseAdminClient } = await import(
      "@/lib/supabase/admin"
    );
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return {
        success: false,
        error: "관리자 클라이언트를 초기화할 수 없습니다.",
      };
    }

    const { data: authUser, error: authError } =
      await adminClient.auth.admin.getUserById(invitation.student_id);

    if (authError || !authUser?.user?.email) {
      logActionError(
        { domain: "service", action: "sendCampInvitationNotification" },
        authError,
        { invitationId, studentId: invitation.student_id }
      );
      return {
        success: false,
        error: "학생의 이메일 주소를 찾을 수 없습니다.",
      };
    }

    const studentEmail = authUser.user.email;

    // 초대 URL 생성
    const baseUrl = env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
    const invitationUrl = `${baseUrl}/camp/${invitationId}`;

    // 날짜 포맷팅
    const formatDate = (dateString: string | null | undefined) => {
      if (!dateString) return undefined;
      try {
        return new Date(dateString).toLocaleDateString("ko-KR", {
          year: "numeric",
          month: "long",
          day: "numeric",
        });
      } catch {
        return dateString;
      }
    };

    // 이메일 발송
    const result = await sendEmail({
      to: studentEmail,
      subject: `[${template.name}] 캠프 초대 안내`,
      react: CampInvitationEmail({
        studentName: student.name || "학생",
        campName: template.name,
        invitationUrl,
        campStartDate: formatDate(template.camp_start_date),
        campEndDate: formatDate(template.camp_end_date),
        campLocation: template.camp_location || undefined,
      }),
    });

    if (!result.success) {
      logActionError(
        { domain: "service", action: "sendCampInvitationNotification" },
        result.error,
        { invitationId, studentEmail }
      );
    }

    // 인앱 알림 발송 (비동기, 실패해도 이메일 발송은 성공으로 처리)
    sendInAppNotification(
      invitation.student_id,
      "camp_invitation",
      `[${template.name}] 캠프 초대`,
      `${template.name} 캠프에 초대되었습니다. 참여 정보를 제출해주세요.`,
      {
        invitationId: invitation.id,
        templateId: template.id,
        invitationUrl,
      }
    ).catch((err) => {
      logActionError(
        { domain: "service", action: "sendCampInvitationNotification" },
        err,
        { context: "인앱 알림", invitationId }
      );
    });

    return result;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendCampInvitationNotification" },
      error,
      { invitationId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 캠프 리마인더 알림 발송
 */
export async function sendCampReminderNotification(
  invitationId: string
): Promise<{ success: boolean; error?: string }> {
  // 리마인더는 초대 알림과 동일한 템플릿 사용 (제목만 변경)
  // 향후 별도 템플릿으로 확장 가능
  try {
    const invitation = await getCampInvitation(invitationId);
    if (!invitation) {
      return {
        success: false,
        error: "초대를 찾을 수 없습니다.",
      };
    }

    const template = await getCampTemplate(invitation.camp_template_id);
    if (!template) {
      return {
        success: false,
        error: "템플릿을 찾을 수 없습니다.",
      };
    }

    const supabase = await createSupabaseServerClient();
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("name")
      .eq("id", invitation.student_id)
      .maybeSingle();

    if (studentError || !student) {
      return {
        success: false,
        error: "학생 정보를 찾을 수 없습니다.",
      };
    }

    // Supabase Auth에서 사용자 이메일 조회
    const { createSupabaseAdminClient } = await import(
      "@/lib/supabase/admin"
    );
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return {
        success: false,
        error: "관리자 클라이언트를 초기화할 수 없습니다.",
      };
    }

    const { data: authUser, error: authError } =
      await adminClient.auth.admin.getUserById(invitation.student_id);

    if (authError || !authUser?.user?.email) {
      return {
        success: false,
        error: "학생의 이메일 주소를 찾을 수 없습니다.",
      };
    }

    const studentEmail = authUser.user.email;

    const baseUrl = env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
    const invitationUrl = `${baseUrl}/camp/${invitationId}`;

    const formatDate = (dateString: string | null | undefined) => {
      if (!dateString) return undefined;
      try {
        return new Date(dateString).toLocaleDateString("ko-KR", {
          year: "numeric",
          month: "long",
          day: "numeric",
        });
      } catch {
        return dateString;
      }
    };

    const result = await sendEmail({
      to: studentEmail,
      subject: `[${template.name}] 캠프 참여 리마인더`,
      react: CampInvitationEmail({
        studentName: student.name || "학생",
        campName: template.name,
        invitationUrl,
        campStartDate: formatDate(template.camp_start_date),
        campEndDate: formatDate(template.camp_end_date),
        campLocation: template.camp_location || undefined,
      }),
    });

    return result;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendCampReminderNotification" },
      error,
      { invitationId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 캠프 상태 변경 알림 발송
 */
export async function sendCampStatusChangeNotification(
  invitationId: string,
  newStatus: string
): Promise<{ success: boolean; error?: string }> {
  // 상태 변경 알림은 향후 구현
  // 현재는 로깅만 수행
  logActionDebug(
    { domain: "service", action: "sendCampStatusChangeNotification" },
    "상태 변경 알림",
    { invitationId, newStatus }
  );
  return { success: true };
}

/**
 * 학생 캠프 참여 수락 시 관리자에게 알림 발송
 */
export async function sendCampAcceptanceNotificationToAdmins(params: {
  templateId: string;
  templateName: string;
  studentId: string;
  studentName: string;
  tenantId: string;
  groupId: string;
}): Promise<{ success: boolean; sentCount: number; error?: string }> {
  const { templateId, templateName, studentId, studentName, tenantId, groupId } = params;

  try {
    const { createSupabaseAdminClient } = await import("@/lib/supabase/admin");
    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      logActionError(
        { domain: "service", action: "sendCampAcceptanceNotificationToAdmins" },
        "Admin 클라이언트 초기화 실패",
        { tenantId }
      );
      return {
        success: false,
        sentCount: 0,
        error: "서버 설정 오류: Admin 클라이언트를 초기화할 수 없습니다.",
      };
    }

    // 해당 테넌트의 관리자 목록 조회
    const { data: adminUsers, error: adminError } = await adminClient
      .from("admin_users")
      .select("id")
      .eq("tenant_id", tenantId)
      .eq("role", "admin");

    if (adminError) {
      logActionError(
        { domain: "service", action: "sendCampAcceptanceNotificationToAdmins" },
        adminError,
        { tenantId }
      );
      return {
        success: false,
        sentCount: 0,
        error: adminError.message,
      };
    }

    if (!adminUsers || adminUsers.length === 0) {
      logActionDebug(
        { domain: "service", action: "sendCampAcceptanceNotificationToAdmins" },
        "해당 테넌트에 관리자가 없습니다",
        { tenantId }
      );
      return {
        success: true,
        sentCount: 0,
      };
    }

    const adminUserIds = adminUsers.map((u) => u.id);

    // 일괄 알림 발송
    const { sendBulkInAppNotification } = await import("./inAppNotificationService");
    const result = await sendBulkInAppNotification(
      adminUserIds,
      "admin_notification",
      `[${templateName}] 캠프 참여 수락`,
      `${studentName} 학생이 "${templateName}" 캠프에 참여를 수락했습니다.`,
      {
        templateId,
        studentId,
        studentName,
        groupId,
        action: "camp_acceptance",
      },
      tenantId
    );

    if (result.success) {
      logActionDebug(
        { domain: "service", action: "sendCampAcceptanceNotificationToAdmins" },
        "관리자 알림 발송 완료",
        {
          templateId,
          templateName,
          studentId,
          studentName,
          adminCount: adminUserIds.length,
          sentCount: result.sentCount,
        }
      );
    }

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendCampAcceptanceNotificationToAdmins" },
      error,
      { templateId, studentId, tenantId }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}

/**
 * 캠프 플랜 생성 완료 시 학생에게 알림 발송
 */
export async function sendPlanCreatedNotificationToStudent(params: {
  studentId: string;
  studentName: string;
  templateId: string;
  templateName: string;
  groupId: string;
  tenantId?: string;
}): Promise<{ success: boolean; error?: string }> {
  const { studentId, studentName, templateName, templateId, groupId, tenantId } = params;

  try {
    const result = await sendInAppNotification(
      studentId,
      "plan_created",
      `[${templateName}] 캠프 플랜 생성 완료`,
      `${studentName}님, "${templateName}" 캠프 플랜이 생성되었습니다. 학습 계획을 확인해보세요.`,
      {
        templateId,
        groupId,
        action: "plan_created",
      },
      tenantId
    );

    if (result.success) {
      logActionDebug(
        { domain: "service", action: "sendPlanCreatedNotificationToStudent" },
        "학생 플랜 생성 알림 발송 완료",
        { studentId, studentName, templateId, templateName, groupId }
      );
    }

    return {
      success: result.success,
      error: result.error,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendPlanCreatedNotificationToStudent" },
      error,
      { studentId, templateId, groupId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * A4 개선: 학생의 연결된 학부모 ID 목록 조회
 */
async function getLinkedParentIds(studentId: string): Promise<string[]> {
  try {
    const { createSupabaseAdminClient } = await import("@/lib/supabase/admin");
    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      logActionError(
        { domain: "service", action: "getLinkedParentIds" },
        "Admin 클라이언트 초기화 실패",
        { studentId }
      );
      return [];
    }

    const { data, error } = await adminClient
      .from("parent_student_links")
      .select("parent_id")
      .eq("student_id", studentId)
      .eq("is_approved", true);

    if (error) {
      logActionError(
        { domain: "service", action: "getLinkedParentIds" },
        error,
        { studentId }
      );
      return [];
    }

    return (data ?? []).map((link) => link.parent_id);
  } catch (error) {
    logActionError(
      { domain: "service", action: "getLinkedParentIds" },
      error,
      { studentId }
    );
    return [];
  }
}

/**
 * A4 개선: 캠프 초대 시 학부모에게 알림 발송
 */
export async function sendCampInvitationNotificationToParents(params: {
  studentId: string;
  studentName: string;
  templateId: string;
  templateName: string;
  tenantId?: string;
}): Promise<{ success: boolean; sentCount: number; error?: string }> {
  const { studentId, studentName, templateId, templateName, tenantId } = params;

  try {
    const parentIds = await getLinkedParentIds(studentId);

    if (parentIds.length === 0) {
      logActionDebug(
        { domain: "service", action: "sendCampInvitationNotificationToParents" },
        "연결된 학부모 없음",
        { studentId }
      );
      return { success: true, sentCount: 0 };
    }

    const { sendBulkInAppNotification } = await import("./inAppNotificationService");
    const result = await sendBulkInAppNotification(
      parentIds,
      "camp_invitation",
      `[${templateName}] 캠프 초대 안내`,
      `${studentName} 학생이 "${templateName}" 캠프에 초대되었습니다.`,
      {
        templateId,
        studentId,
        studentName,
        action: "camp_invitation_parent",
      },
      tenantId
    );

    if (result.success) {
      logActionDebug(
        { domain: "service", action: "sendCampInvitationNotificationToParents" },
        "학부모 캠프 초대 알림 발송 완료",
        {
          studentId,
          studentName,
          templateName,
          parentCount: parentIds.length,
          sentCount: result.sentCount,
        }
      );
    }

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendCampInvitationNotificationToParents" },
      error,
      { studentId, templateId }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}

/**
 * A4 개선: 캠프 플랜 생성 완료 시 학부모에게 알림 발송
 */
export async function sendPlanCreatedNotificationToParents(params: {
  studentId: string;
  studentName: string;
  templateId: string;
  templateName: string;
  groupId: string;
  tenantId?: string;
}): Promise<{ success: boolean; sentCount: number; error?: string }> {
  const { studentId, studentName, templateId, templateName, groupId, tenantId } = params;

  try {
    const parentIds = await getLinkedParentIds(studentId);

    if (parentIds.length === 0) {
      logActionDebug(
        { domain: "service", action: "sendPlanCreatedNotificationToParents" },
        "연결된 학부모 없음",
        { studentId }
      );
      return { success: true, sentCount: 0 };
    }

    const { sendBulkInAppNotification } = await import("./inAppNotificationService");
    const result = await sendBulkInAppNotification(
      parentIds,
      "plan_created",
      `[${templateName}] 캠프 플랜 생성`,
      `${studentName} 학생의 "${templateName}" 캠프 학습 플랜이 생성되었습니다.`,
      {
        templateId,
        studentId,
        studentName,
        groupId,
        action: "plan_created_parent",
      },
      tenantId
    );

    if (result.success) {
      logActionDebug(
        { domain: "service", action: "sendPlanCreatedNotificationToParents" },
        "학부모 플랜 생성 알림 발송 완료",
        {
          studentId,
          studentName,
          templateName,
          groupId,
          parentCount: parentIds.length,
          sentCount: result.sentCount,
        }
      );
    }

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendPlanCreatedNotificationToParents" },
      error,
      { studentId, templateId, groupId }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}

/**
 * A4 개선: 캠프 학습 진행 마일스톤 달성 시 학부모에게 알림 발송
 */
export async function sendCampProgressNotificationToParents(params: {
  studentId: string;
  studentName: string;
  templateName: string;
  completionRate: number;
  tenantId?: string;
}): Promise<{ success: boolean; sentCount: number; error?: string }> {
  const { studentId, studentName, templateName, completionRate, tenantId } = params;

  try {
    const parentIds = await getLinkedParentIds(studentId);

    if (parentIds.length === 0) {
      return { success: true, sentCount: 0 };
    }

    // 마일스톤 메시지 생성
    let milestoneMessage: string;
    if (completionRate >= 100) {
      milestoneMessage = `${studentName} 학생이 "${templateName}" 캠프 학습을 완료했습니다! 🎉`;
    } else if (completionRate >= 75) {
      milestoneMessage = `${studentName} 학생이 "${templateName}" 캠프 학습의 75%를 완료했습니다.`;
    } else if (completionRate >= 50) {
      milestoneMessage = `${studentName} 학생이 "${templateName}" 캠프 학습의 절반을 완료했습니다.`;
    } else if (completionRate >= 25) {
      milestoneMessage = `${studentName} 학생이 "${templateName}" 캠프 학습을 시작했습니다.`;
    } else {
      return { success: true, sentCount: 0 }; // 25% 미만은 알림 안 함
    }

    const { sendBulkInAppNotification } = await import("./inAppNotificationService");
    const result = await sendBulkInAppNotification(
      parentIds,
      "camp_status_change",
      `[${templateName}] 학습 진행 현황`,
      milestoneMessage,
      {
        studentId,
        studentName,
        templateName,
        completionRate,
        action: "progress_milestone_parent",
      },
      tenantId
    );

    if (result.success) {
      logActionDebug(
        { domain: "service", action: "sendCampProgressNotificationToParents" },
        "학부모 진행 알림 발송 완료",
        {
          studentId,
          studentName,
          templateName,
          completionRate,
          parentCount: parentIds.length,
          sentCount: result.sentCount,
        }
      );
    }

    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendCampProgressNotificationToParents" },
      error,
      { studentId, templateName, completionRate }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}
</file>

<file path="campReminderService.ts">
/**
 * 캠프 초대 리마인더 발송 서비스
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCampTemplate } from "@/lib/data/campTemplates";
import { sendCampReminderNotification } from "./campNotificationService";
import type { CampReminderSettings } from "@/lib/types/plan/domain";

/**
 * 리마인더 발송 여부 판단
 * @param invitation 초대 정보
 * @param template 템플릿 정보
 * @returns 리마인더 발송 여부
 */
export function shouldSendReminder(
  invitation: {
    invited_at: string;
    status: string;
  },
  template: {
    reminder_settings: CampReminderSettings | null;
  }
): boolean {
  // 리마인더 설정이 없거나 비활성화된 경우
  if (!template.reminder_settings || !template.reminder_settings.enabled) {
    return false;
  }

  // 초대 상태가 'pending'이 아닌 경우
  if (invitation.status !== "pending") {
    return false;
  }

  const reminderSettings = template.reminder_settings;
  const invitedAt = new Date(invitation.invited_at);
  const now = new Date();
  const daysSinceInvitation = Math.floor(
    (now.getTime() - invitedAt.getTime()) / (1000 * 60 * 60 * 24)
  );

  // 초대 발송 후 경과 일수가 리마인더 간격에 해당하는지 확인
  return reminderSettings.intervals.includes(daysSinceInvitation);
}

/**
 * 템플릿별 리마인더 간격 조회
 * @param template 템플릿 정보
 * @returns 리마인더 간격 배열
 */
export function getReminderIntervals(
  template: {
    reminder_settings: CampReminderSettings | null;
  }
): number[] {
  if (!template.reminder_settings || !template.reminder_settings.enabled) {
    return [];
  }

  return template.reminder_settings.intervals || [];
}

/**
 * 대기 중인 초대에 대한 리마인더 발송
 * @returns 발송된 리마인더 개수
 */
export async function processReminders(): Promise<{
  success: boolean;
  count: number;
  error?: string;
}> {
  try {
    const supabase = await createSupabaseServerClient();

    // 상태가 'pending'인 초대 조회
    const { data: pendingInvitations, error: selectError } = await supabase
      .from("camp_invitations")
      .select("id, camp_template_id, invited_at, status")
      .eq("status", "pending")
      .order("invited_at", { ascending: true });

    if (selectError) {
      console.error(
        "[campReminderService] 대기 중인 초대 조회 실패:",
        selectError
      );
      return {
        success: false,
        count: 0,
        error: selectError.message,
      };
    }

    if (!pendingInvitations || pendingInvitations.length === 0) {
      return {
        success: true,
        count: 0,
      };
    }

    // 템플릿별로 그룹화하여 중복 조회 방지
    const templateIds = Array.from(
      new Set(pendingInvitations.map((inv) => inv.camp_template_id))
    );

    // 템플릿 정보 조회
    const templates = await Promise.all(
      templateIds.map(async (templateId) => {
        const template = await getCampTemplate(templateId);
        return template ? { id: templateId, template } : null;
      })
    );

    const templateMap = new Map(
      templates
        .filter((t) => t !== null && t !== undefined && t.template !== null && t.template !== undefined)
        .map((t) => [t!.id, t!.template!])
    );

    // 리마인더 발송 대상 필터링
    const remindersToSend = pendingInvitations.filter((invitation) => {
      const template = templateMap.get(invitation.camp_template_id);
      if (!template) {
        return false;
      }

      // reminder_settings를 CampReminderSettings 타입으로 변환
      const templateWithSettings = {
        reminder_settings: template.reminder_settings as CampReminderSettings | null,
      };

      return shouldSendReminder(invitation, templateWithSettings);
    });

    if (remindersToSend.length === 0) {
      return {
        success: true,
        count: 0,
      };
    }

    // 리마인더 발송 (병렬 처리)
    const results = await Promise.allSettled(
      remindersToSend.map((invitation) =>
        sendCampReminderNotification(invitation.id)
      )
    );

    const successCount = results.filter(
      (result) => result.status === "fulfilled"
    ).length;

    // 실패한 경우 로깅
    results.forEach((result, index) => {
      if (result.status === "rejected") {
        console.error(
          `[campReminderService] 초대 ${remindersToSend[index].id} 리마인더 발송 실패:`,
          result.reason
        );
      }
    });

    console.log(
      `[campReminderService] ${successCount}/${remindersToSend.length}개의 리마인더를 발송했습니다.`
    );

    return {
      success: true,
      count: successCount,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error(
      "[campReminderService] 리마인더 처리 중 예외 발생:",
      errorMessage
    );
    return {
      success: false,
      count: 0,
      error: errorMessage,
    };
  }
}
</file>

<file path="emailService.ts">
/**
 * 이메일 발송 서비스 (Resend)
 */

import { Resend } from "resend";
import { env } from "@/lib/env";
import { render } from "@react-email/render";
import type { ReactElement } from "react";

// Resend 클라이언트 초기화 (API 키가 있을 때만)
let resendClient: Resend | null = null;

function getResendClient(): Resend | null {
  if (!env.RESEND_API_KEY) {
    if (process.env.NODE_ENV === "development") {
      console.warn(
        "[emailService] RESEND_API_KEY가 설정되지 않았습니다. 이메일 발송 기능이 비활성화됩니다."
      );
    }
    return null;
  }

  if (!resendClient) {
    resendClient = new Resend(env.RESEND_API_KEY);
  }

  return resendClient;
}

export type EmailOptions = {
  to: string | string[];
  subject: string;
  from?: string;
  replyTo?: string;
  html?: string;
  react?: ReactElement;
  text?: string;
};

export type EmailResult = {
  success: boolean;
  messageId?: string;
  error?: string;
};

/**
 * 단일 이메일 발송
 */
export async function sendEmail(
  options: EmailOptions
): Promise<EmailResult> {
  const client = getResendClient();
  if (!client) {
    return {
      success: false,
      error: "이메일 서비스가 설정되지 않았습니다.",
    };
  }

  try {
    // React 컴포넌트가 있으면 HTML로 렌더링
    let html = options.html;
    if (options.react && !html) {
      html = await render(options.react);
    }

    // 발신 주소 설정 (기본값: 환경 변수 또는 noreply)
    const from = options.from || env.EMAIL_FROM || "noreply@example.com";
    const replyTo = options.replyTo || env.EMAIL_REPLY_TO;

    const { data, error } = await client.emails.send({
      from,
      to: Array.isArray(options.to) ? options.to : [options.to],
      subject: options.subject,
      html: html || options.text || "",
      text: options.text,
      replyTo: replyTo,
    });

    if (error) {
      console.error("[emailService] 이메일 발송 실패:", error);
      return {
        success: false,
        error: error.message || "이메일 발송에 실패했습니다.",
      };
    }

    return {
      success: true,
      messageId: data?.id,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error("[emailService] 이메일 발송 중 예외 발생:", errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 일괄 이메일 발송
 */
export async function sendBulkEmail(
  recipients: string[],
  options: Omit<EmailOptions, "to">
): Promise<{
  success: number;
  failed: number;
  errors: Array<{ email: string; error: string }>;
}> {
  const results = {
    success: 0,
    failed: 0,
    errors: [] as Array<{ email: string; error: string }>,
  };

  // Resend는 일괄 발송을 지원하므로, 한 번에 여러 수신자에게 발송
  const client = getResendClient();
  if (!client) {
    return {
      success: 0,
      failed: recipients.length,
      errors: recipients.map((email) => ({
        email,
        error: "이메일 서비스가 설정되지 않았습니다.",
      })),
    };
  }

  try {
    // React 컴포넌트가 있으면 HTML로 렌더링
    let html = options.html;
    if (options.react && !html) {
      html = await render(options.react);
    }

    const from = options.from || env.EMAIL_FROM || "noreply@example.com";
    const replyTo = options.replyTo || env.EMAIL_REPLY_TO;

    // Resend는 최대 50명까지 일괄 발송 가능
    const batchSize = 50;
    for (let i = 0; i < recipients.length; i += batchSize) {
      const batch = recipients.slice(i, i + batchSize);

      const { data, error } = await client.emails.send({
        from,
        to: batch,
        subject: options.subject,
        html: html || options.text || "",
        text: options.text,
        replyTo: replyTo,
      });

      if (error) {
        results.failed += batch.length;
        batch.forEach((email) => {
          results.errors.push({
            email,
            error: error.message || "이메일 발송에 실패했습니다.",
          });
        });
      } else {
        results.success += batch.length;
      }
    }

    return results;
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error("[emailService] 일괄 이메일 발송 중 예외 발생:", errorMessage);

    return {
      success: 0,
      failed: recipients.length,
      errors: recipients.map((email) => ({
        email,
        error: errorMessage,
      })),
    };
  }
}
</file>

<file path="inAppNotificationService.ts">
/**
 * 인앱 알림 서비스
 *
 * 데이터베이스(Supabase) 기반 알림 영속화
 */

import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { Json } from "@/lib/supabase/database.types";
import { logActionError } from "@/lib/logging/actionLogger";

export type NotificationType =
  | "camp_invitation"
  | "camp_reminder"
  | "camp_status_change"
  | "plan_created"
  | "plan_updated"
  | "admin_notification"
  // Learning milestone notifications (Phase 2)
  | "learning_milestone"
  | "daily_goal_complete"
  | "study_streak"
  // Plan reminder notifications (Phase 3)
  | "plan_incomplete_reminder"
  | "plan_delayed_warning"
  | "weekly_plan_summary";

export type Notification = {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  message: string;
  data?: Record<string, unknown>;
  read: boolean;
  createdAt: string;
  readAt?: string;
  tenantId?: string;
};

/**
 * DB 레코드를 Notification 타입으로 변환
 */
function mapDbRecordToNotification(record: {
  id: string;
  user_id: string;
  type: string;
  title: string;
  message: string;
  metadata: Record<string, unknown> | null;
  is_read: boolean;
  created_at: string;
  read_at: string | null;
  tenant_id: string | null;
}): Notification {
  return {
    id: record.id,
    userId: record.user_id,
    type: record.type as NotificationType,
    title: record.title,
    message: record.message,
    data: record.metadata ?? undefined,
    read: record.is_read,
    createdAt: record.created_at,
    readAt: record.read_at ?? undefined,
    tenantId: record.tenant_id ?? undefined,
  };
}

/**
 * 알림 발송 (데이터베이스 저장)
 */
export async function sendInAppNotification(
  userId: string,
  type: NotificationType,
  title: string,
  message: string,
  data?: Record<string, unknown>,
  tenantId?: string
): Promise<{ success: boolean; notificationId?: string; error?: string }> {
  try {
    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      return {
        success: false,
        error: "Admin 클라이언트를 초기화할 수 없습니다.",
      };
    }

    const { data: notification, error } = await adminClient
      .from("notifications")
      .insert({
        user_id: userId,
        type,
        title,
        message,
        metadata: (data ?? {}) as Json,
        is_read: false,
        tenant_id: tenantId ?? null,
      })
      .select("id")
      .single();

    if (error) {
      logActionError(
        { domain: "service", action: "sendInAppNotification" },
        error,
        { userId, type }
      );
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true, notificationId: notification.id };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendInAppNotification" },
      error,
      { userId, type }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 특정 사용자들에게 일괄 알림 발송
 */
export async function sendBulkInAppNotification(
  userIds: string[],
  type: NotificationType,
  title: string,
  message: string,
  data?: Record<string, unknown>,
  tenantId?: string
): Promise<{ success: boolean; sentCount: number; error?: string }> {
  try {
    if (userIds.length === 0) {
      return { success: true, sentCount: 0 };
    }

    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      return {
        success: false,
        sentCount: 0,
        error: "Admin 클라이언트를 초기화할 수 없습니다.",
      };
    }

    const notifications = userIds.map((userId) => ({
      user_id: userId,
      type,
      title,
      message,
      metadata: (data ?? {}) as Json,
      is_read: false,
      tenant_id: tenantId ?? null,
    }));

    const { error } = await adminClient
      .from("notifications")
      .insert(notifications);

    if (error) {
      logActionError(
        { domain: "service", action: "sendBulkInAppNotification" },
        error,
        { userCount: userIds.length, type }
      );
      return {
        success: false,
        sentCount: 0,
        error: error.message,
      };
    }

    return { success: true, sentCount: userIds.length };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "sendBulkInAppNotification" },
      error,
      { userCount: userIds.length, type }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}

/**
 * 사용자의 미읽은 알림 조회
 */
export async function getUnreadNotifications(
  userId: string
): Promise<Notification[]> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("notifications")
      .select("*")
      .eq("user_id", userId)
      .eq("is_read", false)
      .order("created_at", { ascending: false })
      .limit(50);

    if (error) {
      logActionError(
        { domain: "service", action: "getUnreadNotifications" },
        error,
        { userId }
      );
      return [];
    }

    return (data ?? []).map(mapDbRecordToNotification);
  } catch (error) {
    logActionError(
      { domain: "service", action: "getUnreadNotifications" },
      error,
      { userId }
    );
    return [];
  }
}

/**
 * 사용자의 모든 알림 조회
 */
export async function getAllNotifications(
  userId: string,
  limit = 100
): Promise<Notification[]> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("notifications")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (error) {
      logActionError(
        { domain: "service", action: "getAllNotifications" },
        error,
        { userId, limit }
      );
      return [];
    }

    return (data ?? []).map(mapDbRecordToNotification);
  } catch (error) {
    logActionError(
      { domain: "service", action: "getAllNotifications" },
      error,
      { userId, limit }
    );
    return [];
  }
}

/**
 * 사용자의 미읽은 알림 개수 조회
 */
export async function getUnreadNotificationCount(
  userId: string
): Promise<number> {
  try {
    const supabase = await createSupabaseServerClient();

    const { count, error } = await supabase
      .from("notifications")
      .select("*", { count: "exact", head: true })
      .eq("user_id", userId)
      .eq("is_read", false);

    if (error) {
      logActionError(
        { domain: "service", action: "getUnreadNotificationCount" },
        error,
        { userId }
      );
      return 0;
    }

    return count ?? 0;
  } catch (error) {
    logActionError(
      { domain: "service", action: "getUnreadNotificationCount" },
      error,
      { userId }
    );
    return 0;
  }
}

/**
 * 알림 읽음 처리
 */
export async function markNotificationAsRead(
  userId: string,
  notificationId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("notifications")
      .update({
        is_read: true,
        read_at: new Date().toISOString(),
      })
      .eq("id", notificationId)
      .eq("user_id", userId);

    if (error) {
      logActionError(
        { domain: "service", action: "markNotificationAsRead" },
        error,
        { userId, notificationId }
      );
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "markNotificationAsRead" },
      error,
      { userId, notificationId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 모든 알림 읽음 처리
 */
export async function markAllNotificationsAsRead(
  userId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("notifications")
      .update({
        is_read: true,
        read_at: new Date().toISOString(),
      })
      .eq("user_id", userId)
      .eq("is_read", false);

    if (error) {
      logActionError(
        { domain: "service", action: "markAllNotificationsAsRead" },
        error,
        { userId }
      );
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "markAllNotificationsAsRead" },
      error,
      { userId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 알림 삭제
 */
export async function deleteNotification(
  userId: string,
  notificationId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    const { error } = await supabase
      .from("notifications")
      .delete()
      .eq("id", notificationId)
      .eq("user_id", userId);

    if (error) {
      logActionError(
        { domain: "service", action: "deleteNotification" },
        error,
        { userId, notificationId }
      );
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "deleteNotification" },
      error,
      { userId, notificationId }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

// ============================================
// 실시간 브로드캐스트 (Supabase Realtime)
// ============================================

/**
 * 실시간 알림 브로드캐스트 (일시적 알림용)
 *
 * DB에 저장하지 않고 실시간으로 클라이언트에 알림을 전송합니다.
 * 일시적인 알림(예: 타이머 완료, 실시간 상태 업데이트)에 사용합니다.
 *
 * @example
 * ```typescript
 * // 타이머 완료 시 실시간 알림
 * await broadcastNotification(userId, {
 *   type: 'timer_complete',
 *   title: '학습 완료!',
 *   message: '수학 30분 학습을 완료했습니다.',
 * });
 * ```
 */
export async function broadcastNotification(
  userId: string,
  notification: {
    type: string;
    title: string;
    message: string;
    data?: Record<string, unknown>;
  }
): Promise<{ success: boolean; error?: string }> {
  try {
    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      return {
        success: false,
        error: "Admin 클라이언트를 초기화할 수 없습니다.",
      };
    }

    // Supabase Realtime 브로드캐스트 채널 사용
    const channel = adminClient.channel(`notifications-${userId}`);

    await channel.send({
      type: "broadcast",
      event: "notification",
      payload: {
        id: crypto.randomUUID(),
        user_id: userId,
        type: notification.type,
        title: notification.title,
        message: notification.message,
        metadata: notification.data ?? {},
        is_read: false,
        created_at: new Date().toISOString(),
        read_at: null,
        tenant_id: null,
      },
    });

    // 채널 정리
    await adminClient.removeChannel(channel);

    return { success: true };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "broadcastNotification" },
      error,
      { userId, type: notification.type }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 특정 사용자들에게 실시간 알림 브로드캐스트
 */
export async function broadcastBulkNotification(
  userIds: string[],
  notification: {
    type: string;
    title: string;
    message: string;
    data?: Record<string, unknown>;
  }
): Promise<{ success: boolean; sentCount: number; error?: string }> {
  try {
    if (userIds.length === 0) {
      return { success: true, sentCount: 0 };
    }

    const results = await Promise.allSettled(
      userIds.map((userId) => broadcastNotification(userId, notification))
    );

    const successCount = results.filter(
      (r) => r.status === "fulfilled" && r.value.success
    ).length;

    return { success: true, sentCount: successCount };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "broadcastBulkNotification" },
      error,
      { userCount: userIds.length, type: notification.type }
    );
    return {
      success: false,
      sentCount: 0,
      error: errorMessage,
    };
  }
}

// ============================================
// 관리 기능
// ============================================

/**
 * 오래된 알림 정리 (관리자용)
 * @param daysOld 삭제할 알림의 최소 기간 (일)
 */
export async function cleanupOldNotifications(
  daysOld: number = 30
): Promise<{ success: boolean; deletedCount?: number; error?: string }> {
  try {
    const adminClient = createSupabaseAdminClient();

    if (!adminClient) {
      return {
        success: false,
        error: "Admin 클라이언트를 초기화할 수 없습니다.",
      };
    }

    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);

    const { data, error } = await adminClient
      .from("notifications")
      .delete()
      .lt("created_at", cutoffDate.toISOString())
      .eq("is_read", true)
      .select("id");

    if (error) {
      logActionError(
        { domain: "service", action: "cleanupOldNotifications" },
        error,
        { daysOld }
      );
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true, deletedCount: data?.length ?? 0 };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    logActionError(
      { domain: "service", action: "cleanupOldNotifications" },
      error,
      { daysOld }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}
</file>

<file path="locationService.ts">
/**
 * 위치 검증 서비스
 * GPS 기반 출석 체크인 검증
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getTenantContext } from "@/lib/tenant/getTenantContext";

export type LocationVerificationResult = {
  valid: boolean;
  distance?: number; // 미터 단위
  error?: string;
};

/**
 * 두 좌표 간 거리 계산 (Haversine 공식)
 * @param lat1 - 첫 번째 위치의 위도
 * @param lon1 - 첫 번째 위치의 경도
 * @param lat2 - 두 번째 위치의 위도
 * @param lon2 - 두 번째 위치의 경도
 * @returns 거리 (미터 단위)
 */
function calculateDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number {
  const R = 6371000; // 지구 반경 (미터)
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon2 - lon1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * 위치 기반 출석 체크인 검증
 * @param studentLatitude - 학생의 현재 위도
 * @param studentLongitude - 학생의 현재 경도
 * @returns 검증 결과 (거리 포함)
 */
export async function verifyLocationCheckIn(
  studentLatitude: number,
  studentLongitude: number
): Promise<LocationVerificationResult> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    return {
      valid: false,
      error: "테넌트 정보를 찾을 수 없습니다.",
    };
  }

  // 좌표 유효성 검증
  if (
    typeof studentLatitude !== "number" ||
    typeof studentLongitude !== "number" ||
    isNaN(studentLatitude) ||
    isNaN(studentLongitude)
  ) {
    return {
      valid: false,
      error: "유효하지 않은 위치 좌표입니다.",
    };
  }

  if (
    studentLatitude < -90 ||
    studentLatitude > 90 ||
    studentLongitude < -180 ||
    studentLongitude > 180
  ) {
    return {
      valid: false,
      error: "위치 좌표가 범위를 벗어났습니다.",
    };
  }

  const supabase = await createSupabaseServerClient();

  // 학원 위치 정보 조회
  const { data: tenant, error } = await supabase
    .from("tenants")
    .select("location_latitude, location_longitude, location_radius_meters")
    .eq("id", tenantContext.tenantId)
    .single();

  if (error) {
    console.error("[locationService] 학원 위치 정보 조회 실패:", error);
    return {
      valid: false,
      error: "학원 위치 정보를 조회할 수 없습니다.",
    };
  }

  if (!tenant) {
    return {
      valid: false,
      error: "학원 정보를 찾을 수 없습니다.",
    };
  }

  // 위치 설정 여부 확인
  if (tenant.location_latitude === null || tenant.location_longitude === null) {
    return {
      valid: false,
      error: "학원 위치가 설정되지 않았습니다. 관리자에게 문의하세요.",
    };
  }

  // 거리 계산
  const distance = calculateDistance(
    tenant.location_latitude,
    tenant.location_longitude,
    studentLatitude,
    studentLongitude
  );

  const radius = tenant.location_radius_meters || 100; // 기본 반경 100m

  // 반경 내 확인
  if (distance > radius) {
    return {
      valid: false,
      distance: Math.round(distance),
      error: `학원에서 ${Math.round(
        distance
      )}m 떨어져 있습니다. (허용 반경: ${radius}m)`,
    };
  }

  return {
    valid: true,
    distance: Math.round(distance),
  };
}
</file>

<file path="planReminderService.ts">
"use server";

/**
 * Plan Reminder Service
 *
 * 플랜 미완료 알림을 위한 리마인더 서비스
 * - 일일 미완료 알림
 * - 지연 플랜 경고
 * - 주간 미완료 요약
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { sendInAppNotification, type NotificationType } from "./inAppNotificationService";

// ============================================================================
// Types
// ============================================================================

/** 리마인더 타입 */
export type ReminderType =
  | "incomplete_daily" // 일일 미완료 알림
  | "delayed_warning" // 지연 플랜 경고
  | "weekly_summary"; // 주간 미완료 요약

/** 리마인더 설정 */
export interface ReminderSettings {
  incompleteReminderEnabled: boolean;
  incompleteReminderTime: string; // HH:MM 형식
  delayedPlanWarningEnabled: boolean;
  delayedPlanThreshold: number; // 일수
  weeklySummaryEnabled: boolean;
  weeklySummaryDay: number; // 0-6 (일-토)
}

/** 미완료 플랜 정보 */
export interface IncompletePlanInfo {
  planId: string;
  planDate: string;
  title: string;
  subject: string | null;
  daysDelayed: number;
}

/** 리마인더 체크 결과 */
export interface ReminderCheckResult {
  shouldNotify: boolean;
  reminderType: ReminderType;
  incompletePlans: IncompletePlanInfo[];
  message: string;
  subMessage?: string;
}

// ============================================================================
// Constants
// ============================================================================

/** 기본 리마인더 설정 */
const DEFAULT_REMINDER_SETTINGS: ReminderSettings = {
  incompleteReminderEnabled: true,
  incompleteReminderTime: "20:00",
  delayedPlanWarningEnabled: true,
  delayedPlanThreshold: 3,
  weeklySummaryEnabled: true,
  weeklySummaryDay: 0, // 일요일
};

// ============================================================================
// Service Functions
// ============================================================================

/**
 * 학생의 리마인더 설정 조회
 */
export async function getReminderSettings(
  studentId: string
): Promise<ReminderSettings> {
  const supabase = await createSupabaseServerClient();

  const { data } = await supabase
    .from("student_reminder_settings")
    .select("*")
    .eq("student_id", studentId)
    .maybeSingle();

  if (!data) {
    return DEFAULT_REMINDER_SETTINGS;
  }

  return {
    incompleteReminderEnabled: data.incomplete_reminder_enabled ?? true,
    incompleteReminderTime: data.incomplete_reminder_time?.slice(0, 5) ?? "20:00",
    delayedPlanWarningEnabled: data.delayed_plan_warning_enabled ?? true,
    delayedPlanThreshold: data.delayed_plan_threshold ?? 3,
    weeklySummaryEnabled: data.weekly_summary_enabled ?? true,
    weeklySummaryDay: data.weekly_summary_day ?? 0,
  };
}

/**
 * 학생의 리마인더 설정 업데이트
 */
export async function updateReminderSettings(
  studentId: string,
  settings: Partial<ReminderSettings>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const updateData: Record<string, unknown> = {
    student_id: studentId,
    updated_at: new Date().toISOString(),
  };

  if (settings.incompleteReminderEnabled !== undefined) {
    updateData.incomplete_reminder_enabled = settings.incompleteReminderEnabled;
  }
  if (settings.incompleteReminderTime !== undefined) {
    updateData.incomplete_reminder_time = settings.incompleteReminderTime + ":00";
  }
  if (settings.delayedPlanWarningEnabled !== undefined) {
    updateData.delayed_plan_warning_enabled = settings.delayedPlanWarningEnabled;
  }
  if (settings.delayedPlanThreshold !== undefined) {
    updateData.delayed_plan_threshold = settings.delayedPlanThreshold;
  }
  if (settings.weeklySummaryEnabled !== undefined) {
    updateData.weekly_summary_enabled = settings.weeklySummaryEnabled;
  }
  if (settings.weeklySummaryDay !== undefined) {
    updateData.weekly_summary_day = settings.weeklySummaryDay;
  }

  const { error } = await supabase
    .from("student_reminder_settings")
    .upsert(updateData, { onConflict: "student_id" });

  if (error) {
    console.error("[planReminderService] 설정 업데이트 오류:", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * 오늘의 미완료 플랜 조회
 */
export async function getTodayIncompletePlans(
  studentId: string
): Promise<IncompletePlanInfo[]> {
  const supabase = await createSupabaseServerClient();
  const today = new Date().toISOString().split("T")[0];

  const { data, error } = await supabase
    .from("student_plan")
    .select(`
      id,
      plan_date,
      custom_title,
      student_content:student_content_master!left (
        subject,
        content_title:student_content_detail!left (
          detail_subject
        )
      )
    `)
    .eq("student_id", studentId)
    .eq("plan_date", today)
    .is("actual_end_time", null)
    .eq("container_type", "daily");

  if (error || !data) {
    return [];
  }

  return data.map((plan) => {
    const studentContent = plan.student_content as unknown as {
      subject: string | null;
      content_title: Array<{ detail_subject: string | null }> | null;
    } | null;

    return {
      planId: plan.id,
      planDate: plan.plan_date,
      title:
        plan.custom_title ||
        studentContent?.content_title?.[0]?.detail_subject ||
        "학습 플랜",
      subject: studentContent?.subject || null,
      daysDelayed: 0,
    };
  });
}

/**
 * 지연된 플랜 조회 (N일 이상 미완료)
 */
export async function getDelayedPlans(
  studentId: string,
  thresholdDays: number = 3
): Promise<IncompletePlanInfo[]> {
  const supabase = await createSupabaseServerClient();
  const today = new Date();
  const thresholdDate = new Date(today);
  thresholdDate.setDate(thresholdDate.getDate() - thresholdDays);

  const { data, error } = await supabase
    .from("student_plan")
    .select(`
      id,
      plan_date,
      custom_title,
      student_content:student_content_master!left (
        subject,
        content_title:student_content_detail!left (
          detail_subject
        )
      )
    `)
    .eq("student_id", studentId)
    .lt("plan_date", thresholdDate.toISOString().split("T")[0])
    .is("actual_end_time", null)
    .order("plan_date", { ascending: true })
    .limit(10);

  if (error || !data) {
    return [];
  }

  return data.map((plan) => {
    const planDate = new Date(plan.plan_date);
    const daysDelayed = Math.floor(
      (today.getTime() - planDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    const studentContent = plan.student_content as unknown as {
      subject: string | null;
      content_title: Array<{ detail_subject: string | null }> | null;
    } | null;

    return {
      planId: plan.id,
      planDate: plan.plan_date,
      title:
        plan.custom_title ||
        studentContent?.content_title?.[0]?.detail_subject ||
        "학습 플랜",
      subject: studentContent?.subject || null,
      daysDelayed,
    };
  });
}

/**
 * 주간 미완료 플랜 요약 조회
 */
export async function getWeeklyIncompleteSummary(
  studentId: string
): Promise<{
  totalIncomplete: number;
  bySubject: Record<string, number>;
  oldestPlanDate: string | null;
  delayedCount: number;
}> {
  const supabase = await createSupabaseServerClient();
  const today = new Date();
  const todayStr = today.toISOString().split("T")[0];
  const weekAgo = new Date(today);
  weekAgo.setDate(weekAgo.getDate() - 7);

  const { data, error } = await supabase
    .from("student_plan")
    .select(`
      id,
      plan_date,
      student_content:student_content_master!left (
        subject
      )
    `)
    .eq("student_id", studentId)
    .gte("plan_date", weekAgo.toISOString().split("T")[0])
    .lte("plan_date", todayStr)
    .is("actual_end_time", null);

  if (error || !data || data.length === 0) {
    return {
      totalIncomplete: 0,
      bySubject: {},
      oldestPlanDate: null,
      delayedCount: 0,
    };
  }

  const bySubject: Record<string, number> = {};
  let oldestPlanDate: string | null = null;
  let delayedCount = 0;

  for (const plan of data) {
    const studentContent = plan.student_content as unknown as {
      subject: string | null;
    } | null;
    const subject = studentContent?.subject || "기타";
    bySubject[subject] = (bySubject[subject] || 0) + 1;

    if (!oldestPlanDate || plan.plan_date < oldestPlanDate) {
      oldestPlanDate = plan.plan_date;
    }

    // 오늘 이전 날짜의 플랜은 지연된 것으로 간주
    if (plan.plan_date < todayStr) {
      delayedCount++;
    }
  }

  return {
    totalIncomplete: data.length,
    bySubject,
    oldestPlanDate,
    delayedCount,
  };
}

/**
 * 리마인더 발송 여부 체크 (중복 방지)
 */
async function hasReminderBeenSent(
  studentId: string,
  reminderType: ReminderType,
  targetDate: string
): Promise<boolean> {
  const supabase = await createSupabaseServerClient();

  const { data } = await supabase
    .from("plan_reminder_logs")
    .select("id")
    .eq("student_id", studentId)
    .eq("reminder_type", reminderType)
    .eq("reminder_date", targetDate)
    .maybeSingle();

  return !!data;
}

/**
 * 리마인더 발송 로그 저장
 */
async function logReminderSent(
  studentId: string,
  reminderType: ReminderType,
  targetDate: string,
  planCount: number
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  await supabase.from("plan_reminder_logs").insert({
    student_id: studentId,
    reminder_type: reminderType,
    reminder_date: targetDate,
    plan_count: planCount,
    sent_at: new Date().toISOString(),
  });
}

/**
 * 일일 미완료 알림 체크 및 생성
 */
export async function checkAndCreateIncompleteReminder(
  studentId: string,
  cachedSettings?: ReminderSettings
): Promise<ReminderCheckResult | null> {
  const settings = cachedSettings || await getReminderSettings(studentId);

  if (!settings.incompleteReminderEnabled) {
    return null;
  }

  const today = new Date().toISOString().split("T")[0];

  // 캐시된 설정이 없을 때만 중복 체크 (이미 checkAllReminders에서 체크됨)
  if (!cachedSettings) {
    const alreadySent = await hasReminderBeenSent(
      studentId,
      "incomplete_daily",
      today
    );
    if (alreadySent) {
      return null;
    }
  }

  // 미완료 플랜 조회
  const incompletePlans = await getTodayIncompletePlans(studentId);

  if (incompletePlans.length === 0) {
    return null;
  }

  // 알림 로그 저장
  await logReminderSent(studentId, "incomplete_daily", today, incompletePlans.length);

  // 인앱 알림 생성
  await sendInAppNotification(
    studentId,
    "plan_incomplete_reminder" as NotificationType,
    `오늘 ${incompletePlans.length}개의 플랜이 남았어요`,
    incompletePlans.length === 1
      ? `"${incompletePlans[0].title}" 플랜을 완료해보세요!`
      : `${incompletePlans[0].title} 외 ${incompletePlans.length - 1}개의 플랜이 기다리고 있어요.`,
    { actionUrl: "/today" }
  );

  return {
    shouldNotify: true,
    reminderType: "incomplete_daily",
    incompletePlans,
    message: `오늘 ${incompletePlans.length}개의 플랜이 남았어요`,
    subMessage:
      incompletePlans.length === 1
        ? `"${incompletePlans[0].title}" 플랜을 완료해보세요!`
        : `${incompletePlans[0].title} 외 ${incompletePlans.length - 1}개의 플랜이 기다리고 있어요.`,
  };
}

/**
 * 지연 플랜 경고 체크 및 생성
 */
export async function checkAndCreateDelayedWarning(
  studentId: string,
  cachedSettings?: ReminderSettings
): Promise<ReminderCheckResult | null> {
  const settings = cachedSettings || await getReminderSettings(studentId);

  if (!settings.delayedPlanWarningEnabled) {
    return null;
  }

  const today = new Date().toISOString().split("T")[0];

  // 캐시된 설정이 없을 때만 중복 체크
  if (!cachedSettings) {
    const alreadySent = await hasReminderBeenSent(
      studentId,
      "delayed_warning",
      today
    );
    if (alreadySent) {
      return null;
    }
  }

  // 지연 플랜 조회
  const delayedPlans = await getDelayedPlans(studentId, settings.delayedPlanThreshold);

  if (delayedPlans.length === 0) {
    return null;
  }

  // 알림 로그 저장
  await logReminderSent(studentId, "delayed_warning", today, delayedPlans.length);

  const oldestPlan = delayedPlans[0];

  // 인앱 알림 생성
  await sendInAppNotification(
    studentId,
    "plan_incomplete_reminder" as NotificationType,
    `${delayedPlans.length}개의 플랜이 ${settings.delayedPlanThreshold}일 이상 밀렸어요`,
    `가장 오래된 플랜: "${oldestPlan.title}" (${oldestPlan.daysDelayed}일 전)`,
    { actionUrl: "/today" }
  );

  return {
    shouldNotify: true,
    reminderType: "delayed_warning",
    incompletePlans: delayedPlans,
    message: `${delayedPlans.length}개의 플랜이 ${settings.delayedPlanThreshold}일 이상 밀렸어요`,
    subMessage: `가장 오래된 플랜: "${oldestPlan.title}" (${oldestPlan.daysDelayed}일 전)`,
  };
}

/**
 * 주간 요약 체크 및 생성
 */
export async function checkAndCreateWeeklySummary(
  studentId: string,
  cachedSettings?: ReminderSettings
): Promise<ReminderCheckResult | null> {
  const settings = cachedSettings || await getReminderSettings(studentId);

  if (!settings.weeklySummaryEnabled) {
    return null;
  }

  const today = new Date();
  const dayOfWeek = today.getDay();

  // 설정된 요일이 아니면 스킵
  if (dayOfWeek !== settings.weeklySummaryDay) {
    return null;
  }

  const todayStr = today.toISOString().split("T")[0];

  // 캐시된 설정이 없을 때만 중복 체크
  if (!cachedSettings) {
    const alreadySent = await hasReminderBeenSent(
      studentId,
      "weekly_summary",
      todayStr
    );
    if (alreadySent) {
      return null;
    }
  }

  // 주간 요약 조회
  const summary = await getWeeklyIncompleteSummary(studentId);

  if (summary.totalIncomplete === 0) {
    // 미완료가 없어도 축하 메시지 발송
    await logReminderSent(studentId, "weekly_summary", todayStr, 0);

    await sendInAppNotification(
      studentId,
      "daily_goal_complete" as NotificationType,
      "이번 주 플랜을 모두 완료했어요!",
      "대단해요! 다음 주도 화이팅!",
      { actionUrl: "/today" }
    );

    return {
      shouldNotify: true,
      reminderType: "weekly_summary",
      incompletePlans: [],
      message: "이번 주 플랜을 모두 완료했어요!",
      subMessage: "대단해요! 다음 주도 화이팅!",
    };
  }

  // 알림 로그 저장
  await logReminderSent(studentId, "weekly_summary", todayStr, summary.totalIncomplete);

  const subjectList = Object.entries(summary.bySubject)
    .map(([subject, count]) => `${subject} ${count}개`)
    .join(", ");

  // 인앱 알림 생성
  await sendInAppNotification(
    studentId,
    "weekly_plan_summary" as NotificationType,
    `이번 주 ${summary.totalIncomplete}개의 플랜이 미완료예요`,
    `과목별: ${subjectList}`,
    { actionUrl: "/today" }
  );

  return {
    shouldNotify: true,
    reminderType: "weekly_summary",
    incompletePlans: [],
    message: `이번 주 ${summary.totalIncomplete}개의 플랜이 미완료예요`,
    subMessage: `과목별: ${subjectList}`,
  };
}

/**
 * 모든 리마인더 체크 실행 (최적화 버전)
 * - 설정을 한 번만 조회하여 성능 개선
 * - 리마인더 로그 배치 조회
 * (스케줄러나 페이지 로드 시 호출)
 */
export async function checkAllReminders(
  studentId: string
): Promise<ReminderCheckResult[]> {
  const results: ReminderCheckResult[] = [];

  try {
    // 설정 한 번만 조회 (성능 최적화)
    const settings = await getReminderSettings(studentId);
    const todayStr = new Date().toISOString().split("T")[0];

    // 배치로 이미 발송된 리마인더 타입 조회
    const supabase = await createSupabaseServerClient();
    const { data: sentReminders } = await supabase
      .from("plan_reminder_logs")
      .select("reminder_type")
      .eq("student_id", studentId)
      .eq("reminder_date", todayStr);

    const sentTypes = new Set(sentReminders?.map((r) => r.reminder_type) || []);

    // 일일 미완료 알림 (이미 발송되지 않은 경우만)
    if (
      settings.incompleteReminderEnabled &&
      !sentTypes.has("incomplete_daily")
    ) {
      const incompleteResult = await checkAndCreateIncompleteReminder(
        studentId,
        settings
      );
      if (incompleteResult) {
        results.push(incompleteResult);
      }
    }

    // 지연 플랜 경고 (이미 발송되지 않은 경우만)
    if (
      settings.delayedPlanWarningEnabled &&
      !sentTypes.has("delayed_warning")
    ) {
      const delayedResult = await checkAndCreateDelayedWarning(
        studentId,
        settings
      );
      if (delayedResult) {
        results.push(delayedResult);
      }
    }

    // 주간 요약 (이미 발송되지 않은 경우만)
    if (settings.weeklySummaryEnabled && !sentTypes.has("weekly_summary")) {
      const weeklyResult = await checkAndCreateWeeklySummary(studentId, settings);
      if (weeklyResult) {
        results.push(weeklyResult);
      }
    }
  } catch (error) {
    console.error("[planReminderService] 리마인더 체크 오류:", error);
  }

  return results;
}

/**
 * 클라이언트에서 호출 가능한 미완료 플랜 정보 조회
 */
export async function getIncompleteReminderInfo(
  studentId: string
): Promise<{
  todayIncomplete: IncompletePlanInfo[];
  delayedPlans: IncompletePlanInfo[];
  weeklySummary: {
    totalIncomplete: number;
    bySubject: Record<string, number>;
  };
} | null> {
  try {
    const settings = await getReminderSettings(studentId);

    const [todayIncomplete, delayedPlans, weeklySummary] = await Promise.all([
      getTodayIncompletePlans(studentId),
      settings.delayedPlanWarningEnabled
        ? getDelayedPlans(studentId, settings.delayedPlanThreshold)
        : Promise.resolve([]),
      getWeeklyIncompleteSummary(studentId),
    ]);

    return {
      todayIncomplete,
      delayedPlans,
      weeklySummary: {
        totalIncomplete: weeklySummary.totalIncomplete,
        bySubject: weeklySummary.bySubject,
      },
    };
  } catch (error) {
    console.error("[planReminderService] 미완료 정보 조회 오류:", error);
    return null;
  }
}
</file>

<file path="qrCodeService.ts">
/**
 * QR 코드 서비스
 * 출석용 QR 코드 생성 및 검증
 */

import QRCode from "qrcode";
import { headers } from "next/headers";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getBaseUrl } from "@/lib/utils/getBaseUrl";

export type QRCodeData = {
  qrCodeId: string; // 데이터베이스 ID
  tenantId: string;
  timestamp: number;
  type: "attendance";
};

export type QRCodeVerificationResult = {
  valid: boolean;
  tenantId?: string;
  qrCodeId?: string;
  error?: string;
};

export type QRCodeRecord = {
  id: string;
  tenant_id: string;
  qr_data: string;
  qr_code_url: string | null;
  is_active: boolean;
  expires_at: string;
  created_by: string | null;
  created_at: string;
  deactivated_at: string | null;
  deactivated_by: string | null;
  usage_count: number;
  last_used_at: string | null;
};

/**
 * 학원별 출석용 QR 코드 생성
 * @returns QR 코드 이미지 URL (Data URL), QR 코드 데이터, QR 코드 ID
 */
export async function generateAttendanceQRCode(): Promise<{
  qrCodeUrl: string;
  qrCodeData: string;
  qrCodeId: string;
}> {
  const { service } = await import("@/lib/domains/qrCode");
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new Error("테넌트 정보를 찾을 수 없습니다.");
  }

  // 만료 시간 설정 (기본 24시간)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 24);

  // 임시 ID 생성 (실제 ID는 DB에서 생성됨)
  const tempId = crypto.randomUUID();

  // QR 코드 데이터 생성 (임시 ID 사용, 나중에 실제 ID로 업데이트)
  const timestamp = Date.now();
  const qrData: QRCodeData = {
    qrCodeId: tempId,
    tenantId: tenantContext.tenantId,
    timestamp,
    type: "attendance",
  };

  const qrDataString = JSON.stringify(qrData);

  // QR 코드 이미지 생성
  const qrCodeUrl = await QRCode.toDataURL(qrDataString, {
    width: 400,
    margin: 2,
    errorCorrectionLevel: "M",
  });

  // QR 코드 생성 (기존 활성 QR 코드 자동 비활성화)
  const qrCodeRecord = await service.createQRCode(
    qrDataString,
    qrCodeUrl,
    expiresAt
  );

  // 실제 ID로 QR 코드 데이터 업데이트
  const actualQrData: QRCodeData = {
    ...qrData,
    qrCodeId: qrCodeRecord.id,
  };
  const actualQrDataString = JSON.stringify(actualQrData);

  // BASE_URL 가져오기 (Deep Link용)
  const headersList = await headers();
  const baseUrl = getBaseUrl(headersList);
  const deepLinkUrl = `${baseUrl}/attendance/check-in/qr?code=${qrCodeRecord.id}`;

  // Deep Link URL로 QR 코드 이미지 생성 (카메라 앱에서 스캔 시 자동으로 열림)
  const deepLinkQrCodeUrl = await QRCode.toDataURL(deepLinkUrl, {
    width: 400,
    margin: 2,
    errorCorrectionLevel: "M",
  });

  // DB에 실제 QR 코드 데이터 및 이미지 URL 업데이트
  // qr_data는 기존 JSON 형식 유지 (하위 호환성)
  // qr_code_url은 Deep Link URL로 생성된 이미지 사용
  const { repository } = await import("@/lib/domains/qrCode");
  const { createSupabaseServerClient } = await import("@/lib/supabase/server");
  const supabase = await createSupabaseServerClient();

  await supabase
    .from("attendance_qr_codes")
    .update({
      qr_data: actualQrDataString, // JSON 데이터는 DB에 저장 (기존 스캐너 호환)
      qr_code_url: deepLinkQrCodeUrl, // Deep Link URL로 생성된 이미지
    })
    .eq("id", qrCodeRecord.id)
    .eq("tenant_id", tenantContext.tenantId);

  return {
    qrCodeUrl: deepLinkQrCodeUrl,
    qrCodeData: actualQrDataString, // 기존 호환성을 위해 JSON 데이터도 반환
    qrCodeId: qrCodeRecord.id,
  };
}

/**
 * QR 코드 검증 (DB 기반)
 * URL 형식과 JSON 형식 모두 지원
 * @param qrData - 스캔된 QR 코드 데이터 (URL 또는 JSON 문자열)
 * @returns 검증 결과
 */
export async function verifyQRCode(
  qrData: string
): Promise<QRCodeVerificationResult> {
  try {
    // URL 형식인지 확인 (예: https://domain.com/attendance/check-in/qr?code=xxx)
    const urlMatch = qrData.match(/\/attendance\/check-in\/qr\?code=([^&]+)/);
    if (urlMatch) {
      const qrCodeId = urlMatch[1];
      // DB에서 QR 코드 조회 및 검증
      const { service } = await import("@/lib/domains/qrCode");

      try {
        const qrCodeRecord = await service.verifyAndUpdateQRCode(qrCodeId);

        return {
          valid: true,
          tenantId: qrCodeRecord.tenant_id,
          qrCodeId: qrCodeRecord.id,
        };
      } catch (error: unknown) {
        // AppError인 경우 에러 메시지 반환
        if (error instanceof Error) {
          return {
            valid: false,
            error: error.message,
          };
        }
        return {
          valid: false,
          error: "QR 코드 검증에 실패했습니다.",
        };
      }
    }

    // JSON 형식인 경우 (기존 호환성)
    const data = JSON.parse(qrData) as QRCodeData;

    // 타입 검증
    if (data.type !== "attendance") {
      return {
        valid: false,
        error: "잘못된 QR 코드입니다. 출석용 QR 코드가 아닙니다.",
      };
    }

    // qrCodeId 검증
    if (!data.qrCodeId || typeof data.qrCodeId !== "string") {
      return {
        valid: false,
        error: "QR 코드에 ID가 없습니다.",
      };
    }

    // tenantId 검증
    if (!data.tenantId || typeof data.tenantId !== "string") {
      return {
        valid: false,
        error: "QR 코드에 테넌트 정보가 없습니다.",
      };
    }

    // DB에서 QR 코드 조회 및 검증
    const { service } = await import("@/lib/domains/qrCode");

    try {
      const qrCodeRecord = await service.verifyAndUpdateQRCode(data.qrCodeId);

      return {
        valid: true,
        tenantId: qrCodeRecord.tenant_id,
        qrCodeId: qrCodeRecord.id,
      };
    } catch (error: unknown) {
      // AppError인 경우 에러 메시지 반환
      if (error instanceof Error) {
        return {
          valid: false,
          error: error.message,
        };
      }
      return {
        valid: false,
        error: "QR 코드 검증에 실패했습니다.",
      };
    }
  } catch (error) {
    return {
      valid: false,
      error: "QR 코드 형식이 올바르지 않습니다.",
    };
  }
}
</file>

<file path="smsService.ts">
/**
 * SMS 발송 서비스
 * 뿌리오 API를 활용한 문자 발송 기능
 * API 문서: https://www.ppurio.com/send-api/develop
 */

import { env } from "@/lib/env";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getSupabaseClientForRLSBypass } from "@/lib/supabase/clientSelector";
import { logActionError, logActionDebug } from "@/lib/logging/actionLogger";

export interface SendSMSOptions {
  recipientPhone: string;
  message: string;
  recipientId?: string;
  tenantId: string;
  templateId?: string;
  refKey?: string; // 고객사에서 부여한 키
  sendTime?: string; // 예약 발송 시간 (yyyy-MM-ddTHH:mm:ss)
}

interface TokenResponse {
  token: string;
  type: string;
  expired: number; // Unix timestamp
}

interface MessageResponse {
  code: number | string; // 뿌리오 API는 문자열로 반환할 수 있음
  description: string;
  refKey?: string;
  messageKey?: string;
}

interface ErrorResponse {
  code: number | string; // 뿌리오 API는 문자열로 반환할 수 있음
  description: string;
}

// 토큰 캐시 (메모리)
let tokenCache: {
  token: string;
  expiresAt: number;
} | null = null;

/**
 * Base64 인코딩
 */
function base64Encode(str: string): string {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(str).toString("base64");
  }
  // 브라우저 환경 (일반적으로 서버에서만 사용)
  return btoa(unescape(encodeURIComponent(str)));
}

/**
 * 뿌리오 API 엑세스 토큰 발급
 * Basic Authentication 사용 (계정:뿌리오 개발 인증키)
 */
async function getAccessToken(): Promise<string> {
  // 캐시된 토큰이 있고 아직 유효한 경우 재사용
  if (tokenCache && tokenCache.expiresAt > Date.now()) {
    return tokenCache.token;
  }

  const account = env.PPURIO_ACCOUNT;
  const authKey = env.PPURIO_AUTH_KEY;
  const baseUrl = env.PPURIO_API_BASE_URL || "https://message.ppurio.com";

  if (!account || !authKey) {
    throw new Error(
      "뿌리오 계정(PPURIO_ACCOUNT) 및 인증키(PPURIO_AUTH_KEY)가 설정되지 않았습니다."
    );
  }

  // Basic Authentication: 계정:인증키를 Base64 인코딩
  const credentials = base64Encode(`${account}:${authKey}`);
  const tokenEndpoint = `${baseUrl}/v1/token`;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃

    const response = await fetch(tokenEndpoint, {
      method: "POST",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/json",
      },
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `토큰 발급 실패: ${response.status}`;

      try {
        const errorJson: ErrorResponse = JSON.parse(errorText);
        errorMessage = errorJson.description || errorMessage;
      } catch {
        errorMessage = `${errorMessage} - ${errorText}`;
      }

      // 에러 코드별 처리
      const errorCodeMessages: Record<number, string> = {
        3001: "Authorization 헤더가 유효하지 않습니다.",
        3003: "아이피가 유효하지 않습니다.",
        3004: "계정이 유효하지 않습니다.",
        3007: "엑세스 토큰 발행 실패",
        4004: "API 접근 권한이 비활성화 상태입니다.",
        4006: "인증키가 유효하지 않습니다.",
        4007: "인증키를 발행 받지 않았습니다.",
      };

      const errorJson: ErrorResponse | null = (() => {
        try {
          return JSON.parse(errorText);
        } catch {
          return null;
        }
      })();

      if (errorJson) {
        // code를 숫자로 변환 (문자열일 수 있음)
        const parsedCode = typeof errorJson.code === "string" 
          ? parseInt(errorJson.code, 10) 
          : errorJson.code;
        if (errorCodeMessages[parsedCode]) {
          errorMessage = errorCodeMessages[parsedCode];
        }
      }

      throw new Error(errorMessage);
    }

    const result: TokenResponse = await response.json();

    if (!result.token) {
      throw new Error("토큰 발급 응답에 토큰이 없습니다.");
    }

    // 토큰 캐싱 (유효기간 1일, 여유를 두고 23시간으로 설정)
    const expiresAt = result.expired
      ? result.expired * 1000 // Unix timestamp를 밀리초로 변환
      : Date.now() + 23 * 60 * 60 * 1000; // 23시간

    tokenCache = {
      token: result.token,
      expiresAt: expiresAt,
    };

    return result.token;
  } catch (error: unknown) {
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("토큰 발급 요청 시간이 초과되었습니다.");
    }
    if (error instanceof Error && error.message) {
      throw error;
    }
    throw new Error(
      `토큰 발급 실패: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * 전화번호 형식 검증 및 정규화
 * 한국 휴대폰 번호 형식: 010-1234-5678 또는 01012345678
 */
export function validateAndNormalizePhoneNumber(phone: string): {
  isValid: boolean;
  normalized: string;
  error?: string;
} {
  // 하이픈, 공백 제거
  const cleaned = phone.replace(/[-\s]/g, "");

  // 숫자만 남기기
  if (!/^\d+$/.test(cleaned)) {
    return {
      isValid: false,
      normalized: cleaned,
      error: "전화번호는 숫자만 입력 가능합니다.",
    };
  }

  // 한국 휴대폰 번호 형식 검증 (010, 011, 016, 017, 018, 019로 시작, 총 10-11자리)
  const mobilePattern = /^(010|011|016|017|018|019)\d{7,8}$/;
  if (!mobilePattern.test(cleaned)) {
    return {
      isValid: false,
      normalized: cleaned,
      error: "올바른 한국 휴대폰 번호 형식이 아닙니다. (예: 010-1234-5678)",
    };
  }

  return {
    isValid: true,
    normalized: cleaned,
  };
}

/**
 * 단일 SMS 발송 (재시도 로직 포함)
 */
export async function sendSMS(
  options: SendSMSOptions,
  retryCount = 0,
  maxRetries = 2
): Promise<{
  success: boolean;
  messageKey?: string;
  smsLogId?: string;
  error?: string;
}> {
  const {
    recipientPhone,
    message,
    recipientId,
    tenantId,
    templateId,
    refKey,
    sendTime,
  } = options;

  // 환경 변수 확인
  if (
    !env.PPURIO_ACCOUNT ||
    !env.PPURIO_AUTH_KEY ||
    !env.PPURIO_SENDER_NUMBER
  ) {
    return {
      success: false,
      error: "SMS 발송 설정이 완료되지 않았습니다. 관리자에게 문의하세요.",
    };
  }

  // 전화번호 검증 및 정규화
  const phoneValidation = validateAndNormalizePhoneNumber(recipientPhone);
  if (!phoneValidation.isValid) {
    return {
      success: false,
      error: phoneValidation.error || "전화번호 형식이 올바르지 않습니다.",
    };
  }

  const normalizedPhone = phoneValidation.normalized;

  // 1. SMS 로그 생성 (pending 상태) - 재시도가 아닌 경우에만
  // RLS 우회를 위해 Admin 클라이언트 사용 (SMS 로그는 시스템이 생성)
  const logClient = await getSupabaseClientForRLSBypass({
    forceAdmin: true,
    fallbackToServer: false, // Admin 클라이언트 필수
  });
  
  if (!logClient) {
    return {
      success: false,
      error: "시스템 오류: 로깅 클라이언트를 초기화할 수 없습니다.",
    };
  }

  let smsLog;

  const baseUrl = env.PPURIO_API_BASE_URL || "https://message.ppurio.com";
  const messageEndpoint = `${baseUrl}/v1/message`;

  if (retryCount === 0) {
    const { data: logData, error: logError } = await logClient
      .from("sms_logs")
      .insert({
        tenant_id: tenantId,
        recipient_id: recipientId,
        recipient_phone: normalizedPhone,
        message_content: message,
        template_id: templateId,
        status: "pending",
      })
      .select()
      .single();

    if (logError || !logData) {
      logActionError(
        { domain: "service", action: "sendSMS" },
        logError,
        { context: "로그 생성", recipientPhone: normalizedPhone }
      );
      return {
        success: false,
        error: "SMS 로그 생성에 실패했습니다.",
      };
    }
    smsLog = logData;
  } else {
    // 재시도인 경우 기존 로그 조회 (RLS 우회 필요)
    if (!logClient) {
    return { success: false, error: "로깅 클라이언트 초기화 실패" };
  }

  const { data: logData } = await logClient
      .from("sms_logs")
      .select("id")
      .eq("tenant_id", tenantId)
      .eq("recipient_phone", normalizedPhone)
      .eq("message_content", message)
      .order("created_at", { ascending: false })
      .limit(1)
      .single();

    if (!logData) {
      return {
        success: false,
        error: "기존 SMS 로그를 찾을 수 없습니다.",
      };
    }
    smsLog = logData;
  }

  try {
    // 2. 토큰 발급
    const accessToken = await getAccessToken();

    // 3. 메시지 발송 요청
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃

    // 메시지 타입 결정 (SMS: 90byte 이하, LMS: 2000byte 이하)
    const messageBytes = new TextEncoder().encode(message).length;
    const messageType = messageBytes <= 90 ? "SMS" : "LMS";

    // refKey는 최대 32자로 제한 (문서: text(32))
    const refKeyValue = (refKey || smsLog.id).toString().slice(0, 32);

    const requestBody = {
      account: env.PPURIO_ACCOUNT,
      messageType: messageType,
      content: message,
      from: env.PPURIO_SENDER_NUMBER,
      duplicateFlag: "N", // 중복 제거
      targetCount: 1,
      targets: [
        {
          to: normalizedPhone,
        },
      ],
      refKey: refKeyValue,
      ...(sendTime && { sendTime }), // 예약 발송 시간
    };

    // 디버깅: 요청 본문 로깅 (개발 환경에서만)
    logActionDebug(
      { domain: "service", action: "sendSMS" },
      "요청 본문",
      { requestBody }
    );

    const response = await fetch(messageEndpoint, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    const responseText = await response.text();

    // 디버깅: 응답 로깅
    logActionDebug(
      { domain: "service", action: "sendSMS" },
      "API 응답",
      {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        body: responseText,
      }
    );

    // 응답 파싱
    let result: MessageResponse | ErrorResponse;
    try {
      result = JSON.parse(responseText);
    } catch {
      // JSON 파싱 실패는 HTTP 에러로 처리
      if (!response.ok) {
        throw new Error(`응답 파싱 실패 (HTTP ${response.status}): ${responseText}`);
      }
      throw new Error(`응답 파싱 실패: ${responseText}`);
    }

    // 뿌리오 API는 HTTP 200이어도 응답 본문에 에러 코드를 반환할 수 있음
    // 따라서 HTTP 상태 코드와 응답 본문의 code를 모두 확인해야 함

    // HTTP 에러 (4xx, 5xx)
    if (!response.ok) {
      const errorJson = result as ErrorResponse;
      // code를 숫자로 변환 (문자열일 수 있음)
      const errorCode = typeof errorJson.code === "string" 
        ? parseInt(errorJson.code, 10) 
        : errorJson.code;
      const errorMessage = errorJson.description || `API 요청 실패: ${response.status}`;

      // 에러 코드별 처리
      const errorCodeMessages: Record<number, string> = {
        2000: "잘못된 요청입니다.",
        3001: "Authorization 헤더가 유효하지 않습니다.",
        3002: "토큰이 유효하지 않습니다.",
        3003: "아이피가 유효하지 않습니다.",
        3004: "계정이 유효하지 않습니다.",
        3005: "토큰이 유효하지 않습니다.",
        3006: "Authentication Header가 유효하지 않습니다.",
        3008: "너무 많은 요청입니다.",
        4004: "API 접근 권한이 비활성화 상태입니다.",
        4006: "인증키가 유효하지 않습니다.",
        4007: "인증키를 발행 받지 않았습니다.",
      };

      const finalErrorMessage = errorCode && errorCodeMessages[errorCode]
        ? errorCodeMessages[errorCode]
        : errorMessage;

      // 재시도 불가능한 에러 코드 (클라이언트 에러: 2xxx, 3xxx, 4xxx)
      const nonRetryableErrorCodes = [
        2000, 2001, // 잘못된 요청
        3001, 3002, 3003, 3004, 3005, 3006, // 인증/권한 에러
        4004, 4006, 4007, // 설정 에러
      ];

      const error = new Error(finalErrorMessage) as Error & { code?: number; isRetryable?: boolean };
      error.code = errorCode || undefined;
      error.isRetryable = errorCode ? !nonRetryableErrorCodes.includes(errorCode) : false;
      
      throw error;
    }

    // HTTP 200 응답 처리
    const messageResponse = result as MessageResponse;

    // code를 숫자로 변환 (문자열 "1000"도 처리)
    const responseCode = typeof messageResponse.code === "string" 
      ? parseInt(messageResponse.code, 10) 
      : messageResponse.code;

    // 성공 응답 확인: code가 1000이면 성공
    if (responseCode === 1000) {
      // messageKey가 있으면 명시적으로 성공
      // messageKey가 없어도 code가 1000이면 성공으로 간주 (일부 API는 messageKey를 반환하지 않을 수 있음)
      const messageKey = messageResponse.messageKey || `ref-${refKeyValue}`;

      await logClient
        .from("sms_logs")
        .update({
          status: "sent",
          sent_at: new Date().toISOString(),
        })
        .eq("id", smsLog.id);

      logActionDebug(
        { domain: "service", action: "sendSMS" },
        "발송 성공",
        {
          phone: normalizedPhone,
          messageKey,
          code: messageResponse.code,
          description: messageResponse.description,
        }
      );

      return {
        success: true,
        messageKey: messageKey,
        smsLogId: smsLog.id,
      };
    }

    // HTTP 200이지만 응답 본문에 에러 코드가 있는 경우
    // (뿌리오 API는 HTTP 200이어도 code: 2000 같은 에러를 반환할 수 있음)
    const errorMessage = messageResponse.description || "SMS 발송에 실패했습니다.";
    const errorCode = responseCode;

    logActionDebug(
      { domain: "service", action: "sendSMS" },
      "발송 실패 (HTTP 200이지만 에러 코드)",
      {
        phone: normalizedPhone,
        code: errorCode,
        originalCode: messageResponse.code,
        description: errorMessage,
      }
    );

    await logClient
      .from("sms_logs")
      .update({
        status: "failed",
        error_message: errorMessage,
      })
      .eq("id", smsLog.id);

    // 재시도 가능한 에러인지 확인 (5xx 서버 에러, Rate limit만 재시도)
    const isRetryable = errorCode && (errorCode >= 500 || errorCode === 3008);

    if (isRetryable && retryCount < maxRetries) {
      // 지수 백오프: 1초, 2초, 4초...
      const delay = Math.pow(2, retryCount) * 1000;
      await new Promise((resolve) => setTimeout(resolve, delay));

      logActionDebug(
        { domain: "service", action: "sendSMS" },
        `재시도 ${retryCount + 1}/${maxRetries}`,
        { phone: normalizedPhone, errorCode }
      );
      return sendSMS(options, retryCount + 1, maxRetries);
    }

    return {
      success: false,
      error: errorMessage,
    };
  } catch (error: unknown) {
    // 5. 에러 처리
    let errorMessage = "알 수 없는 오류가 발생했습니다.";
    let errorDetails: Record<string, unknown> = {};

    if (error instanceof Error) {
      if (error.name === "AbortError") {
        errorMessage =
          "요청 시간이 초과되었습니다. 네트워크 연결을 확인해주세요.";
        errorDetails = {
          type: "timeout",
          timeout: 10000,
        };
      } else if (
        error.message.includes("fetch") ||
        error.message === "fetch failed"
      ) {
        // DNS 조회 실패 확인
        const isDnsError =
          error.cause &&
          typeof error.cause === "object" &&
          "code" in error.cause &&
          (error.cause.code === "ENOTFOUND" ||
            error.cause.code === "EAI_AGAIN");

        if (isDnsError) {
          const cause = error.cause as
            | { code?: string; hostname?: string }
            | undefined;
          const hostname = cause?.hostname || "unknown";
          const code = cause?.code || "ENOTFOUND";
          errorMessage = `DNS 조회 실패: '${hostname}' 도메인을 찾을 수 없습니다. API 엔드포인트 URL을 확인해주세요.`;
          errorDetails = {
            type: "dns_error",
            endpoint: messageEndpoint,
            hostname: hostname,
            code: code,
            message: error.message,
            hint: "뿌리오 API 문서에서 올바른 엔드포인트를 확인하거나, 기본값(https://message.ppurio.com)을 사용해보세요.",
          };
        } else {
          errorMessage =
            "네트워크 연결에 실패했습니다. 인터넷 연결 및 API 엔드포인트를 확인해주세요.";
          errorDetails = {
            type: "network_error",
            endpoint: messageEndpoint,
            cause: error.cause || "unknown",
            message: error.message,
          };
        }
      } else {
        errorMessage = error.message;
        errorDetails = {
          type: "unknown",
          name: error.name,
          message: error.message,
          stack: error.stack,
        };
      }
    } else {
      errorDetails = {
        type: "non_error_object",
        value: String(error),
      };
    }

    await logClient
      .from("sms_logs")
      .update({
        status: "failed",
        error_message: errorMessage,
      })
      .eq("id", smsLog.id);

    // 상세 에러 로그 출력
    const getHint = () => {
      if (errorDetails.type === "dns_error") {
        return `DNS 조회 실패: '${errorDetails.hostname}' 도메인을 찾을 수 없습니다. 뿌리오 API 문서에서 올바른 엔드포인트를 확인하거나, 기본값(https://message.ppurio.com)을 사용해보세요.`;
      } else if (errorDetails.type === "network_error") {
        return "API 엔드포인트 URL, 네트워크 연결, 방화벽 설정을 확인하세요.";
      } else if (errorDetails.type === "timeout") {
        return "요청 시간이 초과되었습니다. 네트워크 연결을 확인하거나 타임아웃 시간을 늘려보세요.";
      }
      return undefined;
    };

    logActionError(
      { domain: "service", action: "sendSMS" },
      error,
      {
        phone: normalizedPhone,
        retryCount,
        endpoint: messageEndpoint,
        details: errorDetails,
        hint: getHint(),
      }
    );

    // 재시도 가능한 에러인지 확인
    const errorWithCode = error as Error & { code?: number; isRetryable?: boolean };
    
    // 명시적으로 재시도 불가능으로 표시된 경우 제외
    if (errorWithCode.isRetryable === false) {
      return {
        success: false,
        error: errorMessage,
      };
    }

    // 재시도 불가능한 에러 코드 (클라이언트 에러)
    const nonRetryableErrorCodes = [
      2000, 2001, // 잘못된 요청
      3001, 3002, 3003, 3004, 3005, 3006, // 인증/권한 에러
      4004, 4006, 4007, // 설정 에러
    ];

    if (errorWithCode.code && nonRetryableErrorCodes.includes(errorWithCode.code)) {
      return {
        success: false,
        error: errorMessage,
      };
    }

    // 네트워크 에러, 타임아웃, 토큰 에러만 재시도
    const isRetryable =
      error instanceof Error &&
      (error.name === "AbortError" ||
        error.message.includes("fetch") ||
        error.message.includes("network") ||
        error.message.includes("토큰") ||
        error.message.includes("시간이 초과"));

    if (isRetryable && retryCount < maxRetries) {
      // 토큰 관련 에러인 경우 토큰 캐시 초기화
      if (error.message.includes("토큰")) {
        tokenCache = null;
      }

      // 지수 백오프
      const delay = Math.pow(2, retryCount) * 1000;
      await new Promise((resolve) => setTimeout(resolve, delay));

      logActionDebug(
        { domain: "service", action: "sendSMS" },
        `재시도 ${retryCount + 1}/${maxRetries}`,
        { phone: normalizedPhone, errorMessage: error.message }
      );
      return sendSMS(options, retryCount + 1, maxRetries);
    }

    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 예약발송 취소
 */
export async function cancelScheduledMessage(
  messageKey: string,
  tenantId: string
): Promise<{
  success: boolean;
  error?: string;
}> {
  if (!env.PPURIO_ACCOUNT || !env.PPURIO_AUTH_KEY) {
    return {
      success: false,
      error: "SMS 발송 설정이 완료되지 않았습니다.",
    };
  }

  const baseUrl = env.PPURIO_API_BASE_URL || "https://message.ppurio.com";
  const cancelEndpoint = `${baseUrl}/v1/cancel`;

  try {
    // 토큰 발급
    const accessToken = await getAccessToken();

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    const response = await fetch(cancelEndpoint, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        account: env.PPURIO_ACCOUNT,
        messageKey: messageKey,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `예약 취소 실패: ${response.status}`;

      try {
        const errorJson: ErrorResponse = JSON.parse(errorText);
        errorMessage = errorJson.description || errorMessage;

        // 에러 코드별 처리
        const errorCodeMessages: Record<number, string> = {
          2000: "잘못된 요청입니다.",
          2001: "잘못된 URL입니다.",
          3002: "토큰이 유효하지 않습니다.",
          3003: "아이피가 유효하지 않습니다.",
          3004: "계정이 유효하지 않습니다.",
          3005: "인증 정보가 유효하지 않습니다.",
          3006: "Authentication Header가 유효하지 않습니다.",
          3008: "너무 많은 요청입니다.",
          4004: "API 접근 권한이 비활성화 상태입니다.",
          4006: "인증키가 유효하지 않습니다.",
          4007: "인증키를 발행 받지 않았습니다.",
          4009: "메시지키가 유효하지 않습니다.",
          4010: "예약 취소 가능 시간이 지났습니다.",
          4011: "메시지가 이미 발송중인 상태입니다.",
          4012: "예약을 취소할 수 없습니다.",
        };

        // code를 숫자로 변환 (문자열일 수 있음)
        const parsedCode = typeof errorJson.code === "string" 
          ? parseInt(errorJson.code, 10) 
          : errorJson.code;
        if (errorCodeMessages[parsedCode]) {
          errorMessage = errorCodeMessages[parsedCode];
        }
      } catch {
        errorMessage = `${errorMessage} - ${errorText}`;
      }

      throw new Error(errorMessage);
    }

    const result: MessageResponse = await response.json();

    // code를 숫자로 변환 (문자열일 수 있음)
    const responseCode = typeof result.code === "string" 
      ? parseInt(result.code, 10) 
      : result.code;

    if (responseCode === 1000) {
      // SMS 로그 상태 업데이트 (RLS 우회 필요)
      const logClient = await getSupabaseClientForRLSBypass({
        forceAdmin: true,
        fallbackToServer: false,
      });
      if (logClient) {
        await logClient
          .from("sms_logs")
          .update({
            status: "failed",
            error_message: "예약 발송이 취소되었습니다.",
          })
          .eq("tenant_id", tenantId)
          .eq("status", "pending");
      }

      return { success: true };
    } else {
      return {
        success: false,
        error: result.description || "예약 취소에 실패했습니다.",
      };
    }
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error
        ? error.message
        : "예약 취소 중 오류가 발생했습니다.";
    logActionError(
      { domain: "service", action: "cancelScheduledMessage" },
      error,
      { messageKey }
    );
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * 대량 SMS 발송
 * Rate Limit을 고려하여 순차 발송
 */
export async function sendBulkSMS(
  recipients: Array<{
    phone: string;
    message: string;
    recipientId?: string;
  }>,
  tenantId: string,
  templateId?: string
): Promise<{
  success: number;
  failed: number;
  errors: Array<{ phone: string; error: string }>;
}> {
  const results = {
    success: 0,
    failed: 0,
    errors: [] as Array<{ phone: string; error: string }>,
  };

  // 순차 발송 (API Rate Limit 고려)
  for (const recipient of recipients) {
    const result = await sendSMS({
      recipientPhone: recipient.phone,
      message: recipient.message,
      recipientId: recipient.recipientId,
      tenantId,
      templateId,
    });

    if (result.success) {
      results.success++;
    } else {
      results.failed++;
      results.errors.push({
        phone: recipient.phone,
        error: result.error || "알 수 없는 오류",
      });
    }

    // Rate Limit 방지를 위한 딜레이 (100ms)
    await new Promise((resolve) => setTimeout(resolve, 100));
  }

  return results;
}
</file>

<file path="smsTemplates.ts">
/**
 * SMS 템플릿 관리
 * 출석, 수강료, 상담 등 다양한 용도의 SMS 템플릿 정의
 */

export type SMSTemplateType =
  | "attendance_check_in"
  | "attendance_check_out"
  | "attendance_absent"
  | "attendance_late"
  | "payment_due"
  | "payment_overdue"
  | "consultation_scheduled"
  | "notice";

export interface SMSTemplate {
  id: string;
  type: SMSTemplateType;
  title: string;
  content: string;
  variables: string[]; // 템플릿 변수 목록
}

export const SMS_TEMPLATES: Record<SMSTemplateType, SMSTemplate> = {
  attendance_check_in: {
    id: "attendance_check_in",
    type: "attendance_check_in",
    title: "입실 알림",
    content: "[{학원명}] {학생명}님이 {시간}에 입실하셨습니다.",
    variables: ["학원명", "학생명", "시간"],
  },
  attendance_check_out: {
    id: "attendance_check_out",
    type: "attendance_check_out",
    title: "퇴실 알림",
    content: "[{학원명}] {학생명}님이 {시간}에 퇴실하셨습니다.",
    variables: ["학원명", "학생명", "시간"],
  },
  attendance_absent: {
    id: "attendance_absent",
    type: "attendance_absent",
    title: "결석 알림",
    content: "[{학원명}] {학생명}님이 {날짜}에 결석하셨습니다.",
    variables: ["학원명", "학생명", "날짜"],
  },
  attendance_late: {
    id: "attendance_late",
    type: "attendance_late",
    title: "지각 알림",
    content: "[{학원명}] {학생명}님이 {시간}에 지각하셨습니다.",
    variables: ["학원명", "학생명", "시간"],
  },
  payment_due: {
    id: "payment_due",
    type: "payment_due",
    title: "수강료 납부 안내",
    content:
      "[{학원명}] {학생명}님의 {월}월 수강료 {금액}원 납부 기한이 {날짜}까지입니다.",
    variables: ["학원명", "학생명", "월", "금액", "날짜"],
  },
  payment_overdue: {
    id: "payment_overdue",
    type: "payment_overdue",
    title: "수강료 연체 안내",
    content:
      "[{학원명}] {학생명}님의 {월}월 수강료 {금액}원이 연체되었습니다. 빠른 시일 내에 납부 부탁드립니다.",
    variables: ["학원명", "학생명", "월", "금액"],
  },
  consultation_scheduled: {
    id: "consultation_scheduled",
    type: "consultation_scheduled",
    title: "상담 일정 안내",
    content:
      "[{학원명}] {학생명}님의 상담 일정이 {날짜} {시간}로 예약되었습니다.",
    variables: ["학원명", "학생명", "날짜", "시간"],
  },
  notice: {
    id: "notice",
    type: "notice",
    title: "공지사항",
    content: "[{학원명}] {제목}\n{내용}",
    variables: ["학원명", "제목", "내용"],
  },
};

/**
 * SMS 템플릿 포맷팅
 * 변수를 실제 값으로 치환
 */
export function formatSMSTemplate(
  templateType: SMSTemplateType,
  variables: Record<string, string>
): string {
  const template = SMS_TEMPLATES[templateType];
  if (!template) {
    throw new Error(`템플릿을 찾을 수 없습니다: ${templateType}`);
  }

  let content = template.content;

  // 변수 치환
  for (const [key, value] of Object.entries(variables)) {
    content = content.replace(new RegExp(`\\{${key}\\}`, "g"), value);
  }

  // 치환되지 않은 변수가 있는지 확인 (선택사항)
  const remainingVariables = content.match(/\{([^}]+)\}/g);
  if (remainingVariables && remainingVariables.length > 0) {
    console.warn(
      `[SMS Template] 치환되지 않은 변수: ${remainingVariables.join(", ")}`
    );
  }

  return content;
}

/**
 * 템플릿 정보 조회
 */
export function getSMSTemplate(
  templateType: SMSTemplateType
): SMSTemplate | null {
  return SMS_TEMPLATES[templateType] || null;
}

/**
 * 모든 템플릿 목록 조회
 */
export function getAllSMSTemplates(): SMSTemplate[] {
  return Object.values(SMS_TEMPLATES);
}
</file>

<file path="index.ts">
/**
 * Supabase Realtime 훅 모음
 * P2 개선: 실시간 기능 확대
 */

// 플랜 관련 실시간 업데이트
export { usePlanRealtimeUpdates } from "./usePlanRealtimeUpdates";
export {
  usePlanGroupRealtime,
  usePlanProgressRealtime,
} from "./usePlanGroupRealtime";

// 출석 관련 실시간 업데이트
export {
  useAttendanceRealtime,
  useAdminAttendanceRealtime,
} from "./useAttendanceRealtime";

// 관리자 플랜 실시간 업데이트
export { useAdminPlanRealtime } from "./useAdminPlanRealtime";

// 알림 실시간 업데이트
export {
  useNotificationRealtime,
  useNotificationPermission,
  requestNotificationPermission,
  type NotificationPayload,
  type NotificationRealtimeEvent,
  type NotificationEventHandler,
  type UseNotificationRealtimeOptions,
} from "./useNotificationRealtime";

// 채팅 실시간 업데이트
export {
  useChatRealtime,
  useChatRoomListRealtime,
} from "./useChatRealtime";

// 채팅 Presence (타이핑/온라인 상태)
export { useChatPresence } from "./useChatPresence";
</file>

<file path="index.ts">
/**
 * Supabase Realtime 훅 모음
 * P2 개선: 실시간 기능 확대
 */

// 플랜 관련 실시간 업데이트
export { usePlanRealtimeUpdates } from "./usePlanRealtimeUpdates";
export {
  usePlanGroupRealtime,
  usePlanProgressRealtime,
} from "./usePlanGroupRealtime";

// 출석 관련 실시간 업데이트
export {
  useAttendanceRealtime,
  useAdminAttendanceRealtime,
} from "./useAttendanceRealtime";

// 관리자 플랜 실시간 업데이트
export { useAdminPlanRealtime } from "./useAdminPlanRealtime";

// 알림 실시간 업데이트
export {
  useNotificationRealtime,
  useNotificationPermission,
  requestNotificationPermission,
  type NotificationPayload,
  type NotificationRealtimeEvent,
  type NotificationEventHandler,
  type UseNotificationRealtimeOptions,
} from "./useNotificationRealtime";

// 채팅 실시간 업데이트
export {
  useChatRealtime,
  useChatRoomListRealtime,
} from "./useChatRealtime";

// 채팅 Presence (타이핑/온라인 상태)
export { useChatPresence } from "./useChatPresence";
</file>

<file path="useAdminPlanRealtime.ts">
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { createSupabaseBrowserClient } from '@/lib/supabase/client';

type UseAdminPlanRealtimeOptions = {
  studentId: string;
  enabled?: boolean;
  onRefresh: () => void;
  /** Debounce delay in ms (default: 500) */
  debounceMs?: number;
};

/**
 * 관리자용 플랜 실시간 업데이트 훅
 * 특정 학생의 플랜 변경을 실시간으로 감지하여 새로고침 트리거
 */
export function useAdminPlanRealtime({
  studentId,
  enabled = true,
  onRefresh,
  debounceMs = 500,
}: UseAdminPlanRealtimeOptions) {
  const debounceTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastRefreshTime = useRef<number>(0);

  // Debounced refresh to prevent too many refreshes
  const debouncedRefresh = useCallback(() => {
    const now = Date.now();

    // Skip if refreshed within last debounceMs
    if (now - lastRefreshTime.current < debounceMs) {
      return;
    }

    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }

    debounceTimer.current = setTimeout(() => {
      lastRefreshTime.current = Date.now();
      onRefresh();
    }, debounceMs);
  }, [onRefresh, debounceMs]);

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // student_plan 테이블 변경 구독
    const planChannel = supabase
      .channel(`admin-plan-${studentId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'student_plan',
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log('[Admin Realtime] Plan updated:', payload.eventType);
          debouncedRefresh();
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[Admin Realtime] Subscribed to plan updates for student:', studentId);
        }
      });

    // ad_hoc_plans 테이블 변경 구독
    const adHocChannel = supabase
      .channel(`admin-adhoc-${studentId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'ad_hoc_plans',
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log('[Admin Realtime] Ad-hoc plan updated:', payload.eventType);
          debouncedRefresh();
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          console.log('[Admin Realtime] Subscribed to ad-hoc updates for student:', studentId);
        }
      });

    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      supabase.removeChannel(planChannel);
      supabase.removeChannel(adHocChannel);
    };
  }, [studentId, enabled, debouncedRefresh]);
}
</file>

<file path="useAttendanceRealtime.ts">
"use client";

/**
 * P2 개선: 출석 기록 실시간 업데이트 구독
 */

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UseAttendanceRealtimeOptions = {
  studentId: string;
  tenantId?: string;
  enabled?: boolean;
};

/**
 * 출석 기록 실시간 업데이트 훅
 * - 학생의 출석 기록 변경 시 자동으로 쿼리 무효화
 */
export function useAttendanceRealtime({
  studentId,
  tenantId,
  enabled = true,
}: UseAttendanceRealtimeOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`attendance-${studentId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "attendance_records",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Attendance updated:", payload);
          // 출석 관련 쿼리 무효화
          queryClient.invalidateQueries({ queryKey: ["attendance", studentId] });
          queryClient.invalidateQueries({ queryKey: ["attendance", "stats"] });
          queryClient.invalidateQueries({ queryKey: ["dashboard", "attendance"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, tenantId, enabled, queryClient]);
}

/**
 * 관리자용 테넌트 전체 출석 실시간 업데이트 훅
 */
export function useAdminAttendanceRealtime({
  tenantId,
  enabled = true,
}: {
  tenantId: string;
  enabled?: boolean;
}) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !tenantId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`admin-attendance-${tenantId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "attendance_records",
          filter: `tenant_id=eq.${tenantId}`,
        },
        (payload) => {
          console.log("[Realtime] Admin attendance updated:", payload);
          queryClient.invalidateQueries({ queryKey: ["admin", "attendance"] });
          queryClient.invalidateQueries({ queryKey: ["admin", "dashboard"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [tenantId, enabled, queryClient]);
}
</file>

<file path="useChatPresence.ts">
"use client";

/**
 * useChatPresence - 채팅방 Presence 상태 관리
 *
 * Supabase Presence API를 사용하여:
 * - 타이핑 인디케이터 (누가 입력 중인지)
 * - 온라인 상태 (누가 접속 중인지)
 */

import { useEffect, useState, useCallback, useRef } from "react";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimeChannel } from "@supabase/supabase-js";
import type { PresenceUser } from "@/lib/domains/chat/types";

interface UseChatPresenceOptions {
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID */
  userId: string;
  /** 현재 사용자 이름 */
  userName: string;
  /** 활성화 여부 */
  enabled?: boolean;
}

interface UseChatPresenceReturn {
  /** 온라인 사용자 목록 (자신 제외) */
  onlineUsers: PresenceUser[];
  /** 타이핑 중인 사용자 목록 (자신 제외) */
  typingUsers: PresenceUser[];
  /** 타이핑 상태 설정 */
  setTyping: (isTyping: boolean) => void;
}

/** 타이핑 자동 해제 타임아웃 (ms) */
const TYPING_TIMEOUT = 2000;

export function useChatPresence({
  roomId,
  userId,
  userName,
  enabled = true,
}: UseChatPresenceOptions): UseChatPresenceReturn {
  const [onlineUsers, setOnlineUsers] = useState<PresenceUser[]>([]);
  const [typingUsers, setTypingUsers] = useState<PresenceUser[]>([]);
  const channelRef = useRef<RealtimeChannel | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Presence 채널 구독
  useEffect(() => {
    if (!enabled || !roomId || !userId || !userName) return;

    const supabase = createSupabaseBrowserClient();
    const channel = supabase.channel(`presence-${roomId}`, {
      config: {
        presence: {
          key: userId,
        },
      },
    });

    channel
      .on("presence", { event: "sync" }, () => {
        const state = channel.presenceState<PresenceUser>();

        // 모든 사용자 목록 (자신 제외)
        const allUsers = Object.values(state)
          .flat()
          .filter((u) => u.userId !== userId);

        setOnlineUsers(allUsers);
        setTypingUsers(allUsers.filter((u) => u.isTyping));
      })
      .on("presence", { event: "join" }, ({ newPresences }) => {
        // 새 사용자 입장 시 로그 (디버깅용)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User joined:", newPresences);
        }
      })
      .on("presence", { event: "leave" }, ({ leftPresences }) => {
        // 사용자 퇴장 시 로그 (디버깅용)
        if (process.env.NODE_ENV === "development") {
          console.log("[Presence] User left:", leftPresences);
        }
      })
      .subscribe(async (status) => {
        if (status === "SUBSCRIBED") {
          // 초기 상태 등록
          await channel.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }
      });

    channelRef.current = channel;

    return () => {
      // 타이핑 타임아웃 정리
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }

      // 채널 정리
      channel.untrack();
      supabase.removeChannel(channel);
      channelRef.current = null;
    };
  }, [roomId, userId, userName, enabled]);

  // 타이핑 상태 업데이트
  const setTyping = useCallback(
    (isTyping: boolean) => {
      if (!channelRef.current) return;

      // 기존 타임아웃 클리어
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }

      // 상태 업데이트
      channelRef.current.track({
        userId,
        name: userName,
        isTyping,
        lastSeen: new Date().toISOString(),
      });

      // 타이핑 중이면 자동 해제 타이머 설정
      if (isTyping) {
        typingTimeoutRef.current = setTimeout(() => {
          channelRef.current?.track({
            userId,
            name: userName,
            isTyping: false,
            lastSeen: new Date().toISOString(),
          });
        }, TYPING_TIMEOUT);
      }
    },
    [userId, userName]
  );

  return {
    onlineUsers,
    typingUsers,
    setTyping,
  };
}
</file>

<file path="useChatRealtime.ts">
"use client";

/**
 * 채팅 메시지 실시간 구독 훅
 *
 * 특정 채팅방의 새 메시지를 실시간으로 수신합니다.
 * Supabase Realtime postgres_changes 사용.
 */

import { useEffect, useRef, useCallback } from "react";
import { useQueryClient, type InfiniteData } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";
import type {
  ChatUserType,
  ChatMessageType,
  ChatMessageWithSender,
  ChatUser,
  MessagesWithReadStatusResult,
} from "@/lib/domains/chat/types";

// Supabase Realtime Payload 타입 (DB 컬럼과 1:1 매핑)
interface ChatMessagePayload {
  id: string;
  room_id: string;
  sender_id: string;
  sender_type: ChatUserType;
  message_type: ChatMessageType;
  content: string;
  is_deleted: boolean;
  reply_to_id: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

// 캐시 메시지 타입 (낙관적 업데이트 status 포함)
type CacheMessage = ChatMessageWithSender & {
  status?: "sending" | "sent" | "error";
};

// Infinite Query 캐시 구조 (MessagesWithReadStatusResult 기반)
type MessagesPage = Omit<MessagesWithReadStatusResult, "messages"> & {
  messages: CacheMessage[];
};

// InfiniteQuery 캐시 타입
type InfiniteMessagesCache = InfiniteData<MessagesPage, string | undefined>;

type UseChatRealtimeOptions = {
  /** 채팅방 ID */
  roomId: string;
  /** 현재 사용자 ID (본인 메시지 구분용) */
  userId: string;
  /** 구독 활성화 여부 */
  enabled?: boolean;
  /** 새 메시지 수신 콜백 */
  onNewMessage?: (message: ChatMessagePayload) => void;
  /** 메시지 삭제 콜백 */
  onMessageDeleted?: (messageId: string) => void;
};

/**
 * 채팅 메시지 실시간 구독 훅
 *
 * @example
 * ```tsx
 * useChatRealtime({
 *   roomId: "room-123",
 *   userId: "user-456",
 *   onNewMessage: (msg) => {
 *     // 스크롤 또는 알림 처리
 *   },
 * });
 * ```
 */
export function useChatRealtime({
  roomId,
  userId,
  enabled = true,
  onNewMessage,
  onMessageDeleted,
}: UseChatRealtimeOptions) {
  const queryClient = useQueryClient();

  // 콜백을 ref로 저장하여 의존성 변경 방지
  const callbacksRef = useRef({ onNewMessage, onMessageDeleted });
  useEffect(() => {
    callbacksRef.current = { onNewMessage, onMessageDeleted };
  }, [onNewMessage, onMessageDeleted]);

  // 쿼리 무효화 함수
  const invalidateMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-messages" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  const invalidatePinnedMessages = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-pinned" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  const invalidateAnnouncement = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        query.queryKey[0] === "chat-announcement" &&
        query.queryKey[1] === roomId,
    });
  }, [queryClient, roomId]);

  useEffect(() => {
    if (!enabled || !roomId || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-room-${roomId}`)
      // 새 메시지 INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] New message:", payload.new);
          const newMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryData로 캐시에 직접 추가 (서버 재요청 없음) - InfiniteQuery 구조
          queryClient.setQueryData<InfiniteMessagesCache>(
            ["chat-messages", roomId],
            (old) => {
              if (!old?.pages?.length || !newMessage) return old;

              // 첫 번째 페이지(최신 메시지들)에서 중복 체크 및 추가
              const firstPage = old.pages[0];
              const existingIndex = firstPage.messages.findIndex(
                (m) =>
                  m.id === newMessage.id ||
                  (m.id.startsWith("temp-") &&
                    m.content === newMessage.content &&
                    m.sender_id === newMessage.sender_id)
              );

              if (existingIndex !== -1) {
                // 낙관적 메시지 → 실제 메시지로 교체
                const updatedMessages = [...firstPage.messages];
                const existingMessage = updatedMessages[existingIndex];
                updatedMessages[existingIndex] = {
                  ...existingMessage,
                  ...newMessage,
                  sender: existingMessage.sender,
                  status: "sent" as const,
                };
                return {
                  ...old,
                  pages: [
                    { ...firstPage, messages: updatedMessages },
                    ...old.pages.slice(1),
                  ],
                };
              }

              // 타인의 새 메시지 추가
              const defaultSender: ChatUser = {
                id: newMessage.sender_id,
                type: newMessage.sender_type,
                name: "알 수 없음",
              };

              const newCacheMessage: CacheMessage = {
                ...newMessage,
                sender: defaultSender,
                reactions: [],
                replyTarget: null,
              };

              return {
                ...old,
                pages: [
                  {
                    ...firstPage,
                    messages: [...firstPage.messages, newCacheMessage],
                  },
                  ...old.pages.slice(1),
                ],
              };
            }
          );

          // 채팅방 목록도 무효화 (마지막 메시지 업데이트)
          invalidateRoomList();

          // 콜백 호출 (타인의 메시지만)
          if (newMessage?.sender_id && newMessage.sender_id !== userId) {
            callbacksRef.current.onNewMessage?.(newMessage);
          }
        }
      )
      // 메시지 UPDATE (삭제/수정 등)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_messages",
          filter: `room_id=eq.${roomId}`,
        },
        (payload: RealtimePostgresChangesPayload<ChatMessagePayload>) => {
          console.log("[ChatRealtime] Message updated:", payload.new);
          const updatedMessage = payload.new as ChatMessagePayload | undefined;

          // setQueryData로 해당 메시지만 업데이트 (서버 재요청 없음) - InfiniteQuery 구조
          queryClient.setQueryData<InfiniteMessagesCache>(
            ["chat-messages", roomId],
            (old) => {
              if (!old?.pages?.length || !updatedMessage) return old;

              // 모든 페이지에서 해당 메시지 찾아서 업데이트
              return {
                ...old,
                pages: old.pages.map((page) => ({
                  ...page,
                  messages: page.messages.map((m) =>
                    m.id === updatedMessage.id
                      ? {
                          ...m,
                          content: updatedMessage.content,
                          is_deleted: updatedMessage.is_deleted,
                          updated_at: updatedMessage.updated_at,
                          deleted_at: updatedMessage.deleted_at,
                        }
                      : m
                  ),
                })),
              };
            }
          );

          // 삭제된 경우 콜백 호출
          if (updatedMessage?.is_deleted && updatedMessage.id) {
            callbacksRef.current.onMessageDeleted?.(updatedMessage.id);
          }
        }
      )
      // 리액션 INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_message_reactions",
        },
        () => {
          console.log("[ChatRealtime] Reaction added");
          invalidateMessages();
        }
      )
      // 리액션 DELETE
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_message_reactions",
        },
        () => {
          console.log("[ChatRealtime] Reaction removed");
          invalidateMessages();
        }
      )
      // 고정 메시지 INSERT
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_pinned_messages",
          filter: `room_id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Message pinned");
          invalidatePinnedMessages();
        }
      )
      // 고정 메시지 DELETE
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "chat_pinned_messages",
        },
        () => {
          console.log("[ChatRealtime] Message unpinned");
          invalidatePinnedMessages();
        }
      )
      // 채팅방 UPDATE (공지 변경)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_rooms",
          filter: `id=eq.${roomId}`,
        },
        () => {
          console.log("[ChatRealtime] Room updated (announcement)");
          invalidateAnnouncement();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room ${roomId} subscription:`, status);

        if (status === "SUBSCRIBED") {
          // 연결 성공 또는 재연결(Recovery) 시 최신 데이터 동기화
          // 소켓 연결이 끊긴 동안 누락된 메시지나 변경사항을 불러옵니다.
          console.log("[ChatRealtime] Connected/Reconnected. Syncing data...");
          invalidateMessages();
          invalidateRoomList();
          invalidatePinnedMessages();
          invalidateAnnouncement();
        }

        if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
          console.error(`[ChatRealtime] Connection error: ${status}`);
        }
      });

    return () => {
      console.log(`[ChatRealtime] Unsubscribing from room ${roomId}`);
      supabase.removeChannel(channel);
    };
  }, [roomId, userId, enabled, invalidateMessages, invalidateRoomList, invalidatePinnedMessages, invalidateAnnouncement]);
}

// ============================================
// 채팅방 목록 실시간 구독
// ============================================

type UseChatRoomListRealtimeOptions = {
  /** 현재 사용자 ID */
  userId: string;
  /** 사용자 유형 */
  userType: "student" | "admin";
  /** 구독 활성화 여부 */
  enabled?: boolean;
};

/**
 * 채팅방 목록 실시간 구독 훅
 *
 * 새 채팅방 생성, 멤버 변경 등을 실시간으로 반영합니다.
 */
export function useChatRoomListRealtime({
  userId,
  userType,
  enabled = true,
}: UseChatRoomListRealtimeOptions) {
  const queryClient = useQueryClient();

  const invalidateRoomList = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) && query.queryKey[0] === "chat-rooms",
    });
  }, [queryClient]);

  useEffect(() => {
    if (!enabled || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`chat-rooms-${userId}`)
      // 내가 멤버로 추가된 경우
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Added to room:", payload);
          invalidateRoomList();
        }
      )
      // 멤버십 변경 (나가기 등)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chat_room_members",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[ChatRealtime] Membership updated:", payload);
          invalidateRoomList();
        }
      )
      .subscribe((status) => {
        console.log(`[ChatRealtime] Room list subscription:`, status);

        if (status === "SUBSCRIBED") {
          console.log("[ChatRealtime] Room list connected/reconnected. Syncing...");
          invalidateRoomList();
        }

        if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
          console.error(`[ChatRealtime] Room list connection error: ${status}`);
        }
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, userType, enabled, invalidateRoomList]);
}
</file>

<file path="useNotificationRealtime.ts">
"use client";

/**
 * 실시간 알림 구독 훅
 *
 * Supabase Realtime을 사용하여 알림 테이블의 변경사항을 구독합니다.
 * 새 알림이 생성되면 콜백을 호출하고 React Query 캐시를 무효화합니다.
 *
 * @module lib/realtime/useNotificationRealtime
 */

import { useEffect, useCallback, useRef } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";

// ============================================
// 타입 정의
// ============================================

export type NotificationPayload = {
  id: string;
  user_id: string;
  type: string;
  title: string;
  message: string;
  metadata: Record<string, unknown> | null;
  is_read: boolean;
  created_at: string;
  read_at: string | null;
  tenant_id: string | null;
};

export type NotificationRealtimeEvent = "INSERT" | "UPDATE" | "DELETE";

export type NotificationEventHandler = (
  event: NotificationRealtimeEvent,
  notification: NotificationPayload
) => void;

export type UseNotificationRealtimeOptions = {
  /** 사용자 ID */
  userId: string;
  /** 활성화 여부 (기본값: true) */
  enabled?: boolean;
  /** 새 알림 생성 시 콜백 */
  onNewNotification?: (notification: NotificationPayload) => void;
  /** 알림 업데이트 시 콜백 (읽음 처리 등) */
  onNotificationUpdate?: (notification: NotificationPayload) => void;
  /** 알림 삭제 시 콜백 */
  onNotificationDelete?: (notification: NotificationPayload) => void;
  /** 브라우저 알림 표시 여부 (기본값: true) */
  showBrowserNotification?: boolean;
};

// ============================================
// 브라우저 알림 유틸리티
// ============================================

/**
 * 브라우저 알림 권한 요청
 */
export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!("Notification" in window)) {
    console.warn("[Notification] 이 브라우저는 알림을 지원하지 않습니다.");
    return "denied";
  }

  if (Notification.permission === "granted") {
    return "granted";
  }

  if (Notification.permission !== "denied") {
    const permission = await Notification.requestPermission();
    return permission;
  }

  return Notification.permission;
}

/**
 * 브라우저 알림 표시
 */
function showBrowserNotification(
  title: string,
  body: string,
  options?: NotificationOptions
): void {
  if (!("Notification" in window)) {
    return;
  }

  if (Notification.permission !== "granted") {
    return;
  }

  try {
    // renotify는 일부 브라우저에서 지원하지 않을 수 있음
    const notificationOptions: NotificationOptions = {
      body,
      icon: "/icons/icon-192x192.png",
      badge: "/icons/icon-192x192.png",
      tag: "notification",
      ...options,
    };

    const notification = new Notification(title, notificationOptions);

    // 클릭 시 앱으로 포커스
    notification.onclick = () => {
      window.focus();
      notification.close();
    };

    // 5초 후 자동 닫기
    setTimeout(() => {
      notification.close();
    }, 5000);
  } catch (error) {
    console.error("[Notification] 브라우저 알림 표시 실패:", error);
  }
}

// ============================================
// 메인 훅
// ============================================

/**
 * 실시간 알림 구독 훅
 *
 * @example
 * ```tsx
 * function NotificationBell() {
 *   const { unreadCount, setUnreadCount } = useNotificationState();
 *
 *   useNotificationRealtime({
 *     userId: currentUser.id,
 *     onNewNotification: (notification) => {
 *       setUnreadCount((prev) => prev + 1);
 *       toast.info(notification.title);
 *     },
 *     onNotificationUpdate: (notification) => {
 *       if (notification.is_read) {
 *         setUnreadCount((prev) => Math.max(0, prev - 1));
 *       }
 *     },
 *   });
 *
 *   return <Badge count={unreadCount}>알림</Badge>;
 * }
 * ```
 */
export function useNotificationRealtime({
  userId,
  enabled = true,
  onNewNotification,
  onNotificationUpdate,
  onNotificationDelete,
  showBrowserNotification: showBrowserNotif = true,
}: UseNotificationRealtimeOptions) {
  const queryClient = useQueryClient();
  const callbacksRef = useRef({
    onNewNotification,
    onNotificationUpdate,
    onNotificationDelete,
  });

  // 콜백 레퍼런스 업데이트 (리렌더링 시에도 최신 콜백 사용)
  useEffect(() => {
    callbacksRef.current = {
      onNewNotification,
      onNotificationUpdate,
      onNotificationDelete,
    };
  }, [onNewNotification, onNotificationUpdate, onNotificationDelete]);

  // React Query 캐시 무효화
  const invalidateNotificationQueries = useCallback(() => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        Array.isArray(query.queryKey) &&
        (query.queryKey[0] === "notifications" ||
          query.queryKey[0] === "unreadNotifications" ||
          query.queryKey[0] === "notificationCount"),
    });
  }, [queryClient]);

  // 이벤트 핸들러
  const handleRealtimeEvent = useCallback(
    (payload: RealtimePostgresChangesPayload<NotificationPayload>) => {
      const event = payload.eventType as NotificationRealtimeEvent;
      const newRecord = payload.new as NotificationPayload | undefined;
      const oldRecord = payload.old as NotificationPayload | undefined;

      console.log("[Notification Realtime] Event:", event, payload);

      // React Query 캐시 무효화
      invalidateNotificationQueries();

      switch (event) {
        case "INSERT":
          if (newRecord) {
            // 새 알림 콜백 호출
            callbacksRef.current.onNewNotification?.(newRecord);

            // 브라우저 알림 표시
            if (showBrowserNotif && !newRecord.is_read) {
              showBrowserNotification(newRecord.title, newRecord.message, {
                data: { notificationId: newRecord.id, type: newRecord.type },
              });
            }
          }
          break;

        case "UPDATE":
          if (newRecord) {
            callbacksRef.current.onNotificationUpdate?.(newRecord);
          }
          break;

        case "DELETE":
          if (oldRecord) {
            callbacksRef.current.onNotificationDelete?.(oldRecord);
          }
          break;
      }
    },
    [invalidateNotificationQueries, showBrowserNotif]
  );

  // 브로드캐스트 이벤트 핸들러 (일시적 알림용)
  const handleBroadcastEvent = useCallback(
    (payload: { payload: NotificationPayload }) => {
      const notification = payload.payload;
      console.log("[Notification Realtime] Broadcast received:", notification);

      // 새 알림 콜백 호출
      callbacksRef.current.onNewNotification?.(notification);

      // 브라우저 알림 표시
      if (showBrowserNotif && !notification.is_read) {
        showBrowserNotification(notification.title, notification.message, {
          data: { notificationId: notification.id, type: notification.type },
        });
      }
    },
    [showBrowserNotif]
  );

  // Supabase Realtime 구독
  useEffect(() => {
    if (!enabled || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // 알림 테이블 변경 및 브로드캐스트 구독
    const channel = supabase
      .channel(`notifications-${userId}`)
      // DB 변경 구독 (영구 알림)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "notifications",
          filter: `user_id=eq.${userId}`,
        },
        handleRealtimeEvent
      )
      // 브로드캐스트 구독 (일시적 알림)
      .on("broadcast", { event: "notification" }, handleBroadcastEvent)
      .subscribe((status) => {
        console.log("[Notification Realtime] Subscription status:", status);
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, enabled, handleRealtimeEvent, handleBroadcastEvent]);
}

// ============================================
// 유틸리티 훅
// ============================================

/**
 * 브라우저 알림 권한 상태 훅
 */
export function useNotificationPermission() {
  const getPermission = useCallback((): NotificationPermission => {
    if (!("Notification" in window)) {
      return "denied";
    }
    return Notification.permission;
  }, []);

  const requestPermission = useCallback(async () => {
    return requestNotificationPermission();
  }, []);

  return {
    permission: typeof window !== "undefined" ? getPermission() : "default",
    requestPermission,
    isSupported: typeof window !== "undefined" && "Notification" in window,
  };
}
</file>

<file path="usePlanGroupRealtime.ts">
"use client";

/**
 * P2 개선: 플랜 그룹 상태 변경 실시간 구독
 */

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UsePlanGroupRealtimeOptions = {
  studentId: string;
  enabled?: boolean;
};

/**
 * 플랜 그룹 상태 변경 실시간 업데이트 훅
 * - 플랜 그룹 상태 변경(active, paused, completed 등) 시 자동 반영
 */
export function usePlanGroupRealtime({
  studentId,
  enabled = true,
}: UsePlanGroupRealtimeOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channel = supabase
      .channel(`plan-groups-${studentId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group updated:", payload);
          // 플랜 그룹 관련 쿼리 무효화
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
          queryClient.invalidateQueries({ queryKey: ["dashboard", "planGroups"] });
        }
      )
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group created:", payload);
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
        }
      )
      .on(
        "postgres_changes",
        {
          event: "DELETE",
          schema: "public",
          table: "plan_groups",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan group deleted:", payload);
          queryClient.invalidateQueries({ queryKey: ["planGroups", studentId] });
          queryClient.invalidateQueries({ queryKey: ["plan-groups"] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, enabled, queryClient]);
}

/**
 * 플랜 진행률 실시간 업데이트 훅
 * - student_plan 테이블의 completed_amount, progress 변경 시 자동 반영
 */
export function usePlanProgressRealtime({
  studentId,
  planGroupId,
  enabled = true,
}: {
  studentId: string;
  planGroupId?: string;
  enabled?: boolean;
}) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !studentId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    const channelName = planGroupId
      ? `plan-progress-${studentId}-${planGroupId}`
      : `plan-progress-${studentId}`;

    const channel = supabase
      .channel(channelName)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "student_plan",
          filter: `student_id=eq.${studentId}`,
        },
        (payload) => {
          const newRecord = payload.new as {
            completed_amount?: number;
            progress?: number;
            plan_group_id?: string;
          };

          // completed_amount 또는 progress가 변경된 경우에만 처리
          if (
            newRecord.completed_amount !== undefined ||
            newRecord.progress !== undefined
          ) {
            console.log("[Realtime] Plan progress updated:", payload);

            // 진행률 관련 쿼리 무효화
            queryClient.invalidateQueries({ queryKey: ["plans", studentId] });
            queryClient.invalidateQueries({ queryKey: ["today", "progress"] });
            queryClient.invalidateQueries({ queryKey: ["dashboard", "progress"] });

            if (planGroupId) {
              queryClient.invalidateQueries({
                queryKey: ["planGroup", planGroupId, "progress"],
              });
            }
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [studentId, planGroupId, enabled, queryClient]);
}
</file>

<file path="usePlanRealtimeUpdates.ts">
"use client";

import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";

type UsePlanRealtimeUpdatesOptions = {
  planDate: string;
  userId: string;
  enabled?: boolean;
};

export function usePlanRealtimeUpdates({
  planDate,
  userId,
  enabled = true,
}: UsePlanRealtimeUpdatesOptions) {
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled || !planDate || !userId) {
      return;
    }

    const supabase = createSupabaseBrowserClient();

    // 플랜 변경 구독
    const planChannel = supabase
      .channel(`plan-updates-${userId}-${planDate}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "student_plan",
          filter: `student_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[Realtime] Plan updated:", payload);
          // predicate 기반 무효화로 모든 관련 쿼리 처리
          queryClient.invalidateQueries({
            predicate: (query) =>
              Array.isArray(query.queryKey) &&
              (query.queryKey[0] === "todayPlans" ||
                query.queryKey[0] === "todayContainerPlans" ||
                query.queryKey[0] === "today" ||
                query.queryKey[0] === "plans"),
          });
        }
      )
      .subscribe();

    // 학습 세션 변경 구독
    const sessionChannel = supabase
      .channel(`session-updates-${userId}-${planDate}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "student_study_sessions",
          filter: `student_id=eq.${userId}`,
        },
        (payload) => {
          console.log("[Realtime] Session updated:", payload);
          // predicate 기반 무효화로 모든 관련 쿼리 처리
          queryClient.invalidateQueries({
            predicate: (query) =>
              Array.isArray(query.queryKey) &&
              (query.queryKey[0] === "todayPlans" ||
                query.queryKey[0] === "today" ||
                query.queryKey[0] === "sessions"),
          });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(planChannel);
      supabase.removeChannel(sessionChannel);
    };
  }, [planDate, userId, enabled, queryClient]);
}
</file>

<file path="consulting.ts">
"use server";

import { revalidatePath } from "next/cache";
import { requireAdminOrConsultant } from "@/lib/auth/guards";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { logActionError } from "@/lib/logging/actionLogger";

export async function addConsultingNote(
  studentId: string,
  consultantId: string,
  formData: FormData
): Promise<{ success: boolean; error?: string } | null> {
  try {
    // 권한 확인
    const { userId, role, tenantId } = await requireAdminOrConsultant();

    if (userId !== consultantId) {
      return { success: false, error: "잘못된 요청입니다." };
    }

    // 테넌트 컨텍스트 확인
    const tenantContext = await getTenantContext();
    if (!tenantContext?.tenantId) {
      return { success: false, error: "기관 정보를 찾을 수 없습니다." };
    }

    const note = String(formData.get("note") ?? "").trim();

    if (!note) {
      return { success: false, error: "상담 내용을 입력해주세요." };
    }

    const supabase = await createSupabaseServerClient();

    // 테넌트 격리: 학생이 해당 테넌트에 속하는지 확인
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", studentId)
      .maybeSingle();

    if (studentError || !student) {
      return { success: false, error: "학생을 찾을 수 없습니다." };
    }

    // 테넌트 격리 검증 (superadmin 제외)
    if (role !== "superadmin" && student.tenant_id !== tenantContext.tenantId) {
      return { success: false, error: "권한이 없습니다." };
    }

    const { error } = await supabase.from("student_consulting_notes").insert({
      student_id: studentId,
      consultant_id: consultantId,
      note,
    });

    if (error) {
      logActionError({ domain: "student", action: "addConsultingNote" }, error, { studentId, consultantId });
      return { success: false, error: error.message };
    }

    revalidatePath(`/admin/students/${studentId}`);
    return { success: true };
  } catch (error) {
    logActionError({ domain: "student", action: "addConsultingNote" }, error, { studentId, consultantId });
    return { success: false, error: "상담노트 저장에 실패했습니다." };
  }
}

export async function deleteConsultingNote(
  noteId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // 권한 확인
    const { role } = await requireAdminOrConsultant();
    const user = await getCurrentUser();
    
    if (!user) {
      return { success: false, error: "사용자 정보를 찾을 수 없습니다." };
    }

    // 테넌트 컨텍스트 확인
    const tenantContext = await getTenantContext();
    if (!tenantContext?.tenantId) {
      return { success: false, error: "기관 정보를 찾을 수 없습니다." };
    }

    // Admin Client 사용 (RLS 우회)
    const supabase = createSupabaseAdminClient();
    if (!supabase) {
      return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
    }

    // 상담노트 조회 및 권한 확인
    // 테넌트 격리: 학생이 해당 테넌트에 속하는지 먼저 확인
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", studentId)
      .maybeSingle();

    if (studentError || !student) {
      return { success: false, error: "학생을 찾을 수 없습니다." };
    }

    // 테넌트 격리 검증 (superadmin 제외)
    if (role !== "superadmin" && student.tenant_id !== tenantContext.tenantId) {
      return { success: false, error: "권한이 없습니다." };
    }

    const { data: note, error: fetchError } = await supabase
      .from("student_consulting_notes")
      .select("consultant_id")
      .eq("id", noteId)
      .eq("student_id", studentId)
      .maybeSingle();

    if (fetchError || !note) {
      return { success: false, error: "상담노트를 찾을 수 없습니다." };
    }

    // 본인이 작성한 노트만 삭제 가능 (또는 admin은 모든 노트 삭제 가능)
    if (role !== "admin" && role !== "superadmin" && note.consultant_id !== user.userId) {
      return { success: false, error: "권한이 없습니다." };
    }

    const { data: deletedRows, error } = await supabase
      .from("student_consulting_notes")
      .delete()
      .eq("id", noteId)
      .select();

    if (error) {
      logActionError({ domain: "student", action: "deleteConsultingNote" }, error, { noteId, studentId });
      return { success: false, error: error.message };
    }

    if (!deletedRows || deletedRows.length === 0) {
      return { success: false, error: "상담노트를 찾을 수 없습니다." };
    }

    revalidatePath(`/admin/students/${studentId}`);
    return { success: true };
  } catch (error) {
    logActionError({ domain: "student", action: "deleteConsultingNote" }, error, { noteId, studentId });
    return { success: false, error: "상담노트 삭제에 실패했습니다." };
  }
}
</file>

<file path="divisions.ts">
"use server";

/**
 * Student 도메인 Server Actions
 *
 * 권한 검증 + Repository 호출 + 캐시 재검증을 담당합니다.
 */

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { isAdminRole } from "@/lib/auth/isAdminRole";
import { AppError, ErrorCode } from "@/lib/errors";
import { logActionError } from "@/lib/logging/actionLogger";
import { withActionResponse } from "@/lib/utils/serverActionHandler";
import type { StudentDivision } from "@/lib/constants/students";
import * as repository from "../repository";

// ============================================
// 학생 구분 할당 Actions (학생에게 구분 할당)
// from: app/actions/students.ts
// ============================================

/**
 * 구분 값 검증 헬퍼 함수
 */
function validateDivision(
  division: StudentDivision | null
): { valid: boolean; error?: string } {
  if (
    division !== null &&
    division !== "고등부" &&
    division !== "중등부" &&
    division !== "기타"
  ) {
    return {
      valid: false,
      error: "유효하지 않은 구분입니다. 고등부, 중등부, 기타 중 하나를 선택해주세요.",
    };
  }
  return { valid: true };
}

/**
 * 학생 구분 업데이트 (관리자만)
 */
export async function updateStudentDivisionAction(
  studentId: string,
  division: StudentDivision | null
): Promise<{ success: boolean; error?: string }> {
  const { role } = await getCurrentUserRole();

  if (!isAdminRole(role)) {
    return {
      success: false,
      error: "권한이 없습니다. 관리자만 학생 구분을 수정할 수 있습니다.",
    };
  }

  const validation = validateDivision(division);
  if (!validation.valid) {
    return {
      success: false,
      error: validation.error,
    };
  }

  const result = await repository.updateStudentDivision(studentId, division);

  if (result.success) {
    revalidatePath("/admin/students");
  }

  return result;
}

/**
 * 구분별 학생 목록 조회 (관리자만)
 */
export async function getStudentsByDivisionAction(
  division: StudentDivision | null
): Promise<{ success: boolean; data?: unknown[]; error?: string }> {
  const { role } = await getCurrentUserRole();

  if (!isAdminRole(role)) {
    return {
      success: false,
      error: "권한이 없습니다. 관리자만 학생 목록을 조회할 수 있습니다.",
    };
  }

  try {
    const students = await repository.getStudentsByDivision(division);
    return {
      success: true,
      data: students,
    };
  } catch (error) {
    logActionError(
      { domain: "student", action: "getStudentsByDivision" },
      error,
      { division }
    );
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "학생 목록 조회에 실패했습니다.",
    };
  }
}

/**
 * 구분별 학생 통계 조회 (관리자만)
 */
export async function getStudentDivisionStatsAction(): Promise<{
  success: boolean;
  data?: Array<{ division: StudentDivision | null; count: number }>;
  error?: string;
}> {
  const { role } = await getCurrentUserRole();

  if (!isAdminRole(role)) {
    return {
      success: false,
      error: "권한이 없습니다. 관리자만 통계를 조회할 수 있습니다.",
    };
  }

  try {
    const stats = await repository.getStudentDivisionStats();
    return {
      success: true,
      data: stats,
    };
  } catch (error) {
    logActionError(
      { domain: "student", action: "getStudentDivisionStats" },
      error
    );
    return {
      success: false,
      error: error instanceof Error ? error.message : "통계 조회에 실패했습니다.",
    };
  }
}

/**
 * 학생 구분 일괄 업데이트 (관리자만)
 */
export async function batchUpdateStudentDivisionAction(
  studentIds: string[],
  division: StudentDivision | null
): Promise<{
  success: boolean;
  successCount: number;
  failureCount: number;
  errors?: Array<{ studentId: string; error: string }>;
}> {
  const { role } = await getCurrentUserRole();

  if (!isAdminRole(role)) {
    return {
      success: false,
      successCount: 0,
      failureCount: studentIds.length,
      errors: studentIds.map((id) => ({
        studentId: id,
        error: "권한이 없습니다. 관리자만 학생 구분을 수정할 수 있습니다.",
      })),
    };
  }

  if (!Array.isArray(studentIds) || studentIds.length === 0) {
    return {
      success: false,
      successCount: 0,
      failureCount: 0,
      errors: [{ studentId: "", error: "학생을 선택해주세요." }],
    };
  }

  const validation = validateDivision(division);
  if (!validation.valid) {
    return {
      success: false,
      successCount: 0,
      failureCount: studentIds.length,
      errors: studentIds.map((id) => ({
        studentId: id,
        error: validation.error || "유효하지 않은 구분입니다.",
      })),
    };
  }

  const result = await repository.batchUpdateStudentDivision(studentIds, division);

  if (result.success) {
    revalidatePath("/admin/students");
  }

  return result;
}

// ============================================
// 학생 구분 항목 관리 Actions (구분 목록 CRUD)
// from: app/actions/studentDivisionsActions.ts
// ============================================

/**
 * 학생 구분 항목 목록 조회
 */
export const getStudentDivisionsAction = withActionResponse(async () => {
  const user = await getCurrentUser();
  if (!user || user.role !== "admin") {
    throw new AppError("권한이 없습니다.", ErrorCode.UNAUTHORIZED, 401, true);
  }
  return await repository.getStudentDivisions();
});

/**
 * 활성 학생 구분 항목만 조회
 */
export const getActiveStudentDivisionsAction = withActionResponse(async () => {
  const user = await getCurrentUser();
  if (!user || user.role !== "admin") {
    throw new AppError("권한이 없습니다.", ErrorCode.UNAUTHORIZED, 401, true);
  }
  return await repository.getActiveStudentDivisions();
});

/**
 * 학생 구분 항목 생성
 */
export const createStudentDivisionItemAction = withActionResponse(
  async (name: string, displayOrder?: number) => {
    const user = await getCurrentUser();
    if (!user || user.role !== "admin") {
      throw new AppError("권한이 없습니다.", ErrorCode.UNAUTHORIZED, 401, true);
    }

    let finalDisplayOrder = displayOrder;
    if (finalDisplayOrder === undefined) {
      const existingDivisions = await repository.getStudentDivisions();
      finalDisplayOrder =
        existingDivisions.length > 0
          ? Math.max(...existingDivisions.map((d) => d.display_order ?? 0)) + 1
          : 0;
    }

    const result = await repository.createStudentDivision(name, finalDisplayOrder);
    revalidatePath("/admin/settings");
    return result;
  }
);

/**
 * 학생 구분 항목 수정
 */
export const updateStudentDivisionItemAction = withActionResponse(
  async (
    id: string,
    updates: Partial<{
      name: string;
      display_order: number;
      is_active: boolean;
    }>
  ) => {
    const user = await getCurrentUser();
    if (!user || user.role !== "admin") {
      throw new AppError("권한이 없습니다.", ErrorCode.UNAUTHORIZED, 401, true);
    }

    const result = await repository.updateStudentDivisionItem(id, updates);
    revalidatePath("/admin/settings");
    return result;
  }
);

/**
 * 학생 구분 항목 삭제
 */
export const deleteStudentDivisionItemAction = withActionResponse(
  async (id: string) => {
    const user = await getCurrentUser();
    if (!user || user.role !== "admin") {
      throw new AppError("권한이 없습니다.", ErrorCode.UNAUTHORIZED, 401, true);
    }

    const result = await repository.deleteStudentDivision(id);
    revalidatePath("/admin/settings");
    return result;
  }
);

// ============================================
// Legacy 호환성 (deprecated)
// ============================================

/**
 * @deprecated createStudentDivisionItemAction 사용
 */
export const createStudentDivisionAction = createStudentDivisionItemAction;

/**
 * @deprecated updateStudentDivisionItemAction 사용
 */
export const updateStudentDivisionItemActionLegacy = updateStudentDivisionItemAction;

/**
 * @deprecated deleteStudentDivisionItemAction 사용
 */
export const deleteStudentDivisionAction = deleteStudentDivisionItemAction;
</file>

<file path="index.ts">
/**
 * Student Domain Actions
 *
 * Admin-facing and Student-facing Server Actions for student management.
 */

// ============================================
// Division Management (학생 구분)
// ============================================

export {
  // 학생 구분 할당 Actions
  updateStudentDivisionAction,
  getStudentsByDivisionAction,
  getStudentDivisionStatsAction,
  batchUpdateStudentDivisionAction,
  // 학생 구분 항목 관리 Actions
  getStudentDivisionsAction,
  getActiveStudentDivisionsAction,
  createStudentDivisionItemAction,
  updateStudentDivisionItemAction,
  deleteStudentDivisionItemAction,
  // Legacy 호환성
  createStudentDivisionAction,
  deleteStudentDivisionAction,
} from "./divisions";

// ============================================
// Student Management (학생 관리 - Admin)
// ============================================

export {
  toggleStudentStatus,
  deleteStudent,
  bulkToggleStudentStatus,
  bulkDeleteStudents,
  updateStudentClass,
  updateStudentInfo,
  createStudent,
  regenerateConnectionCode,
  getStudentConnectionCode,
} from "./management";

// ============================================
// Parent Links (학부모 연결)
// ============================================

export {
  type StudentParent,
  type SearchableParent,
  type ParentRelation,
  type PendingLinkRequest,
  getStudentParents,
  searchParents,
  createParentStudentLink,
  deleteParentStudentLink,
  updateLinkRelation,
  getPendingLinkRequests,
  approveLinkRequest,
  rejectLinkRequest,
  approveLinkRequests,
  rejectLinkRequests,
} from "./parentLinks";

// ============================================
// Consulting Notes (상담 노트)
// ============================================

export {
  addConsultingNote,
  deleteConsultingNote,
} from "./consulting";

// ============================================
// Student Profile (학생 프로필 - Student)
// ============================================

export {
  saveStudentInfo,
  updateStudentProfile,
  getCurrentStudent,
} from "./profile";

// ============================================
// Study Sessions (학습 세션 - Student)
// ============================================

export {
  startStudySession,
  endStudySession,
  cancelStudySession,
  pauseStudySession,
  resumeStudySession,
} from "./sessions";

// ============================================
// Notification Settings (알림 설정 - Student)
// ============================================

export {
  type NotificationSettings,
  updateNotificationSettings,
} from "./notifications";
</file>

<file path="index.ts">
/**
 * Student Domain Actions
 *
 * Admin-facing and Student-facing Server Actions for student management.
 */

// ============================================
// Division Management (학생 구분)
// ============================================

export {
  // 학생 구분 할당 Actions
  updateStudentDivisionAction,
  getStudentsByDivisionAction,
  getStudentDivisionStatsAction,
  batchUpdateStudentDivisionAction,
  // 학생 구분 항목 관리 Actions
  getStudentDivisionsAction,
  getActiveStudentDivisionsAction,
  createStudentDivisionItemAction,
  updateStudentDivisionItemAction,
  deleteStudentDivisionItemAction,
  // Legacy 호환성
  createStudentDivisionAction,
  deleteStudentDivisionAction,
} from "./divisions";

// ============================================
// Student Management (학생 관리 - Admin)
// ============================================

export {
  toggleStudentStatus,
  deleteStudent,
  bulkToggleStudentStatus,
  bulkDeleteStudents,
  updateStudentClass,
  updateStudentInfo,
  createStudent,
  regenerateConnectionCode,
  getStudentConnectionCode,
} from "./management";

// ============================================
// Parent Links (학부모 연결)
// ============================================

export {
  type StudentParent,
  type SearchableParent,
  type ParentRelation,
  type PendingLinkRequest,
  getStudentParents,
  searchParents,
  createParentStudentLink,
  deleteParentStudentLink,
  updateLinkRelation,
  getPendingLinkRequests,
  approveLinkRequest,
  rejectLinkRequest,
  approveLinkRequests,
  rejectLinkRequests,
} from "./parentLinks";

// ============================================
// Consulting Notes (상담 노트)
// ============================================

export {
  addConsultingNote,
  deleteConsultingNote,
} from "./consulting";

// ============================================
// Student Profile (학생 프로필 - Student)
// ============================================

export {
  saveStudentInfo,
  updateStudentProfile,
  getCurrentStudent,
} from "./profile";

// ============================================
// Study Sessions (학습 세션 - Student)
// ============================================

export {
  startStudySession,
  endStudySession,
  cancelStudySession,
  pauseStudySession,
  resumeStudySession,
} from "./sessions";

// ============================================
// Notification Settings (알림 설정 - Student)
// ============================================

export {
  type NotificationSettings,
  updateNotificationSettings,
} from "./notifications";
</file>

<file path="management.ts">
"use server";

import { redirect } from "next/navigation";
import { requireAdminOrConsultant } from "@/lib/auth/guards";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { AppError, ErrorCode } from "@/lib/errors";
import { logActionError, logActionWarn } from "@/lib/logging/actionLogger";

/**
 * 학생 계정 비활성화/활성화
 */
export async function toggleStudentStatus(
  studentId: string,
  isActive: boolean
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }

  const { data: updatedRows, error } = await supabase
    .from("students")
    .update({ is_active: isActive })
    .eq("id", studentId)
    .eq("tenant_id", tenantContext.tenantId)
    .select();

  if (error) {
    logActionError(
      { domain: "student", action: "toggleStudentStatus" },
      error,
      { studentId, isActive }
    );
    return {
      success: false,
      error: error.message || "상태 변경에 실패했습니다.",
    };
  }

  if (!updatedRows || updatedRows.length === 0) {
    return { success: false, error: "학생을 찾을 수 없습니다." };
  }

  revalidatePath("/admin/students");
  revalidatePath(`/admin/students/${studentId}`);

  return { success: true };
}

/**
 * 학생 계정 삭제 (하드 삭제: 실제 DB에서 삭제)
 * NO ACTION 제약조건이 있는 테이블들을 먼저 삭제한 후 students 테이블 삭제
 */
export async function deleteStudent(
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인 (관리자만)
  const { role } = await requireAdminOrConsultant();
  if (role !== "admin") {
    return { success: false, error: "관리자만 학생을 삭제할 수 있습니다." };
  }
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }

  try {
    // NO ACTION 제약조건이 있는 테이블들을 먼저 삭제 (순서 중요)
    // 1. student_score_analysis_cache
    const { error: cacheError } = await supabase
      .from("student_score_analysis_cache")
      .delete()
      .eq("student_id", studentId);

    if (cacheError) {
      logActionWarn(
        { domain: "student", action: "deleteStudent" },
        "성적 분석 캐시 삭제 실패",
        { studentId, error: cacheError.message }
      );
      // 경고만 하고 계속 진행
    }

    // 2. student_score_events
    const { error: eventsError } = await supabase
      .from("student_score_events")
      .delete()
      .eq("student_id", studentId);

    if (eventsError) {
      logActionWarn(
        { domain: "student", action: "deleteStudent" },
        "성적 이벤트 삭제 실패",
        { studentId, error: eventsError.message }
      );
      // 경고만 하고 계속 진행
    }

    // 3. student_internal_scores
    const { error: internalScoresError } = await supabase
      .from("student_internal_scores")
      .delete()
      .eq("student_id", studentId);

    if (internalScoresError) {
      logActionError(
        { domain: "student", action: "deleteStudent" },
        internalScoresError,
        { studentId, step: "student_internal_scores" }
      );
      return {
        success: false,
        error: `내신 성적 삭제 실패: ${internalScoresError.message}`,
      };
    }

    // 4. student_mock_scores
    const { error: mockScoresError } = await supabase
      .from("student_mock_scores")
      .delete()
      .eq("student_id", studentId);

    if (mockScoresError) {
      logActionError(
        { domain: "student", action: "deleteStudent" },
        mockScoresError,
        { studentId, step: "student_mock_scores" }
      );
      return {
        success: false,
        error: `모의고사 성적 삭제 실패: ${mockScoresError.message}`,
      };
    }

    // 5. student_terms
    const { error: termsError } = await supabase
      .from("student_terms")
      .delete()
      .eq("student_id", studentId);

    if (termsError) {
      logActionError(
        { domain: "student", action: "deleteStudent" },
        termsError,
        { studentId, step: "student_terms" }
      );
      return {
        success: false,
        error: `학기 정보 삭제 실패: ${termsError.message}`,
      };
    }

    // 6. auth.users에서 사용자 삭제 (관리자 권한 필요)
    const { error: authDeleteError } = await supabase.auth.admin.deleteUser(
      studentId
    );

    if (authDeleteError) {
      logActionError(
        { domain: "student", action: "deleteStudent" },
        authDeleteError,
        { studentId, step: "auth.admin.deleteUser" }
      );
      return {
        success: false,
        error: `인증 사용자 삭제 실패: ${authDeleteError.message}`,
      };
    }

    // 7. students 테이블에서 삭제 (CASCADE로 나머지 관련 데이터 자동 삭제)
    const { data: deletedRows, error: deleteError } = await supabase
      .from("students")
      .delete()
      .eq("id", studentId)
      .eq("tenant_id", tenantContext.tenantId)
      .select();

    if (deleteError) {
      logActionError(
        { domain: "student", action: "deleteStudent" },
        deleteError,
        { studentId, step: "students" }
      );
      return {
        success: false,
        error: deleteError.message || "학생 삭제에 실패했습니다.",
      };
    }

    if (!deletedRows || deletedRows.length === 0) {
      return {
        success: false,
        error: "학생을 찾을 수 없습니다.",
      };
    }

    revalidatePath("/admin/students");
    revalidatePath(`/admin/students/${studentId}`);

    return { success: true };
  } catch (error) {
    logActionError(
      { domain: "student", action: "deleteStudent" },
      error,
      { studentId }
    );
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "학생 삭제 중 알 수 없는 오류가 발생했습니다.",
    };
  }
}

/**
 * 여러 학생의 상태를 일괄 변경 (활성화/비활성화)
 */
export async function bulkToggleStudentStatus(
  studentIds: string[],
  isActive: boolean
): Promise<{ success: boolean; error?: string; updatedCount?: number }> {
  // 권한 확인
  await requireAdminOrConsultant();
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  if (studentIds.length === 0) {
    return { success: false, error: "선택된 학생이 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }

  const { data, error, count } = await supabase
    .from("students")
    .update({ is_active: isActive })
    .in("id", studentIds)
    .eq("tenant_id", tenantContext.tenantId)
    .select("id");

  if (error) {
    logActionError(
      { domain: "student", action: "bulkToggleStudentStatus" },
      error,
      { studentIds, isActive }
    );
    return {
      success: false,
      error: error.message || "상태 변경에 실패했습니다.",
    };
  }

  revalidatePath("/admin/students");

  const updatedCount = data?.length ?? count ?? studentIds.length;
  return { success: true, updatedCount };
}

/**
 * 여러 학생을 일괄 삭제 (관리자 전용, 하드 삭제)
 * 각 학생에 대해 deleteStudent와 동일한 프로세스 수행
 */
export async function bulkDeleteStudents(
  studentIds: string[]
): Promise<{ success: boolean; error?: string; deletedCount?: number }> {
  // 권한 확인 (관리자만)
  const { role } = await requireAdminOrConsultant();
  if (role !== "admin") {
    return { success: false, error: "관리자만 학생을 삭제할 수 있습니다." };
  }
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  if (studentIds.length === 0) {
    return { success: false, error: "선택된 학생이 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }
  let successCount = 0;
  const errors: string[] = [];

  // NO ACTION 제약조건이 있는 테이블들을 배치 삭제 (N+1 → 5 쿼리로 최적화)
  // 이 테이블들은 개별 에러 추적이 필요 없으므로 배치 처리
  const batchDeleteResults = await Promise.all([
    supabase
      .from("student_score_analysis_cache")
      .delete()
      .in("student_id", studentIds),
    supabase
      .from("student_score_events")
      .delete()
      .in("student_id", studentIds),
    supabase
      .from("student_internal_scores")
      .delete()
      .in("student_id", studentIds),
    supabase
      .from("student_mock_scores")
      .delete()
      .in("student_id", studentIds),
    supabase
      .from("student_terms")
      .delete()
      .in("student_id", studentIds),
  ]);

  // 배치 삭제 에러 확인 (치명적 에러만 로깅)
  const batchErrors = batchDeleteResults
    .map((result, index) => {
      const tableNames = [
        "student_score_analysis_cache",
        "student_score_events",
        "student_internal_scores",
        "student_mock_scores",
        "student_terms",
      ];
      if (result.error) {
        return `${tableNames[index]}: ${result.error.message}`;
      }
      return null;
    })
    .filter(Boolean);

  if (batchErrors.length > 0) {
    logActionWarn(
      { domain: "student", action: "bulkDeleteStudents" },
      "배치 삭제 경고",
      { studentIds, batchErrors }
    );
  }

  // 1단계: auth.users에서 사용자 삭제 (Supabase API 제한으로 개별 처리 필요)
  const authDeletedIds: string[] = [];
  for (const studentId of studentIds) {
    try {
      const { error: authDeleteError } = await supabase.auth.admin.deleteUser(
        studentId
      );

      if (authDeleteError) {
        errors.push(
          `${studentId}: 인증 사용자 삭제 실패 - ${authDeleteError.message}`
        );
        continue;
      }

      authDeletedIds.push(studentId);
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : "알 수 없는 오류";
      errors.push(`${studentId}: ${errorMessage}`);
      logActionError(
        { domain: "student", action: "bulkDeleteStudents" },
        err,
        { studentId, step: "auth.admin.deleteUser" }
      );
    }
  }

  // 2단계: students 테이블에서 배치 삭제 (N+1 방지)
  if (authDeletedIds.length > 0) {
    const { data: deletedRows, error: deleteError } = await supabase
      .from("students")
      .delete()
      .in("id", authDeletedIds)
      .eq("tenant_id", tenantContext.tenantId)
      .select("id");

    if (deleteError) {
      errors.push(`학생 테이블 배치 삭제 실패: ${deleteError.message}`);
    } else {
      successCount = deletedRows?.length || 0;

      // 삭제되지 않은 학생 확인
      const deletedIdSet = new Set(deletedRows?.map((r) => r.id) || []);
      for (const id of authDeletedIds) {
        if (!deletedIdSet.has(id)) {
          errors.push(`${id}: 학생을 찾을 수 없습니다.`);
        }
      }
    }
  }

  revalidatePath("/admin/students");

  if (errors.length > 0) {
    return {
      success: errors.length < studentIds.length,
      error: `일부 학생 삭제에 실패했습니다: ${errors.slice(0, 3).join(", ")}${
        errors.length > 3 ? "..." : ""
      }`,
      deletedCount: successCount,
    };
  }

  return { success: true, deletedCount: successCount };
}

/**
 * 학생 반 정보 업데이트 (관리자 전용)
 */
export async function updateStudentClass(
  studentId: string,
  classValue: string | null
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }

  // 빈 문자열을 null로 변환
  const normalizedClass = classValue?.trim() || null;

  const { data: updatedRows, error } = await supabase
    .from("students")
    .update({ class: normalizedClass })
    .eq("id", studentId)
    .eq("tenant_id", tenantContext.tenantId)
    .select();

  if (error) {
    logActionError(
      { domain: "student", action: "updateStudentClass" },
      error,
      { studentId, classValue }
    );
    return {
      success: false,
      error: error.message || "반 정보 변경에 실패했습니다.",
    };
  }

  if (!updatedRows || updatedRows.length === 0) {
    return {
      success: false,
      error: "학생을 찾을 수 없습니다.",
    };
  }

  revalidatePath("/admin/students");
  revalidatePath(`/admin/students/${studentId}`);

  return { success: true };
}

/**
 * 통합 학생 정보 업데이트 (관리자 전용)
 * 3개 테이블(students, student_profiles, student_career_goals)을 한 번에 업데이트
 */
export async function updateStudentInfo(
  studentId: string,
  payload: {
    basic?: {
      name?: string | null;
      grade?: string;
      class?: string | null;
      birth_date?: string;
      school_id?: string | null;
      division?: "고등부" | "중등부" | "기타" | null;
      memo?: string | null;
      status?: "enrolled" | "on_leave" | "graduated" | "transferred" | null;
      is_active?: boolean;
    };
    profile?: {
      gender?: "남" | "여" | null;
      phone?: string | null;
      mother_phone?: string | null;
      father_phone?: string | null;
      address?: string | null;
      emergency_contact?: string | null;
      emergency_contact_phone?: string | null;
      medical_info?: string | null;
    };
    career?: {
      exam_year?: number | null;
      curriculum_revision?: "2009 개정" | "2015 개정" | "2022 개정" | null;
      desired_university_ids?: string[] | null;
      desired_career_field?: string | null;
    };
  }
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();
  
  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return { success: false, error: "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다." };
  }

  // 기존 학생 정보 조회
  const { getStudentById } = await import("@/lib/data/students");
  const existingStudent = await getStudentById(studentId);

  if (!existingStudent) {
    return { success: false, error: "학생 정보를 찾을 수 없습니다." };
  }

  // 1. 기본 정보 업데이트
  if (payload.basic) {
    const {
      upsertStudent,
    } = await import("@/lib/data/students");
    const {
      normalizePhoneNumber,
      validatePhoneNumber,
    } = await import("@/lib/utils/studentFormUtils");

    // 이름 업데이트 시 user_metadata에도 동기화
    if (payload.basic.name !== undefined && payload.basic.name !== existingStudent.name) {
      const { data: authUser } = await supabase.auth.admin.getUserById(studentId);
      if (authUser?.user && payload.basic.name) {
        await supabase.auth.admin.updateUserById(studentId, {
          user_metadata: {
            ...authUser.user.user_metadata,
            display_name: payload.basic.name,
          },
        });
      }
    }

    const basicResult = await upsertStudent({
      id: studentId,
      tenant_id: existingStudent.tenant_id ?? null,
      name: payload.basic.name,
      grade: payload.basic.grade ?? existingStudent.grade ?? "",
      class: payload.basic.class ?? existingStudent.class ?? "",
      birth_date: payload.basic.birth_date ?? existingStudent.birth_date ?? "",
      school_id: payload.basic.school_id !== undefined 
        ? payload.basic.school_id 
        : existingStudent.school_id ?? null,
      division: payload.basic.division !== undefined
        ? payload.basic.division
        : existingStudent.division ?? null,
      status: payload.basic.status !== undefined
        ? payload.basic.status
        : existingStudent.status ?? null,
    });

    if (!basicResult.success) {
      return basicResult;
    }

    // memo와 is_active는 별도 업데이트 (upsertStudent에 포함되지 않음)
    if (payload.basic.memo !== undefined || payload.basic.is_active !== undefined) {
      const updateData: Record<string, unknown> = {};
      if (payload.basic.memo !== undefined) {
        updateData.memo = payload.basic.memo;
      }
      if (payload.basic.is_active !== undefined) {
        updateData.is_active = payload.basic.is_active;
      }

      const { error: updateError } = await supabase
        .from("students")
        .update(updateData)
        .eq("id", studentId);

      if (updateError) {
        logActionError(
          { domain: "student", action: "updateStudentInfo" },
          updateError,
          { studentId, step: "memo/is_active" }
        );
        return {
          success: false,
          error: updateError.message || "학생 정보 업데이트에 실패했습니다.",
        };
      }
    }
  }

  // 2. 프로필 정보 업데이트
  if (payload.profile) {
    const {
      upsertStudentProfile,
    } = await import("@/lib/data/studentProfiles");
    const {
      normalizePhoneNumber,
      validatePhoneNumber,
    } = await import("@/lib/utils/studentFormUtils");

    // 전화번호 검증 및 정규화
    const phoneRaw = payload.profile.phone;
    const motherPhoneRaw = payload.profile.mother_phone;
    const fatherPhoneRaw = payload.profile.father_phone;
    const emergencyPhoneRaw = payload.profile.emergency_contact_phone;

    if (phoneRaw) {
      const phoneValidation = validatePhoneNumber(phoneRaw);
      if (!phoneValidation.valid) {
        return { success: false, error: `본인 연락처: ${phoneValidation.error}` };
      }
    }

    if (motherPhoneRaw) {
      const motherPhoneValidation = validatePhoneNumber(motherPhoneRaw);
      if (!motherPhoneValidation.valid) {
        return {
          success: false,
          error: `모 연락처: ${motherPhoneValidation.error}`,
        };
      }
    }

    if (fatherPhoneRaw) {
      const fatherPhoneValidation = validatePhoneNumber(fatherPhoneRaw);
      if (!fatherPhoneValidation.valid) {
        return {
          success: false,
          error: `부 연락처: ${fatherPhoneValidation.error}`,
        };
      }
    }

    if (emergencyPhoneRaw) {
      const emergencyPhoneValidation = validatePhoneNumber(emergencyPhoneRaw);
      if (!emergencyPhoneValidation.valid) {
        return {
          success: false,
          error: `비상연락처: ${emergencyPhoneValidation.error}`,
        };
      }
    }

    // 전화번호 정규화
    const phone = phoneRaw ? normalizePhoneNumber(phoneRaw) : null;
    const motherPhone = motherPhoneRaw ? normalizePhoneNumber(motherPhoneRaw) : null;
    const fatherPhone = fatherPhoneRaw ? normalizePhoneNumber(fatherPhoneRaw) : null;
    const emergencyPhone = emergencyPhoneRaw ? normalizePhoneNumber(emergencyPhoneRaw) : null;

    // 정규화 실패 시 에러 반환
    if (phoneRaw && !phone) {
      return {
        success: false,
        error: "본인 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
      };
    }
    if (motherPhoneRaw && !motherPhone) {
      return {
        success: false,
        error: "모 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
      };
    }
    if (fatherPhoneRaw && !fatherPhone) {
      return {
        success: false,
        error: "부 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
      };
    }
    if (emergencyPhoneRaw && !emergencyPhone) {
      return {
        success: false,
        error: "비상연락처 형식이 올바르지 않습니다 (010-1234-5678)",
      };
    }

    const profileResult = await upsertStudentProfile({
      id: studentId,
      tenant_id: existingStudent.tenant_id ?? null,
      gender: payload.profile.gender,
      phone,
      mother_phone: motherPhone,
      father_phone: fatherPhone,
      address: payload.profile.address,
      emergency_contact: payload.profile.emergency_contact,
      emergency_contact_phone: emergencyPhone,
      medical_info: payload.profile.medical_info,
    });

    if (!profileResult.success) {
      return profileResult;
    }
  }

  // 3. 진로 정보 업데이트
  if (payload.career) {
    const {
      upsertStudentCareerGoal,
    } = await import("@/lib/data/studentCareerGoals");

    const careerGoalResult = await upsertStudentCareerGoal({
      student_id: studentId,
      tenant_id: existingStudent.tenant_id ?? null,
      exam_year: payload.career.exam_year,
      curriculum_revision: payload.career.curriculum_revision,
      desired_university_ids: payload.career.desired_university_ids,
      desired_career_field: payload.career.desired_career_field,
    });

    if (!careerGoalResult.success) {
      return careerGoalResult;
    }
  }

  revalidatePath("/admin/students");
  revalidatePath(`/admin/students/${studentId}`);

  return { success: true };
}

/**
 * 연결 코드 생성 (STU-XXXX-XXXX 형식)
 * crypto.getRandomValues를 사용하여 보안 강화
 */
function generateConnectionCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  
  // crypto.getRandomValues를 사용하여 보안 강화
  const getRandomChar = () => {
    const randomArray = new Uint32Array(1);
    crypto.getRandomValues(randomArray);
    const index = randomArray[0] % chars.length;
    return chars[index];
  };
  
  const part1 = Array.from({ length: 4 }, getRandomChar).join("");
  const part2 = Array.from({ length: 4 }, getRandomChar).join("");
  
  return `STU-${part1}-${part2}`;
}

/**
 * 고유 연결 코드 생성 (중복 체크 포함)
 * 
 * @param supabase - Supabase 클라이언트
 * @param maxRetries - 최대 재시도 횟수 (기본값: 10)
 * @returns 고유한 연결 코드
 */
async function generateUniqueConnectionCode(
  supabase: Awaited<ReturnType<typeof createSupabaseServerClient>>,
  maxRetries = 10
): Promise<string> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const code = generateConnectionCode();
    
    // 중복 체크
    const { data, error } = await supabase
      .from("student_connection_codes")
      .select("id")
      .eq("connection_code", code)
      .maybeSingle();
    
    if (error && error.code !== "PGRST116") {
      // PGRST116은 "no rows returned" 에러이므로 정상
      logActionError(
        { domain: "student", action: "generateUniqueConnectionCode" },
        error,
        { code, attempt }
      );
      throw new Error("연결 코드 생성 중 오류가 발생했습니다.");
    }
    
    // 중복이 없으면 반환
    if (!data) {
      return code;
    }
    
    // 중복이 있으면 재시도
    logActionWarn(
      { domain: "student", action: "generateUniqueConnectionCode" },
      `연결 코드 중복 감지, 재시도 ${attempt + 1}/${maxRetries}`,
      { code, attempt }
    );
  }
  
  // 최대 재시도 횟수 초과
  throw new Error("고유한 연결 코드를 생성할 수 없습니다. 다시 시도해주세요.");
}

/**
 * 신규 학생 등록 (인증 계정 없이)
 * 
 * @param formData - 학생 정보 FormData
 * @returns 학생 ID와 연결 코드
 */
export async function createStudent(
  formData: FormData
): Promise<{
  success: boolean;
  studentId?: string;
  connectionCode?: string;
  error?: string;
}> {
  const { role, tenantId, userId } = await getCurrentUserRole();

  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "권한이 없습니다." };
  }

  if (!tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  if (!userId) {
    return { success: false, error: "사용자 정보를 찾을 수 없습니다." };
  }

  const supabase = await createSupabaseServerClient();

  // FormData 필드 분리
  const { separateStudentFormFields } = await import("@/lib/utils/studentFormDataHelpers");
  const { formDataToObject } = await import("@/lib/validation/schemas");
  const { createStudentSchema } = await import("@/lib/validation/studentSchemas");
  
  // 필드를 기본정보, 프로필, 진로정보로 분리
  const { basic: basicFormData, profile: profileFormData, career: careerFormData } = 
    separateStudentFormFields(formData);
  
  // 각 필드 그룹을 객체로 변환
  const basicObj = formDataToObject(basicFormData);
  
  // 프로필과 진로 정보는 선택사항이므로 빈 FormData인지 확인
  const profileObj = profileFormData.keys().next().done ? null : formDataToObject(profileFormData);
  const careerObj = careerFormData.keys().next().done ? null : formDataToObject(careerFormData);
  
  // 스키마 검증
  const validationResult = createStudentSchema.safeParse({
    basic: basicObj,
    profile: profileObj,
    career: careerObj,
  });

  if (!validationResult.success) {
    const firstError = validationResult.error.errors[0];
    return {
      success: false,
      error: firstError?.message || "입력 정보가 올바르지 않습니다.",
    };
  }

  const { basic, profile, career } = validationResult.data;

  try {
    // 학생 ID 생성 (UUID)
    const studentId = crypto.randomUUID();

    // 1. students 테이블 레코드 생성
    const { upsertStudent } = await import("@/lib/data/students");
    const basicResult = await upsertStudent({
      id: studentId,
      tenant_id: tenantId,
      name: basic.name,
      grade: basic.grade,
      class: basic.class ?? "",
      birth_date: basic.birth_date,
      school_id: basic.school_id ?? null,
      school_type: basic.school_type ?? null,
      division: basic.division ?? null,
      student_number: basic.student_number ?? null,
      enrolled_at: basic.enrolled_at ?? null,
      status: basic.status ?? "enrolled",
    });

    if (!basicResult.success) {
      return { success: false, error: basicResult.error || "학생 정보 저장에 실패했습니다." };
    }

    // 2. student_profiles 테이블 레코드 생성 (데이터 있는 경우)
    if (profile) {
      const { upsertStudentProfile } = await import("@/lib/data/studentProfiles");
      const profileResult = await upsertStudentProfile({
        id: studentId,
        tenant_id: tenantId,
        gender: profile.gender ?? null,
        phone: profile.phone ?? null,
        mother_phone: profile.mother_phone ?? null,
        father_phone: profile.father_phone ?? null,
        address: profile.address ?? null,
        address_detail: profile.address_detail ?? null,
        postal_code: profile.postal_code ?? null,
        emergency_contact: profile.emergency_contact ?? null,
        emergency_contact_phone: profile.emergency_contact_phone ?? null,
        medical_info: profile.medical_info ?? null,
        bio: profile.bio ?? null,
        interests: profile.interests ?? null,
      });

      if (!profileResult.success) {
        // 프로필 저장 실패는 치명적이지 않으므로 경고만
        logActionWarn(
          { domain: "student", action: "createStudent" },
          "프로필 저장 실패",
          { studentId, error: profileResult.error }
        );
      }
    }

    // 3. student_career_goals 테이블 레코드 생성 (데이터 있는 경우)
    if (career) {
      const { upsertStudentCareerGoal } = await import("@/lib/data/studentCareerGoals");
      const careerResult = await upsertStudentCareerGoal({
        student_id: studentId,
        tenant_id: tenantId,
        exam_year: career.exam_year ?? null,
        curriculum_revision: career.curriculum_revision ?? null,
        desired_university_ids: career.desired_university_ids ?? null,
        desired_career_field: career.desired_career_field ?? null,
        target_major: career.target_major ?? null,
        target_major_2: career.target_major_2 ?? null,
        target_score: career.target_score ?? null,
        target_university_type: career.target_university_type ?? null,
        notes: career.notes ?? null,
      });

      if (!careerResult.success) {
        // 진로 정보 저장 실패는 치명적이지 않으므로 경고만
        logActionWarn(
          { domain: "student", action: "createStudent" },
          "진로 정보 저장 실패",
          { studentId, error: careerResult.error }
        );
      }
    }

    // 4. 연결 코드 생성 및 저장 (고유 코드 생성 함수 사용)
    const connectionCode = await generateUniqueConnectionCode(supabase);
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30); // 30일 후 만료

    const { error: codeError } = await supabase
      .from("student_connection_codes")
      .insert({
        student_id: studentId,
        connection_code: connectionCode,
        expires_at: expiresAt.toISOString(),
        created_by: userId,
      });

    if (codeError) {
      logActionError(
        { domain: "student", action: "createStudent" },
        codeError,
        { studentId, step: "student_connection_codes" }
      );
      return {
        success: false,
        error: `연결 코드 저장에 실패했습니다: ${codeError.message}`,
      };
    }

    revalidatePath("/admin/students");

    return {
      success: true,
      studentId,
      connectionCode,
    };
  } catch (error) {
    logActionError(
      { domain: "student", action: "createStudent" },
      error
    );
    return {
      success: false,
      error: error instanceof Error ? error.message : "학생 등록 중 알 수 없는 오류가 발생했습니다.",
    };
  }
}

// validateConnectionCode 함수는 lib/utils/connectionCodeUtils.ts로 이동되었습니다.
// 사용처가 없으므로 제거되었습니다.

/**
 * 연결 코드 재발급
 * 
 * @param studentId - 학생 ID
 * @returns 새로운 연결 코드
 */
export async function regenerateConnectionCode(
  studentId: string
): Promise<{
  success: boolean;
  connectionCode?: string;
  error?: string;
}> {
  const { role, tenantId, userId } = await getCurrentUserRole();

  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "권한이 없습니다." };
  }

  if (!tenantId || !userId) {
    return { success: false, error: "사용자 정보를 찾을 수 없습니다." };
  }

  const supabase = await createSupabaseServerClient();

  // 기존 코드 비활성화 (used_at 설정)
  await supabase
    .from("student_connection_codes")
    .update({ used_at: new Date().toISOString() })
    .eq("student_id", studentId)
    .is("used_at", null);

  // 새 코드 생성 (고유 코드 생성 함수 사용)
  const connectionCode = await generateUniqueConnectionCode(supabase);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 30); // 30일 후 만료

  const { error: codeError } = await supabase
    .from("student_connection_codes")
    .insert({
      student_id: studentId,
      connection_code: connectionCode,
      expires_at: expiresAt.toISOString(),
      created_by: userId,
    });

  if (codeError) {
    logActionError(
      { domain: "student", action: "regenerateConnectionCode" },
      codeError,
      { studentId }
    );
    return {
      success: false,
      error: `연결 코드 재발급에 실패했습니다: ${codeError.message}`,
    };
  }

  revalidatePath(`/admin/students/${studentId}`);

  return {
    success: true,
    connectionCode,
  };
}

/**
 * 학생의 연결 코드 조회
 * 
 * @param studentId - 학생 ID
 * @returns 연결 코드 정보
 */
export async function getStudentConnectionCode(
  studentId: string
): Promise<{
  success: boolean;
  data?: {
    connection_code: string;
    expires_at: string;
    used_at: string | null;
  } | null;
  error?: string;
}> {
  const { role } = await getCurrentUserRole();

  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "권한이 없습니다." };
  }

  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_connection_codes")
    .select("connection_code, expires_at, used_at")
    .eq("student_id", studentId)
    .is("used_at", null)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    logActionError(
      { domain: "student", action: "getStudentConnectionCode" },
      error,
      { studentId }
    );
    return { success: false, error: error.message || "연결 코드를 조회할 수 없습니다." };
  }

  return {
    success: true,
    data: data ?? null,
  };
}
</file>

<file path="notifications.ts">
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { logActionError } from "@/lib/logging/actionLogger";

export type NotificationSettings = {
  plan_start_enabled: boolean;
  plan_complete_enabled: boolean;
  daily_goal_achieved_enabled: boolean;
  weekly_report_enabled: boolean;
  plan_delay_enabled: boolean;
  plan_delay_threshold_minutes: number;
  notification_time_start: string;
  notification_time_end: string;
  quiet_hours_enabled: boolean;
  quiet_hours_start: string;
  quiet_hours_end: string;
  attendance_check_in_enabled?: boolean | null;
  attendance_check_out_enabled?: boolean | null;
  attendance_absent_enabled?: boolean | null;
  attendance_late_enabled?: boolean | null;
};

export async function updateNotificationSettings(
  settings: NotificationSettings
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return { success: false, error: "로그인이 필요합니다." };
    }

    // 기존 설정 확인
    const { data: existing } = await supabase
      .from("student_notification_preferences")
      .select("id")
      .eq("student_id", user.id)
      .single();

    if (existing) {
      // 업데이트
      const { error } = await supabase
        .from("student_notification_preferences")
        .update({
          ...settings,
          updated_at: new Date().toISOString(),
        })
        .eq("student_id", user.id);

      if (error) {
        logActionError(
          { domain: "student", action: "updateNotificationSettings", userId: user.id },
          error,
          { operation: "update" }
        );
        return { success: false, error: "설정 저장에 실패했습니다." };
      }
    } else {
      // 생성
      const { error } = await supabase
        .from("student_notification_preferences")
        .insert({
          student_id: user.id,
          ...settings,
        });

      if (error) {
        logActionError(
          { domain: "student", action: "updateNotificationSettings", userId: user.id },
          error,
          { operation: "insert" }
        );
        return { success: false, error: "설정 저장에 실패했습니다." };
      }
    }

    return { success: true };
  } catch (error: unknown) {
    logActionError(
      { domain: "student", action: "updateNotificationSettings" },
      error
    );
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "설정 저장 중 오류가 발생했습니다.",
    };
  }
}
</file>

<file path="parentLinks.ts">
"use server";

import { requireAdminOrConsultant } from "@/lib/auth/guards";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { extractJoinResult } from "@/lib/supabase/queryHelpers";
import { revalidatePath } from "next/cache";
import { PARENT_STUDENT_LINK_MESSAGES } from "@/lib/constants/parentStudentLinkMessages";
import { ErrorCodeCheckers } from "@/lib/constants/errorCodes";
import { logActionError } from "@/lib/logging/actionLogger";

// 타입 정의
export type StudentParent = {
  linkId: string;
  parentId: string;
  parentName: string | null;
  parentEmail: string | null;
  relation: string;
};

export type SearchableParent = {
  id: string;
  name: string | null;
  email: string | null;
};

export type ParentRelation = "father" | "mother" | "guardian" | "other";

export type PendingLinkRequest = {
  id: string;
  studentId: string;
  studentName: string | null;
  studentGrade: string | null;
  studentClass: string | null;
  parentId: string;
  parentName: string | null;
  parentEmail: string | null;
  relation: string;
  created_at: string;
};

// Supabase 쿼리 결과 타입
type ParentStudentLinkRow = {
  id: string;
  parent_id: string;
  relation: string;
  parent_users:
    | {
        id: string;
        name: string | null;
      }
    | {
        id: string;
        name: string | null;
      }[]
    | null;
};

type ParentStudentLinkWithStudentRow = {
  id: string;
  student_id: string;
  parent_id: string;
  relation: string;
  created_at: string;
  students:
    | {
        id: string;
        name: string | null;
        grade: string | null;
        class: string | null;
      }
    | {
        id: string;
        name: string | null;
        grade: string | null;
        class: string | null;
      }[]
    | null;
  parent_users:
    | {
        id: string;
        name: string | null;
      }
    | {
        id: string;
        name: string | null;
      }[]
    | null;
};

type SearchableParentRow = {
  id: string;
  name: string | null;
};

/**
 * 학생에 연결된 학부모 목록 조회
 */
export async function getStudentParents(
  studentId: string
): Promise<{ success: boolean; data?: StudentParent[]; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  const supabase = await createSupabaseServerClient();

  try {
    const selectLinks = () =>
      supabase
        .from("parent_student_links")
        .select(
          `
          id,
          relation,
          parent_id,
          parent_users:parent_id(
            id,
            name
          )
        `
        )
        .eq("student_id", studentId);

    let { data: links, error } = await selectLinks();

    // 컬럼 없음 에러 처리 (42703)
    if (ErrorCodeCheckers.isColumnNotFound(error)) {
      ({ data: links, error } = await selectLinks());
    }

    if (error) {
      logActionError(
        { domain: "student", action: "getStudentParents" },
        error,
        { studentId }
      );
      return {
        success: false,
        error: error.message || "학부모 목록을 조회할 수 없습니다.",
      };
    }

    if (!links) {
      return { success: true, data: [] };
    }

    // 데이터 변환
    const parents: StudentParent[] = links
      .map((link: ParentStudentLinkRow): StudentParent | null => {
        const parentUser = extractJoinResult(link.parent_users);
        if (!parentUser) return null;

        return {
          linkId: link.id,
          parentId: link.parent_id,
          parentName: parentUser.name,
          parentEmail: null,
          relation: link.relation || "other",
        };
      })
      .filter((p): p is StudentParent => p !== null);

    return { success: true, data: parents };
  } catch (error) {
    logActionError(
      { domain: "student", action: "getStudentParents" },
      error,
      { studentId }
    );
    return {
      success: false,
      error: "학부모 목록을 조회하는 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 학부모 검색 (이름 또는 이메일)
 */
export async function searchParents(
  query: string,
  tenantId?: string
): Promise<{ success: boolean; data?: SearchableParent[]; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 최소 2글자 이상 검색
  if (!query || query.trim().length < 2) {
    return { success: true, data: [] };
  }

  const supabase = await createSupabaseServerClient();

  try {
    const searchQuery = query.trim();

    // parent_users에서 직접 검색 (name만 사용, email은 auth.users에 있어 조회 불가)
    const selectParents = () =>
      supabase
        .from("parent_users")
        .select(
          `
          id,
          name
        `
        )
        .ilike("name", `%${searchQuery}%`)
        .limit(10);

    // tenant_id 필터 추가 (있는 경우)
    let queryBuilder = selectParents();
    if (tenantId) {
      queryBuilder = queryBuilder.eq("tenant_id", tenantId);
    }

    let { data: parents, error } = await queryBuilder;

    // 컬럼 없음 에러 처리 (42703)
    if (ErrorCodeCheckers.isColumnNotFound(error)) {
      ({ data: parents, error } = await queryBuilder);
    }

    if (error) {
      logActionError(
        { domain: "student", action: "searchParents" },
        error,
        { query, tenantId }
      );
      return {
        success: false,
        error: error.message || "학부모 검색에 실패했습니다.",
      };
    }

    if (!parents) {
      return { success: true, data: [] };
    }

    // 데이터 변환
    const searchResults: SearchableParent[] = parents
      .map((parent: SearchableParentRow): SearchableParent | null => {
        if (!parent.name) return null;

        return {
          id: parent.id,
          name: parent.name,
          email: null,
        };
      })
      .filter((p): p is SearchableParent => p !== null);

    return { success: true, data: searchResults };
  } catch (error) {
    logActionError(
      { domain: "student", action: "searchParents" },
      error,
      { query, tenantId }
    );
    return {
      success: false,
      error: "학부모 검색 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 학생-학부모 연결 생성
 */
export async function createParentStudentLink(
  studentId: string,
  parentId: string,
  relation: ParentRelation
): Promise<{ success: boolean; linkId?: string; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // relation 값 검증
  const validRelations: ParentRelation[] = [
    "father",
    "mother",
    "guardian",
    "other",
  ];
  if (!validRelations.includes(relation)) {
    return {
      success: false,
      error: PARENT_STUDENT_LINK_MESSAGES.errors.INVALID_RELATION,
    };
  }

  const supabase = await createSupabaseServerClient();

  try {
    // 중복 체크
    const { data: existing, error: checkError } = await supabase
      .from("parent_student_links")
      .select("id")
      .eq("student_id", studentId)
      .eq("parent_id", parentId)
      .maybeSingle();

    if (checkError && checkError.code !== "PGRST116") {
      logActionError(
        { domain: "student", action: "createParentStudentLink" },
        checkError,
        { studentId, parentId, relation }
      );
      return {
        success: false,
        error: "연결 확인 중 오류가 발생했습니다.",
      };
    }

    if (existing) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.LINK_ALREADY_EXISTS,
      };
    }

    // 연결 생성
    const { data, error } = await supabase
      .from("parent_student_links")
      .insert({
        student_id: studentId,
        parent_id: parentId,
        relation: relation,
      })
      .select("id")
      .single();

    if (error) {
      // UNIQUE 제약조건 에러 처리
      if (error.code === "23505") {
        return {
          success: false,
          error: PARENT_STUDENT_LINK_MESSAGES.errors.LINK_ALREADY_EXISTS,
        };
      }

      logActionError(
        { domain: "student", action: "createParentStudentLink" },
        error,
        { studentId, parentId, relation }
      );
      return {
        success: false,
        error: error.message || "연결 생성에 실패했습니다.",
      };
    }

    revalidatePath("/admin/students");
    revalidatePath(`/admin/students/${studentId}`);

    return { success: true, linkId: data.id };
  } catch (error) {
    logActionError(
      { domain: "student", action: "createParentStudentLink" },
      error,
      { studentId, parentId, relation }
    );
    return {
      success: false,
      error: "연결 생성 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 학생-학부모 연결 삭제
 */
export async function deleteParentStudentLink(
  linkId: string
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      error:
        "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
    };
  }

  try {
    // 먼저 student_id를 조회하여 revalidatePath에 사용
    const { data: link, error: fetchError } = await supabase
      .from("parent_student_links")
      .select("student_id")
      .eq("id", linkId)
      .maybeSingle();

    if (fetchError) {
      logActionError(
        { domain: "student", action: "deleteParentStudentLink" },
        fetchError,
        { linkId }
      );
      return {
        success: false,
        error: "연결 정보를 찾을 수 없습니다.",
      };
    }

    if (!link) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.LINK_NOT_FOUND,
      };
    }

    const studentId = link.student_id;

    // 연결 삭제
    const { data: deletedRows, error } = await supabase
      .from("parent_student_links")
      .delete()
      .eq("id", linkId)
      .select();

    if (error) {
      logActionError(
        { domain: "student", action: "deleteParentStudentLink" },
        error,
        { linkId }
      );
      return {
        success: false,
        error: error.message || "연결 삭제에 실패했습니다.",
      };
    }

    if (!deletedRows || deletedRows.length === 0) {
      return {
        success: false,
        error: "연결을 찾을 수 없습니다.",
      };
    }

    revalidatePath("/admin/students");
    revalidatePath(`/admin/students/${studentId}`);

    return { success: true };
  } catch (error) {
    logActionError(
      { domain: "student", action: "deleteParentStudentLink" },
      error,
      { linkId }
    );
    return {
      success: false,
      error: "연결 삭제 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 연결의 관계 수정
 */
export async function updateLinkRelation(
  linkId: string,
  relation: ParentRelation
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // relation 값 검증
  const validRelations: ParentRelation[] = [
    "father",
    "mother",
    "guardian",
    "other",
  ];
  if (!validRelations.includes(relation)) {
    return {
      success: false,
      error: PARENT_STUDENT_LINK_MESSAGES.errors.INVALID_RELATION,
    };
  }

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      error:
        "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
    };
  }

  try {
    // 먼저 student_id를 조회하여 revalidatePath에 사용
    const { data: link, error: fetchError } = await supabase
      .from("parent_student_links")
      .select("student_id")
      .eq("id", linkId)
      .maybeSingle();

    if (fetchError) {
      logActionError(
        { domain: "student", action: "updateLinkRelation" },
        fetchError,
        { linkId, relation }
      );
      return {
        success: false,
        error: "연결 정보를 찾을 수 없습니다.",
      };
    }

    if (!link) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.LINK_NOT_FOUND,
      };
    }

    const studentId = link.student_id;

    // 관계 수정
    const { data: updatedRows, error } = await supabase
      .from("parent_student_links")
      .update({ relation })
      .eq("id", linkId)
      .select();

    if (error) {
      logActionError(
        { domain: "student", action: "updateLinkRelation" },
        error,
        { linkId, relation }
      );
      return {
        success: false,
        error: error.message || "관계 수정에 실패했습니다.",
      };
    }

    if (!updatedRows || updatedRows.length === 0) {
      return {
        success: false,
        error: "연결을 찾을 수 없습니다.",
      };
    }

    revalidatePath("/admin/students");
    revalidatePath(`/admin/students/${studentId}`);

    return { success: true };
  } catch (error) {
    logActionError(
      { domain: "student", action: "updateLinkRelation" },
      error,
      { linkId, relation }
    );
    return {
      success: false,
      error: "관계 수정 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 승인 대기 중인 연결 요청 목록 조회
 */
export async function getPendingLinkRequests(tenantId?: string): Promise<{
  success: boolean;
  data?: PendingLinkRequest[];
  error?: string;
}> {
  // 권한 확인
  const { tenantId: userTenantId } = await requireAdminOrConsultant();

  const supabase = await createSupabaseServerClient();
  const targetTenantId = tenantId || userTenantId;

  try {
    // 테넌트 필터링: 먼저 해당 테넌트의 학생 ID 목록 조회
    let studentIds: string[] | undefined;
    if (targetTenantId) {
      const { data: students, error: studentsError } = await supabase
        .from("students")
        .select("id")
        .eq("tenant_id", targetTenantId);

      if (studentsError) {
        logActionError(
          { domain: "student", action: "getPendingLinkRequests" },
          studentsError,
          { tenantId: targetTenantId }
        );
        return {
          success: false,
          error: "학생 목록을 조회할 수 없습니다.",
        };
      }

      studentIds = students?.map((s) => s.id) || [];
      if (studentIds.length === 0) {
        // 해당 테넌트에 학생이 없으면 빈 배열 반환
        return { success: true, data: [] };
      }
    }

    const selectLinks = () => {
      let query = supabase
        .from("parent_student_links")
        .select(
          `
          id,
          student_id,
          parent_id,
          relation,
          created_at,
          students:student_id(
            id,
            name,
            grade,
            class
          ),
          parent_users:parent_id(
            id,
            name
          )
        `
        )
        .or("is_approved.is.null,is_approved.eq.false")
        .order("created_at", { ascending: false });

      // 테넌트 필터링: 학생 ID 목록으로 필터링
      if (studentIds && studentIds.length > 0) {
        query = query.in("student_id", studentIds);
      }

      return query;
    };

    let { data: links, error } = await selectLinks();

    // 컬럼 없음 에러 처리 (42703)
    if (ErrorCodeCheckers.isColumnNotFound(error)) {
      ({ data: links, error } = await selectLinks());
    }

    if (error) {
      logActionError(
        { domain: "student", action: "getPendingLinkRequests" },
        error,
        { tenantId: targetTenantId }
      );
      return {
        success: false,
        error: error.message || "승인 대기 요청을 조회할 수 없습니다.",
      };
    }

    if (!links) {
      return { success: true, data: [] };
    }

    // parent_users.id 목록 수집
    const parentIds = links
      .map((link) => {
        const parentUser = extractJoinResult(link.parent_users);
        return parentUser?.id;
      })
      .filter((id): id is string => id !== undefined);

    // auth.users에서 email 배치 조회 (N+1 문제 해결)
    const parentEmailsMap = new Map<string, string | null>();
    if (parentIds.length > 0) {
      const { getAuthUserMetadata } = await import("@/lib/utils/authUserMetadata");
      const adminClient = createSupabaseAdminClient();
      const userMetadata = await getAuthUserMetadata(adminClient, parentIds);
      
      // email만 추출하여 Map에 저장
      userMetadata.forEach((metadata, userId) => {
        parentEmailsMap.set(userId, metadata.email);
      });
    }

    // 데이터 변환
    const requests: PendingLinkRequest[] = links
      .map((link: ParentStudentLinkWithStudentRow) => {
        const student = extractJoinResult(link.students);
        if (!student) return null;

        const parentUser = extractJoinResult(link.parent_users);
        if (!parentUser) return null;

        return {
          id: link.id,
          studentId: link.student_id,
          studentName: student.name,
          studentGrade: student.grade,
          studentClass: student.class,
          parentId: link.parent_id,
          parentName: parentUser.name,
          parentEmail: parentEmailsMap.get(parentUser.id) || null,
          relation: link.relation || "other",
          created_at: link.created_at,
        };
      })
      .filter((r): r is PendingLinkRequest => r !== null);

    return { success: true, data: requests };
  } catch (error) {
    logActionError(
      { domain: "student", action: "getPendingLinkRequests" },
      error,
      { tenantId: targetTenantId }
    );
    return {
      success: false,
      error: "승인 대기 요청 조회 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 연결 요청 승인
 */
export async function approveLinkRequest(
  linkId: string
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      error:
        "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
    };
  }

  try {
    // 먼저 요청 존재 여부 확인
    const { data: link, error: fetchError } = await supabase
      .from("parent_student_links")
      .select("id, student_id, is_approved")
      .eq("id", linkId)
      .maybeSingle();

    if (fetchError) {
      logActionError(
        { domain: "student", action: "approveLinkRequest" },
        fetchError,
        { linkId }
      );
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.FETCH_ERROR,
      };
    }

    if (!link) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_NOT_FOUND,
      };
    }

    // 이미 승인된 경우
    if (link.is_approved === true) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_ALREADY_APPROVED,
      };
    }

    // 승인 처리
    const { data: updatedRows, error } = await supabase
      .from("parent_student_links")
      .update({
        is_approved: true,
        approved_at: new Date().toISOString(),
      })
      .eq("id", linkId)
      .select();

    if (error) {
      logActionError(
        { domain: "student", action: "approveLinkRequest" },
        error,
        { linkId }
      );
      return {
        success: false,
        error: error.message || "요청 승인에 실패했습니다.",
      };
    }

    if (!updatedRows || updatedRows.length === 0) {
      return {
        success: false,
        error: "연결 요청을 찾을 수 없습니다.",
      };
    }

    revalidatePath("/admin/parent-links");
    revalidatePath(`/admin/students/${link.student_id}`);

    return { success: true };
  } catch (error) {
    logActionError(
      { domain: "student", action: "approveLinkRequest" },
      error,
      { linkId }
    );
    return {
      success: false,
      error: "요청 승인 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 연결 요청 거부 (삭제)
 */
export async function rejectLinkRequest(
  linkId: string
): Promise<{ success: boolean; error?: string }> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return { success: false, error: "기관 정보를 찾을 수 없습니다." };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      error:
        "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
    };
  }

  try {
    // 먼저 요청 존재 여부 확인
    const { data: link, error: fetchError } = await supabase
      .from("parent_student_links")
      .select("id, student_id")
      .eq("id", linkId)
      .maybeSingle();

    if (fetchError) {
      logActionError(
        { domain: "student", action: "rejectLinkRequest" },
        fetchError,
        { linkId }
      );
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.FETCH_ERROR,
      };
    }

    if (!link) {
      return {
        success: false,
        error: PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_NOT_FOUND,
      };
    }

    const studentId = link.student_id;

    // 요청 삭제 (거부)
    const { data: deletedRows, error } = await supabase
      .from("parent_student_links")
      .delete()
      .eq("id", linkId)
      .select();

    if (error) {
      logActionError(
        { domain: "student", action: "rejectLinkRequest" },
        error,
        { linkId }
      );
      return {
        success: false,
        error: error.message || "요청 거부에 실패했습니다.",
      };
    }

    if (!deletedRows || deletedRows.length === 0) {
      return {
        success: false,
        error: "연결 요청을 찾을 수 없습니다.",
      };
    }

    revalidatePath("/admin/parent-links");
    revalidatePath(`/admin/students/${studentId}`);

    return { success: true };
  } catch (error) {
    logActionError(
      { domain: "student", action: "rejectLinkRequest" },
      error,
      { linkId }
    );
    return {
      success: false,
      error: "요청 거부 중 오류가 발생했습니다.",
    };
  }
}

/**
 * 여러 연결 요청을 한 번에 승인
 */
export async function approveLinkRequests(linkIds: string[]): Promise<{
  success: boolean;
  approvedCount?: number;
  errors?: Array<{ linkId: string; error: string }>;
}> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return {
      success: false,
      errors: [{ linkId: "", error: "기관 정보를 찾을 수 없습니다." }],
    };
  }

  if (!linkIds || linkIds.length === 0) {
    return { success: false, errors: [] };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      errors: [
        {
          linkId: "",
          error:
            "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
        },
      ],
    };
  }
  const errors: Array<{ linkId: string; error: string }> = [];
  let approvedCount = 0;
  const studentIds = new Set<string>();

  try {
    // 병렬 처리
    const updatePromises = linkIds.map(async (linkId) => {
      try {
        // 먼저 요청 존재 여부 확인
        const { data: link, error: fetchError } = await supabase
          .from("parent_student_links")
          .select("id, student_id, is_approved")
          .eq("id", linkId)
          .maybeSingle();

        if (fetchError || !link) {
          return {
            linkId,
            error: fetchError
              ? PARENT_STUDENT_LINK_MESSAGES.errors.FETCH_ERROR
              : PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_NOT_FOUND,
            link: null,
          };
        }

        // 이미 승인된 경우
        if (link.is_approved === true) {
          return {
            linkId,
            error: "이미 승인된 요청입니다.",
            link: null,
          };
        }

        // 승인 처리
        const { data: updatedRows, error } = await supabase
          .from("parent_student_links")
          .update({
            is_approved: true,
            approved_at: new Date().toISOString(),
          })
          .eq("id", linkId)
          .select();

        if (error) {
          return {
            linkId,
            error: error.message || "요청 승인에 실패했습니다.",
            link: null,
          };
        }

        if (!updatedRows || updatedRows.length === 0) {
          return {
            linkId,
            error: "연결 요청을 찾을 수 없습니다.",
            link: null,
          };
        }

        return { linkId, error: null, link };
      } catch (err) {
        logActionError(
          { domain: "student", action: "approveLinkRequests" },
          err,
          { linkId }
        );
        return {
          linkId,
          error: "요청 승인 중 오류가 발생했습니다.",
          link: null,
        };
      }
    });

    const results = await Promise.all(updatePromises);

    // 결과 집계
    for (const result of results) {
      if (result.error) {
        errors.push({ linkId: result.linkId, error: result.error });
      } else if (result.link) {
        approvedCount++;
        studentIds.add(result.link.student_id);
      }
    }

    // 성공한 항목이 있으면 경로 재검증
    if (approvedCount > 0) {
      revalidatePath("/admin/parent-links");
      for (const studentId of studentIds) {
        revalidatePath(`/admin/students/${studentId}`);
      }
    }

    return {
      success: errors.length === 0,
      approvedCount,
      errors: errors.length > 0 ? errors : undefined,
    };
  } catch (error) {
    logActionError(
      { domain: "student", action: "approveLinkRequests" },
      error,
      { linkIds }
    );
    return {
      success: false,
      approvedCount: 0,
      errors: [{ linkId: "", error: "일괄 승인 중 오류가 발생했습니다." }],
    };
  }
}

/**
 * 여러 연결 요청을 한 번에 거부 (삭제)
 */
export async function rejectLinkRequests(linkIds: string[]): Promise<{
  success: boolean;
  rejectedCount?: number;
  errors?: Array<{ linkId: string; error: string }>;
}> {
  // 권한 확인
  await requireAdminOrConsultant();

  // 테넌트 컨텍스트 확인
  const tenantContext = await getTenantContext();
  if (!tenantContext?.tenantId) {
    return {
      success: false,
      errors: [{ linkId: "", error: "기관 정보를 찾을 수 없습니다." }],
    };
  }

  if (!linkIds || linkIds.length === 0) {
    return { success: false, errors: [] };
  }

  // Admin Client 사용 (RLS 우회)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    return {
      success: false,
      errors: [
        {
          linkId: "",
          error:
            "관리자 권한이 필요합니다. Service Role Key가 설정되지 않았습니다.",
        },
      ],
    };
  }
  const errors: Array<{ linkId: string; error: string }> = [];
  let rejectedCount = 0;
  const studentIds = new Set<string>();

  try {
    // 병렬 처리
    const deletePromises = linkIds.map(async (linkId) => {
      try {
        // 먼저 요청 존재 여부 확인
        const { data: link, error: fetchError } = await supabase
          .from("parent_student_links")
          .select("id, student_id")
          .eq("id", linkId)
          .maybeSingle();

        if (fetchError || !link) {
          return {
            linkId,
            error: fetchError
              ? PARENT_STUDENT_LINK_MESSAGES.errors.FETCH_ERROR
              : PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_NOT_FOUND,
            studentId: null,
          };
        }

        const studentId = link.student_id;

        // 요청 삭제 (거부)
        const { data: deletedRows, error } = await supabase
          .from("parent_student_links")
          .delete()
          .eq("id", linkId)
          .select();

        if (error) {
          return {
            linkId,
            error: error.message || "요청 거부에 실패했습니다.",
            studentId: null,
          };
        }

        if (!deletedRows || deletedRows.length === 0) {
          return {
            linkId,
            error: "연결 요청을 찾을 수 없습니다.",
            studentId: null,
          };
        }

        return { linkId, error: null, studentId };
      } catch (err) {
        logActionError(
          { domain: "student", action: "rejectLinkRequests" },
          err,
          { linkId }
        );
        return {
          linkId,
          error: "요청 거부 중 오류가 발생했습니다.",
          studentId: null,
        };
      }
    });

    const results = await Promise.all(deletePromises);

    // 결과 집계
    for (const result of results) {
      if (result.error) {
        errors.push({ linkId: result.linkId, error: result.error });
      } else if (result.studentId) {
        rejectedCount++;
        studentIds.add(result.studentId);
      }
    }

    // 성공한 항목이 있으면 경로 재검증
    if (rejectedCount > 0) {
      revalidatePath("/admin/parent-links");
      for (const studentId of studentIds) {
        revalidatePath(`/admin/students/${studentId}`);
      }
    }

    return {
      success: errors.length === 0,
      rejectedCount,
      errors: errors.length > 0 ? errors : undefined,
    };
  } catch (error) {
    logActionError(
      { domain: "student", action: "rejectLinkRequests" },
      error,
      { linkIds }
    );
    return {
      success: false,
      rejectedCount: 0,
      errors: [{ linkId: "", error: "일괄 거부 중 오류가 발생했습니다." }],
    };
  }
}
</file>

<file path="profile.ts">
"use server";

/**
 * Student Profile Actions
 *
 * 학생이 자신의 프로필을 관리하는 Server Actions.
 */

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  upsertStudent,
  getStudentById,
  type Student,
} from "@/lib/data/students";
import { logActionError, logActionWarn } from "@/lib/logging/actionLogger";
import {
  upsertStudentProfile,
  getStudentProfileById,
  type StudentProfile,
} from "@/lib/data/studentProfiles";
import {
  upsertStudentCareerGoal,
  getStudentCareerGoalById,
  type StudentCareerGoal,
} from "@/lib/data/studentCareerGoals";
import type { CareerField } from "@/lib/data/studentCareerFieldPreferences";
import {
  normalizePhoneNumber,
  validatePhoneNumber,
} from "@/lib/utils/studentFormUtils";

/**
 * 학생 정보 저장 (회원가입 시)
 */
export async function saveStudentInfo(formData: FormData): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error("로그인이 필요합니다.");
  }

  const name = String(formData.get("name") ?? "").trim();
  const grade = String(formData.get("grade") ?? "").trim();
  const klass = String(formData.get("class") ?? "").trim();
  const birthDate = String(formData.get("birth_date") ?? "").trim();

  if (!name || !grade || !klass || !birthDate) {
    throw new Error("모든 필드를 입력해주세요.");
  }

  // 이름을 user_metadata에도 저장
  if (name && name !== user.user_metadata?.display_name) {
    const { error: updateError } = await supabase.auth.updateUser({
      data: { display_name: name },
    });
    if (updateError) {
      logActionWarn(
        { domain: "student", action: "saveStudentInfo" },
        "이름 업데이트 실패 (계속 진행)",
        { error: updateError.message }
      );
    }
  }

  // user_metadata에서 tenant_id 가져오기 (회원가입 시 선택한 기관)
  const tenantIdFromMetadata = user.user_metadata?.tenant_id as
    | string
    | null
    | undefined;

  const result = await upsertStudent({
    id: user.id,
    tenant_id: tenantIdFromMetadata || null, // 회원가입 시 선택한 기관 사용, 없으면 기본 tenant 자동 할당
    name,
    grade,
    class: klass,
    birth_date: birthDate,
  });

  if (!result.success) {
    throw new Error(result.error || "학생 정보 저장에 실패했습니다.");
  }

  redirect("/dashboard");
}

/**
 * 마이페이지에서 학생 정보 업데이트 (기본 정보, 프로필, 진로 정보 분리)
 */
export async function updateStudentProfile(
  formData: FormData
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: "로그인이 필요합니다." };
  }

  // 기존 학생 정보 조회 (없으면 새로 생성)
  let existingStudent = await getStudentById(user.id);
  if (!existingStudent) {
    // 학생 정보가 없으면 기본 정보로 생성
    const name =
      String(formData.get("name") ?? "").trim() ||
      (user.user_metadata?.display_name as string | undefined) ||
      "";
    const grade = String(formData.get("grade") ?? "").trim() || "";
    const birthDate = String(formData.get("birth_date") ?? "").trim() || "";

    if (!name || !grade || !birthDate) {
      return {
        success: false,
        error: "필수 정보(이름, 학년, 생년월일)를 입력해주세요.",
      };
    }

    // user_metadata에서 tenant_id 가져오기 (회원가입 시 선택한 기관)
    const tenantIdFromMetadata = user.user_metadata?.tenant_id as
      | string
      | null
      | undefined;

    const createResult = await upsertStudent({
      id: user.id,
      tenant_id: tenantIdFromMetadata || null, // 회원가입 시 선택한 기관 사용, 없으면 기본 tenant 자동 할당
      name,
      grade,
      class: "",
      birth_date: birthDate,
    });

    if (!createResult.success) {
      return createResult;
    }

    // 생성된 학생 정보 다시 조회 (약간의 지연 후 재시도)
    // Supabase의 eventual consistency를 고려하여 재시도 로직 추가
    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 100; // 100ms

    while (retryCount < maxRetries) {
      existingStudent = await getStudentById(user.id);
      if (existingStudent) {
        break;
      }

      retryCount++;
      if (retryCount < maxRetries) {
        // 마지막 시도가 아니면 잠시 대기 후 재시도
        await new Promise((resolve) =>
          setTimeout(resolve, retryDelay * retryCount)
        );
      }
    }

    if (!existingStudent) {
      logActionError(
        { domain: "student", action: "updateStudentProfile", userId: user.id },
        new Error("학생 정보 생성 후 조회 실패"),
        { retryCount, createResult }
      );
      return {
        success: false,
        error:
          "학생 정보 생성 후 조회에 실패했습니다. 잠시 후 다시 시도해주세요.",
      };
    }
  }

  // 0. 이름 업데이트 (user_metadata의 display_name)
  const name = String(formData.get("name") ?? "").trim();
  if (name && name !== user.user_metadata?.display_name) {
    const { error: updateError } = await supabase.auth.updateUser({
      data: { display_name: name },
    });
    if (updateError) {
      logActionWarn(
        { domain: "student", action: "updateStudentProfile", userId: user.id },
        "이름 업데이트 실패 (계속 진행)",
        { error: updateError.message }
      );
    }
  }

  // 1. 기본 정보 업데이트
  const grade =
    String(formData.get("grade") ?? "").trim() || existingStudent.grade || "";
  const schoolId = String(formData.get("school_id") ?? "").trim() || null;
  const birthDate =
    String(formData.get("birth_date") ?? "").trim() ||
    existingStudent.birth_date ||
    "";

  // name이 없으면 기존 값 또는 user_metadata의 display_name 사용
  let nameValue = name || null;
  if (!nameValue) {
    nameValue =
      existingStudent.name || user.user_metadata?.display_name || null;
  }

  const basicResult = await upsertStudent({
    id: user.id,
    tenant_id: existingStudent.tenant_id ?? null,
    name: nameValue,
    grade,
    // 반 필드는 관리자만 수정 가능하므로 항상 기존 값 유지
    // 학생은 마이페이지에서 반 정보를 수정할 수 없음
    class: existingStudent.class || "",
    birth_date: birthDate,
    school_id: schoolId,
  });

  if (!basicResult.success) {
    return basicResult;
  }

  // 2. 프로필 정보 업데이트
  const gender = (formData.get("gender") as "남" | "여" | null) || null;

  // 전화번호 정규화 및 검증
  const phoneRaw = String(formData.get("phone") ?? "").trim();
  const motherPhoneRaw = String(formData.get("mother_phone") ?? "").trim();
  const fatherPhoneRaw = String(formData.get("father_phone") ?? "").trim();

  // 전화번호 검증
  if (phoneRaw) {
    const phoneValidation = validatePhoneNumber(phoneRaw);
    if (!phoneValidation.valid) {
      return { success: false, error: `본인 연락처: ${phoneValidation.error}` };
    }
  }

  if (motherPhoneRaw) {
    const motherPhoneValidation = validatePhoneNumber(motherPhoneRaw);
    if (!motherPhoneValidation.valid) {
      return {
        success: false,
        error: `모 연락처: ${motherPhoneValidation.error}`,
      };
    }
  }

  if (fatherPhoneRaw) {
    const fatherPhoneValidation = validatePhoneNumber(fatherPhoneRaw);
    if (!fatherPhoneValidation.valid) {
      return {
        success: false,
        error: `부 연락처: ${fatherPhoneValidation.error}`,
      };
    }
  }

  // 전화번호 정규화 (010-1234-5678 형식으로 통일)
  const phone = phoneRaw ? normalizePhoneNumber(phoneRaw) : null;
  const motherPhone = motherPhoneRaw
    ? normalizePhoneNumber(motherPhoneRaw)
    : null;
  const fatherPhone = fatherPhoneRaw
    ? normalizePhoneNumber(fatherPhoneRaw)
    : null;

  // 정규화 실패 시 에러 반환
  if (phoneRaw && !phone) {
    return {
      success: false,
      error: "본인 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
    };
  }
  if (motherPhoneRaw && !motherPhone) {
    return {
      success: false,
      error: "모 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
    };
  }
  if (fatherPhoneRaw && !fatherPhone) {
    return {
      success: false,
      error: "부 연락처 형식이 올바르지 않습니다 (010-1234-5678)",
    };
  }

  const profileResult = await upsertStudentProfile({
    id: user.id,
    tenant_id: existingStudent.tenant_id,
    gender,
    phone,
    mother_phone: motherPhone,
    father_phone: fatherPhone,
  });

  if (!profileResult.success) {
    return profileResult;
  }

  // 3. 진로 목표 정보 업데이트
  const examYearStr = String(formData.get("exam_year") ?? "").trim();
  const examYear = examYearStr ? parseInt(examYearStr, 10) : null;
  const curriculumRevision =
    (formData.get("curriculum_revision") as
      | "2009 개정"
      | "2015 개정"
      | "2022 개정"
      | null) || null;

  // desired_university_ids 배열 처리
  const desiredUniversityIds = formData
    .getAll("desired_university_ids")
    .map((id) => String(id).trim())
    .filter((id) => id.length > 0);

  // 진로 계열 (단일 선택)
  const desiredCareerField =
    (formData.get("desired_career_field") as CareerField | null) || null;

  const careerGoalResult = await upsertStudentCareerGoal({
    student_id: user.id,
    tenant_id: existingStudent.tenant_id,
    exam_year: examYear,
    curriculum_revision: curriculumRevision,
    desired_university_ids:
      desiredUniversityIds.length > 0 ? desiredUniversityIds : null,
    desired_career_field: desiredCareerField,
  });

  if (!careerGoalResult.success) {
    return careerGoalResult;
  }

  return { success: true };
}

/**
 * 현재 로그인한 학생 정보 조회 (기본 정보 + 프로필 + 진로 정보 통합)
 */
export async function getCurrentStudent(): Promise<
  | (Student &
      Partial<StudentProfile> &
      Partial<StudentCareerGoal> & { desired_career_field?: string | null })
  | null
> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return null;
  }

  const student = await getStudentById(user.id);
  if (!student) {
    return null;
  }

  // 이름은 user_metadata에서 가져오기
  const name = user.user_metadata?.display_name as string | undefined;

  // 프로필 정보 조회
  const profile = await getStudentProfileById(user.id);

  // 진로 목표 정보 조회
  const careerGoal = await getStudentCareerGoalById(user.id);

  return {
    ...student,
    name: name || student.name || null,
    ...profile,
    ...careerGoal,
    desired_career_field: careerGoal?.desired_career_field || null,
  };
}
</file>

<file path="sessions.ts">
"use server";

/**
 * Student Study Session Actions
 *
 * 학생 학습 세션 관리 Server Actions.
 */

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import {
  getActiveSession,
  createSession,
  endSession,
  deleteSession,
  getSessionById,
} from "@/lib/data/studentSessions";
import { getPlanById } from "@/lib/data/studentPlans";
import { recordHistory } from "@/lib/history/record";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { isSessionPaused } from "@/lib/utils/timerUtils";
import { TIMER_ERRORS } from "@/lib/domains/today/errors";
import { sessionLogger } from "@/lib/domains/today/logger";

/**
 * 학습 세션 시작
 */
export async function startStudySession(
  planId?: string
): Promise<{ success: boolean; sessionId?: string; error?: string; isDuplicate?: boolean }> {
  // planId가 없으면 세션 생성 불가 (고아 세션 방지)
  if (!planId) {
    sessionLogger.warn("planId 없이 startStudySession 호출됨 - 거부", {
      action: "startStudySession",
    });
    return { success: false, error: TIMER_ERRORS.PLAN_ID_REQUIRED };
  }

  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: TIMER_ERRORS.AUTH_REQUIRED };
  }

  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    return { success: false, error: TIMER_ERRORS.TENANT_NOT_FOUND };
  }

  try {
    // 기존 활성 세션 확인 (planId가 있는 경우 해당 플랜의 세션만 확인)
    if (planId) {
      // 특정 플랜의 활성 세션이 있는지 확인 (일시정지된 세션 제외)
      const supabase = await createSupabaseServerClient();
      const { data: existingSession } = await supabase
        .from("student_study_sessions")
        .select("id, paused_at, resumed_at")
        .eq("plan_id", planId)
        .eq("student_id", user.userId)
        .is("ended_at", null)
        .maybeSingle();

      // 일시정지되지 않은 실제 활성 세션이 있으면 에러 반환
      // 일시정지된 세션(paused_at이 있고 resumed_at이 없는 경우)은 허용
      if (existingSession && !isSessionPaused(existingSession)) {
        // 이미 해당 플랜의 세션이 활성화되어 있으면 에러 반환
        return { success: false, error: TIMER_ERRORS.TIMER_ALREADY_RUNNING_SAME_PLAN };
      }
    } else {
      // planId가 없는 경우 전체 활성 세션 확인
      const activeSession = await getActiveSession(
        user.userId,
        tenantContext.tenantId
      );
      if (activeSession) {
        // 기존 세션 강제 종료 후 새 세션 시작 (planId가 없는 경우만)
        await endStudySession(activeSession.id);
      }
    }

    // 플랜 정보 조회 (planId가 있는 경우)
    let contentType: string | null = null;
    let contentId: string | null = null;

    if (planId) {
      const plan = await getPlanById(
        planId,
        user.userId,
        tenantContext.tenantId
      );
      if (plan) {
        contentType = plan.content_type;
        contentId = plan.content_id;
      }
    }

    // 새 세션 생성
    const result = await createSession({
      tenant_id: tenantContext.tenantId,
      student_id: user.userId,
      plan_id: planId || null,
      content_type: contentType,
      content_id: contentId,
    });

    if (!result.success) {
      // isDuplicate: DB 유니크 제약 위반 시 true (Race Condition 발생)
      return { success: false, error: result.error, isDuplicate: result.isDuplicate };
    }

    // revalidatePath는 호출하는 쪽(startPlan 등)에서 처리하므로 여기서는 제거
    // 중복 호출 방지를 위해 제거 (성능 최적화)
    return { success: true, sessionId: result.sessionId };
  } catch (error) {
    sessionLogger.error("세션 시작 실패", {
      action: "startStudySession",
      id: planId,
      error: error instanceof Error ? error : new Error(String(error)),
    });
    return {
      success: false,
      error: error instanceof Error ? error.message : "세션 시작에 실패했습니다.",
    };
  }
}

/**
 * 학습 세션 종료
 */
export async function endStudySession(
  sessionId: string
): Promise<{ success: boolean; durationSeconds?: number; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "로그인이 필요합니다." };
  }

  try {
    const tenantContext = await getTenantContext();

    // 세션 조회 및 검증
    const session = await getSessionById(
      sessionId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!session) {
      return { success: false, error: "세션을 찾을 수 없습니다." };
    }

    if (session.ended_at) {
      return { success: false, error: "이미 종료된 세션입니다." };
    }

    // 일시정지된 시간 계산 (세션 종료 시)
    // Single Source of Truth: plan의 paused_duration_seconds를 사용
    // (resumePlan에서 plan에만 누적하고 session에는 업데이트하지 않음)
    let totalPausedDuration = 0;

    if (session.plan_id) {
      // plan의 paused_duration_seconds 조회 (누적된 일시정지 시간)
      const plan = await getPlanById(
        session.plan_id,
        user.userId,
        tenantContext?.tenantId || null
      );
      totalPausedDuration = plan?.paused_duration_seconds || 0;
    } else {
      // plan_id가 없는 경우 fallback (이전 호환성)
      totalPausedDuration = session.paused_duration_seconds || 0;
    }

    if (isSessionPaused(session)) {
      // 현재 일시정지 중인 경우, 아직 plan에 반영되지 않은 일시정지 시간 추가
      // isSessionPaused가 true면 paused_at은 반드시 존재
      const pausedAt = new Date(session.paused_at!);
      const now = new Date();
      const currentPauseDuration = Math.floor((now.getTime() - pausedAt.getTime()) / 1000);
      totalPausedDuration += currentPauseDuration;
    }

    // 세션 종료
    const result = await endSession(sessionId, user.userId, undefined, totalPausedDuration);

    if (!result.success) {
      return { success: false, error: result.error };
    }

    // 히스토리 기록
    if (session.content_type && session.content_id) {
      const { formatDateString } = await import("@/lib/date/calendarUtils");
      const sessionDate = formatDateString(new Date(session.started_at));
      const supabase = await createSupabaseServerClient();
      await recordHistory(
        supabase,
        user.userId,
        "study_session",
        {
          session_id: sessionId,
          duration: result.durationSeconds || 0,
          content_type: session.content_type,
          content_id: session.content_id,
          date: sessionDate,
        },
        tenantContext?.tenantId || null
      );
    }

    revalidatePath("/today");
    return { success: true, durationSeconds: result.durationSeconds };
  } catch (error) {
    sessionLogger.error("세션 종료 실패", {
      action: "endStudySession",
      id: sessionId,
      error: error instanceof Error ? error : new Error(String(error)),
    });
    return {
      success: false,
      error: error instanceof Error ? error.message : "세션 종료에 실패했습니다.",
    };
  }
}

/**
 * 학습 세션 취소 (삭제)
 */
export async function cancelStudySession(
  sessionId: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "로그인이 필요합니다." };
  }

  try {
    const tenantContext = await getTenantContext();

    // 세션 조회 및 검증
    const session = await getSessionById(
      sessionId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!session) {
      return { success: false, error: "세션을 찾을 수 없습니다." };
    }

    // 종료되지 않은 세션만 취소 가능
    if (session.ended_at) {
      return { success: false, error: "이미 종료된 세션은 취소할 수 없습니다." };
    }

    // 세션 삭제
    const result = await deleteSession(sessionId, user.userId);

    if (!result.success) {
      return { success: false, error: result.error };
    }

    revalidatePath("/today");
    revalidatePath("/dashboard");
    return { success: true };
  } catch (error) {
    sessionLogger.error("세션 취소 실패", {
      action: "cancelStudySession",
      id: sessionId,
      error: error instanceof Error ? error : new Error(String(error)),
    });
    return {
      success: false,
      error: error instanceof Error ? error.message : "세션 취소에 실패했습니다.",
    };
  }
}

/**
 * 학습 세션 일시정지
 */
export async function pauseStudySession(
  sessionId: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "로그인이 필요합니다." };
  }

  try {
    const tenantContext = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // 세션 조회 및 검증
    const session = await getSessionById(
      sessionId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!session) {
      return { success: false, error: "세션을 찾을 수 없습니다." };
    }

    if (session.ended_at) {
      return { success: false, error: "이미 종료된 세션입니다." };
    }

    // 이미 일시정지된 상태인지 확인
    if (isSessionPaused(session)) {
      return { success: false, error: "이미 일시정지된 상태입니다." };
    }

    // 세션 일시정지
    await supabase
      .from("student_study_sessions")
      .update({
        paused_at: new Date().toISOString(),
      })
      .eq("id", sessionId)
      .eq("student_id", user.userId);

    revalidatePath("/today");
    revalidatePath("/dashboard");
    return { success: true };
  } catch (error) {
    sessionLogger.error("세션 일시정지 실패", {
      action: "pauseStudySession",
      id: sessionId,
      error: error instanceof Error ? error : new Error(String(error)),
    });
    return {
      success: false,
      error: error instanceof Error ? error.message : "세션 일시정지에 실패했습니다.",
    };
  }
}

/**
 * 학습 세션 재개
 */
export async function resumeStudySession(
  sessionId: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "로그인이 필요합니다." };
  }

  try {
    const tenantContext = await getTenantContext();
    const supabase = await createSupabaseServerClient();

    // 세션 조회 및 검증
    const session = await getSessionById(
      sessionId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!session) {
      return { success: false, error: "세션을 찾을 수 없습니다." };
    }

    if (session.ended_at) {
      return { success: false, error: "이미 종료된 세션입니다." };
    }

    // 일시정지 상태인지 확인
    if (!isSessionPaused(session)) {
      return { success: false, error: "일시정지된 상태가 아닙니다." };
    }

    // 일시정지 시간 계산
    // isSessionPaused 통과 후이므로 paused_at은 반드시 존재
    const pausedAt = new Date(session.paused_at!);
    const resumedAt = new Date();
    const pauseDuration = Math.floor((resumedAt.getTime() - pausedAt.getTime()) / 1000);
    const totalPausedDuration = (session.paused_duration_seconds || 0) + pauseDuration;

    // 세션 재개
    await supabase
      .from("student_study_sessions")
      .update({
        resumed_at: resumedAt.toISOString(),
        paused_duration_seconds: totalPausedDuration,
      })
      .eq("id", sessionId)
      .eq("student_id", user.userId);

    revalidatePath("/today");
    revalidatePath("/dashboard");
    return { success: true };
  } catch (error) {
    sessionLogger.error("세션 재개 실패", {
      action: "resumeStudySession",
      id: sessionId,
      error: error instanceof Error ? error : new Error(String(error)),
    });
    return {
      success: false,
      error: error instanceof Error ? error.message : "세션 재개에 실패했습니다.",
    };
  }
}
</file>

<file path="useActivePlan.ts">
"use client";

import { queryOptions } from "@tanstack/react-query";
import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { CACHE_STALE_TIME_REALTIME, CACHE_GC_TIME_REALTIME } from "@/lib/constants/queryCache";
import { POSTGRES_ERROR_CODES } from "@/lib/constants/errorCodes";

type UseActivePlanOptions = {
  studentId: string;
  planDate: string;
  enabled?: boolean;
};

type ActivePlan = {
  id: string;
  plan_date: string;
  content_type: string | null;
  content_id: string | null;
  actual_start_time: string | null;
  actual_end_time: string | null;
  total_duration_seconds: number | null;
  paused_duration_seconds: number | null;
  pause_count: number | null;
} | null;

/**
 * 활성 플랜 조회 쿼리 옵션 (타입 안전)
 * 
 * queryOptions를 사용하여 타입 안전성을 향상시킵니다.
 * queryClient.getQueryData()에서도 타입 추론이 자동으로 됩니다.
 */
function activePlanQueryOptions(studentId: string, planDate: string) {
  return queryOptions({
    queryKey: ["activePlan", studentId, planDate] as const,
    queryFn: async (): Promise<ActivePlan> => {
      const supabase = createSupabaseBrowserClient();
      const { data: activeSession } = await supabase
        .from("student_study_sessions")
        .select("plan_id")
        .eq("student_id", studentId)
        .is("ended_at", null)
        .maybeSingle();

      if (!activeSession?.plan_id) {
        return null;
      }

      const { data: plan, error } = await supabase
        .from("student_plan")
        .select(
          "id,plan_date,content_type,content_id,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count"
        )
        .eq("id", activeSession.plan_id)
        .eq("plan_date", planDate)
        .maybeSingle();

      // 컬럼이 없는 경우 (UNDEFINED_COLUMN 에러) null 반환
      if (error && error.code === POSTGRES_ERROR_CODES.UNDEFINED_COLUMN) {
        console.warn("[useActivePlan] actual_start_time 컬럼이 없습니다. 마이그레이션을 실행해주세요.");
        return null;
      }

      if (error) throw error;

      return plan;
    },
    staleTime: CACHE_STALE_TIME_REALTIME, // 10초 (실시간 업데이트를 위해 짧게)
    gcTime: CACHE_GC_TIME_REALTIME, // 5분 (캐시 유지 시간)
    refetchInterval: 1000 * 30, // 30초마다 자동 리페치
  });
}

export function useActivePlan({
  studentId,
  planDate,
  enabled = true,
}: UseActivePlanOptions) {
  return useTypedQuery({
    ...activePlanQueryOptions(studentId, planDate),
    enabled,
  });
}

/**
 * 활성 플랜 쿼리 옵션을 외부에서도 사용할 수 있도록 export
 * (prefetchQuery 등에서 사용)
 */
export { activePlanQueryOptions };
</file>

<file path="useActivePlanDetails.ts">
"use client";

import { queryOptions } from "@tanstack/react-query";
import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { POSTGRES_ERROR_CODES } from "@/lib/constants/errorCodes";
import { CACHE_GC_TIME_REALTIME } from "@/lib/constants/queryCache";

type ActivePlanDetails = {
  id: string;
  title: string;
  contentType: "book" | "lecture" | "custom";
  actualStartTime: string;
  pausedDurationSeconds: number;
  pauseCount: number;
  isPaused: boolean;
};

type UseActivePlanDetailsOptions = {
  planId: string | null;
  enabled?: boolean;
};

/**
 * 활성 플랜 상세 정보 조회 쿼리 옵션 (타입 안전)
 * 
 * queryOptions를 사용하여 타입 안전성을 향상시킵니다.
 * queryClient.getQueryData()에서도 타입 추론이 자동으로 됩니다.
 */
function activePlanDetailsQueryOptions(planId: string) {
  return queryOptions({
    queryKey: ["activePlanDetails", planId] as const,
    queryFn: async (): Promise<ActivePlanDetails | null> => {
      const supabase = createSupabaseBrowserClient();

      // 플랜 기본 정보 조회
      const { data: plan, error: planError } = await supabase
        .from("student_plan")
        .select(
          "id, actual_start_time, actual_end_time, paused_duration_seconds, pause_count, content_type, content_id, content_title"
        )
        .eq("id", planId)
        .maybeSingle();

      if (planError) {
        // 컬럼이 없는 경우 (UNDEFINED_COLUMN 에러) null 반환
        if (planError.code === POSTGRES_ERROR_CODES.UNDEFINED_COLUMN) {
          return null;
        }
        throw planError;
      }

      if (!plan || !plan.actual_start_time) {
        return null;
      }

      // 활성 세션 조회하여 일시정지 상태 확인
      const { data: activeSession } = await supabase
        .from("student_study_sessions")
        .select("paused_at, resumed_at")
        .eq("plan_id", planId)
        .is("ended_at", null)
        .maybeSingle();

      const isPaused = activeSession?.paused_at && !activeSession?.resumed_at;

      // content_title이 있으면 사용, 없으면 콘텐츠 테이블에서 조회
      let title = plan.content_title || "학습 중";
      const contentType = (plan.content_type as "book" | "lecture" | "custom") || "book";

      if (!plan.content_title && plan.content_id) {
        try {
          if (contentType === "book") {
            const { data: book } = await supabase
              .from("books")
              .select("title")
              .eq("id", plan.content_id)
              .maybeSingle();
            title = book?.title || "책";
          } else if (contentType === "lecture") {
            const { data: lecture } = await supabase
              .from("lectures")
              .select("title")
              .eq("id", plan.content_id)
              .maybeSingle();
            title = lecture?.title || "강의";
          } else if (contentType === "custom") {
            const { data: custom } = await supabase
              .from("student_custom_contents")
              .select("title")
              .eq("id", plan.content_id)
              .maybeSingle();
            title = custom?.title || "커스텀 콘텐츠";
          }
        } catch (contentError) {
          console.warn("[useActivePlanDetails] 콘텐츠 제목 조회 실패", contentError);
          // 제목 조회 실패해도 계속 진행
        }
      }

      return {
        id: plan.id,
        title,
        contentType,
        actualStartTime: plan.actual_start_time,
        pausedDurationSeconds: plan.paused_duration_seconds || 0,
        pauseCount: plan.pause_count || 0,
        isPaused: !!isPaused,
      };
    },
    // Optimistic Update로 즉각적인 UI 반응이 보장되므로 캐시 전략 완화
    staleTime: 1000 * 60, // 1분 (Optimistic Update가 실시간성 보장)
    gcTime: CACHE_GC_TIME_REALTIME, // 5분 (캐시 유지 시간)
    refetchInterval: 1000 * 60, // 1분마다 자동 리페치 (백그라운드 동기화)
    refetchOnWindowFocus: false, // usePlanTimer가 포커스 시 동기화 처리
  });
}

/**
 * 활성 플랜 상세 정보를 React Query로 로드하는 훅
 * 지연 로딩을 위해 클라이언트에서만 실행
 */
export function useActivePlanDetails({
  planId,
  enabled = true,
}: UseActivePlanDetailsOptions) {
  return useTypedQuery({
    ...activePlanDetailsQueryOptions(planId || ""),
    enabled: enabled && !!planId,
  });
}

/**
 * 활성 플랜 상세 정보 쿼리 옵션을 외부에서도 사용할 수 있도록 export
 * (prefetchQuery 등에서 사용)
 */
export { activePlanDetailsQueryOptions };
</file>

<file path="useAdminDockQueries.ts">
'use client';

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useCallback } from 'react';
import {
  adminDockKeys,
  dailyPlansQueryOptions,
  dailyAdHocPlansQueryOptions,
  weeklyPlansQueryOptions,
  weeklyAdHocPlansQueryOptions,
  unfinishedPlansQueryOptions,
  getWeekRange,
  type DailyPlan,
  type WeeklyPlan,
  type UnfinishedPlan,
  type AdHocPlan,
} from '@/lib/query-options/adminDock';

/**
 * Daily Dock 쿼리 훅
 * @param studentId 학생 ID
 * @param date 날짜
 * @param plannerId 플래너 ID (선택, 플래너 기반 필터링용)
 */
export function useDailyDockQuery(studentId: string, date: string, plannerId?: string) {
  const queryClient = useQueryClient();

  const plansQuery = useQuery(dailyPlansQueryOptions(studentId, date, plannerId));
  const adHocQuery = useQuery(dailyAdHocPlansQueryOptions(studentId, date));

  const invalidate = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: adminDockKeys.daily(studentId, date, plannerId) });
    queryClient.invalidateQueries({ queryKey: adminDockKeys.dailyAdHoc(studentId, date) });
  }, [queryClient, studentId, date, plannerId]);

  return {
    plans: plansQuery.data ?? [],
    adHocPlans: adHocQuery.data ?? [],
    isLoading: plansQuery.isLoading || adHocQuery.isLoading,
    isError: plansQuery.isError || adHocQuery.isError,
    error: plansQuery.error || adHocQuery.error,
    invalidate,
    refetch: () => {
      plansQuery.refetch();
      adHocQuery.refetch();
    },
  };
}

/**
 * Weekly Dock 쿼리 훅
 * @param studentId 학생 ID
 * @param selectedDate 선택된 날짜
 * @param plannerId 플래너 ID (선택, 플래너 기반 필터링용)
 */
export function useWeeklyDockQuery(studentId: string, selectedDate: string, plannerId?: string) {
  const queryClient = useQueryClient();
  const weekRange = getWeekRange(selectedDate);

  const plansQuery = useQuery(
    weeklyPlansQueryOptions(studentId, weekRange.start, weekRange.end, plannerId)
  );
  const adHocQuery = useQuery(
    weeklyAdHocPlansQueryOptions(studentId, weekRange.start, weekRange.end)
  );

  const invalidate = useCallback(() => {
    queryClient.invalidateQueries({
      queryKey: adminDockKeys.weekly(studentId, weekRange.start, weekRange.end, plannerId),
    });
    queryClient.invalidateQueries({
      queryKey: adminDockKeys.weeklyAdHoc(studentId, weekRange.start, weekRange.end),
    });
  }, [queryClient, studentId, weekRange.start, weekRange.end, plannerId]);

  return {
    plans: plansQuery.data ?? [],
    adHocPlans: adHocQuery.data ?? [],
    isLoading: plansQuery.isLoading || adHocQuery.isLoading,
    isError: plansQuery.isError || adHocQuery.isError,
    error: plansQuery.error || adHocQuery.error,
    weekRange,
    invalidate,
    refetch: () => {
      plansQuery.refetch();
      adHocQuery.refetch();
    },
  };
}

/**
 * Unfinished Dock 쿼리 훅
 * @param studentId 학생 ID
 * @param plannerId 플래너 ID (선택, 플래너 기반 필터링용)
 */
export function useUnfinishedDockQuery(studentId: string, plannerId?: string) {
  const queryClient = useQueryClient();

  const plansQuery = useQuery(unfinishedPlansQueryOptions(studentId, plannerId));

  const invalidate = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: adminDockKeys.unfinished(studentId, plannerId) });
  }, [queryClient, studentId, plannerId]);

  return {
    plans: plansQuery.data ?? [],
    isLoading: plansQuery.isLoading,
    isError: plansQuery.isError,
    error: plansQuery.error,
    invalidate,
    refetch: plansQuery.refetch,
  };
}

/**
 * 모든 Admin Dock 쿼리 무효화
 * AdminPlanManagement에서 전체 새로고침 시 사용
 */
export function useInvalidateAllDockQueries() {
  const queryClient = useQueryClient();

  return useCallback(() => {
    queryClient.invalidateQueries({ queryKey: adminDockKeys.all });
  }, [queryClient]);
}

// Re-export types
export type { DailyPlan, WeeklyPlan, UnfinishedPlan, AdHocPlan };
</file>

<file path="useAdminFormSubmit.ts">
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";
import { z } from "zod";
import { useToast } from "@/components/ui/ToastProvider";
import { validateFormData } from "@/lib/validation/schemas";

type UseAdminFormSubmitOptions<T> = {
  action: (formData: FormData) => Promise<void | { success: boolean; message?: string }>;
  schema: z.ZodSchema<T>;
  onSuccess?: (data: T) => void | Promise<void>;
  successMessage?: string;
  redirectPath?: string;
  onError?: (error: Error) => void;
};

type UseAdminFormSubmitReturn = {
  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  handleSubmitWithFormData: (formData: FormData) => void;
  isPending: boolean;
};

/**
 * Admin 폼 제출 로직을 추상화한 커스텀 훅
 * 
 * @example
 * ```tsx
 * const { handleSubmit, isPending } = useAdminFormSubmit({
 *   action: addMasterBook,
 *   schema: masterBookSchema,
 *   successMessage: "교재가 성공적으로 등록되었습니다.",
 *   redirectPath: "/admin/master-books",
 * });
 * 
 * <form onSubmit={handleSubmit}>
 *   ...
 * </form>
 * ```
 */
export function useAdminFormSubmit<T>({
  action,
  schema,
  onSuccess,
  successMessage,
  redirectPath,
  onError,
}: UseAdminFormSubmitOptions<T>): UseAdminFormSubmitReturn {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();
  const { showError, showSuccess } = useToast();

  function handleSubmitWithFormData(formData: FormData) {
    // 클라이언트 사이드 검증
    const validation = validateFormData(formData, schema);
    if (!validation.success) {
      const firstError = validation.errors.errors[0];
      showError(firstError.message);
      return;
    }

    startTransition(async () => {
      try {
        const result = await action(formData);
        
        // 성공 메시지 표시
        if (successMessage) {
          showSuccess(successMessage);
        } else if (result && typeof result === "object" && "message" in result && result.message) {
          showSuccess(result.message);
        }

        // 성공 콜백 실행
        if (onSuccess) {
          await onSuccess(validation.data);
        }

        // 리다이렉트
        if (redirectPath) {
          router.push(redirectPath);
        }
      } catch (error) {
        console.error("폼 제출 실패:", error);
        const errorMessage =
          error instanceof Error ? error.message : "처리에 실패했습니다.";
        showError(errorMessage);
        
        // 에러 콜백 실행
        if (onError && error instanceof Error) {
          onError(error);
        }
      }
    });
  }

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    handleSubmitWithFormData(formData);
  }

  return { handleSubmit, handleSubmitWithFormData, isPending };
}
</file>

<file path="useAttendance.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { recordAttendanceAction } from "@/lib/domains/attendance";
import type { CreateAttendanceRecordInput } from "@/lib/domains/attendance/types";

/**
 * 출석 기록 생성/수정 Mutation 반환 타입
 */
export type RecordAttendanceResult = {
  success: boolean;
  error?: string;
  smsResult?: {
    success: boolean;
    error?: string;
    skipped?: boolean;
  };
};

/**
 * 출석 기록 생성/수정 Mutation
 * 성공 시 출석 목록 및 통계 쿼리를 자동으로 무효화합니다.
 */
export function useRecordAttendance() {
  const queryClient = useQueryClient();

  return useMutation<RecordAttendanceResult, Error, CreateAttendanceRecordInput>({
    mutationFn: async (input: CreateAttendanceRecordInput) => {
      const result = await recordAttendanceAction(input);
      if (!result.success) {
        throw new Error(result.error || "출석 기록 저장에 실패했습니다.");
      }
      return result;
    },
    onSuccess: () => {
      // 출석 목록 쿼리 무효화
      queryClient.invalidateQueries({
        queryKey: ["attendance", "list"],
      });
      // 출석 통계 쿼리 무효화
      queryClient.invalidateQueries({
        queryKey: ["attendance", "statistics"],
      });
      // 학생별 출석 기록 쿼리 무효화
      queryClient.invalidateQueries({
        queryKey: ["attendance", "student"],
      });
    },
  });
}
</file>

<file path="useBeforeUnload.ts">
/**
 * useBeforeUnload Hook
 * 페이지 이탈 시 경고 메시지를 표시합니다.
 *
 * @param shouldWarn - 경고를 표시할지 여부 (예: isDirty 상태)
 * @param message - 일부 브라우저에서 표시될 수 있는 메시지 (대부분의 모던 브라우저에서는 무시됨)
 */

import { useEffect } from "react";

export function useBeforeUnload(
  shouldWarn: boolean,
  message: string = "변경사항이 저장되지 않을 수 있습니다. 정말 나가시겠습니까?"
): void {
  useEffect(() => {
    if (!shouldWarn) return;

    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      // 표준에 따라 메시지를 설정해야 함
      e.preventDefault();
      e.returnValue = message; // Chrome에서는 빈 문자열이 필요
      return message; // 일부 브라우저에서는 반환값 필요
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [shouldWarn, message]);
}
</file>

<file path="useBlockSet.ts">
"use client";

/**
 * 블록 세트 관리 훅
 *
 * UI 컴포넌트에서 블록 세트 관련 비즈니스 로직을 분리했습니다.
 * Step1BasicInfo 등에서 사용합니다.
 */

import { useState, useCallback, useTransition } from "react";
import {
  createBlockSet,
  getBlockSets,
  updateBlockSet,
} from "@/lib/domains/block/actions";
import { isSuccessResponse } from "@/lib/types/actionResponse";

export type BlockSetItem = {
  id: string;
  name: string;
  blocks?: Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
  }>;
};

export type BlockSetMode = "select" | "create" | "edit";

export type TimeBlock = {
  day: number;
  startTime: string;
  endTime: string;
};

export type UseBlockSetOptions = {
  initialBlockSets?: BlockSetItem[];
  onBlockSetCreated?: (blockSet: { id: string; name: string }) => void;
  onBlockSetsLoaded?: (blockSets: BlockSetItem[]) => void;
};

export type UseBlockSetReturn = {
  // 상태
  blockSets: BlockSetItem[];
  mode: BlockSetMode;
  selectedBlockSetId: string | null;
  editingBlockSetId: string | null;
  isPending: boolean;
  isLoading: boolean;

  // 생성/수정 관련 상태
  newBlockSetName: string;
  editingBlockSetName: string;
  selectedWeekdays: number[];
  blockStartTime: string;
  blockEndTime: string;
  addedBlocks: TimeBlock[];

  // 액션
  setMode: (mode: BlockSetMode) => void;
  selectBlockSet: (id: string) => void;
  loadBlockSets: () => Promise<void>;
  createNewBlockSet: () => Promise<{ success: boolean; error?: string }>;
  updateExistingBlockSet: () => Promise<{ success: boolean; error?: string }>;
  startEdit: (blockSet: BlockSetItem) => void;
  cancelEdit: () => void;

  // 블록 관리
  setNewBlockSetName: (name: string) => void;
  setEditingBlockSetName: (name: string) => void;
  setSelectedWeekdays: (days: number[]) => void;
  setBlockStartTime: (time: string) => void;
  setBlockEndTime: (time: string) => void;
  addTimeBlock: () => void;
  removeTimeBlock: (index: number) => void;
  clearAddedBlocks: () => void;
};

/**
 * 블록 세트 관리 훅
 */
export function useBlockSet(
  options: UseBlockSetOptions = {}
): UseBlockSetReturn {
  const {
    initialBlockSets = [],
    onBlockSetCreated,
    onBlockSetsLoaded,
  } = options;

  const [blockSets, setBlockSets] = useState<BlockSetItem[]>(initialBlockSets);
  const [mode, setMode] = useState<BlockSetMode>("select");
  const [selectedBlockSetId, setSelectedBlockSetId] = useState<string | null>(
    null
  );
  const [editingBlockSetId, setEditingBlockSetId] = useState<string | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isPending, startTransition] = useTransition();

  // 생성/수정 관련 상태
  const [newBlockSetName, setNewBlockSetName] = useState("");
  const [editingBlockSetName, setEditingBlockSetName] = useState("");
  const [selectedWeekdays, setSelectedWeekdays] = useState<number[]>([]);
  const [blockStartTime, setBlockStartTime] = useState("");
  const [blockEndTime, setBlockEndTime] = useState("");
  const [addedBlocks, setAddedBlocks] = useState<TimeBlock[]>([]);

  // 블록 세트 목록 로드
  const loadBlockSets = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await getBlockSets();
      if (isSuccessResponse(result) && result.data) {
        setBlockSets(result.data);
        onBlockSetsLoaded?.(result.data);
      }
    } catch (error) {
      console.error("[useBlockSet] 블록 세트 로드 실패:", error);
    } finally {
      setIsLoading(false);
    }
  }, [onBlockSetsLoaded]);

  // 블록 세트 선택
  const selectBlockSet = useCallback((id: string) => {
    setSelectedBlockSetId(id);
  }, []);

  // 새 블록 세트 생성
  const createNewBlockSet = useCallback(async (): Promise<{
    success: boolean;
    error?: string;
  }> => {
    if (!newBlockSetName.trim()) {
      return { success: false, error: "블록 세트 이름을 입력해주세요." };
    }

    if (addedBlocks.length === 0) {
      return { success: false, error: "최소 하나의 시간 블록을 추가해주세요." };
    }

    return new Promise((resolve) => {
      startTransition(async () => {
        try {
          const formData = new FormData();
          formData.append("name", newBlockSetName);
          const result = await createBlockSet(formData);

          if (isSuccessResponse(result) && result.data) {
            const newBlockSet = {
              id: result.data.blockSetId,
              name: result.data.name,
              blocks: addedBlocks.map((block) => ({
                id: crypto.randomUUID(),
                day_of_week: block.day,
                start_time: block.startTime,
                end_time: block.endTime,
              })),
            };

            setBlockSets((prev) => [...prev, newBlockSet]);
            onBlockSetCreated?.({ id: result.data.blockSetId, name: result.data.name });
          }

          // 상태 초기화
          setNewBlockSetName("");
          setAddedBlocks([]);
          setSelectedWeekdays([]);
          setBlockStartTime("");
          setBlockEndTime("");
          setMode("select");

          resolve({ success: true });
        } catch (error) {
          console.error("[useBlockSet] 블록 세트 생성 실패:", error);
          resolve({ success: false, error: "생성 중 오류가 발생했습니다." });
        }
      });
    });
  }, [newBlockSetName, addedBlocks, onBlockSetCreated]);

  // 블록 세트 수정
  const updateExistingBlockSet = useCallback(async (): Promise<{
    success: boolean;
    error?: string;
  }> => {
    if (!editingBlockSetId) {
      return {
        success: false,
        error: "수정할 블록 세트가 선택되지 않았습니다.",
      };
    }

    if (!editingBlockSetName.trim()) {
      return { success: false, error: "블록 세트 이름을 입력해주세요." };
    }

    return new Promise((resolve) => {
      startTransition(async () => {
        try {
          const formData = new FormData();
          formData.append("id", editingBlockSetId);
          formData.append("name", editingBlockSetName);
          await updateBlockSet(formData);

          setBlockSets((prev) =>
            prev.map((bs) =>
              bs.id === editingBlockSetId
                ? { ...bs, name: editingBlockSetName }
                : bs
            )
          );

          // 상태 초기화
          setEditingBlockSetId(null);
          setEditingBlockSetName("");
          setMode("select");

          resolve({ success: true });
        } catch (error) {
          console.error("[useBlockSet] 블록 세트 수정 실패:", error);
          resolve({ success: false, error: "수정 중 오류가 발생했습니다." });
        }
      });
    });
  }, [editingBlockSetId, editingBlockSetName]);

  // 수정 시작
  const startEdit = useCallback((blockSet: BlockSetItem) => {
    setEditingBlockSetId(blockSet.id);
    setEditingBlockSetName(blockSet.name);
    setMode("edit");
  }, []);

  // 수정 취소
  const cancelEdit = useCallback(() => {
    setEditingBlockSetId(null);
    setEditingBlockSetName("");
    setNewBlockSetName("");
    setAddedBlocks([]);
    setSelectedWeekdays([]);
    setBlockStartTime("");
    setBlockEndTime("");
    setMode("select");
  }, []);

  // 시간 블록 추가
  const addTimeBlock = useCallback(() => {
    if (selectedWeekdays.length === 0 || !blockStartTime || !blockEndTime) {
      return;
    }

    const newBlocks = selectedWeekdays.map((day) => ({
      day,
      startTime: blockStartTime,
      endTime: blockEndTime,
    }));

    setAddedBlocks((prev) => [...prev, ...newBlocks]);
    setSelectedWeekdays([]);
    setBlockStartTime("");
    setBlockEndTime("");
  }, [selectedWeekdays, blockStartTime, blockEndTime]);

  // 시간 블록 제거
  const removeTimeBlock = useCallback((index: number) => {
    setAddedBlocks((prev) => prev.filter((_, i) => i !== index));
  }, []);

  // 추가된 블록 초기화
  const clearAddedBlocks = useCallback(() => {
    setAddedBlocks([]);
  }, []);

  return {
    // 상태
    blockSets,
    mode,
    selectedBlockSetId,
    editingBlockSetId,
    isPending,
    isLoading,

    // 생성/수정 관련 상태
    newBlockSetName,
    editingBlockSetName,
    selectedWeekdays,
    blockStartTime,
    blockEndTime,
    addedBlocks,

    // 액션
    setMode,
    selectBlockSet,
    loadBlockSets,
    createNewBlockSet,
    updateExistingBlockSet,
    startEdit,
    cancelEdit,

    // 블록 관리
    setNewBlockSetName,
    setEditingBlockSetName,
    setSelectedWeekdays,
    setBlockStartTime,
    setBlockEndTime,
    addTimeBlock,
    removeTimeBlock,
    clearAddedBlocks,
  };
}
</file>

<file path="useBlockSets.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { blockSetsQueryOptions } from "@/lib/query-options/blockSets";

type UseBlockSetsOptions = {
  studentId: string;
  enabled?: boolean;
};

/**
 * 블록 세트 목록 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: blockSets, isLoading } = useBlockSets({
 *   studentId: "student-123",
 * });
 * ```
 * 
 * @param options - 조회 옵션
 * @returns React Query 쿼리 결과
 */
export function useBlockSets({
  studentId,
  enabled = true,
}: UseBlockSetsOptions) {
  return useTypedQuery({
    ...blockSetsQueryOptions(studentId),
    enabled: enabled && !!studentId,
  });
}
</file>

<file path="useBookMetadata.ts">
"use client";

import { useState, useEffect } from "react";
import {
  getCurriculumRevisionsAction,
  getPublishersAction,
  getSubjectGroupsAction,
  getSubjectsByGroupAction,
} from "@/lib/domains/content";
import type { SubjectGroup, Subject } from "@/lib/data/subjects";

type UseBookMetadataReturn = {
  // 메타데이터 목록
  revisions: Array<{ id: string; name: string }>;
  subjectGroups: SubjectGroup[];
  subjects: Subject[];
  publishers: Array<{ id: string; name: string }>;

  // 선택된 ID
  selectedRevisionId: string;
  selectedSubjectGroupId: string;
  selectedSubjectId: string;
  selectedPublisherId: string;

  // 선택 핸들러
  setSelectedRevisionId: (id: string) => void;
  setSelectedSubjectGroupId: (id: string) => void;
  setSelectedSubjectId: (id: string) => void;
  setSelectedPublisherId: (id: string) => void;

  // 로딩 상태
  isLoading: boolean;

  // FormData 변환 헬퍼
  populateFormDataWithMetadata: (formData: FormData) => void;
};

/**
 * 교재 등록 시 필요한 메타데이터를 로드하고 관리하는 커스텀 훅
 */
export function useBookMetadata(): UseBookMetadataReturn {
  const [revisions, setRevisions] = useState<Array<{ id: string; name: string }>>([]);
  const [subjectGroups, setSubjectGroups] = useState<SubjectGroup[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [publishers, setPublishers] = useState<Array<{ id: string; name: string }>>([]);

  const [selectedRevisionId, setSelectedRevisionId] = useState<string>("");
  const [selectedSubjectGroupId, setSelectedSubjectGroupId] = useState<string>("");
  const [selectedSubjectId, setSelectedSubjectId] = useState<string>("");
  const [selectedPublisherId, setSelectedPublisherId] = useState<string>("");

  const [isLoading, setIsLoading] = useState(true);

  // 초기 메타데이터 로드 (개정교육과정, 출판사)
  useEffect(() => {
    async function loadMetadata() {
      try {
        setIsLoading(true);
        const [revs, pubs] = await Promise.all([
          getCurriculumRevisionsAction(),
          getPublishersAction(),
        ]);
        setRevisions(revs.filter((r) => r.is_active));
        setPublishers(pubs.filter((p) => p.is_active));
      } catch (error) {
        console.error("메타데이터 로드 실패:", error);
      } finally {
        setIsLoading(false);
      }
    }

    loadMetadata();
  }, []);

  // 개정교육과정 선택 시 교과 그룹 로드
  useEffect(() => {
    async function loadSubjectGroups() {
      if (selectedRevisionId) {
        try {
          const groups = await getSubjectGroupsAction(selectedRevisionId);
          setSubjectGroups(groups);
          setSelectedSubjectGroupId("");
          setSubjects([]);
        } catch (error) {
          console.error("교과 그룹 로드 실패:", error);
        }
      } else {
        setSubjectGroups([]);
        setSubjects([]);
      }
    }

    loadSubjectGroups();
  }, [selectedRevisionId]);

  // 교과 그룹 선택 시 과목 로드
  useEffect(() => {
    async function loadSubjects() {
      if (selectedSubjectGroupId) {
        try {
          const subs = await getSubjectsByGroupAction(selectedSubjectGroupId);
          setSubjects(subs);
          setSelectedSubjectId("");
        } catch (error) {
          console.error("과목 로드 실패:", error);
        }
      } else {
        setSubjects([]);
      }
    }

    loadSubjects();
  }, [selectedSubjectGroupId]);

  // FormData에 선택된 메타데이터 이름 추가
  function populateFormDataWithMetadata(formData: FormData) {
    // 개정교육과정 이름 추가
    if (selectedRevisionId) {
      const revision = revisions.find((r) => r.id === selectedRevisionId);
      if (revision) {
        formData.set("revision", revision.name);
      }
    }

    // 교과 이름 추가
    if (selectedSubjectGroupId) {
      const group = subjectGroups.find((g) => g.id === selectedSubjectGroupId);
      if (group) {
        formData.set("subject_category", group.name);
      }
    }

    // 과목 이름 추가
    if (selectedSubjectId) {
      const subject = subjects.find((s) => s.id === selectedSubjectId);
      if (subject) {
        formData.set("subject", subject.name);
      }
    }

    // 출판사 이름 추가
    if (selectedPublisherId) {
      const publisher = publishers.find((p) => p.id === selectedPublisherId);
      if (publisher) {
        formData.set("publisher_name", publisher.name);
      }
    }
  }

  return {
    revisions,
    subjectGroups,
    subjects,
    publishers,
    selectedRevisionId,
    selectedSubjectGroupId,
    selectedSubjectId,
    selectedPublisherId,
    setSelectedRevisionId,
    setSelectedSubjectGroupId,
    setSelectedSubjectId,
    setSelectedPublisherId,
    isLoading,
    populateFormDataWithMetadata,
  };
}
</file>

<file path="useCalendarTimeSelection.ts">
/**
 * useCalendarTimeSelection 훅
 *
 * 캘린더에서 드래그로 시간 범위를 선택하고 플랜 생성을 트리거합니다.
 *
 * @module lib/hooks/useCalendarTimeSelection
 */

"use client";

import { useState, useCallback, useRef, useMemo } from "react";

// ============================================================================
// 타입 정의
// ============================================================================

/**
 * 선택된 시간 범위
 */
export interface TimeSelection {
  /** 선택 날짜 (YYYY-MM-DD) */
  date: string;
  /** 시작 시간 (HH:MM) */
  startTime: string;
  /** 종료 시간 (HH:MM) */
  endTime: string;
  /** 선택 시간 (분 단위) */
  durationMinutes: number;
}

/**
 * 드래그 상태
 */
export interface DragState {
  /** 드래그 중 여부 */
  isDragging: boolean;
  /** 드래그 시작 시간 */
  startTime: string | null;
  /** 현재 드래그 위치 시간 */
  currentTime: string | null;
  /** 드래그 시작 날짜 */
  date: string | null;
}

/**
 * 훅 옵션
 */
export interface UseCalendarTimeSelectionOptions {
  /** 시간 간격 (분 단위, 기본값: 30) */
  timeSlotInterval?: number;
  /** 최소 선택 시간 (분 단위, 기본값: 30) */
  minDuration?: number;
  /** 최대 선택 시간 (분 단위, 기본값: 480 = 8시간) */
  maxDuration?: number;
  /** 선택 완료 콜백 */
  onSelectionComplete?: (selection: TimeSelection) => void;
  /** 선택 취소 콜백 */
  onSelectionCancel?: () => void;
}

// ============================================================================
// 상수
// ============================================================================

const DEFAULT_TIME_SLOT_INTERVAL = 30;
const DEFAULT_MIN_DURATION = 30;
const DEFAULT_MAX_DURATION = 480;

// ============================================================================
// 유틸리티 함수
// ============================================================================

/**
 * 시간을 분 단위로 변환
 */
function timeToMinutes(time: string): number {
  const [h, m] = time.split(":").map(Number);
  return h * 60 + m;
}

/**
 * 분을 시간 형식으로 변환
 */
function minutesToTime(minutes: number): string {
  const h = Math.floor(minutes / 60) % 24;
  const m = minutes % 60;
  return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
}

/**
 * 시간을 지정된 간격으로 반올림
 */
function roundToInterval(time: string, interval: number, roundUp: boolean = false): string {
  const minutes = timeToMinutes(time);
  const rounded = roundUp
    ? Math.ceil(minutes / interval) * interval
    : Math.floor(minutes / interval) * interval;
  return minutesToTime(Math.max(0, Math.min(1439, rounded)));
}

/**
 * Y 좌표를 시간으로 변환
 */
function yToTime(
  y: number,
  containerTop: number,
  containerHeight: number,
  startHour: number,
  endHour: number
): string {
  const relativeY = Math.max(0, Math.min(containerHeight, y - containerTop));
  const ratio = relativeY / containerHeight;
  const totalMinutes = (endHour - startHour) * 60;
  const minutes = startHour * 60 + ratio * totalMinutes;
  return minutesToTime(Math.round(minutes));
}

// ============================================================================
// 훅
// ============================================================================

/**
 * 캘린더 시간 선택 훅
 *
 * @example
 * ```tsx
 * const {
 *   selection,
 *   dragState,
 *   handlers,
 *   clearSelection,
 *   isSelecting
 * } = useCalendarTimeSelection({
 *   onSelectionComplete: (selection) => {
 *     // 플랜 생성 모달 열기
 *     setQuickAddOpen(true);
 *     setSelectedDate(selection.date);
 *     setSelectedStartTime(selection.startTime);
 *     setSelectedEndTime(selection.endTime);
 *   }
 * });
 *
 * return (
 *   <div
 *     ref={containerRef}
 *     {...handlers}
 *     className={cn("relative", isSelecting && "select-none")}
 *   >
 *     {// 캘린더 타임라인}
 *   </div>
 * );
 * ```
 */
export function useCalendarTimeSelection(
  options: UseCalendarTimeSelectionOptions = {}
) {
  const {
    timeSlotInterval = DEFAULT_TIME_SLOT_INTERVAL,
    minDuration = DEFAULT_MIN_DURATION,
    maxDuration = DEFAULT_MAX_DURATION,
    onSelectionComplete,
    onSelectionCancel,
  } = options;

  // 상태
  const [selection, setSelection] = useState<TimeSelection | null>(null);
  const [dragState, setDragState] = useState<DragState>({
    isDragging: false,
    startTime: null,
    currentTime: null,
    date: null,
  });

  // Refs
  const containerRef = useRef<HTMLDivElement | null>(null);
  const isDraggingRef = useRef(false);

  // 드래그 시작
  const handleDragStart = useCallback(
    (date: string, time: string, e: React.MouseEvent | React.TouchEvent) => {
      e.preventDefault();
      isDraggingRef.current = true;
      const roundedTime = roundToInterval(time, timeSlotInterval);

      setDragState({
        isDragging: true,
        startTime: roundedTime,
        currentTime: roundedTime,
        date,
      });
      setSelection(null);
    },
    [timeSlotInterval]
  );

  // 드래그 중
  const handleDragMove = useCallback(
    (time: string) => {
      if (!isDraggingRef.current || !dragState.startTime || !dragState.date) return;

      const roundedTime = roundToInterval(time, timeSlotInterval, true);

      setDragState((prev) => ({
        ...prev,
        currentTime: roundedTime,
      }));
    },
    [dragState.startTime, dragState.date, timeSlotInterval]
  );

  // 드래그 종료
  const handleDragEnd = useCallback(() => {
    if (!isDraggingRef.current) return;
    isDraggingRef.current = false;

    const { startTime, currentTime, date } = dragState;
    if (!startTime || !currentTime || !date) {
      setDragState({
        isDragging: false,
        startTime: null,
        currentTime: null,
        date: null,
      });
      return;
    }

    // 시작/종료 시간 정렬
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(currentTime);
    const actualStart = Math.min(startMinutes, endMinutes);
    const actualEnd = Math.max(startMinutes, endMinutes);
    const duration = actualEnd - actualStart;

    // 드래그 상태 초기화
    setDragState({
      isDragging: false,
      startTime: null,
      currentTime: null,
      date: null,
    });

    // 최소 시간 미만이면 취소
    if (duration < minDuration) {
      onSelectionCancel?.();
      return;
    }

    // 최대 시간 제한
    const limitedDuration = Math.min(duration, maxDuration);
    const limitedEnd = actualStart + limitedDuration;

    const finalSelection: TimeSelection = {
      date,
      startTime: minutesToTime(actualStart),
      endTime: minutesToTime(limitedEnd),
      durationMinutes: limitedDuration,
    };

    setSelection(finalSelection);
    onSelectionComplete?.(finalSelection);
  }, [dragState, minDuration, maxDuration, onSelectionComplete, onSelectionCancel]);

  // 선택 지우기
  const clearSelection = useCallback(() => {
    setSelection(null);
    setDragState({
      isDragging: false,
      startTime: null,
      currentTime: null,
      date: null,
    });
    isDraggingRef.current = false;
  }, []);

  // 드래그 중 미리보기 범위 계산
  const previewRange = useMemo(() => {
    if (!dragState.isDragging || !dragState.startTime || !dragState.currentTime) {
      return null;
    }

    const startMinutes = timeToMinutes(dragState.startTime);
    const endMinutes = timeToMinutes(dragState.currentTime);

    return {
      startTime: minutesToTime(Math.min(startMinutes, endMinutes)),
      endTime: minutesToTime(Math.max(startMinutes, endMinutes)),
      durationMinutes: Math.abs(endMinutes - startMinutes),
    };
  }, [dragState]);

  // 컨테이너에서 Y 좌표를 시간으로 변환하는 헬퍼
  const getTimeFromY = useCallback(
    (y: number, startHour: number = 0, endHour: number = 24): string | null => {
      if (!containerRef.current) return null;
      const rect = containerRef.current.getBoundingClientRect();
      return yToTime(y, rect.top, rect.height, startHour, endHour);
    },
    []
  );

  return {
    // 상태
    selection,
    dragState,
    previewRange,
    isSelecting: dragState.isDragging,

    // Ref
    containerRef,

    // 핸들러
    handleDragStart,
    handleDragMove,
    handleDragEnd,
    clearSelection,

    // 유틸리티
    getTimeFromY,
  };
}

/**
 * 드래그 선택 오버레이 스타일 계산
 */
export function getSelectionOverlayStyle(
  startTime: string,
  endTime: string,
  startHour: number = 0,
  endHour: number = 24
): React.CSSProperties {
  const totalMinutes = (endHour - startHour) * 60;
  const startMinutes = timeToMinutes(startTime) - startHour * 60;
  const endMinutes = timeToMinutes(endTime) - startHour * 60;

  const topPercent = (startMinutes / totalMinutes) * 100;
  const heightPercent = ((endMinutes - startMinutes) / totalMinutes) * 100;

  return {
    position: "absolute",
    top: `${topPercent}%`,
    height: `${heightPercent}%`,
    left: 0,
    right: 0,
    backgroundColor: "rgba(99, 102, 241, 0.2)",
    borderRadius: "0.25rem",
    border: "2px dashed rgb(99, 102, 241)",
    pointerEvents: "none" as const,
  };
}
</file>

<file path="useCampLearning.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import {
  campLearningStatsQueryOptions,
  campDatePlansQueryOptions,
  campLearningRecordsQueryOptions,
  campStudentLearningStatsQueryOptions,
} from "@/lib/query-options/campLearning";

// queryOptions re-export (하위 호환성)
export {
  campLearningStatsQueryOptions,
  campDatePlansQueryOptions,
  campLearningRecordsQueryOptions,
  campStudentLearningStatsQueryOptions,
};

/**
 * 캠프 학습 통계 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: learningStats, isLoading } = useCampLearningStats("template-123");
 * ```
 */
export function useCampLearningStats(
  templateId: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campLearningStatsQueryOptions(templateId),
    enabled: options?.enabled !== false && !!templateId,
  });
}

/**
 * 날짜별 플랜 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: planDetail, isLoading } = useCampDatePlans("template-123", "2024-01-15");
 * ```
 */
export function useCampDatePlans(
  templateId: string,
  date: string,
  studentIds?: string[],
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campDatePlansQueryOptions(templateId, date, studentIds),
    enabled: options?.enabled !== false && !!templateId && !!date,
  });
}

/**
 * 캠프 기간 전체 학습 기록 조회 훅 (달력용)
 * 
 * @example
 * ```typescript
 * const { data: records, isLoading } = useCampLearningRecords(
 *   "template-123",
 *   "2024-01-01",
 *   "2024-01-31"
 * );
 * ```
 */
export function useCampLearningRecords(
  templateId: string,
  startDate: string,
  endDate: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campLearningRecordsQueryOptions(templateId, startDate, endDate),
    enabled: options?.enabled !== false && !!templateId && !!startDate && !!endDate,
  });
}

/**
 * 학생별 학습 통계 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: stats, isLoading } = useCampStudentLearningStats(
 *   "template-123",
 *   "student-456"
 * );
 * ```
 */
export function useCampStudentLearningStats(
  templateId: string,
  studentId: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campStudentLearningStatsQueryOptions(templateId, studentId),
    enabled: options?.enabled !== false && !!templateId && !!studentId,
  });
}
</file>

<file path="useCampStats.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import {
  campStatsQueryOptions,
  campAttendanceStatsQueryOptions,
  campLearningStatsQueryOptions,
  campDateAttendanceQueryOptions,
  campAttendanceRecordsQueryOptions,
} from "@/lib/query-options/campStats";

// queryOptions re-export (하위 호환성)
export {
  campStatsQueryOptions,
  campAttendanceStatsQueryOptions,
  campLearningStatsQueryOptions,
  campDateAttendanceQueryOptions,
  campAttendanceRecordsQueryOptions,
};

/**
 * 캠프 출석 통계 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: attendanceStats, isLoading } = useCampAttendanceStats("template-123");
 * ```
 */
export function useCampAttendanceStats(
  templateId: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campAttendanceStatsQueryOptions(templateId),
    enabled: options?.enabled !== false && !!templateId,
  });
}

/**
 * 캠프 학습 통계 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: learningStats, isLoading } = useCampLearningStats("template-123");
 * ```
 */
export function useCampLearningStats(
  templateId: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campLearningStatsQueryOptions(templateId),
    enabled: options?.enabled !== false && !!templateId,
  });
}

/**
 * 캠프 통계 조회 훅 (출석 + 학습 통합)
 * 
 * @example
 * ```typescript
 * const { data, isLoading } = useCampStats("template-123");
 * // data.attendance, data.learning 사용
 * ```
 */
export function useCampStats(
  templateId: string,
  options?: { enabled?: boolean }
) {
  const statsQuery = useTypedQuery({
    ...campStatsQueryOptions(templateId),
    enabled: options?.enabled !== false && !!templateId,
  });

  return {
    data: statsQuery.data,
    attendance: statsQuery.data?.attendance ?? null,
    learning: statsQuery.data?.learning ?? null,
    isLoading: statsQuery.isLoading,
    isError: statsQuery.isError,
    error: statsQuery.error,
  };
}

/**
 * 날짜별 출석 기록 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: records, isLoading } = useCampDateAttendance("template-123", "2024-01-15");
 * ```
 */
export function useCampDateAttendance(
  templateId: string,
  date: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campDateAttendanceQueryOptions(templateId, date),
    enabled: options?.enabled !== false && !!templateId && !!date,
  });
}

/**
 * 캠프 기간 전체 출석 기록 조회 훅 (달력용)
 * 
 * @example
 * ```typescript
 * const { data: records, isLoading } = useCampAttendanceRecords(
 *   "template-123",
 *   "2024-01-01",
 *   "2024-01-31"
 * );
 * ```
 */
export function useCampAttendanceRecords(
  templateId: string,
  startDate: string,
  endDate: string,
  options?: { enabled?: boolean }
) {
  return useTypedQuery({
    ...campAttendanceRecordsQueryOptions(templateId, startDate, endDate),
    enabled: options?.enabled !== false && !!templateId && !!startDate && !!endDate,
  });
}
</file>

<file path="useCampTemplates.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { campTemplatesQueryOptions, type CampTemplatesFilters } from "@/lib/query-options/campTemplates";

// 타입 re-export (하위 호환성)
export type { CampTemplatesFilters };

type UseCampTemplatesOptions = {
  tenantId: string;
  page?: number;
  pageSize?: number;
  filters?: CampTemplatesFilters;
  enabled?: boolean;
};

/**
 * 캠프 템플릿 목록 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: templates, isLoading } = useCampTemplates({
 *   tenantId: "tenant-123",
 *   page: 1,
 *   pageSize: 20,
 *   filters: {
 *     search: "윈터",
 *     status: "active",
 *   },
 * });
 * ```
 * 
 * @param options - 조회 옵션
 * @returns React Query 쿼리 결과
 */
export function useCampTemplates({
  tenantId,
  page = 1,
  pageSize = 20,
  filters = {},
  enabled = true,
}: UseCampTemplatesOptions) {
  return useTypedQuery({
    ...campTemplatesQueryOptions(tenantId, {
      page,
      pageSize,
      filters,
    }),
    enabled: enabled && !!tenantId,
  });
}
</file>

<file path="useContainerDragDrop.ts">
'use client';

import { useState, useCallback, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useToast } from '@/components/ui/ToastProvider';
import { handlePlanDrop, moveAdHocPlan, type ContainerType, type DropTarget } from '@/lib/domains/plan/actions/move';

export type DragItemType = 'student_plan' | 'ad_hoc_plan';

export type ContainerDragItem = {
  id: string;
  type: DragItemType;
  sourceContainer: ContainerType;
  title: string;
};

export type ContainerDropZone = {
  container: ContainerType;
};

interface UseContainerDragDropOptions {
  onMoveSuccess?: () => void;
  onMoveError?: (error: string) => void;
}

/**
 * 컨테이너 간 드래그앤드롭을 위한 커스텀 훅
 *
 * HTML5 Drag and Drop API를 사용하여 플랜을 다른 컨테이너로 이동합니다.
 *
 * 컨테이너:
 * - unfinished: 미완료 (이월된 플랜)
 * - daily: 오늘 할 일
 * - weekly: 이번 주 유동
 */
export function useContainerDragDrop(options?: UseContainerDragDropOptions) {
  const router = useRouter();
  const { showToast } = useToast();

  const [draggedItem, setDraggedItem] = useState<ContainerDragItem | null>(null);
  const [dropTargetContainer, setDropTargetContainer] = useState<ContainerType | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const dragImageRef = useRef<HTMLDivElement | null>(null);
  const draggedElementRef = useRef<HTMLElement | null>(null);

  // 드래그 이미지 요소 생성 (화면 밖에 위치)
  useEffect(() => {
    if (!dragImageRef.current) {
      const div = document.createElement('div');
      div.style.cssText = `
        position: fixed;
        left: -1000px;
        top: -1000px;
        padding: 8px 12px;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        font-size: 14px;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        z-index: 9999;
      `;
      document.body.appendChild(div);
      dragImageRef.current = div;
    }

    return () => {
      if (dragImageRef.current && document.body.contains(dragImageRef.current)) {
        document.body.removeChild(dragImageRef.current);
        dragImageRef.current = null;
      }
    };
  }, []);

  // 드래그 시작 핸들러
  const handleDragStart = useCallback(
    (e: React.DragEvent<HTMLDivElement>, item: ContainerDragItem) => {
      if (isProcessing) {
        e.preventDefault();
        return;
      }

      setDraggedItem(item);
      draggedElementRef.current = e.currentTarget;

      // 드래그 이미지 설정
      if (dragImageRef.current) {
        dragImageRef.current.textContent = `📦 ${item.title}`;
        e.dataTransfer.setDragImage(dragImageRef.current, 0, 0);
      }

      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('application/json', JSON.stringify(item));

      // 드래그 시작 시 시각적 피드백
      requestAnimationFrame(() => {
        if (draggedElementRef.current) {
          draggedElementRef.current.style.opacity = '0.5';
          draggedElementRef.current.style.transform = 'scale(0.98)';
        }
      });
    },
    [isProcessing]
  );

  // 드래그 종료 핸들러
  const handleDragEnd = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    setDraggedItem(null);
    setDropTargetContainer(null);

    // 시각적 피드백 복원
    if (draggedElementRef.current) {
      draggedElementRef.current.style.opacity = '1';
      draggedElementRef.current.style.transform = 'scale(1)';
    }
    draggedElementRef.current = null;
  }, []);

  // 드롭 영역 진입 핸들러
  const handleDragEnter = useCallback(
    (e: React.DragEvent<HTMLDivElement>, container: ContainerType) => {
      e.preventDefault();
      e.stopPropagation();

      // 같은 컨테이너로는 드롭 불가
      if (draggedItem && draggedItem.sourceContainer === container) {
        e.dataTransfer.dropEffect = 'none';
        return;
      }

      setDropTargetContainer(container);
      e.dataTransfer.dropEffect = 'move';
    },
    [draggedItem]
  );

  // 드롭 영역 위 핸들러
  const handleDragOver = useCallback(
    (e: React.DragEvent<HTMLDivElement>, container: ContainerType) => {
      e.preventDefault();
      e.stopPropagation();

      // 같은 컨테이너로는 드롭 불가
      if (draggedItem && draggedItem.sourceContainer === container) {
        e.dataTransfer.dropEffect = 'none';
        return;
      }

      e.dataTransfer.dropEffect = 'move';
    },
    [draggedItem]
  );

  // 드롭 영역 이탈 핸들러
  const handleDragLeave = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();

    // 자식 요소로 이동할 때는 무시
    const relatedTarget = e.relatedTarget as HTMLElement | null;
    const currentTarget = e.currentTarget as HTMLElement;
    if (relatedTarget && currentTarget.contains(relatedTarget)) {
      return;
    }

    setDropTargetContainer(null);
  }, []);

  // 드롭 처리 핸들러
  const handleDrop = useCallback(
    async (e: React.DragEvent<HTMLDivElement>, targetContainer: ContainerType) => {
      e.preventDefault();
      e.stopPropagation();

      setDropTargetContainer(null);

      const data = e.dataTransfer.getData('application/json');
      if (!data) return;

      try {
        const item: ContainerDragItem = JSON.parse(data);

        // 같은 컨테이너로는 이동하지 않음
        if (item.sourceContainer === targetContainer) {
          return;
        }

        setIsProcessing(true);

        const dropTarget: DropTarget = {
          container: targetContainer,
        };

        let result;
        if (item.type === 'ad_hoc_plan') {
          // Ad-hoc 플랜은 별도 함수 사용
          const today = new Date().toISOString().split('T')[0];
          result = await moveAdHocPlan(item.id, today, targetContainer);
        } else {
          result = await handlePlanDrop(item.id, dropTarget);
        }

        if (result.success) {
          const containerName = getContainerDisplayName(targetContainer);
          showToast(`"${item.title}"을(를) ${containerName}(으)로 이동했습니다.`, 'success');
          options?.onMoveSuccess?.();
          router.refresh();
        } else {
          showToast(result.error || '플랜 이동에 실패했습니다.', 'error');
          options?.onMoveError?.(result.error || 'Unknown error');
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        showToast('플랜 이동 중 오류가 발생했습니다.', 'error');
        options?.onMoveError?.(errorMessage);
      } finally {
        setIsProcessing(false);
        setDraggedItem(null);
      }
    },
    [router, showToast, options]
  );

  // 드래그 가능 요소 속성 생성
  const getDraggableProps = useCallback(
    (item: ContainerDragItem) => ({
      draggable: !isProcessing,
      onDragStart: (e: React.DragEvent<HTMLDivElement>) => handleDragStart(e, item),
      onDragEnd: handleDragEnd,
    }),
    [isProcessing, handleDragStart, handleDragEnd]
  );

  // 드롭 영역 속성 생성
  const getDropZoneProps = useCallback(
    (container: ContainerType) => ({
      onDragEnter: (e: React.DragEvent<HTMLDivElement>) => handleDragEnter(e, container),
      onDragOver: (e: React.DragEvent<HTMLDivElement>) => handleDragOver(e, container),
      onDragLeave: handleDragLeave,
      onDrop: (e: React.DragEvent<HTMLDivElement>) => handleDrop(e, container),
    }),
    [handleDragEnter, handleDragOver, handleDragLeave, handleDrop]
  );

  // 드롭 가능 여부 확인
  const canDropOnContainer = useCallback(
    (container: ContainerType) => {
      if (!draggedItem) return false;
      return draggedItem.sourceContainer !== container;
    },
    [draggedItem]
  );

  // 특정 컨테이너가 현재 드롭 타겟인지 확인
  const isDropTarget = useCallback(
    (container: ContainerType) => {
      return dropTargetContainer === container && canDropOnContainer(container);
    },
    [dropTargetContainer, canDropOnContainer]
  );

  return {
    // 상태
    draggedItem,
    dropTargetContainer,
    isProcessing,
    isDragging: draggedItem !== null,

    // 헬퍼 함수
    getDraggableProps,
    getDropZoneProps,
    canDropOnContainer,
    isDropTarget,
  };
}

// 컨테이너 표시명
function getContainerDisplayName(container: ContainerType): string {
  switch (container) {
    case 'unfinished':
      return '미완료';
    case 'daily':
      return '오늘 할 일';
    case 'weekly':
      return '주간 유동';
    default:
      return container;
  }
}
</file>

<file path="useContainerMoveActions.ts">
'use client';

import { useOptimistic, useTransition, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useToast } from '@/components/ui/ToastProvider';
import { moveToDaily, moveToWeekly } from '@/lib/domains/today/actions/containerPlans';
import type { ContainerSummary, ContainerPlan } from '@/lib/domains/today/actions/containerPlans';
import type { AdHocPlan, ContainerType } from '@/lib/domains/admin-plan/types';

type MoveAction = {
  type: 'moveToDaily' | 'moveToWeekly';
  planId: string;
  planType: 'student_plan' | 'ad_hoc_plan';
  sourceContainer: ContainerType;
};

/**
 * 컨테이너 이동 액션을 위한 커스텀 훅
 * - useOptimistic을 사용하여 즉각적인 UI 피드백 제공
 * - 성공/실패 시 토스트 알림 표시
 * - router.refresh()로 서버 데이터와 동기화
 */
export function useContainerMoveActions(initialData: ContainerSummary) {
  const router = useRouter();
  const { showToast } = useToast();
  const [isPending, startTransition] = useTransition();

  // Optimistic state management
  const [optimisticData, addOptimisticUpdate] = useOptimistic(
    initialData,
    (currentData: ContainerSummary, action: MoveAction): ContainerSummary => {
      const { type, planId, planType, sourceContainer } = action;
      const targetContainer: ContainerType = type === 'moveToDaily' ? 'daily' : 'weekly';

      // 같은 컨테이너로 이동하는 경우 무시
      if (sourceContainer === targetContainer) {
        return currentData;
      }

      // Deep clone the current data
      const newData: ContainerSummary = {
        unfinished: {
          plans: [...currentData.unfinished.plans],
          adHocPlans: [...currentData.unfinished.adHocPlans],
          totalCount: currentData.unfinished.totalCount,
        },
        daily: {
          plans: [...currentData.daily.plans],
          adHocPlans: [...currentData.daily.adHocPlans],
          totalCount: currentData.daily.totalCount,
          completedCount: currentData.daily.completedCount,
        },
        weekly: {
          plans: [...currentData.weekly.plans],
          adHocPlans: [...currentData.weekly.adHocPlans],
          totalCount: currentData.weekly.totalCount,
        },
      };

      // Find and remove from source container
      let movedPlan: ContainerPlan | undefined;
      let movedAdHocPlan: AdHocPlan | undefined;

      const sourceContainerData = newData[sourceContainer];
      if (planType === 'student_plan') {
        const planIndex = sourceContainerData.plans.findIndex((p) => p.id === planId);
        if (planIndex !== -1) {
          [movedPlan] = sourceContainerData.plans.splice(planIndex, 1);
          // Update container_type on the moved plan
          movedPlan = { ...movedPlan, container_type: targetContainer };
        }
      } else {
        const planIndex = sourceContainerData.adHocPlans.findIndex((p) => p.id === planId);
        if (planIndex !== -1) {
          [movedAdHocPlan] = sourceContainerData.adHocPlans.splice(planIndex, 1);
          // Update container_type on the moved plan
          movedAdHocPlan = { ...movedAdHocPlan, container_type: targetContainer };
        }
      }

      // Add to target container
      const targetContainerData = newData[targetContainer];
      if (movedPlan) {
        targetContainerData.plans.push(movedPlan);
      }
      if (movedAdHocPlan) {
        targetContainerData.adHocPlans.push(movedAdHocPlan);
      }

      // Recalculate counts
      newData.unfinished.totalCount =
        newData.unfinished.plans.length + newData.unfinished.adHocPlans.length;
      newData.daily.totalCount =
        newData.daily.plans.length + newData.daily.adHocPlans.length;
      newData.weekly.totalCount =
        newData.weekly.plans.length + newData.weekly.adHocPlans.length;

      return newData;
    }
  );

  const handleMoveToDaily = useCallback(
    (planId: string, planType: 'student_plan' | 'ad_hoc_plan', sourceContainer: ContainerType) => {
      // Immediate optimistic update
      addOptimisticUpdate({
        type: 'moveToDaily',
        planId,
        planType,
        sourceContainer,
      });

      startTransition(async () => {
        try {
          const result = await moveToDaily(planId, planType);
          if (result.success) {
            showToast('오늘 할 일로 이동했습니다', 'success');
          } else {
            showToast(result.error ?? '이동에 실패했습니다', 'error');
          }
        } catch {
          showToast('오류가 발생했습니다', 'error');
        }
        // 항상 서버 데이터와 동기화 (성공/실패 모두)
        router.refresh();
      });
    },
    [addOptimisticUpdate, showToast, router]
  );

  const handleMoveToWeekly = useCallback(
    (planId: string, planType: 'student_plan' | 'ad_hoc_plan', sourceContainer: ContainerType) => {
      // Immediate optimistic update
      addOptimisticUpdate({
        type: 'moveToWeekly',
        planId,
        planType,
        sourceContainer,
      });

      startTransition(async () => {
        try {
          const result = await moveToWeekly(planId, planType);
          if (result.success) {
            showToast('주간 유동으로 이동했습니다', 'success');
          } else {
            showToast(result.error ?? '이동에 실패했습니다', 'error');
          }
        } catch {
          showToast('오류가 발생했습니다', 'error');
        }
        // 항상 서버 데이터와 동기화 (성공/실패 모두)
        router.refresh();
      });
    },
    [addOptimisticUpdate, showToast, router]
  );

  return {
    optimisticData,
    isPending,
    handleMoveToDaily,
    handleMoveToWeekly,
  };
}
</file>

<file path="useDebounce.ts">
"use client";

import { useState, useEffect, useRef, useCallback } from "react";

/**
 * useDebounce 훅
 * 
 * 입력값 변경을 debounce하여 불필요한 재계산을 방지합니다.
 * 주로 서버 요청이나 무거운 계산을 지연시킬 때 사용합니다.
 * 
 * @param value - debounce할 값
 * @param delay - 지연 시간 (밀리초), 기본값 500ms
 * @returns debounce된 값
 * 
 * @example
 * ```tsx
 * const [searchTerm, setSearchTerm] = useState("");
 * const debouncedSearchTerm = useDebounce(searchTerm, 500);
 * 
 * useEffect(() => {
 *   if (debouncedSearchTerm) {
 *     // 500ms 후에 실행됨
 *     performSearch(debouncedSearchTerm);
 *   }
 * }, [debouncedSearchTerm]);
 * ```
 */
export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // delay 시간 후에 값을 업데이트
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // cleanup: 컴포넌트 언마운트 또는 value/delay 변경 시 이전 타이머 취소
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

/**
 * useDebouncedCallback 훅
 *
 * 콜백 함수 호출을 debounce하여 불필요한 실행을 방지합니다.
 * 마지막 호출로부터 delay 시간이 지난 후에만 실행됩니다.
 *
 * @param callback - debounce할 콜백 함수
 * @param delay - 지연 시간 (밀리초), 기본값 500ms
 * @returns debounce된 콜백 함수
 *
 * @example
 * ```tsx
 * const debouncedSave = useDebouncedCallback(
 *   () => saveToServer(),
 *   500
 * );
 *
 * // 빠른 연속 호출 시 마지막 호출만 실행됨
 * debouncedSave();
 * ```
 */
export function useDebouncedCallback<T extends (...args: unknown[]) => void>(
  callback: T,
  delay: number = 500
): (...args: Parameters<T>) => void {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const callbackRef = useRef(callback);

  // 최신 콜백 유지
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        callbackRef.current(...args);
      }, delay);
    },
    [delay]
  );
}
</file>

<file path="useDeviceConflict.ts">
"use client";

/**
 * Device Conflict Management Hook
 *
 * 멀티 디바이스 충돌을 감지하고 관리하는 React 훅입니다.
 *
 * @example
 * function PlanTimer({ planId }: { planId: string }) {
 *   const {
 *     hasConflict,
 *     conflictInfo,
 *     checkForConflict,
 *     takeover,
 *     dismiss,
 *   } = useDeviceConflict(planId);
 *
 *   if (hasConflict && conflictInfo) {
 *     return (
 *       <ConflictWarning
 *         deviceDescription={conflictInfo.deviceDescription}
 *         onTakeover={takeover}
 *         onDismiss={dismiss}
 *       />
 *     );
 *   }
 *
 *   return <TimerDisplay />;
 * }
 */

import { useState, useCallback, useEffect, useRef } from "react";
import {
  getOrCreateDeviceSessionId,
  getDeviceInfo,
} from "@/lib/device";
import {
  checkDeviceConflict,
  updateSessionHeartbeat,
  takeoverSession,
  setSessionDeviceInfo,
  type DeviceConflictInfo,
} from "@/lib/domains/today";

// Heartbeat 간격 (30초)
const HEARTBEAT_INTERVAL_MS = 30 * 1000;

export type UseDeviceConflictOptions = {
  /** 플랜 ID */
  planId: string;
  /** 자동 heartbeat 활성화 여부 */
  enableHeartbeat?: boolean;
  /** 충돌 발생 시 콜백 */
  onConflictDetected?: (conflict: DeviceConflictInfo) => void;
  /** 충돌 해결 시 콜백 */
  onConflictResolved?: () => void;
};

export type UseDeviceConflictReturn = {
  /** 충돌 발생 여부 */
  hasConflict: boolean;
  /** 충돌 정보 */
  conflictInfo: DeviceConflictInfo | null;
  /** 현재 디바이스 세션 ID */
  deviceSessionId: string;
  /** 충돌 확인 진행 중 */
  isChecking: boolean;
  /** 인수 진행 중 */
  isTakingOver: boolean;
  /** 활성 세션 ID */
  activeSessionId: string | null;
  /** 충돌 확인 */
  checkForConflict: () => Promise<boolean>;
  /** 세션 인수 (다른 디바이스에서 가져오기) */
  takeover: () => Promise<boolean>;
  /** 충돌 경고 무시 */
  dismiss: () => void;
  /** 세션에 디바이스 정보 설정 */
  registerDevice: (sessionId: string) => Promise<boolean>;
  /** Heartbeat 전송 */
  sendHeartbeat: () => Promise<boolean>;
};

export function useDeviceConflict({
  planId,
  enableHeartbeat = true,
  onConflictDetected,
  onConflictResolved,
}: UseDeviceConflictOptions): UseDeviceConflictReturn {
  const [hasConflict, setHasConflict] = useState(false);
  const [conflictInfo, setConflictInfo] = useState<DeviceConflictInfo | null>(null);
  const [isChecking, setIsChecking] = useState(false);
  const [isTakingOver, setIsTakingOver] = useState(false);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);

  const deviceSessionId = useRef<string>("");
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // 초기화: 디바이스 세션 ID 가져오기
  useEffect(() => {
    deviceSessionId.current = getOrCreateDeviceSessionId();
  }, []);

  // Heartbeat 설정
  useEffect(() => {
    if (!enableHeartbeat || !activeSessionId) {
      return;
    }

    // 즉시 heartbeat 전송
    updateSessionHeartbeat(activeSessionId).catch(console.error);

    // 주기적 heartbeat
    heartbeatIntervalRef.current = setInterval(() => {
      if (activeSessionId) {
        updateSessionHeartbeat(activeSessionId).catch(console.error);
      }
    }, HEARTBEAT_INTERVAL_MS);

    return () => {
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }
    };
  }, [enableHeartbeat, activeSessionId]);

  // 충돌 확인
  const checkForConflict = useCallback(async (): Promise<boolean> => {
    if (!planId) return false;

    setIsChecking(true);
    try {
      const result = await checkDeviceConflict(planId, deviceSessionId.current);

      if (result.activeSession) {
        setActiveSessionId(result.activeSession.id);
      }

      if (result.hasConflict && result.conflict) {
        setHasConflict(true);
        setConflictInfo(result.conflict);
        onConflictDetected?.(result.conflict);
        return true;
      }

      setHasConflict(false);
      setConflictInfo(null);
      return false;
    } catch (error) {
      console.error("[useDeviceConflict] 충돌 확인 오류:", error);
      return false;
    } finally {
      setIsChecking(false);
    }
  }, [planId, onConflictDetected]);

  // 세션 인수
  const takeover = useCallback(async (): Promise<boolean> => {
    if (!activeSessionId) {
      console.warn("[useDeviceConflict] 인수할 세션이 없습니다.");
      return false;
    }

    setIsTakingOver(true);
    try {
      const result = await takeoverSession(
        activeSessionId,
        deviceSessionId.current,
        getDeviceInfo()
      );

      if (result.success) {
        setHasConflict(false);
        setConflictInfo(null);
        onConflictResolved?.();
        return true;
      }

      console.error("[useDeviceConflict] 세션 인수 실패:", result.error);
      return false;
    } catch (error) {
      console.error("[useDeviceConflict] 세션 인수 오류:", error);
      return false;
    } finally {
      setIsTakingOver(false);
    }
  }, [activeSessionId, onConflictResolved]);

  // 충돌 경고 무시
  const dismiss = useCallback(() => {
    setHasConflict(false);
    setConflictInfo(null);
  }, []);

  // 세션에 디바이스 정보 등록
  const registerDevice = useCallback(async (sessionId: string): Promise<boolean> => {
    try {
      const result = await setSessionDeviceInfo(
        sessionId,
        deviceSessionId.current,
        getDeviceInfo()
      );

      if (result.success) {
        setActiveSessionId(sessionId);
        return true;
      }

      console.error("[useDeviceConflict] 디바이스 등록 실패:", result.error);
      return false;
    } catch (error) {
      console.error("[useDeviceConflict] 디바이스 등록 오류:", error);
      return false;
    }
  }, []);

  // Heartbeat 전송
  const sendHeartbeat = useCallback(async (): Promise<boolean> => {
    if (!activeSessionId) {
      return false;
    }

    try {
      const result = await updateSessionHeartbeat(activeSessionId);
      return result.success;
    } catch (error) {
      console.error("[useDeviceConflict] Heartbeat 전송 오류:", error);
      return false;
    }
  }, [activeSessionId]);

  return {
    hasConflict,
    conflictInfo,
    deviceSessionId: deviceSessionId.current,
    isChecking,
    isTakingOver,
    activeSessionId,
    checkForConflict,
    takeover,
    dismiss,
    registerDevice,
    sendHeartbeat,
  };
}
</file>

<file path="useDifficultyOptions.ts">
"use client";

import { useState, useEffect } from "react";
import type { DifficultyLevel } from "@/lib/data/difficultyLevels";

type UseDifficultyOptionsOptions = {
  contentType: "book" | "lecture" | "custom";
};

/**
 * 콘텐츠 타입별 난이도 옵션 조회 훅
 * API 엔드포인트: /api/difficulty-levels?contentType=book
 */
export function useDifficultyOptions({ contentType }: UseDifficultyOptionsOptions) {
  const [options, setOptions] = useState<DifficultyLevel[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    async function fetchOptions() {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `/api/difficulty-levels?contentType=${contentType}`
        );

        if (!response.ok) {
          throw new Error(`난이도 조회 실패: ${response.statusText}`);
        }

        const data = await response.json();
        setOptions(data);
      } catch (err) {
        console.error("[useDifficultyOptions] 난이도 조회 실패:", err);
        setError(err instanceof Error ? err : new Error("난이도를 불러오는데 실패했습니다."));
        setOptions([]);
      } finally {
        setLoading(false);
      }
    }

    fetchOptions();
  }, [contentType]);

  return {
    options,
    loading,
    error,
  };
}
</file>

<file path="useGlobalShortcuts.ts">
"use client";

import { useEffect, useCallback, useRef } from "react";
import { useRouter } from "next/navigation";

/**
 * 단축키 정의
 * - alt+n: 새 빠른 플랜 생성
 * - alt+t: 오늘의 학습으로 이동
 * - alt+c: 캘린더로 이동
 * - alt+h: 습관으로 이동
 * - space: 타이머 토글 (타이머 컨텍스트에서만)
 * - alt+enter: 현재 플랜 완료 (타이머 컨텍스트에서만)
 * - escape: 모달/오버레이 닫기
 */

export type ShortcutAction =
  | "newQuickPlan"
  | "goToToday"
  | "goToCalendar"
  | "goToHabits"
  | "toggleTimer"
  | "completeCurrentPlan"
  | "closeOverlay";

export interface ShortcutConfig {
  key: string;
  alt?: boolean;
  ctrl?: boolean;
  shift?: boolean;
  meta?: boolean;
  action: ShortcutAction;
  description: string;
}

export const DEFAULT_SHORTCUTS: ShortcutConfig[] = [
  {
    key: "n",
    alt: true,
    action: "newQuickPlan",
    description: "새 플랜 생성",
  },
  {
    key: "t",
    alt: true,
    action: "goToToday",
    description: "오늘의 학습",
  },
  {
    key: "c",
    alt: true,
    action: "goToCalendar",
    description: "캘린더",
  },
  {
    key: "h",
    alt: true,
    action: "goToHabits",
    description: "습관",
  },
  {
    key: " ", // space
    alt: false,
    action: "toggleTimer",
    description: "타이머 토글",
  },
  {
    key: "Enter",
    alt: true,
    action: "completeCurrentPlan",
    description: "플랜 완료",
  },
  {
    key: "Escape",
    action: "closeOverlay",
    description: "닫기",
  },
];

interface UseGlobalShortcutsOptions {
  enabled?: boolean;
  shortcuts?: ShortcutConfig[];
  onAction?: (action: ShortcutAction) => void;
  // 특정 액션에 대한 커스텀 핸들러
  onToggleTimer?: () => void;
  onCompleteCurrentPlan?: () => void;
  onCloseOverlay?: () => void;
}

function matchesShortcut(
  event: KeyboardEvent,
  shortcut: ShortcutConfig
): boolean {
  // 키 매칭
  const keyMatch =
    event.key.toLowerCase() === shortcut.key.toLowerCase() ||
    event.code === shortcut.key;

  // 수정자 키 매칭
  const altMatch = shortcut.alt ? event.altKey : !event.altKey;
  const ctrlMatch = shortcut.ctrl ? event.ctrlKey : !event.ctrlKey;
  const shiftMatch = shortcut.shift ? event.shiftKey : !event.shiftKey;
  const metaMatch = shortcut.meta ? event.metaKey : !event.metaKey;

  return keyMatch && altMatch && ctrlMatch && shiftMatch && metaMatch;
}

export function useGlobalShortcuts(options: UseGlobalShortcutsOptions = {}) {
  const {
    enabled = true,
    shortcuts = DEFAULT_SHORTCUTS,
    onAction,
    onToggleTimer,
    onCompleteCurrentPlan,
    onCloseOverlay,
  } = options;

  const router = useRouter();
  const optionsRef = useRef(options);
  optionsRef.current = options;

  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      // 입력 필드에서는 단축키 비활성화
      const target = event.target as HTMLElement;
      if (
        target.tagName === "INPUT" ||
        target.tagName === "TEXTAREA" ||
        target.isContentEditable
      ) {
        // Escape는 항상 허용
        if (event.key !== "Escape") {
          return;
        }
      }

      // 단축키 매칭
      for (const shortcut of shortcuts) {
        if (matchesShortcut(event, shortcut)) {
          event.preventDefault();

          // 액션 실행
          const action = shortcut.action;

          // 커스텀 핸들러 우선
          if (action === "toggleTimer" && optionsRef.current.onToggleTimer) {
            optionsRef.current.onToggleTimer();
            return;
          }
          if (
            action === "completeCurrentPlan" &&
            optionsRef.current.onCompleteCurrentPlan
          ) {
            optionsRef.current.onCompleteCurrentPlan();
            return;
          }
          if (action === "closeOverlay" && optionsRef.current.onCloseOverlay) {
            optionsRef.current.onCloseOverlay();
            return;
          }

          // 기본 액션
          switch (action) {
            case "newQuickPlan":
              router.push("/plan/quick-create");
              break;
            case "goToToday":
              router.push("/today");
              break;
            case "goToCalendar":
              router.push("/plan/calendar");
              break;
            case "goToHabits":
              router.push("/habits");
              break;
          }

          // 콜백 호출
          optionsRef.current.onAction?.(action);
          return;
        }
      }
    },
    [shortcuts, router]
  );

  useEffect(() => {
    if (!enabled) return;

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [enabled, handleKeyDown]);

  return {
    shortcuts,
  };
}

/**
 * 단축키 표시용 유틸리티
 */
export function formatShortcut(shortcut: ShortcutConfig): string {
  const parts: string[] = [];

  if (shortcut.ctrl) parts.push("Ctrl");
  if (shortcut.alt) parts.push("Alt");
  if (shortcut.shift) parts.push("Shift");
  if (shortcut.meta) parts.push("⌘");

  // 키 표시 포맷팅
  let keyDisplay = shortcut.key;
  if (keyDisplay === " ") keyDisplay = "Space";
  if (keyDisplay === "Escape") keyDisplay = "Esc";
  if (keyDisplay === "Enter") keyDisplay = "↵";

  parts.push(keyDisplay.toUpperCase());

  return parts.join("+");
}

/**
 * 단축키 가이드 컴포넌트에서 사용할 데이터
 */
export function getShortcutGuide(): Array<{
  action: string;
  shortcut: string;
  description: string;
}> {
  return DEFAULT_SHORTCUTS.filter(
    (s) => s.action !== "closeOverlay" && s.action !== "toggleTimer"
  ).map((shortcut) => ({
    action: shortcut.action,
    shortcut: formatShortcut(shortcut),
    description: shortcut.description,
  }));
}
</file>

<file path="useIdempotencyKey.ts">
"use client";

/**
 * Idempotency Key Hook
 *
 * 클라이언트에서 멱등성 키를 생성하고 관리하는 React 훅
 *
 * @example
 * ```tsx
 * function CreatePlanButton() {
 *   const { generateKey, getKeyForAction, clearKey } = useIdempotencyKey();
 *
 *   const handleCreate = async () => {
 *     const key = generateKey("createPlan");
 *     try {
 *       const result = await createPlanAction(data, key);
 *       if (result.success) {
 *         clearKey("createPlan");
 *       }
 *     } catch (error) {
 *       // 재시도 시 같은 키 사용
 *       const retryKey = getKeyForAction("createPlan");
 *     }
 *   };
 * }
 * ```
 */

import { useCallback, useRef } from "react";

/**
 * UUID v4 생성 (브라우저 환경)
 */
function generateUUID(): string {
  return crypto.randomUUID();
}

/**
 * 타임스탬프 기반 고유 키 생성
 */
function generateTimestampKey(): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 10);
  return `${timestamp}-${random}`;
}

export type IdempotencyKeyOptions = {
  /** 키 생성 전략 */
  strategy?: "uuid" | "timestamp";
  /** 키 만료 시간 (ms) - 클라이언트 측 */
  ttlMs?: number;
};

export type UseIdempotencyKeyReturn = {
  /** 새 멱등성 키 생성 */
  generateKey: (actionName: string) => string;
  /** 특정 액션의 현재 키 조회 */
  getKeyForAction: (actionName: string) => string | undefined;
  /** 특정 액션의 키 삭제 */
  clearKey: (actionName: string) => void;
  /** 모든 키 삭제 */
  clearAllKeys: () => void;
  /** 키가 있는지 확인 */
  hasKey: (actionName: string) => boolean;
};

/**
 * 멱등성 키 관리 훅
 */
export function useIdempotencyKey(
  options: IdempotencyKeyOptions = {}
): UseIdempotencyKeyReturn {
  const { strategy = "uuid", ttlMs = 5 * 60 * 1000 } = options; // 기본 5분 TTL

  // 액션별 키 저장 (메모리)
  const keysRef = useRef<Map<string, { key: string; createdAt: number }>>(
    new Map()
  );

  /**
   * 만료된 키 정리
   */
  const cleanupExpiredKeys = useCallback(() => {
    const now = Date.now();
    const keys = keysRef.current;

    for (const [actionName, entry] of keys.entries()) {
      if (now - entry.createdAt > ttlMs) {
        keys.delete(actionName);
      }
    }
  }, [ttlMs]);

  /**
   * 새 멱등성 키 생성
   */
  const generateKey = useCallback(
    (actionName: string): string => {
      cleanupExpiredKeys();

      const key =
        strategy === "uuid" ? generateUUID() : generateTimestampKey();
      keysRef.current.set(actionName, { key, createdAt: Date.now() });

      return key;
    },
    [strategy, cleanupExpiredKeys]
  );

  /**
   * 특정 액션의 현재 키 조회
   */
  const getKeyForAction = useCallback(
    (actionName: string): string | undefined => {
      cleanupExpiredKeys();

      const entry = keysRef.current.get(actionName);
      if (!entry) return undefined;

      // 만료 확인
      if (Date.now() - entry.createdAt > ttlMs) {
        keysRef.current.delete(actionName);
        return undefined;
      }

      return entry.key;
    },
    [ttlMs, cleanupExpiredKeys]
  );

  /**
   * 특정 액션의 키 삭제
   */
  const clearKey = useCallback((actionName: string): void => {
    keysRef.current.delete(actionName);
  }, []);

  /**
   * 모든 키 삭제
   */
  const clearAllKeys = useCallback((): void => {
    keysRef.current.clear();
  }, []);

  /**
   * 키가 있는지 확인
   */
  const hasKey = useCallback(
    (actionName: string): boolean => {
      cleanupExpiredKeys();
      return keysRef.current.has(actionName);
    },
    [cleanupExpiredKeys]
  );

  return {
    generateKey,
    getKeyForAction,
    clearKey,
    clearAllKeys,
    hasKey,
  };
}

/**
 * 요청별 자동 멱등성 키 생성 훅
 *
 * 폼 제출 등에서 자동으로 새 키를 생성하고 관리
 */
export function useAutoIdempotencyKey(
  actionName: string,
  options: IdempotencyKeyOptions = {}
): {
  key: string;
  regenerate: () => string;
  clear: () => void;
} {
  const { generateKey, getKeyForAction, clearKey } = useIdempotencyKey(options);

  // 현재 키 또는 새 키 생성
  const key = getKeyForAction(actionName) ?? generateKey(actionName);

  const regenerate = useCallback(() => {
    clearKey(actionName);
    return generateKey(actionName);
  }, [actionName, clearKey, generateKey]);

  const clear = useCallback(() => {
    clearKey(actionName);
  }, [actionName, clearKey]);

  return { key, regenerate, clear };
}
</file>

<file path="useInstallPrompt.ts">
"use client";

import { useEffect, useState } from "react";

interface BeforeInstallPromptEvent extends Event {
  readonly platforms: string[];
  readonly userChoice: Promise<{
    outcome: "accepted" | "dismissed";
    platform: string;
  }>;
  prompt(): Promise<void>;
}

interface UseInstallPromptReturn {
  isInstallable: boolean;
  isInstalled: boolean;
  isIOS: boolean;
  isStandalone: boolean;
  prompt: (() => Promise<void>) | null;
  install: () => Promise<void>;
}

// 초기 상태 계산 함수들
function getInitialIOS(): boolean {
  if (typeof window === "undefined") return false;
  return (
    /iPad|iPhone|iPod/.test(navigator.userAgent) &&
    !(window as Window & { MSStream?: unknown }).MSStream
  );
}

function getInitialStandalone(): boolean {
  if (typeof window === "undefined") return false;
  return (
    window.matchMedia("(display-mode: standalone)").matches ||
    (window.navigator as Navigator & { standalone?: boolean }).standalone ===
      true
  );
}

/**
 * PWA 설치 프롬프트를 관리하는 훅
 * iOS Safari와 Android Chrome 모두 지원
 */
export function useInstallPrompt(): UseInstallPromptReturn {
  const [deferredPrompt, setDeferredPrompt] =
    useState<BeforeInstallPromptEvent | null>(null);
  const [isInstallable, setIsInstallable] = useState(false);
  const [isInstalled, setIsInstalled] = useState(getInitialStandalone);
  const [isIOS] = useState(getInitialIOS);
  const [isStandalone] = useState(getInitialStandalone);

  useEffect(() => {
    // beforeinstallprompt 이벤트 리스너 (Android Chrome)
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      setIsInstallable(true);
    };

    // appinstalled 이벤트 리스너 (설치 완료)
    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setDeferredPrompt(null);
    };

    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);

    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, []);

  const install = async () => {
    if (!deferredPrompt) {
      return;
    }

    try {
      await deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;

      if (outcome === "accepted") {
        setIsInstallable(false);
        setDeferredPrompt(null);
      }
    } catch (error) {
      console.error("PWA 설치 중 오류 발생:", error);
    }
  };

  return {
    isInstallable: isInstallable && !isInstalled,
    isInstalled,
    isIOS,
    isStandalone,
    prompt: deferredPrompt ? install : null,
    install,
  };
}
</file>

<file path="useInterval.ts">
import { useEffect, useRef } from "react";

/**
 * React에서 setInterval을 안정적으로 사용하기 위한 훅
 * 
 * @param callback 실행할 콜백 함수
 * @param delay 지연 시간 (밀리초), null이면 interval이 정지됨
 */
export function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = useRef(callback);

  // 콜백이 변경될 때마다 ref 업데이트
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // interval 설정
  useEffect(() => {
    if (delay === null) {
      return;
    }

    const id = setInterval(() => {
      savedCallback.current();
    }, delay);

    return () => clearInterval(id);
  }, [delay]);
}
</file>

<file path="useInvalidationHandler.ts">
"use client";

/**
 * React Query 무효화 힌트 처리 훅
 *
 * 서버 액션에서 반환된 invalidationHints를 자동으로 처리하여
 * React Query 캐시를 무효화합니다.
 *
 * @module lib/hooks/useInvalidationHandler
 *
 * @example
 * ```tsx
 * const { processHints } = useInvalidationHandler();
 *
 * const handleSubmit = async () => {
 *   const result = await createQuickPlan(input);
 *   if (result.success) {
 *     // 자동으로 캐시 무효화
 *     processHints(result.invalidationHints);
 *   }
 * };
 * ```
 */

import { useCallback } from "react";
import { useQueryClient } from "@tanstack/react-query";
import {
  getQueryKeysFromHints,
  type InvalidationHint,
} from "@/lib/query/keys";

/**
 * 무효화 결과 정보
 */
interface InvalidationResult {
  /** 무효화된 쿼리 수 */
  invalidatedCount: number;
  /** 무효화된 쿼리 키 목록 */
  invalidatedKeys: ReadonlyArray<readonly unknown[]>;
}

/**
 * useInvalidationHandler 훅 반환 타입
 */
interface UseInvalidationHandlerReturn {
  /** 힌트 배열을 처리하여 캐시 무효화 */
  processHints: (hints?: InvalidationHint[]) => Promise<InvalidationResult>;
  /** 서버 액션 결과에서 힌트를 추출하여 처리 */
  processResultHints: <T extends { invalidationHints?: InvalidationHint[] }>(
    result: T
  ) => Promise<InvalidationResult>;
}

/**
 * 서버 액션 결과의 invalidationHints를 자동으로 처리하는 훅
 *
 * @returns {UseInvalidationHandlerReturn} 힌트 처리 함수들
 */
export function useInvalidationHandler(): UseInvalidationHandlerReturn {
  const queryClient = useQueryClient();

  /**
   * InvalidationHint 배열을 받아 React Query 캐시를 무효화
   */
  const processHints = useCallback(
    async (hints?: InvalidationHint[]): Promise<InvalidationResult> => {
      if (!hints || hints.length === 0) {
        return { invalidatedCount: 0, invalidatedKeys: [] };
      }

      const queryKeyObjects = getQueryKeysFromHints(hints);
      const invalidatedKeys: Array<readonly unknown[]> = [];

      // 각 쿼리 키에 대해 무효화 실행
      await Promise.all(
        queryKeyObjects.map(async ({ queryKey }) => {
          await queryClient.invalidateQueries({ queryKey });
          invalidatedKeys.push(queryKey);
        })
      );

      return {
        invalidatedCount: invalidatedKeys.length,
        invalidatedKeys,
      };
    },
    [queryClient]
  );

  /**
   * 서버 액션 결과 객체에서 invalidationHints를 추출하여 처리
   */
  const processResultHints = useCallback(
    async <T extends { invalidationHints?: InvalidationHint[] }>(
      result: T
    ): Promise<InvalidationResult> => {
      return processHints(result.invalidationHints);
    },
    [processHints]
  );

  return {
    processHints,
    processResultHints,
  };
}

/**
 * 서버 액션 래퍼: 실행 후 자동으로 캐시 무효화
 *
 * @example
 * ```tsx
 * const { executeWithInvalidation } = useServerActionWithInvalidation(createQuickPlan);
 *
 * const handleSubmit = async () => {
 *   const result = await executeWithInvalidation(input);
 *   if (result.success) {
 *     toast.success("플랜이 생성되었습니다.");
 *   }
 * };
 * ```
 */
export function useServerActionWithInvalidation<
  TResult extends { success: boolean; invalidationHints?: InvalidationHint[] },
  TArgs extends unknown[],
>(
  action: (...args: TArgs) => Promise<TResult>
): {
  executeWithInvalidation: (...args: TArgs) => Promise<TResult>;
} {
  const { processHints } = useInvalidationHandler();

  const executeWithInvalidation = useCallback(
    async (...args: TArgs): Promise<TResult> => {
      const result = await action(...args);

      // 성공 시 자동 캐시 무효화
      if (result.success && result.invalidationHints) {
        await processHints(result.invalidationHints);
      }

      return result;
    },
    [action, processHints]
  );

  return { executeWithInvalidation };
}
</file>

<file path="useKeyboardShortcuts.ts">
"use client";

import { useEffect, useCallback, useRef, useMemo } from "react";

// ============================================================================
// Types
// ============================================================================

export type ModifierKey = "ctrl" | "alt" | "shift" | "meta";

export interface KeyboardShortcut {
  /** 단축키 조합 (예: "ctrl+s", "meta+k", "g then d") */
  key: string;
  /** 실행 함수 */
  handler: (event: KeyboardEvent) => void;
  /** 설명 */
  description?: string;
  /** 활성화 여부 */
  enabled?: boolean;
  /** 입력 필드에서도 작동 */
  enableInInput?: boolean;
  /** 기본 동작 방지 */
  preventDefault?: boolean;
}

export interface UseKeyboardShortcutsOptions {
  /** 단축키 목록 */
  shortcuts: KeyboardShortcut[];
  /** 전역 활성화 여부 */
  enabled?: boolean;
  /** 스코프 (특정 요소 내에서만 작동) */
  scope?: React.RefObject<HTMLElement>;
}

// ============================================================================
// Constants
// ============================================================================

const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
const CONTENT_EDITABLE_ATTR = "contenteditable";

// 시퀀스 키 타임아웃 (ms)
const SEQUENCE_TIMEOUT = 1000;

// ============================================================================
// Utilities
// ============================================================================

/**
 * 키 문자열 파싱
 * 예: "ctrl+shift+s" => { key: "s", ctrl: true, shift: true }
 */
function parseKeyString(keyString: string): {
  key: string;
  ctrl: boolean;
  alt: boolean;
  shift: boolean;
  meta: boolean;
} {
  const parts = keyString.toLowerCase().split("+").map((p) => p.trim());
  const result = {
    key: "",
    ctrl: false,
    alt: false,
    shift: false,
    meta: false,
  };

  parts.forEach((part) => {
    switch (part) {
      case "ctrl":
      case "control":
        result.ctrl = true;
        break;
      case "alt":
      case "option":
        result.alt = true;
        break;
      case "shift":
        result.shift = true;
        break;
      case "meta":
      case "cmd":
      case "command":
      case "win":
      case "windows":
        result.meta = true;
        break;
      default:
        result.key = part;
    }
  });

  return result;
}

/**
 * 시퀀스 키 파싱
 * 예: "g then d" => ["g", "d"]
 */
function parseSequence(keyString: string): string[] {
  if (keyString.includes(" then ")) {
    return keyString.split(" then ").map((s) => s.trim());
  }
  return [keyString];
}

/**
 * 키보드 이벤트가 단축키와 일치하는지 확인
 */
function matchesShortcut(
  event: KeyboardEvent,
  shortcut: ReturnType<typeof parseKeyString>
): boolean {
  const eventKey = event.key.toLowerCase();
  const eventCode = event.code.toLowerCase();

  // 특수 키 매핑
  const keyMap: Record<string, string[]> = {
    escape: ["escape", "esc"],
    enter: ["enter", "return"],
    space: [" ", "space"],
    arrowup: ["arrowup", "up"],
    arrowdown: ["arrowdown", "down"],
    arrowleft: ["arrowleft", "left"],
    arrowright: ["arrowright", "right"],
    backspace: ["backspace", "delete"],
  };

  const matchKey = (target: string): boolean => {
    const lowerTarget = target.toLowerCase();
    if (keyMap[lowerTarget]) {
      return keyMap[lowerTarget].includes(eventKey);
    }
    return eventKey === lowerTarget || eventCode === `key${lowerTarget}`;
  };

  return (
    matchKey(shortcut.key) &&
    event.ctrlKey === shortcut.ctrl &&
    event.altKey === shortcut.alt &&
    event.shiftKey === shortcut.shift &&
    event.metaKey === shortcut.meta
  );
}

/**
 * 입력 요소 내에서 이벤트가 발생했는지 확인
 */
function isInputElement(element: EventTarget | null): boolean {
  if (!element || !(element instanceof HTMLElement)) return false;

  if (INPUT_TAGS.includes(element.tagName)) return true;
  if (element.getAttribute(CONTENT_EDITABLE_ATTR) === "true") return true;

  return false;
}

// ============================================================================
// Hook
// ============================================================================

/**
 * 키보드 단축키 훅
 *
 * @example
 * // 단일 단축키
 * useKeyboardShortcuts({
 *   shortcuts: [
 *     { key: "ctrl+s", handler: handleSave, description: "저장" },
 *     { key: "escape", handler: handleClose, description: "닫기" },
 *   ]
 * });
 *
 * @example
 * // 시퀀스 단축키 (vim 스타일)
 * useKeyboardShortcuts({
 *   shortcuts: [
 *     { key: "g then d", handler: () => router.push("/dashboard"), description: "대시보드로 이동" },
 *     { key: "g then t", handler: () => router.push("/today"), description: "Today로 이동" },
 *   ]
 * });
 *
 * @example
 * // 스코프 제한
 * const containerRef = useRef<HTMLDivElement>(null);
 * useKeyboardShortcuts({
 *   shortcuts: [...],
 *   scope: containerRef,
 * });
 */
export function useKeyboardShortcuts({
  shortcuts,
  enabled = true,
  scope,
}: UseKeyboardShortcutsOptions): void {
  const sequenceBufferRef = useRef<string[]>([]);
  const sequenceTimeoutRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);

  // 시퀀스 버퍼 초기화
  const resetSequence = useCallback(() => {
    sequenceBufferRef.current = [];
    if (sequenceTimeoutRef.current) {
      clearTimeout(sequenceTimeoutRef.current);
    }
  }, []);

  // 키보드 이벤트 핸들러
  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      if (!enabled) return;

      // 스코프 확인
      if (scope?.current && !scope.current.contains(event.target as Node)) {
        return;
      }

      // 입력 필드 확인
      const inInput = isInputElement(event.target);

      for (const shortcut of shortcuts) {
        if (shortcut.enabled === false) continue;
        if (inInput && !shortcut.enableInInput) continue;

        const sequence = parseSequence(shortcut.key);

        if (sequence.length === 1) {
          // 단일 키 단축키
          const parsed = parseKeyString(sequence[0]);
          if (matchesShortcut(event, parsed)) {
            if (shortcut.preventDefault !== false) {
              event.preventDefault();
            }
            shortcut.handler(event);
            resetSequence();
            return;
          }
        } else {
          // 시퀀스 단축키
          const currentKey = event.key.toLowerCase();
          const expectedIndex = sequenceBufferRef.current.length;

          if (expectedIndex < sequence.length) {
            const expectedParsed = parseKeyString(sequence[expectedIndex]);

            if (
              expectedParsed.key === currentKey &&
              !expectedParsed.ctrl &&
              !expectedParsed.alt &&
              !expectedParsed.shift &&
              !expectedParsed.meta
            ) {
              sequenceBufferRef.current.push(currentKey);

              // 시퀀스 완료 확인
              if (sequenceBufferRef.current.length === sequence.length) {
                if (shortcut.preventDefault !== false) {
                  event.preventDefault();
                }
                shortcut.handler(event);
                resetSequence();
                return;
              }

              // 타임아웃 설정
              if (sequenceTimeoutRef.current) {
                clearTimeout(sequenceTimeoutRef.current);
              }
              sequenceTimeoutRef.current = setTimeout(resetSequence, SEQUENCE_TIMEOUT);
              return;
            }
          }
        }
      }

      // 일치하는 단축키가 없으면 시퀀스 초기화
      if (sequenceBufferRef.current.length > 0) {
        resetSequence();
      }
    },
    [enabled, shortcuts, scope, resetSequence]
  );

  // 이벤트 리스너 등록
  useEffect(() => {
    const target = scope?.current ?? window;
    target.addEventListener("keydown", handleKeyDown as EventListener);

    return () => {
      target.removeEventListener("keydown", handleKeyDown as EventListener);
      if (sequenceTimeoutRef.current) {
        clearTimeout(sequenceTimeoutRef.current);
      }
    };
  }, [handleKeyDown, scope]);
}

// ============================================================================
// Shortcut Registration Hook
// ============================================================================

/**
 * 단축키 등록 훅 (컴포넌트 생명주기에 맞춤)
 *
 * @example
 * // 컴포넌트 마운트 시 단축키 등록, 언마운트 시 해제
 * useShortcut("ctrl+s", handleSave, { description: "저장" });
 */
export function useShortcut(
  key: string,
  handler: (event: KeyboardEvent) => void,
  options?: Omit<KeyboardShortcut, "key" | "handler">
): void {
  const shortcut = useMemo(
    () => ({
      key,
      handler,
      ...options,
    }),
    [key, handler, options]
  );

  useKeyboardShortcuts({
    shortcuts: [shortcut],
    enabled: options?.enabled ?? true,
  });
}

// ============================================================================
// Navigation Shortcuts Hook
// ============================================================================

/**
 * 네비게이션 단축키 훅
 *
 * @example
 * useNavigationShortcuts({
 *   "g then d": "/dashboard",
 *   "g then t": "/today",
 *   "g then p": "/plan",
 * });
 */
export function useNavigationShortcuts(
  routes: Record<string, string>,
  options?: { enabled?: boolean }
): void {
  const shortcuts = useMemo(() => {
    // router를 동적으로 가져오기 위해 next/navigation 대신 window.location 사용
    return Object.entries(routes).map(([key, path]) => ({
      key,
      handler: () => {
        window.location.href = path;
      },
      description: `${path}로 이동`,
      enabled: options?.enabled ?? true,
    }));
  }, [routes, options?.enabled]);

  useKeyboardShortcuts({ shortcuts });
}

// ============================================================================
// Shortcut Display Utilities
// ============================================================================

/**
 * 단축키를 사용자 친화적인 문자열로 변환
 */
export function formatShortcut(key: string): string {
  const isMac = typeof navigator !== "undefined" && /Mac|iPod|iPhone|iPad/.test(navigator.platform);

  return key
    .split(" then ")
    .map((part) =>
      part
        .split("+")
        .map((k) => {
          const lower = k.toLowerCase().trim();
          switch (lower) {
            case "ctrl":
            case "control":
              return isMac ? "⌃" : "Ctrl";
            case "alt":
            case "option":
              return isMac ? "⌥" : "Alt";
            case "shift":
              return isMac ? "⇧" : "Shift";
            case "meta":
            case "cmd":
            case "command":
              return isMac ? "⌘" : "Win";
            case "enter":
            case "return":
              return "↵";
            case "escape":
            case "esc":
              return "Esc";
            case "space":
              return "Space";
            case "arrowup":
            case "up":
              return "↑";
            case "arrowdown":
            case "down":
              return "↓";
            case "arrowleft":
            case "left":
              return "←";
            case "arrowright":
            case "right":
              return "→";
            case "backspace":
              return "⌫";
            case "delete":
              return "Del";
            case "tab":
              return "Tab";
            default:
              return k.toUpperCase();
          }
        })
        .join(isMac ? "" : "+")
    )
    .join(" → ");
}

/**
 * 단축키를 배열로 분리
 */
export function parseShortcutKeys(key: string): string[] {
  return key.split(" then ").flatMap((part) => part.split("+").map((k) => k.trim()));
}

// ============================================================================
// Preset Shortcuts
// ============================================================================

/**
 * 공통 단축키 프리셋
 */
export const commonShortcuts = {
  save: "ctrl+s",
  undo: "ctrl+z",
  redo: "ctrl+shift+z",
  copy: "ctrl+c",
  paste: "ctrl+v",
  cut: "ctrl+x",
  selectAll: "ctrl+a",
  find: "ctrl+f",
  close: "escape",
  submit: "ctrl+enter",
  newItem: "ctrl+n",
  delete: "delete",
  goBack: "alt+arrowleft",
  goForward: "alt+arrowright",
  refresh: "ctrl+r",
  help: "shift+?",
} as const;

/**
 * 에디터 단축키 프리셋
 */
export const editorShortcuts = {
  bold: "ctrl+b",
  italic: "ctrl+i",
  underline: "ctrl+u",
  strikethrough: "ctrl+shift+s",
  link: "ctrl+k",
  heading1: "ctrl+1",
  heading2: "ctrl+2",
  heading3: "ctrl+3",
  bulletList: "ctrl+shift+8",
  numberedList: "ctrl+shift+9",
  quote: "ctrl+shift+q",
  code: "ctrl+`",
} as const;

export default useKeyboardShortcuts;
</file>

<file path="useLectureEpisodesCalculation.ts">
import { useState, useMemo, useRef } from "react";
import type { LectureEpisode } from "@/lib/types/plan";
import { secondsToMinutes } from "@/lib/utils/duration";

type EpisodeState = {
  episode_number: number;
  episode_title: string;
  duration: number; // 분 단위
};

type UseLectureEpisodesCalculationReturn = {
  episodes: EpisodeState[];
  totalEpisodes: number;
  totalDuration: number; // 분 단위
  handleEpisodesChange: (episodes: Omit<LectureEpisode, "id" | "created_at">[]) => void;
  handleApplyTotalEpisodes: () => void;
  handleApplyTotalDuration: () => void;
  totalEpisodesRef: React.RefObject<HTMLInputElement | null>;
  totalDurationRef: React.RefObject<HTMLInputElement | null>;
};

/**
 * 강의 회차 정보 기반 계산 로직을 관리하는 공통 훅
 * 
 * @param initialEpisodes 초기 회차 정보 (선택사항, DB에서 온 데이터는 duration이 초 단위)
 * @returns 회차 정보 상태, 계산된 총 회차/시간(분 단위), 핸들러 함수들
 */
export function useLectureEpisodesCalculation(
  initialEpisodes?: LectureEpisode[]
): UseLectureEpisodesCalculationReturn {
  // 회차 정보 상태 관리
  // initialEpisodes는 DB에서 온 데이터이므로 duration이 항상 초 단위
  // LectureEpisodesManager에서 onChange로 전달되는 데이터는 이미 분 단위로 변환됨
  const [episodes, setEpisodes] = useState<EpisodeState[]>(() => {
    if (!initialEpisodes) return [];
    
    // DB에서 온 초기값: 항상 초 단위이므로 분으로 변환
    return initialEpisodes.map((e) => ({
      episode_number: e.episode_number || 0,
      episode_title: e.episode_title || "",
      duration: e.duration ? secondsToMinutes(e.duration) || 0 : 0,
    }));
  });

  // ref 선언
  const totalEpisodesRef = useRef<HTMLInputElement | null>(null);
  const totalDurationRef = useRef<HTMLInputElement | null>(null);

  // 총 회차 수 계산 (배열 길이 기반)
  const totalEpisodes = useMemo(() => episodes.length, [episodes]);

  // 총 강의시간 계산 (시간 합계, 분 단위)
  const totalDuration = useMemo(() => {
    return episodes.reduce((sum, episode) => {
      return sum + (episode.duration || 0);
    }, 0);
  }, [episodes]);

  // 회차 정보 변경 핸들러
  // LectureEpisodesManager에서 전달되는 episodes는 이미 분 단위로 변환되어 있음
  const handleEpisodesChange = (
    newEpisodes: Omit<LectureEpisode, "id" | "created_at">[]
  ) => {
    setEpisodes(
      newEpisodes.map((e) => ({
        episode_number: e.episode_number || 0,
        episode_title: e.episode_title || "",
        duration: e.duration || 0, // 이미 분 단위
      }))
    );
  };

  // 총 회차 적용 버튼 핸들러
  const handleApplyTotalEpisodes = () => {
    if (totalEpisodesRef.current && totalEpisodes > 0) {
      totalEpisodesRef.current.value = totalEpisodes.toString();
      // input 이벤트 트리거하여 React가 값 변경을 인식하도록
      totalEpisodesRef.current.dispatchEvent(
        new Event("input", { bubbles: true })
      );
    }
  };

  // 총 강의시간 적용 버튼 핸들러
  const handleApplyTotalDuration = () => {
    if (totalDurationRef.current && totalDuration > 0) {
      totalDurationRef.current.value = totalDuration.toString();
      // input 이벤트 트리거하여 React가 값 변경을 인식하도록
      totalDurationRef.current.dispatchEvent(
        new Event("input", { bubbles: true })
      );
    }
  };

  return {
    episodes,
    totalEpisodes,
    totalDuration,
    handleEpisodesChange,
    handleApplyTotalEpisodes,
    handleApplyTotalDuration,
    totalEpisodesRef,
    totalDurationRef,
  };
}
</file>

<file path="useLongPress.ts">
"use client";

/**
 * useLongPress - Long Press 감지 훅
 *
 * 모바일에서 터치 길게 누르기, 데스크톱에서 우클릭을 감지합니다.
 * 컨텍스트 메뉴 표시 등에 사용됩니다.
 */

import { useCallback, useRef } from "react";

interface UseLongPressOptions {
  /** Long press 발생 시 콜백 */
  onLongPress: () => void;
  /** Long press 감지까지의 지연 시간 (ms, 기본값 500ms) */
  delay?: number;
  /** 움직임 허용 범위 (px, 기본값 10px) - 이 범위를 벗어나면 취소 */
  threshold?: number;
  /** 비활성화 여부 */
  disabled?: boolean;
}

interface LongPressHandlers {
  onTouchStart: (e: React.TouchEvent) => void;
  onTouchMove: (e: React.TouchEvent) => void;
  onTouchEnd: () => void;
  onContextMenu: (e: React.MouseEvent) => void;
}

/**
 * Long Press 감지 훅
 *
 * @example
 * ```tsx
 * const longPressHandlers = useLongPress({
 *   onLongPress: () => setMenuOpen(true),
 *   delay: 500,
 *   disabled: isSystem,
 * });
 *
 * return <div {...longPressHandlers}>...</div>;
 * ```
 */
export function useLongPress({
  onLongPress,
  delay = 500,
  threshold = 10,
  disabled = false,
}: UseLongPressOptions): LongPressHandlers {
  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const startPosRef = useRef<{ x: number; y: number } | null>(null);
  const isLongPressTriggeredRef = useRef(false);

  // 타이머 정리
  const clear = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  }, []);

  // 터치 시작
  const onTouchStart = useCallback(
    (e: React.TouchEvent) => {
      if (disabled) return;

      const touch = e.touches[0];
      startPosRef.current = { x: touch.clientX, y: touch.clientY };
      isLongPressTriggeredRef.current = false;

      timerRef.current = setTimeout(() => {
        isLongPressTriggeredRef.current = true;
        // 햅틱 피드백 (지원하는 경우)
        if (navigator.vibrate) {
          navigator.vibrate(10);
        }
        onLongPress();
      }, delay);
    },
    [disabled, delay, onLongPress]
  );

  // 터치 이동 - 일정 범위 이상 이동하면 취소
  const onTouchMove = useCallback(
    (e: React.TouchEvent) => {
      if (!startPosRef.current) return;

      const touch = e.touches[0];
      const dx = Math.abs(touch.clientX - startPosRef.current.x);
      const dy = Math.abs(touch.clientY - startPosRef.current.y);

      // 임계값 초과 시 취소
      if (dx > threshold || dy > threshold) {
        clear();
      }
    },
    [threshold, clear]
  );

  // 터치 종료
  const onTouchEnd = useCallback(() => {
    clear();
    startPosRef.current = null;
  }, [clear]);

  // 데스크톱 우클릭
  const onContextMenu = useCallback(
    (e: React.MouseEvent) => {
      if (disabled) return;
      e.preventDefault();
      onLongPress();
    },
    [disabled, onLongPress]
  );

  return {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onContextMenu,
  };
}
</file>

<file path="useMasterBooksRefresh.ts">
"use client";

import { useState, useCallback } from "react";
import { getMasterBooksListAction } from "@/lib/domains/content";

/**
 * 마스터 교재 목록 새로고침을 위한 커스텀 훅
 * 
 * @param initialBooks 초기 교재 목록
 * @returns { masterBooks, refreshMasterBooks } 교재 목록과 새로고침 함수
 */
export function useMasterBooksRefresh(
  initialBooks: Array<{ id: string; title: string }>
) {
  const [masterBooks, setMasterBooks] = useState<Array<{ id: string; title: string }>>(initialBooks);
  
  const refreshMasterBooks = useCallback(async () => {
    try {
      const books = await getMasterBooksListAction();
      setMasterBooks(books);
      return books;
    } catch (error) {
      console.error("교재 목록 새로고침 실패:", error);
      // 에러 발생 시 기존 목록 유지
      return masterBooks;
    }
  }, [masterBooks]);
  
  return { masterBooks, refreshMasterBooks };
}
</file>

<file path="useMasterContentSearch.ts">
"use client";

import { useState, useCallback } from "react";

/**
 * 마스터 콘텐츠 검색 결과 타입
 */
export type MasterContentResult = {
  id: string;
  title: string;
  content_type: "book" | "lecture";
  subject_category?: string | null;
  subject?: string | null;
  publisher?: string | null;
  platform?: string | null;
  publisher_or_academy?: string | null;
  total_pages?: number | null;
  total_episodes?: number | null;
};

type UseMasterContentSearchOptions = {
  contentType?: "book" | "lecture";
  debounceMs?: number;
  limit?: number;
};

type UseMasterContentSearchReturn = {
  query: string;
  setQuery: (query: string) => void;
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  results: MasterContentResult[];
  isLoading: boolean;
  isSearching: boolean;
  hasSearched: boolean;
  error: string | null;
  search: (searchQuery: string) => Promise<void>;
  reset: () => void;
};

/**
 * 마스터 콘텐츠 검색 Hook
 *
 * TODO: 실제 검색 API 연동 필요
 */
export function useMasterContentSearch(
  _options?: UseMasterContentSearchOptions
): UseMasterContentSearchReturn {
  const [query, setQuery] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [results, setResults] = useState<MasterContentResult[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const search = useCallback(async (_searchQuery: string) => {
    setIsLoading(true);
    setIsSearching(true);
    setError(null);
    try {
      // TODO: 실제 검색 API 호출
      // const response = await searchMasterContents(searchQuery, options);
      // setResults(response);
      setResults([]);
      setHasSearched(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : "검색 중 오류가 발생했습니다.");
    } finally {
      setIsLoading(false);
      setIsSearching(false);
    }
  }, []);

  const reset = useCallback(() => {
    setQuery("");
    setSearchQuery("");
    setResults([]);
    setError(null);
    setHasSearched(false);
  }, []);

  return {
    query,
    setQuery,
    searchQuery,
    setSearchQuery,
    results,
    isLoading,
    isSearching,
    hasSearched,
    error,
    search,
    reset,
  };
}
</file>

<file path="useMilestoneNotification.ts">
"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import type { AchievedMilestone } from "@/lib/domains/today/types/milestone";

interface UseMilestoneNotificationOptions {
  /** 사운드 활성화 여부 */
  soundEnabled?: boolean;
  /** 체크 간격 (ms) - 기본 60초 */
  checkIntervalMs?: number;
  /** 최소 학습 시간 (초) - 이 시간 이후부터 체크 시작 */
  minStudySecondsToCheck?: number;
}

interface UseMilestoneNotificationReturn {
  /** 현재 표시할 마일스톤 목록 */
  milestones: AchievedMilestone[];
  /** 마일스톤 추가 */
  addMilestone: (milestone: AchievedMilestone) => void;
  /** 마일스톤 여러 개 추가 */
  addMilestones: (milestones: AchievedMilestone[]) => void;
  /** 특정 마일스톤 제거 */
  dismissMilestone: (index: number) => void;
  /** 모든 마일스톤 제거 */
  clearMilestones: () => void;
  /** 마일스톤 체크가 필요한지 여부 */
  shouldCheck: (currentStudySeconds: number) => boolean;
  /** 마지막 체크 시간 업데이트 */
  updateLastCheckTime: () => void;
  /** 사운드 활성화 상태 */
  soundEnabled: boolean;
  /** 사운드 활성화 토글 */
  toggleSound: () => void;
}

/**
 * 마일스톤 알림 관리 훅
 *
 * 학습 중 마일스톤 달성 알림을 관리합니다.
 */
export function useMilestoneNotification(
  options: UseMilestoneNotificationOptions = {}
): UseMilestoneNotificationReturn {
  const {
    soundEnabled: initialSoundEnabled = true,
    checkIntervalMs = 60000, // 1분
    minStudySecondsToCheck = 1500, // 25분 (첫 번째 마일스톤 전)
  } = options;

  const [milestones, setMilestones] = useState<AchievedMilestone[]>([]);
  const [soundEnabled, setSoundEnabled] = useState(initialSoundEnabled);
  const lastCheckTimeRef = useRef<number>(0);
  const lastCheckedSecondsRef = useRef<number>(0);

  // 마일스톤 추가
  const addMilestone = useCallback((milestone: AchievedMilestone) => {
    setMilestones((prev) => {
      // 중복 체크
      const isDuplicate = prev.some(
        (m) => m.type === milestone.type && m.value === milestone.value
      );
      if (isDuplicate) return prev;
      return [...prev, milestone];
    });
  }, []);

  // 마일스톤 여러 개 추가
  const addMilestones = useCallback((newMilestones: AchievedMilestone[]) => {
    if (newMilestones.length === 0) return;

    setMilestones((prev) => {
      const existingKeys = new Set(prev.map((m) => `${m.type}-${m.value}`));
      const uniqueNew = newMilestones.filter(
        (m) => !existingKeys.has(`${m.type}-${m.value}`)
      );
      return [...prev, ...uniqueNew];
    });
  }, []);

  // 특정 마일스톤 제거
  const dismissMilestone = useCallback((index: number) => {
    setMilestones((prev) => prev.filter((_, i) => i !== index));
  }, []);

  // 모든 마일스톤 제거
  const clearMilestones = useCallback(() => {
    setMilestones([]);
  }, []);

  // 마일스톤 체크가 필요한지 여부
  const shouldCheck = useCallback(
    (currentStudySeconds: number): boolean => {
      // 최소 학습 시간 미달
      if (currentStudySeconds < minStudySecondsToCheck) {
        return false;
      }

      const now = Date.now();

      // 첫 체크거나 간격이 지남
      if (
        lastCheckTimeRef.current === 0 ||
        now - lastCheckTimeRef.current >= checkIntervalMs
      ) {
        // 마지막 체크 이후 최소 30초 이상 학습했는지
        const secondsSinceLastCheck =
          currentStudySeconds - lastCheckedSecondsRef.current;
        return secondsSinceLastCheck >= 30;
      }

      return false;
    },
    [checkIntervalMs, minStudySecondsToCheck]
  );

  // 마지막 체크 시간 업데이트
  const updateLastCheckTime = useCallback(() => {
    lastCheckTimeRef.current = Date.now();
  }, []);

  // 사운드 토글
  const toggleSound = useCallback(() => {
    setSoundEnabled((prev) => !prev);
  }, []);

  // lastCheckedSeconds 업데이트 (shouldCheck 후 호출용)
  useEffect(() => {
    // 마일스톤이 추가될 때 현재 체크 시간 저장
    if (milestones.length > 0) {
      lastCheckedSecondsRef.current = Date.now();
    }
  }, [milestones.length]);

  return {
    milestones,
    addMilestone,
    addMilestones,
    dismissMilestone,
    clearMilestones,
    shouldCheck,
    updateLastCheckTime,
    soundEnabled,
    toggleSound,
  };
}

/**
 * 마일스톤 체크를 위한 서버 액션 호출 래퍼
 *
 * usePlanTimer에서 사용할 수 있는 헬퍼 함수
 */
export async function checkMilestonesAction(
  studentId: string,
  currentStudySeconds: number,
  planId?: string
): Promise<AchievedMilestone[]> {
  try {
    // 동적 import로 서버 액션 로드
    const { checkMilestones } = await import(
      "@/lib/domains/today/services/learningFeedbackService"
    );
    const result = await checkMilestones(studentId, currentStudySeconds, planId);
    return result.achieved;
  } catch (error) {
    console.error("[useMilestoneNotification] 마일스톤 체크 오류:", error);
    return [];
  }
}
</file>

<file path="useNetworkStatus.ts">
"use client";

/**
 * 네트워크 상태 감지 훅
 *
 * 브라우저의 온라인/오프라인 상태를 실시간으로 감지합니다.
 *
 * @module lib/hooks/useNetworkStatus
 */

import { useState, useEffect, useCallback } from "react";

export type NetworkStatus = {
  /** 온라인 여부 */
  isOnline: boolean;
  /** 오프라인 여부 */
  isOffline: boolean;
  /** 마지막 상태 변경 시간 */
  lastChangedAt: Date | null;
  /** 이전에 오프라인이었다가 복구됨 */
  wasOffline: boolean;
};

/**
 * 네트워크 상태 감지 훅
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { isOnline, isOffline, wasOffline } = useNetworkStatus();
 *
 *   if (isOffline) {
 *     return <div>인터넷 연결을 확인해주세요.</div>;
 *   }
 *
 *   if (wasOffline) {
 *     return <div>인터넷 연결이 복구되었습니다.</div>;
 *   }
 *
 *   return <div>정상 동작 중</div>;
 * }
 * ```
 */
export function useNetworkStatus(): NetworkStatus {
  const [status, setStatus] = useState<NetworkStatus>(() => ({
    isOnline: typeof window !== "undefined" ? navigator.onLine : true,
    isOffline: typeof window !== "undefined" ? !navigator.onLine : false,
    lastChangedAt: null,
    wasOffline: false,
  }));

  const handleOnline = useCallback(() => {
    setStatus((prev) => ({
      isOnline: true,
      isOffline: false,
      lastChangedAt: new Date(),
      wasOffline: prev.isOffline, // 이전에 오프라인이었으면 true
    }));
  }, []);

  const handleOffline = useCallback(() => {
    setStatus({
      isOnline: false,
      isOffline: true,
      lastChangedAt: new Date(),
      wasOffline: false,
    });
  }, []);

  useEffect(() => {
    // 초기 상태 설정
    setStatus({
      isOnline: navigator.onLine,
      isOffline: !navigator.onLine,
      lastChangedAt: null,
      wasOffline: false,
    });

    // 이벤트 리스너 등록
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, [handleOnline, handleOffline]);

  return status;
}

/**
 * 오프라인 상태에서 자동 재시도를 위한 훅
 *
 * @param retryFn 재시도할 함수
 * @param options 옵션
 */
export function useRetryOnReconnect(
  retryFn: () => void,
  options: {
    enabled?: boolean;
    delay?: number;
  } = {}
) {
  const { enabled = true, delay = 1000 } = options;
  const { isOnline, wasOffline } = useNetworkStatus();

  useEffect(() => {
    if (enabled && isOnline && wasOffline) {
      // 연결 복구 후 약간의 지연 후 재시도
      const timer = setTimeout(retryFn, delay);
      return () => clearTimeout(timer);
    }
  }, [enabled, isOnline, wasOffline, retryFn, delay]);
}
</file>

<file path="usePagination.ts">
/**
 * 공통 페이지네이션 훅
 */

import { useState, useCallback } from "react";

type UsePaginationOptions = {
  initialPage?: number;
  initialPageSize?: number;
  onPageChange?: (page: number, pageSize: number) => void;
};

export function usePagination({
  initialPage = 1,
  initialPageSize = 20,
  onPageChange,
}: UsePaginationOptions = {}) {
  const [page, setPage] = useState(initialPage);
  const [pageSize, setPageSize] = useState(initialPageSize);

  const handlePageChange = useCallback(
    (newPage: number) => {
      setPage(newPage);
      onPageChange?.(newPage, pageSize);
    },
    [pageSize, onPageChange]
  );

  const handlePageSizeChange = useCallback(
    (newPageSize: number) => {
      setPage(1); // 페이지 사이즈 변경 시 첫 페이지로
      setPageSize(newPageSize);
      onPageChange?.(1, newPageSize);
    },
    [onPageChange]
  );

  const resetPage = useCallback(() => {
    setPage(1);
    onPageChange?.(1, pageSize);
  }, [pageSize, onPageChange]);

  const adjustPageAfterDeletion = useCallback(
    (deletedCount: number, totalItems: number) => {
      const remainingCount = totalItems - deletedCount;
      const currentPageStart = (page - 1) * pageSize;

      if (remainingCount <= currentPageStart && page > 1) {
        const newPage = page - 1;
        setPage(newPage);
        onPageChange?.(newPage, pageSize);
      } else {
        onPageChange?.(page, pageSize);
      }
    },
    [page, pageSize, onPageChange]
  );

  return {
    page,
    pageSize,
    setPage: handlePageChange,
    setPageSize: handlePageSizeChange,
    resetPage,
    adjustPageAfterDeletion,
  };
}
</file>

<file path="usePlanCardActions.ts">
"use client";

import { useState, useMemo, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import { useToast } from "@/components/ui/ToastProvider";
import { calculateTimerState, type TimerState } from "@/lib/utils/timerStateCalculator";
import { buildPlanExecutionUrl } from "@/app/(student)/today/_utils/navigationUtils";
import {
  startPlan,
  pausePlan,
  resumePlan,
  preparePlanCompletion,
  postponePlan,
} from "@/lib/domains/today";
import type { PlanGroup } from "@/app/(student)/today/_utils/planGroupUtils";
import type { PendingAction } from "@/lib/domains/today/types";

export type PlanRunState = "idle" | "running" | "paused" | "completed";

type SessionState = {
  isPaused: boolean;
  startedAt?: string | null;
  pausedAt?: string | null;
  resumedAt?: string | null;
  pausedDurationSeconds?: number | null;
};

type UsePlanCardActionsOptions = {
  group: PlanGroup;
  sessions: Map<string, SessionState>;
  campMode?: boolean;
};

type UsePlanCardActionsReturn = {
  // 상태
  isLoading: boolean;
  pendingAction: PendingAction | undefined;

  // 파생 상태
  resolvedStatus: PlanRunState;
  isRunning: boolean;
  isPausedState: boolean;

  // 타이머 상태
  timerState: TimerState;

  // 핸들러
  handleStart: () => Promise<void>;
  handlePause: () => Promise<void>;
  handleResume: () => Promise<void>;
  handleComplete: () => Promise<void>;
  handlePostponePlan: (planId: string) => Promise<void>;

  // 연기 가능 여부
  canPostpone: boolean;
};

/**
 * PlanCard 타이머 액션 관리 Hook
 *
 * - 타이머 시작/일시정지/재개/완료 핸들러
 * - 로딩 및 펜딩 액션 상태
 * - 낙관적 UI 상태 관리
 * - 타이머 상태 계산
 */
export function usePlanCardActions({
  group,
  sessions,
  campMode = false,
}: UsePlanCardActionsOptions): UsePlanCardActionsReturn {
  const router = useRouter();
  const { showError, showInfo } = useToast();
  const timerStore = usePlanTimerStore();

  // 로딩 및 펜딩 상태
  const [isLoading, setIsLoading] = useState(false);
  const [pendingAction, setPendingAction] = useState<PendingAction | undefined>(undefined);

  // 세션 데이터
  const sessionForPlan = sessions.get(group.plan.id);

  // 서버 데이터 기반 상태 계산
  const derivedStatus = useMemo<PlanRunState>(() => {
    if (group.plan.actual_end_time) {
      return "completed";
    }
    if (group.plan.actual_start_time) {
      return sessionForPlan?.isPaused ? "paused" : "running";
    }
    return "idle";
  }, [group.plan.actual_end_time, group.plan.actual_start_time, sessionForPlan?.isPaused]);

  // 낙관적 UI 상태
  const [optimisticStatus, setOptimisticStatus] = useState<PlanRunState | null>(null);

  // 서버 상태 변경 시 낙관적 상태 리셋
  useEffect(() => {
    setOptimisticStatus(null);
  }, [derivedStatus]);

  // 최종 상태 (낙관적 또는 서버)
  const resolvedStatus = optimisticStatus ?? derivedStatus;
  const isRunning = resolvedStatus === "running";
  const isPausedState = resolvedStatus === "paused";

  // 타이머 상태 계산
  const timerState = useMemo(() => {
    const plan = group.plan;
    const session = sessions.get(plan.id);

    return calculateTimerState({
      actualStartTime: plan.actual_start_time ?? null,
      actualEndTime: plan.actual_end_time ?? null,
      totalDurationSeconds: plan.total_duration_seconds ?? null,
      pausedDurationSeconds: plan.paused_duration_seconds ?? null,
      isPaused: session?.isPaused ?? false,
      currentPausedAt: session?.pausedAt ?? null,
      sessionStartedAt: session?.startedAt ?? null,
      sessionPausedDurationSeconds: session?.pausedDurationSeconds ?? null,
    });
  }, [group.plan, sessions]);

  // 연기 가능 여부
  const canPostpone = Boolean(
    group.plan.is_reschedulable && !group.plan.actual_end_time
  );

  // 플랜 연기 핸들러
  const handlePostponePlan = useCallback(
    async (planId: string) => {
      if (isLoading) return;
      if (!group.plan.is_reschedulable) {
        showInfo("이 플랜은 일정 미루기가 허용되지 않습니다.");
        return;
      }
      if (!confirm("이 플랜을 내일 일정으로 미루시겠습니까?")) {
        return;
      }

      setIsLoading(true);
      try {
        const result = await postponePlan(planId);
        if (!result.success) {
          showError(result.error || "일정을 미루는 중 오류가 발생했습니다.");
        }
      } catch (error) {
        console.error("[usePlanCardActions] 일정 미루기 오류:", error);
        showError("오류가 발생했습니다.");
      } finally {
        setIsLoading(false);
      }
    },
    [isLoading, group.plan.is_reschedulable, showInfo, showError]
  );

  // 타이머 시작 핸들러
  const handleStart = useCallback(async () => {
    const plan = group.plan;
    if (plan.actual_start_time || plan.actual_end_time || isLoading) return;

    setIsLoading(true);
    setPendingAction("start");
    setOptimisticStatus("running");
    try {
      const timestamp = new Date().toISOString();
      const result = await startPlan(plan.id, timestamp);
      if (!result.success) {
        showError(result.error || "플랜 시작에 실패했습니다.");
        setOptimisticStatus(null);
      } else if (result.serverNow && result.status && result.startedAt) {
        timerStore.startTimer(plan.id, result.serverNow, result.startedAt);
      }
    } catch (error) {
      setOptimisticStatus(null);
      showError("오류가 발생했습니다.");
    } finally {
      setPendingAction(undefined);
      setIsLoading(false);
    }
  }, [group.plan, isLoading, showError, timerStore]);

  // 타이머 일시정지 핸들러
  const handlePause = useCallback(async () => {
    if (isLoading) return;
    if (resolvedStatus !== "running") {
      showInfo("일시정지할 활성 플랜이 없습니다.");
      return;
    }

    const plan = group.plan;
    setOptimisticStatus("paused");
    setIsLoading(true);
    setPendingAction("pause");
    try {
      const timestamp = new Date().toISOString();
      const result = await pausePlan(plan.id, timestamp);
      if (!result.success) {
        setOptimisticStatus(null);
        showError(result.error || "플랜 일시정지에 실패했습니다.");
      } else if (result.serverNow && result.accumulatedSeconds !== undefined) {
        timerStore.pauseTimer(plan.id, result.accumulatedSeconds);
      }
    } catch (error) {
      console.error("[usePlanCardActions] 일시정지 오류:", error);
      setOptimisticStatus(null);
      showError("오류가 발생했습니다.");
    } finally {
      setPendingAction(undefined);
      setIsLoading(false);
    }
  }, [isLoading, resolvedStatus, group.plan, showInfo, showError, timerStore]);

  // 타이머 재개 핸들러
  const handleResume = useCallback(async () => {
    if (resolvedStatus !== "paused") {
      showInfo("재개할 일시정지된 플랜이 없습니다.");
      return;
    }

    const plan = group.plan;
    setOptimisticStatus("running");
    setIsLoading(true);
    setPendingAction("resume");
    try {
      const timestamp = new Date().toISOString();
      const result = await resumePlan(plan.id, timestamp);
      if (!result.success) {
        setOptimisticStatus(null);
        showError(result.error || "플랜 재개에 실패했습니다.");
      } else if (result.serverNow && result.status && result.startedAt) {
        timerStore.startTimer(plan.id, result.serverNow, result.startedAt);
      }
    } catch (error) {
      console.error("[usePlanCardActions] 재개 오류:", error);
      setOptimisticStatus(null);
      showError("오류가 발생했습니다.");
    } finally {
      setPendingAction(undefined);
      setIsLoading(false);
    }
  }, [resolvedStatus, group.plan, showInfo, showError, timerStore]);

  // 플랜 완료 핸들러
  const handleComplete = useCallback(async () => {
    const targetPlanId = group.plan.id;

    const confirmed = confirm(
      "지금까지의 학습을 기준으로 이 플랜을 완료 입력 화면으로 이동할까요?"
    );

    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    setPendingAction("complete");
    try {
      const result = await preparePlanCompletion(targetPlanId);

      if (!result.success) {
        showError(result.error || "플랜 완료 준비에 실패했습니다.");
        return;
      }

      timerStore.removeTimer(targetPlanId);
      router.push(buildPlanExecutionUrl(targetPlanId, campMode));
    } catch (error) {
      console.error("[usePlanCardActions] 완료 처리 오류:", error);
      showError("오류가 발생했습니다.");
    } finally {
      setPendingAction(undefined);
      setIsLoading(false);
    }
  }, [group.plan.id, campMode, showError, timerStore, router]);

  return {
    // 상태
    isLoading,
    pendingAction,

    // 파생 상태
    resolvedStatus,
    isRunning,
    isPausedState,

    // 타이머 상태
    timerState,

    // 핸들러
    handleStart,
    handlePause,
    handleResume,
    handleComplete,
    handlePostponePlan,

    // 연기 가능 여부
    canPostpone,
  };
}
</file>

<file path="usePlanDragDrop.ts">
"use client";

import { useState, useCallback } from "react";
import { useToast } from "@/components/ui/ToastProvider";
import {
  handlePlanDrop,
  movePlanToDate,
  reorderPlans,
  type DropTarget,
} from "@/lib/domains/plan/actions/move";

export type DragItem = {
  id: string;
  type: "plan" | "adhoc";
  sourceContainer: "daily" | "weekly" | "unfinished";
  index: number;
};

export type DropZone = {
  container: "daily" | "weekly" | "unfinished";
  date?: string;
  index?: number;
};

interface UsePlanDragDropOptions {
  onSuccess?: () => void;
  onError?: (error: string) => void;
}

export function usePlanDragDrop(options?: UsePlanDragDropOptions) {
  const [isDragging, setIsDragging] = useState(false);
  const [dragItem, setDragItem] = useState<DragItem | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const { showSuccess, showError } = useToast();

  const handleDragStart = useCallback((item: DragItem) => {
    setIsDragging(true);
    setDragItem(item);
  }, []);

  const handleDragEnd = useCallback(() => {
    setIsDragging(false);
    setDragItem(null);
  }, []);

  const handleDrop = useCallback(
    async (dropZone: DropZone) => {
      if (!dragItem) return;

      setIsProcessing(true);
      try {
        const dropTarget: DropTarget = {
          container: dropZone.container,
          date: dropZone.date,
          position: dropZone.index,
        };

        const result = await handlePlanDrop(dragItem.id, dropTarget);

        if (!result.success) {
          showError(result.error || "이동 실패");
          options?.onError?.(result.error || "Unknown error");
        } else {
          showSuccess(
            `${dropZone.container === "daily" ? "Daily" : dropZone.container === "weekly" ? "Weekly" : "Unfinished"} Dock으로 이동했습니다.`
          );
          options?.onSuccess?.();
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        showError(errorMessage);
        options?.onError?.(errorMessage);
      } finally {
        setIsProcessing(false);
        handleDragEnd();
      }
    },
    [dragItem, options, handleDragEnd, showSuccess, showError]
  );

  const moveToDate = useCallback(
    async (planId: string, newDate: string, keepTime?: boolean) => {
      setIsProcessing(true);
      try {
        const result = await movePlanToDate(planId, newDate, { keepTime });

        if (!result.success) {
          showError(result.error || "날짜 변경 실패");
          options?.onError?.(result.error || "Unknown error");
          return false;
        }

        showSuccess(`${newDate}로 이동했습니다.`);
        options?.onSuccess?.();
        return true;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        showError(errorMessage);
        options?.onError?.(errorMessage);
        return false;
      } finally {
        setIsProcessing(false);
      }
    },
    [options, showSuccess, showError]
  );

  const reorder = useCallback(
    async (planIds: string[], newOrder: number[]) => {
      setIsProcessing(true);
      try {
        const result = await reorderPlans(planIds, newOrder);

        if (!result.success) {
          showError(result.error || "순서 변경 실패");
          options?.onError?.(result.error || "Unknown error");
          return false;
        }

        options?.onSuccess?.();
        return true;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        showError(errorMessage);
        options?.onError?.(errorMessage);
        return false;
      } finally {
        setIsProcessing(false);
      }
    },
    [options, showError]
  );

  return {
    isDragging,
    dragItem,
    isProcessing,
    handleDragStart,
    handleDragEnd,
    handleDrop,
    moveToDate,
    reorder,
  };
}
</file>

<file path="usePlanGenerationProgress.ts">
"use client";

/**
 * P3 개선: 플랜 생성 진행률 React 훅
 *
 * 플랜 생성 중 진행 상태를 관리하고 UI에 반영합니다.
 *
 * @module lib/hooks/usePlanGenerationProgress
 */

import { useState, useCallback, useRef } from "react";
import {
  PlanGenerationStep,
  PlanGenerationProgress,
  PlanGenerationProgressTracker,
  STEP_MESSAGES,
} from "@/lib/plan/progress";

/**
 * 플랜 생성 진행률 훅 반환 타입
 */
export interface UsePlanGenerationProgressReturn {
  /** 현재 진행 상태 */
  progress: PlanGenerationProgress;
  /** 진행 중 여부 */
  isInProgress: boolean;
  /** 완료 여부 */
  isCompleted: boolean;
  /** 오류 발생 여부 */
  hasError: boolean;
  /** 진행률 추적기 */
  tracker: PlanGenerationProgressTracker;
  /** 진행 시작 */
  start: () => void;
  /** 진행 초기화 */
  reset: () => void;
}

/**
 * 초기 진행 상태
 */
const INITIAL_PROGRESS: PlanGenerationProgress = {
  currentStep: PlanGenerationStep.INITIALIZING,
  overallProgress: 0,
  stepProgress: 0,
  message: STEP_MESSAGES[PlanGenerationStep.INITIALIZING],
};

/**
 * 플랜 생성 진행률 관리 훅
 *
 * @example
 * ```tsx
 * function PlanGenerator() {
 *   const { progress, isInProgress, tracker, start, reset } = usePlanGenerationProgress();
 *
 *   const handleGenerate = async () => {
 *     start();
 *     try {
 *       tracker.update(PlanGenerationStep.VALIDATING, 0);
 *       await validateInputs();
 *       tracker.update(PlanGenerationStep.VALIDATING, 100);
 *
 *       tracker.nextStep();
 *       await loadContents();
 *       // ...
 *
 *       tracker.complete();
 *     } catch (error) {
 *       tracker.setError('GENERATION_FAILED', error.message);
 *     }
 *   };
 *
 *   return (
 *     <div>
 *       <ProgressBar value={progress.overallProgress} />
 *       <p>{progress.message}</p>
 *       {isInProgress && <Spinner />}
 *     </div>
 *   );
 * }
 * ```
 */
export function usePlanGenerationProgress(): UsePlanGenerationProgressReturn {
  const [progress, setProgress] = useState<PlanGenerationProgress>(INITIAL_PROGRESS);

  const trackerRef = useRef<PlanGenerationProgressTracker | null>(null);

  // 진행 상태 콜백
  const handleProgressUpdate = useCallback((newProgress: PlanGenerationProgress) => {
    setProgress(newProgress);
  }, []);

  // 트래커 초기화 (lazy)
  if (!trackerRef.current) {
    trackerRef.current = new PlanGenerationProgressTracker(handleProgressUpdate);
  }

  const start = useCallback(() => {
    trackerRef.current?.update(PlanGenerationStep.INITIALIZING, 0);
  }, []);

  const reset = useCallback(() => {
    setProgress(INITIAL_PROGRESS);
    trackerRef.current = new PlanGenerationProgressTracker(handleProgressUpdate);
  }, [handleProgressUpdate]);

  const isInProgress =
    progress.currentStep !== PlanGenerationStep.COMPLETED &&
    progress.currentStep !== PlanGenerationStep.ERROR &&
    progress.currentStep !== PlanGenerationStep.INITIALIZING;

  const isCompleted = progress.currentStep === PlanGenerationStep.COMPLETED;
  const hasError = progress.currentStep === PlanGenerationStep.ERROR;

  return {
    progress,
    isInProgress,
    isCompleted,
    hasError,
    tracker: trackerRef.current,
    start,
    reset,
  };
}
</file>

<file path="usePlanGroups.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { planGroupsQueryOptions } from "@/lib/query-options/planGroups";
import type { PlanGroupFilters } from "@/lib/data/planGroups";
import type { PlanGroupWithStats, PlanGroupStats } from "@/lib/query-options/planGroups";

// 타입 re-export (하위 호환성)
export type { PlanGroupFilters, PlanGroupWithStats, PlanGroupStats };

type UsePlanGroupsOptions = {
  filters: PlanGroupFilters;
  enabled?: boolean;
};

/**
 * 플랜 그룹 목록 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: planGroups, isLoading } = usePlanGroups({
 *   filters: {
 *     studentId: "student-123",
 *     tenantId: "tenant-456",
 *     includeDeleted: false,
 *   },
 * });
 * ```
 * 
 * @param options - 조회 옵션
 * @returns React Query 쿼리 결과
 */
export function usePlanGroups({
  filters,
  enabled = true,
}: UsePlanGroupsOptions) {
  return useTypedQuery({
    ...planGroupsQueryOptions(filters),
    enabled: enabled && !!filters.studentId,
  });
}
</file>

<file path="usePlanPeriod.ts">
"use client";

/**
 * 플랜 기간 관리 훅
 *
 * UI 컴포넌트에서 플랜 기간 관련 비즈니스 로직을 분리했습니다.
 * Step1BasicInfo 등에서 사용합니다.
 */

import { useState, useCallback } from "react";
import {
  getTodayParts,
  parseDateString,
  formatDateString,
  getDaysInMonth,
  calculateDday,
  isValidDateRange,
  getWeeksDifference,
  calculateEndDate,
} from "@/lib/utils/date";

export type PeriodInputType = "dday" | "direct" | "weeks";

export type DateParts = {
  year: number;
  month: number;
  day: number;
};

export type DirectPeriodState = {
  startYear: number;
  startMonth: number;
  startDay: number;
  endYear: number;
  endMonth: number;
  endDay: number;
};

export type DdayState = {
  date: string;
  calculated: boolean;
};

export type WeeksState = {
  startDate: string;
  weeks: number;
};

export type UsePlanPeriodOptions = {
  initialPeriodStart?: string;
  initialPeriodEnd?: string;
  initialTargetDate?: string;
};

export type UsePlanPeriodReturn = {
  // 상태
  periodInputType: PeriodInputType;
  directState: DirectPeriodState;
  ddayState: DdayState;
  weeksState: WeeksState;

  // 계산된 값
  periodStart: string;
  periodEnd: string;
  dday: number | null;

  // 유효성
  isValid: boolean;
  errorMessage: string | null;

  // 액션
  setPeriodInputType: (type: PeriodInputType) => void;
  setDirectState: (state: Partial<DirectPeriodState>) => void;
  setDdayState: (state: Partial<DdayState>) => void;
  setWeeksState: (state: Partial<WeeksState>) => void;
  reset: () => void;

  // 헬퍼
  getDaysInMonth: (year: number, month: number) => number;
};

/**
 * 플랜 기간 관리 훅
 */
export function usePlanPeriod(
  options: UsePlanPeriodOptions = {}
): UsePlanPeriodReturn {
  const { initialPeriodStart, initialPeriodEnd, initialTargetDate } = options;

  // 기본 상태 초기화
  const today = getTodayParts();

  const [periodInputType, setPeriodInputType] = useState<PeriodInputType>(() => {
    if (initialTargetDate) return "dday";
    if (initialPeriodStart && initialPeriodEnd) {
      const weeks = getWeeksDifference(initialPeriodStart, initialPeriodEnd);
      const days =
        (new Date(initialPeriodEnd).getTime() -
          new Date(initialPeriodStart).getTime()) /
        (1000 * 60 * 60 * 24);
      if (days % 7 === 0 && weeks >= 4) return "weeks";
    }
    return "direct";
  });

  const [directState, setDirectStateInternal] = useState<DirectPeriodState>(() => {
    const startParts = initialPeriodStart
      ? parseDateString(initialPeriodStart)
      : today;
    const endParts = initialPeriodEnd
      ? parseDateString(initialPeriodEnd)
      : today;

    return {
      startYear: startParts.year,
      startMonth: startParts.month,
      startDay: startParts.day,
      endYear: endParts.year,
      endMonth: endParts.month,
      endDay: endParts.day,
    };
  });

  const [ddayState, setDdayStateInternal] = useState<DdayState>({
    date: initialTargetDate || "",
    calculated: !!initialTargetDate,
  });

  const [weeksState, setWeeksStateInternal] = useState<WeeksState>(() => {
    if (initialPeriodStart && initialPeriodEnd && !initialTargetDate) {
      const weeks = getWeeksDifference(initialPeriodStart, initialPeriodEnd);
      return { startDate: initialPeriodStart, weeks: weeks >= 4 ? weeks : 4 };
    }
    return { startDate: "", weeks: 4 };
  });

  // 계산된 기간 값
  const periodStart = useCallback((): string => {
    switch (periodInputType) {
      case "direct":
        return formatDateString(
          directState.startYear,
          directState.startMonth,
          directState.startDay
        );
      case "weeks":
        return weeksState.startDate || formatDateString(today.year, today.month, today.day);
      case "dday":
        return formatDateString(today.year, today.month, today.day);
      default:
        return "";
    }
  }, [periodInputType, directState, weeksState, today]);

  const periodEnd = useCallback((): string => {
    switch (periodInputType) {
      case "direct":
        return formatDateString(
          directState.endYear,
          directState.endMonth,
          directState.endDay
        );
      case "weeks":
        return weeksState.startDate
          ? calculateEndDate(weeksState.startDate, weeksState.weeks)
          : "";
      case "dday":
        return ddayState.date || "";
      default:
        return "";
    }
  }, [periodInputType, directState, weeksState, ddayState]);

  // D-day 계산
  const dday = useCallback((): number | null => {
    const end = periodEnd();
    if (!end) return null;
    return calculateDday(end);
  }, [periodEnd]);

  // 유효성 검사
  const validation = useCallback((): {
    isValid: boolean;
    errorMessage: string | null;
  } => {
    const start = periodStart();
    const end = periodEnd();

    if (!start || !end) {
      return { isValid: false, errorMessage: "기간을 입력해주세요." };
    }

    if (!isValidDateRange(start, end)) {
      return { isValid: false, errorMessage: "시작일이 종료일보다 늦을 수 없습니다." };
    }

    return { isValid: true, errorMessage: null };
  }, [periodStart, periodEnd]);

  // 액션
  const setDirectState = useCallback(
    (state: Partial<DirectPeriodState>) => {
      setDirectStateInternal((prev) => ({ ...prev, ...state }));
    },
    []
  );

  const setDdayState = useCallback((state: Partial<DdayState>) => {
    setDdayStateInternal((prev) => ({ ...prev, ...state }));
  }, []);

  const setWeeksState = useCallback((state: Partial<WeeksState>) => {
    setWeeksStateInternal((prev) => ({ ...prev, ...state }));
  }, []);

  const reset = useCallback(() => {
    const today = getTodayParts();
    setPeriodInputType("direct");
    setDirectStateInternal({
      startYear: today.year,
      startMonth: today.month,
      startDay: today.day,
      endYear: today.year,
      endMonth: today.month,
      endDay: today.day,
    });
    setDdayStateInternal({ date: "", calculated: false });
    setWeeksStateInternal({ startDate: "", weeks: 4 });
  }, []);

  const { isValid, errorMessage } = validation();

  return {
    // 상태
    periodInputType,
    directState,
    ddayState,
    weeksState,

    // 계산된 값
    periodStart: periodStart(),
    periodEnd: periodEnd(),
    dday: dday(),

    // 유효성
    isValid,
    errorMessage,

    // 액션
    setPeriodInputType,
    setDirectState,
    setDdayState,
    setWeeksState,
    reset,

    // 헬퍼
    getDaysInMonth,
  };
}
</file>

<file path="usePlanReminder.ts">
"use client";

import { useState, useEffect, useCallback } from "react";
import type { IncompletePlanInfo } from "@/lib/services/planReminderService";

interface UsePlanReminderOptions {
  studentId: string;
  /** 자동 새로고침 여부 */
  autoRefresh?: boolean;
  /** 새로고침 간격 (ms) - 기본 5분 */
  refreshIntervalMs?: number;
}

interface UsePlanReminderReturn {
  /** 오늘 미완료 플랜 */
  todayIncomplete: IncompletePlanInfo[];
  /** 지연된 플랜 */
  delayedPlans: IncompletePlanInfo[];
  /** 주간 요약 */
  weeklySummary: {
    totalIncomplete: number;
    bySubject: Record<string, number>;
  };
  /** 로딩 상태 */
  isLoading: boolean;
  /** 에러 */
  error: string | null;
  /** 새로고침 */
  refresh: () => Promise<void>;
  /** 배너 표시 여부 */
  shouldShowBanner: boolean;
  /** 배너 닫기 */
  dismissBanner: () => void;
}

/**
 * 플랜 리마인더 데이터 훅
 *
 * 미완료 플랜 정보를 로드하고 관리합니다.
 */
export function usePlanReminder({
  studentId,
  autoRefresh = false,
  refreshIntervalMs = 5 * 60 * 1000, // 5분
}: UsePlanReminderOptions): UsePlanReminderReturn {
  const [todayIncomplete, setTodayIncomplete] = useState<IncompletePlanInfo[]>([]);
  const [delayedPlans, setDelayedPlans] = useState<IncompletePlanInfo[]>([]);
  const [weeklySummary, setWeeklySummary] = useState<{
    totalIncomplete: number;
    bySubject: Record<string, number>;
  }>({ totalIncomplete: 0, bySubject: {} });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [bannerDismissed, setBannerDismissed] = useState(false);

  // 데이터 로드
  const loadData = useCallback(async () => {
    if (!studentId) return;

    try {
      setError(null);
      // 동적 import로 서버 액션 로드
      const { getIncompleteReminderInfo } = await import(
        "@/lib/services/planReminderService"
      );
      const data = await getIncompleteReminderInfo(studentId);

      if (data) {
        setTodayIncomplete(data.todayIncomplete);
        setDelayedPlans(data.delayedPlans);
        setWeeklySummary(data.weeklySummary);
      }
    } catch (err) {
      console.error("[usePlanReminder] 데이터 로드 오류:", err);
      setError("미완료 플랜 정보를 불러오지 못했습니다");
    } finally {
      setIsLoading(false);
    }
  }, [studentId]);

  // 초기 로드
  useEffect(() => {
    loadData();
  }, [loadData]);

  // 자동 새로고침
  useEffect(() => {
    if (!autoRefresh) return;

    const interval = setInterval(loadData, refreshIntervalMs);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshIntervalMs, loadData]);

  // 새로고침
  const refresh = useCallback(async () => {
    setIsLoading(true);
    await loadData();
  }, [loadData]);

  // 배너 닫기
  const dismissBanner = useCallback(() => {
    setBannerDismissed(true);
    // 세션 스토리지에 저장 (같은 세션 동안 유지)
    try {
      const today = new Date().toISOString().split("T")[0];
      sessionStorage.setItem(`reminder_dismissed_${today}`, "true");
    } catch {
      // 스토리지 접근 실패 무시
    }
  }, []);

  // 세션 스토리지에서 닫기 상태 복원
  useEffect(() => {
    try {
      const today = new Date().toISOString().split("T")[0];
      const dismissed = sessionStorage.getItem(`reminder_dismissed_${today}`);
      if (dismissed === "true") {
        setBannerDismissed(true);
      }
    } catch {
      // 스토리지 접근 실패 무시
    }
  }, []);

  // 배너 표시 여부 결정
  const shouldShowBanner =
    !bannerDismissed &&
    !isLoading &&
    (todayIncomplete.length > 0 || delayedPlans.length > 0);

  return {
    todayIncomplete,
    delayedPlans,
    weeklySummary,
    isLoading,
    error,
    refresh,
    shouldShowBanner,
    dismissBanner,
  };
}
</file>

<file path="usePlanReorder.ts">
'use client';

import { useState, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useToast } from '@/components/ui/ToastProvider';
import { reorderPlans } from '@/lib/domains/plan/actions/move';

export type ReorderItem = {
  id: string;
  sequence: number;
};

interface UsePlanReorderOptions {
  onReorderSuccess?: () => void;
  onReorderError?: (error: string) => void;
}

/**
 * 플랜 순서 재정렬을 위한 커스텀 훅
 *
 * HTML5 Drag and Drop API를 사용하여 같은 컨테이너 내에서 플랜 순서를 변경합니다.
 */
export function usePlanReorder(options?: UsePlanReorderOptions) {
  const router = useRouter();
  const { showToast } = useToast();

  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  const [dropTargetIndex, setDropTargetIndex] = useState<number | null>(null);
  const [isReordering, setIsReordering] = useState(false);

  const draggedElementRef = useRef<HTMLElement | null>(null);

  // 드래그 시작
  const handleDragStart = useCallback(
    (e: React.DragEvent<HTMLDivElement>, index: number) => {
      if (isReordering) {
        e.preventDefault();
        return;
      }

      setDraggedIndex(index);
      draggedElementRef.current = e.currentTarget;

      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', String(index));

      // 시각적 피드백
      requestAnimationFrame(() => {
        if (draggedElementRef.current) {
          draggedElementRef.current.style.opacity = '0.5';
        }
      });
    },
    [isReordering]
  );

  // 드래그 종료
  const handleDragEnd = useCallback(() => {
    setDraggedIndex(null);
    setDropTargetIndex(null);

    if (draggedElementRef.current) {
      draggedElementRef.current.style.opacity = '1';
    }
    draggedElementRef.current = null;
  }, []);

  // 드롭 영역 진입
  const handleDragEnter = useCallback(
    (e: React.DragEvent<HTMLDivElement>, index: number) => {
      e.preventDefault();
      e.stopPropagation();

      if (draggedIndex === null || draggedIndex === index) {
        return;
      }

      setDropTargetIndex(index);
    },
    [draggedIndex]
  );

  // 드롭 영역 위
  const handleDragOver = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
  }, []);

  // 드롭 영역 이탈
  const handleDragLeave = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();

    const relatedTarget = e.relatedTarget as HTMLElement | null;
    const currentTarget = e.currentTarget as HTMLElement;
    if (relatedTarget && currentTarget.contains(relatedTarget)) {
      return;
    }

    setDropTargetIndex(null);
  }, []);

  // 순서 변경 적용
  const handleDrop = useCallback(
    async <T extends ReorderItem>(
      e: React.DragEvent<HTMLDivElement>,
      targetIndex: number,
      items: T[],
      onOptimisticUpdate?: (newItems: T[]) => void
    ) => {
      e.preventDefault();
      e.stopPropagation();

      const sourceIndex = draggedIndex;
      setDraggedIndex(null);
      setDropTargetIndex(null);

      if (sourceIndex === null || sourceIndex === targetIndex) {
        return;
      }

      // 새 순서 계산
      const newItems = [...items];
      const [movedItem] = newItems.splice(sourceIndex, 1);
      newItems.splice(targetIndex, 0, movedItem);

      // Optimistic update
      if (onOptimisticUpdate) {
        onOptimisticUpdate(newItems);
      }

      setIsReordering(true);

      try {
        // 서버에 순서 변경 요청
        const planIds = newItems.map((item) => item.id);
        const newOrder = newItems.map((_, idx) => idx);

        const result = await reorderPlans(planIds, newOrder);

        if (result.success) {
          showToast('순서가 변경되었습니다.', 'success');
          options?.onReorderSuccess?.();
          router.refresh();
        } else {
          showToast(result.error || '순서 변경에 실패했습니다.', 'error');
          options?.onReorderError?.(result.error || 'Unknown error');
          // 실패 시 원래 순서로 복원
          if (onOptimisticUpdate) {
            onOptimisticUpdate(items);
          }
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        showToast('순서 변경 중 오류가 발생했습니다.', 'error');
        options?.onReorderError?.(errorMessage);
        // 실패 시 원래 순서로 복원
        if (onOptimisticUpdate) {
          onOptimisticUpdate(items);
        }
      } finally {
        setIsReordering(false);
      }
    },
    [draggedIndex, router, showToast, options]
  );

  // 순서 재정렬 가능 아이템용 props 생성
  const getReorderableProps = useCallback(
    <T extends ReorderItem>(
      index: number,
      items: T[],
      onOptimisticUpdate?: (newItems: T[]) => void
    ) => ({
      draggable: !isReordering,
      onDragStart: (e: React.DragEvent<HTMLDivElement>) => handleDragStart(e, index),
      onDragEnd: handleDragEnd,
      onDragEnter: (e: React.DragEvent<HTMLDivElement>) => handleDragEnter(e, index),
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDrop: (e: React.DragEvent<HTMLDivElement>) =>
        handleDrop(e, index, items, onOptimisticUpdate),
    }),
    [
      isReordering,
      handleDragStart,
      handleDragEnd,
      handleDragEnter,
      handleDragOver,
      handleDragLeave,
      handleDrop,
    ]
  );

  // 현재 드롭 타겟인지 확인
  const isDropTargetAt = useCallback(
    (index: number) => {
      return dropTargetIndex === index && draggedIndex !== null && draggedIndex !== index;
    },
    [dropTargetIndex, draggedIndex]
  );

  // 현재 드래그 중인 아이템인지 확인
  const isDraggedAt = useCallback(
    (index: number) => {
      return draggedIndex === index;
    },
    [draggedIndex]
  );

  return {
    // 상태
    draggedIndex,
    dropTargetIndex,
    isReordering,
    isDragging: draggedIndex !== null,

    // 헬퍼 함수
    getReorderableProps,
    isDropTargetAt,
    isDraggedAt,
  };
}
</file>

<file path="usePlans.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { plansQueryOptions } from "@/lib/query-options/plans";

type UsePlansOptions = {
  studentId: string;
  tenantId: string | null;
  planDate: string;
  enabled?: boolean;
};

/**
 * 플랜 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: plans, isLoading } = usePlans({
 *   studentId: "student-123",
 *   tenantId: "tenant-456",
 *   planDate: "2025-01-01",
 * });
 * ```
 */
export function usePlans({
  studentId,
  tenantId,
  planDate,
  enabled = true,
}: UsePlansOptions) {
  return useTypedQuery({
    ...plansQueryOptions(studentId, tenantId, planDate),
    enabled,
  });
}
</file>

<file path="usePlanTimer.ts">
"use client";

/**
 * UI-only consumption hook for plan timer
 *
 * 스토어를 구독하여 타이머 상태를 읽어옵니다.
 * 이 훅 자체는 interval을 생성하지 않습니다.
 *
 * 최적화: selector 패턴을 사용하여 특정 planId의 타이머만 구독합니다.
 *
 * 동기화 전략:
 * 1. Visibility 변경 시 즉시 동기화
 * 2. RUNNING 상태에서 5분마다 주기적 동기화
 * 3. 서버-클라이언트 시간 차이가 큰 경우 동기화
 */

import { useEffect, useRef, useState, useCallback } from "react";
import { useShallow } from "zustand/react/shallow";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import type { TimerStatus } from "@/lib/store/planTimerStore";
import { getServerTime, syncTimerProgress } from "@/lib/domains/today";
import type { AchievedMilestone } from "@/lib/domains/today/types/milestone";

// 주기적 동기화 간격 (5분)
const PERIODIC_SYNC_INTERVAL_MS = 5 * 60 * 1000;
// 시간 차이 임계값 (2초 이상이면 동기화)
const SYNC_THRESHOLD_SECONDS = 2;
// 마일스톤 체크 간격 (1분)
const MILESTONE_CHECK_INTERVAL_MS = 60 * 1000;
// 마일스톤 체크 최소 학습 시간 (25분 - 첫 마일스톤 전에 시작)
const MIN_SECONDS_FOR_MILESTONE_CHECK = 25 * 60;

export type UsePlanTimerOptions = {
  /** 플랜 ID */
  planId: string;
  /** 서버에서 계산된 초기 상태 */
  status: TimerStatus;
  /** 서버에서 계산된 누적 시간 (초) */
  accumulatedSeconds: number;
  /** 마지막 시작 시각 (UTC ISO 타임스탬프) */
  startedAt: string | null;
  /** 서버 현재 시간 (밀리초) */
  serverNow: number;
  /** 타이머가 완료되었는지 여부 */
  isCompleted?: boolean;
  /** 학생 ID (마일스톤 체크용) */
  studentId?: string;
  /** 마일스톤 달성 시 콜백 */
  onMilestoneAchieved?: (milestones: AchievedMilestone[]) => void;
  /** 마일스톤 체크 활성화 여부 (기본값: true) */
  enableMilestoneCheck?: boolean;
};

/** 동기화 상태 */
export type SyncState = "idle" | "syncing" | "synced" | "error";

export type UsePlanTimerReturn = {
  /** 현재 경과 시간 (초) */
  seconds: number;
  /** 타이머가 실행 중인지 여부 */
  isRunning: boolean;
  /** 타이머 상태 */
  status: TimerStatus;
  /** 동기화 상태 */
  syncState: SyncState;
  /** 마지막 동기화 시간 (밀리초 타임스탬프) */
  lastSyncAt: number | null;
};

/**
 * 플랜 타이머를 구독하는 훅
 * 
 * 스토어에서 타이머 상태를 읽어오며, 초기화는 자동으로 수행됩니다.
 * 
 * @param options 타이머 옵션
 * @returns 타이머 상태
 */
export function usePlanTimer({
  planId,
  status,
  accumulatedSeconds,
  startedAt,
  serverNow,
  isCompleted = false,
  studentId,
  onMilestoneAchieved,
  enableMilestoneCheck = true,
}: UsePlanTimerOptions): UsePlanTimerReturn {
  // Selector 패턴: 특정 planId의 타이머만 구독하여 불필요한 리렌더링 방지
  // Map 구조이므로 특정 키의 값만 추출하여 구독
  const timer = usePlanTimerStore(
    useShallow((state) => {
      const timerData = state.timers.get(planId);
      // timerData가 없으면 undefined 반환 (shallow equality 체크)
      if (!timerData) return undefined;
      // timerData의 필요한 필드만 반환하여 불필요한 리렌더링 방지
      return {
        seconds: timerData.seconds,
        isRunning: timerData.isRunning,
        status: timerData.status,
      };
    })
  );

  // 스토어 액션은 selector 없이 직접 접근 (액션은 변경되지 않으므로)
  const initPlanTimer = usePlanTimerStore((state) => state.initPlanTimer);
  const removeTimer = usePlanTimerStore((state) => state.removeTimer);
  const syncNow = usePlanTimerStore((state) => state.syncNow);

  // visibility 변경 감지를 위한 구독
  const visibilityChangeTimestamp = usePlanTimerStore(
    (state) => state.visibilityChangeTimestamp
  );

  // 동기화 상태 추적
  const [syncState, setSyncState] = useState<SyncState>("idle");
  const [lastSyncAt, setLastSyncAt] = useState<number | null>(null);

  // Debounce를 위한 ref
  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastVisibilityTimestampRef = useRef<number | null>(null);
  // 주기적 동기화를 위한 ref
  const periodicSyncIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastPeriodicSyncRef = useRef<number>(Date.now());

  // 마일스톤 체크를 위한 ref
  const milestoneCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastMilestoneCheckRef = useRef<number>(0);
  const lastCheckedSecondsRef = useRef<number>(0);

  // 참조 카운팅: 컴포넌트 마운트 시 참조 증가
  useEffect(() => {
    const addTimerRef = usePlanTimerStore.getState().addTimerRef;
    addTimerRef(planId);

    // 언마운트 시 참조 감소
    return () => {
      const removeTimerRef = usePlanTimerStore.getState().removeTimerRef;
      removeTimerRef(planId);
    };
  }, [planId]);

  // Visibility 변경 시 서버에서 정확한 시간을 가져와 동기화
  useEffect(() => {
    // 첫 마운트 시에는 동기화 불필요
    if (visibilityChangeTimestamp === null) {
      return;
    }

    // 같은 타임스탬프에 대해 중복 동기화 방지
    if (lastVisibilityTimestampRef.current === visibilityChangeTimestamp) {
      return;
    }
    lastVisibilityTimestampRef.current = visibilityChangeTimestamp;

    // 현재 타이머가 RUNNING 상태인 경우에만 서버 동기화
    const currentTimer = usePlanTimerStore.getState().timers.get(planId);
    if (!currentTimer || currentTimer.status !== "RUNNING" || !currentTimer.isRunning) {
      return;
    }

    // 서버에서 정확한 시간을 가져와 동기화
    const syncWithServer = async () => {
      setSyncState("syncing");
      try {
        const { serverNow } = await getServerTime();
        syncNow(planId, serverNow);

        // 탭이 숨겨질 때 (visibilityChangeTimestamp가 있으면) DB에도 저장
        // 브라우저 종료/새로고침 시 데이터 손실 방지
        const timer = usePlanTimerStore.getState().timers.get(planId);
        if (timer && timer.seconds > 0) {
          await syncTimerProgress(planId, timer.seconds);
        }

        setSyncState("synced");
        setLastSyncAt(Date.now());
        // 3초 후 idle로 복귀
        setTimeout(() => setSyncState("idle"), 3000);
      } catch (error) {
        // 서버 요청 실패 시 기존 offset 사용하여 폴백
        console.warn("[usePlanTimer] 서버 시간 동기화 실패, 로컬 시간 사용:", error);
        const now = Date.now();
        const fallbackServerNow = now + (currentTimer.timeOffset || 0);
        syncNow(planId, fallbackServerNow);
        setSyncState("error");
        // 5초 후 idle로 복귀
        setTimeout(() => setSyncState("idle"), 5000);
      }
    };

    syncWithServer();
  }, [planId, visibilityChangeTimestamp, syncNow]);

  // 주기적 동기화: RUNNING 상태에서 5분마다 서버와 동기화
  useEffect(() => {
    // 현재 타이머가 RUNNING 상태인지 확인
    const currentTimer = usePlanTimerStore.getState().timers.get(planId);
    const isRunning = currentTimer?.status === "RUNNING" && currentTimer?.isRunning;

    // RUNNING 상태가 아니면 interval 정리
    if (!isRunning) {
      if (periodicSyncIntervalRef.current) {
        clearInterval(periodicSyncIntervalRef.current);
        periodicSyncIntervalRef.current = null;
      }
      return;
    }

    // 이미 interval이 있으면 중복 생성 방지
    if (periodicSyncIntervalRef.current) {
      return;
    }

    // 주기적 동기화 설정
    periodicSyncIntervalRef.current = setInterval(async () => {
      const timer = usePlanTimerStore.getState().timers.get(planId);
      if (!timer || timer.status !== "RUNNING" || !timer.isRunning) {
        // 더 이상 RUNNING 상태가 아니면 interval 정리
        if (periodicSyncIntervalRef.current) {
          clearInterval(periodicSyncIntervalRef.current);
          periodicSyncIntervalRef.current = null;
        }
        return;
      }

      setSyncState("syncing");
      try {
        // 서버 시간 동기화
        const { serverNow } = await getServerTime();
        syncNow(planId, serverNow);
        lastPeriodicSyncRef.current = Date.now();

        // DB에 학습 시간 저장 (데이터 손실 방지)
        const currentSeconds = timer.seconds;
        if (currentSeconds > 0) {
          await syncTimerProgress(planId, currentSeconds);
        }

        setSyncState("synced");
        setLastSyncAt(Date.now());
        setTimeout(() => setSyncState("idle"), 3000);
      } catch (error) {
        console.warn("[usePlanTimer] 주기적 동기화 실패:", error);
        setSyncState("error");
        setTimeout(() => setSyncState("idle"), 5000);
      }
    }, PERIODIC_SYNC_INTERVAL_MS);

    // Cleanup
    return () => {
      if (periodicSyncIntervalRef.current) {
        clearInterval(periodicSyncIntervalRef.current);
        periodicSyncIntervalRef.current = null;
      }
    };
  }, [planId, timer?.status, timer?.isRunning, syncNow]);

  // 마일스톤 체크: RUNNING 상태에서 1분마다 마일스톤 달성 체크
  useEffect(() => {
    // 마일스톤 체크가 비활성화되어 있거나 studentId가 없으면 스킵
    if (!enableMilestoneCheck || !studentId || !onMilestoneAchieved) {
      if (milestoneCheckIntervalRef.current) {
        clearInterval(milestoneCheckIntervalRef.current);
        milestoneCheckIntervalRef.current = null;
      }
      return;
    }

    // 현재 타이머가 RUNNING 상태인지 확인
    const currentTimer = usePlanTimerStore.getState().timers.get(planId);
    const isRunning = currentTimer?.status === "RUNNING" && currentTimer?.isRunning;

    // RUNNING 상태가 아니면 interval 정리
    if (!isRunning) {
      if (milestoneCheckIntervalRef.current) {
        clearInterval(milestoneCheckIntervalRef.current);
        milestoneCheckIntervalRef.current = null;
      }
      return;
    }

    // 이미 interval이 있으면 중복 생성 방지
    if (milestoneCheckIntervalRef.current) {
      return;
    }

    // 마일스톤 체크 설정
    milestoneCheckIntervalRef.current = setInterval(async () => {
      const timer = usePlanTimerStore.getState().timers.get(planId);
      if (!timer || timer.status !== "RUNNING" || !timer.isRunning) {
        // 더 이상 RUNNING 상태가 아니면 interval 정리
        if (milestoneCheckIntervalRef.current) {
          clearInterval(milestoneCheckIntervalRef.current);
          milestoneCheckIntervalRef.current = null;
        }
        return;
      }

      const currentSeconds = timer.seconds;

      // 최소 학습 시간 미달 시 스킵
      if (currentSeconds < MIN_SECONDS_FOR_MILESTONE_CHECK) {
        return;
      }

      // 마지막 체크 이후 최소 30초 이상 학습했는지 확인
      const secondsSinceLastCheck = currentSeconds - lastCheckedSecondsRef.current;
      if (secondsSinceLastCheck < 30) {
        return;
      }

      try {
        // 동적 import로 서버 액션 로드
        const { checkMilestones } = await import(
          "@/lib/domains/today/services/learningFeedbackService"
        );

        const result = await checkMilestones(studentId, currentSeconds, planId);

        if (result.achieved.length > 0) {
          onMilestoneAchieved(result.achieved);
        }

        lastMilestoneCheckRef.current = Date.now();
        lastCheckedSecondsRef.current = currentSeconds;
      } catch (error) {
        console.warn("[usePlanTimer] 마일스톤 체크 실패:", error);
      }
    }, MILESTONE_CHECK_INTERVAL_MS);

    // Cleanup
    return () => {
      if (milestoneCheckIntervalRef.current) {
        clearInterval(milestoneCheckIntervalRef.current);
        milestoneCheckIntervalRef.current = null;
      }
    };
  }, [planId, timer?.status, timer?.isRunning, studentId, enableMilestoneCheck, onMilestoneAchieved]);

  // 초기화 또는 상태 동기화
  useEffect(() => {
    // 완료된 경우 타이머 제거하고 더 이상 실행하지 않음
    if (isCompleted || status === "COMPLETED") {
      // 기존 timeout 정리
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
        syncTimeoutRef.current = null;
      }
      removeTimer(planId);
      return;
    }

    // 현재 타이머 상태 확인 (effect 실행 시점의 값)
    // timer는 이미 selector로 구독 중이지만, 전체 타이머 데이터가 필요하므로 스토어에서 직접 조회
    const currentTimer = usePlanTimerStore.getState().timers.get(planId);

    // 타이머가 없거나 상태가 변경된 경우 즉시 초기화 (debounce 없음)
    if (!currentTimer || currentTimer.status !== status) {
      // 기존 timeout 정리
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
        syncTimeoutRef.current = null;
      }
      initPlanTimer(planId, {
        status,
        accumulatedSeconds,
        startedAt,
        serverNow,
      });
      return;
    }

    // 상태가 같아도 서버 데이터가 변경되었을 수 있으므로 동기화
    // 동기화 체크는 debounce 처리 (300ms)
    const currentSeconds = currentTimer.seconds;
    const expectedSeconds = accumulatedSeconds;

    // 기존 timeout 정리
    if (syncTimeoutRef.current) {
      clearTimeout(syncTimeoutRef.current);
    }

    // 차이가 크면 (SYNC_THRESHOLD_SECONDS 이상) debounce 후 동기화
    if (Math.abs(currentSeconds - expectedSeconds) > SYNC_THRESHOLD_SECONDS) {
      syncTimeoutRef.current = setTimeout(() => {
        syncNow(planId, serverNow);
        syncTimeoutRef.current = null;
      }, 300);
    }

    // Cleanup: 컴포넌트 언마운트 또는 의존성 변경 시 timeout 정리
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
        syncTimeoutRef.current = null;
      }
    };
     
  }, [planId, status, accumulatedSeconds, startedAt, serverNow, isCompleted, initPlanTimer, removeTimer, syncNow]);

  // 컴포넌트 언마운트 시 타이머 제거 (선택사항 - 여러 탭에서 사용 중이면 제거하지 않음)
  // useEffect(() => {
  //   return () => {
  //     // 타이머는 여러 컴포넌트에서 사용될 수 있으므로 제거하지 않음
  //   };
  // }, [planId, store]);

  return {
    seconds: timer?.seconds ?? accumulatedSeconds,
    isRunning: timer?.isRunning ?? (status === "RUNNING"),
    status: timer?.status ?? status,
    syncState,
    lastSyncAt,
  };
}
</file>

<file path="usePlanViewState.ts">
"use client";

import { useState, useCallback, useMemo, useEffect, useRef } from "react";
import type { PlanGroup } from "@/app/(student)/today/_utils/planGroupUtils";

export type ViewMode = "single" | "daily";

type UsePlanViewStateOptions = {
  initialMode?: ViewMode;
  initialSelectedPlanNumber?: number | null;
  groups: PlanGroup[];
  planDate: string;
};

type UsePlanViewStateReturn = {
  // 상태
  viewMode: ViewMode;
  selectedPlanNumber: number | null;
  selectedPlanId: string | null;

  // 핸들러
  handleViewDetail: (planId: string) => void;
  handleSelectPlan: (planNumber: number | null) => void;
  handleSelectPlanById: (planId: string) => void;
  handleModeChange: (mode: ViewMode) => void;
};

/**
 * PlanView 선택 및 뷰 모드 상태 관리 Hook
 *
 * - viewMode (single/daily) 관리
 * - 선택된 플랜 (planNumber, planId) 관리
 * - groups 변경 시 선택 동기화
 *
 * 참고: planDate 관리는 컴포넌트에서 직접 처리 (순환 의존성 방지)
 */
export function usePlanViewState({
  initialMode = "daily",
  initialSelectedPlanNumber = null,
  groups,
  planDate,
}: UsePlanViewStateOptions): UsePlanViewStateReturn {
  // 뷰 모드 상태
  const [viewMode, setViewMode] = useState<ViewMode>(initialMode);

  // 선택된 플랜 상태
  const [selectedPlanNumber, setSelectedPlanNumber] = useState<number | null>(
    initialSelectedPlanNumber
  );
  const [selectedPlanId, setSelectedPlanId] = useState<string | null>(null);

  // 사용자 선택 추적 refs
  const lastUserSelectedPlanNumber = useRef<number | null>(null);
  const lastUserSelectedPlanId = useRef<string | null>(null);
  const lastPlanDate = useRef<string>(planDate);
  const prevGroupsKey = useRef<string>("");

  // groups 키 계산 (변경 감지용)
  const groupsKey = useMemo(() => {
    return groups.map((g) => g.plan.id).join(",");
  }, [groups]);

  // planDate 변경 시 선택 초기화
  useEffect(() => {
    if (planDate !== lastPlanDate.current) {
      lastPlanDate.current = planDate;
      lastUserSelectedPlanNumber.current = null;
      lastUserSelectedPlanId.current = null;
      if (groups.length > 0) {
        setSelectedPlanNumber(groups[0]?.planNumber ?? null);
        setSelectedPlanId(groups[0]?.plan.id ?? null);
      } else {
        setSelectedPlanNumber(null);
        setSelectedPlanId(null);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [planDate]);

  // groups 변경 시 선택 동기화
  useEffect(() => {
    // planDate 변경은 위의 useEffect에서 처리
    if (planDate !== lastPlanDate.current) {
      prevGroupsKey.current = groupsKey;
      return;
    }

    // groupsKey가 변경되지 않았으면 실행하지 않음
    if (groupsKey === prevGroupsKey.current) {
      return;
    }
    prevGroupsKey.current = groupsKey;

    // 사용자 선택이 유효하면 유지
    if (lastUserSelectedPlanId.current !== null) {
      if (groups.some((g) => g.plan.id === lastUserSelectedPlanId.current)) {
        return;
      }
    }
    if (lastUserSelectedPlanNumber.current !== null) {
      if (groups.some((g) => g.planNumber === lastUserSelectedPlanNumber.current)) {
        return;
      }
    }

    // 그룹이 없으면 null로 설정
    if (groups.length === 0) {
      if (selectedPlanNumber !== null) {
        setSelectedPlanNumber(null);
      }
      if (selectedPlanId !== null) {
        setSelectedPlanId(null);
      }
      return;
    }

    // 현재 선택이 유효한지 확인
    const isValidSelection = selectedPlanId
      ? groups.some((g) => g.plan.id === selectedPlanId)
      : selectedPlanNumber !== null
      ? groups.some((g) => g.planNumber === selectedPlanNumber)
      : groups.length > 0;

    if (!isValidSelection) {
      setSelectedPlanNumber(groups[0]?.planNumber ?? null);
      setSelectedPlanId(groups[0]?.plan.id ?? null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [groupsKey, planDate]);

  // 플랜 상세 보기 (daily → single 전환)
  const handleViewDetail = useCallback(
    (planId: string) => {
      const selectedGroup = groups.find((g) => g.plan.id === planId);
      if (selectedGroup) {
        const planNumber = selectedGroup.planNumber;
        lastUserSelectedPlanNumber.current = planNumber;
        lastUserSelectedPlanId.current = planId;
        setSelectedPlanNumber(planNumber);
        setSelectedPlanId(planId);
        setViewMode("single");
      } else if (groups.length > 0) {
        const planNumber = groups[0].planNumber;
        const firstPlanId = groups[0].plan.id;
        lastUserSelectedPlanNumber.current = planNumber;
        lastUserSelectedPlanId.current = firstPlanId;
        setSelectedPlanNumber(planNumber);
        setSelectedPlanId(firstPlanId);
        setViewMode("single");
      }
    },
    [groups]
  );

  // planNumber로 플랜 선택
  const handleSelectPlan = useCallback(
    (planNumber: number | null) => {
      lastUserSelectedPlanNumber.current = planNumber;
      setSelectedPlanNumber(planNumber);
      const selectedGroup = groups.find((g) => g.planNumber === planNumber);
      if (selectedGroup) {
        lastUserSelectedPlanId.current = selectedGroup.plan.id;
        setSelectedPlanId(selectedGroup.plan.id);
      } else if (planNumber === null) {
        lastUserSelectedPlanId.current = null;
        setSelectedPlanId(null);
      }
    },
    [groups]
  );

  // planId로 플랜 선택
  const handleSelectPlanById = useCallback(
    (planId: string) => {
      const selectedGroup = groups.find((g) => g.plan.id === planId);
      if (selectedGroup) {
        const planNumber = selectedGroup.planNumber;
        lastUserSelectedPlanNumber.current = planNumber;
        lastUserSelectedPlanId.current = planId;
        setSelectedPlanNumber(planNumber);
        setSelectedPlanId(planId);
      }
    },
    [groups]
  );

  // 뷰 모드 변경
  const handleModeChange = useCallback(
    (mode: ViewMode) => {
      setViewMode(mode);
      if (mode === "single" && !selectedPlanNumber && groups.length > 0) {
        setSelectedPlanNumber(groups[0]?.planNumber ?? null);
        setSelectedPlanId(groups[0]?.plan.id ?? null);
      }
    },
    [groups, selectedPlanNumber]
  );

  return {
    viewMode,
    selectedPlanNumber,
    selectedPlanId,
    handleViewDetail,
    handleSelectPlan,
    handleSelectPlanById,
    handleModeChange,
  };
}
</file>

<file path="useReducedMotion.ts">
"use client";

import { useState, useEffect } from "react";

/**
 * useReducedMotion - prefers-reduced-motion 미디어 쿼리 감지 훅
 *
 * 사용자가 시스템 설정에서 "모션 줄이기"를 활성화했는지 감지합니다.
 * 접근성 향상을 위해 애니메이션과 전환 효과를 조건부로 적용할 때 사용합니다.
 *
 * @returns {boolean} true이면 사용자가 모션 줄이기를 선호함
 *
 * @example
 * const prefersReducedMotion = useReducedMotion();
 * const animationClass = prefersReducedMotion ? '' : 'transition-all duration-300';
 */
export function useReducedMotion(): boolean {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);

  useEffect(() => {
    // SSR 환경에서는 matchMedia가 없을 수 있음
    if (typeof window === "undefined" || !window.matchMedia) {
      return;
    }

    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");

    // 초기값 설정
    setPrefersReducedMotion(mediaQuery.matches);

    // 변경 감지 핸들러
    const handleChange = (event: MediaQueryListEvent) => {
      setPrefersReducedMotion(event.matches);
    };

    // 이벤트 리스너 등록
    mediaQuery.addEventListener("change", handleChange);

    return () => {
      mediaQuery.removeEventListener("change", handleChange);
    };
  }, []);

  return prefersReducedMotion;
}

/**
 * getMotionSafeClass - 모션 안전 클래스 유틸리티
 *
 * Tailwind의 motion-safe/motion-reduce 변형을 사용하여
 * 접근성을 고려한 클래스 문자열을 생성합니다.
 *
 * @param baseClass - 모션이 허용될 때 적용할 기본 클래스
 * @param reduceClass - 모션 줄이기 시 대체할 클래스 (기본값: 빈 문자열)
 * @returns Tailwind 클래스 문자열
 *
 * @example
 * // 결과: "motion-safe:transition-all motion-safe:duration-300"
 * getMotionSafeClass("transition-all duration-300")
 */
export function getMotionSafeClass(
  baseClass: string,
  reduceClass: string = ""
): string {
  const safeClasses = baseClass
    .split(" ")
    .filter(Boolean)
    .map((cls) => `motion-safe:${cls}`)
    .join(" ");

  if (reduceClass) {
    const reduceClasses = reduceClass
      .split(" ")
      .filter(Boolean)
      .map((cls) => `motion-reduce:${cls}`)
      .join(" ");
    return `${safeClasses} ${reduceClasses}`;
  }

  return safeClasses;
}
</file>

<file path="useSchoolSearch.ts">
/**
 * 학교 검색 관련 커스텀 훅
 * 
 * 학교 검색, 조회 로직을 분리하여 재사용 가능하게 만든 훅입니다.
 * UI 상태는 컴포넌트에서 관리하고, 데이터 페칭 로직만 이 훅에서 처리합니다.
 */

import { useState, useCallback } from "react";
import {
  searchSchools,
  getSchoolById,
  getSchoolByName,
  type School,
} from "@/lib/domains/school";

export type SchoolType = "중학교" | "고등학교" | "대학교";

export interface UseSchoolSearchOptions {
  type?: SchoolType;
}

export interface UseSchoolSearchReturn {
  schools: School[];
  loading: boolean;
  error: Error | null;
  search: (query: string) => Promise<void>;
  getById: (id: string) => Promise<School | null>;
  getByName: (name: string, type?: SchoolType) => Promise<School | null>;
  clear: () => void;
}

/**
 * 학교 검색 커스텀 훅
 * 
 * @param options 검색 옵션 (학교 타입 등)
 * @returns 학교 검색 관련 상태와 함수들
 * 
 * @example
 * ```tsx
 * const { schools, loading, search } = useSchoolSearch({ type: "고등학교" });
 * 
 * useEffect(() => {
 *   search("서울");
 * }, [searchQuery]);
 * ```
 */
export function useSchoolSearch(options: UseSchoolSearchOptions = {}): UseSchoolSearchReturn {
  const [schools, setSchools] = useState<School[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  /**
   * 학교 검색
   * 
   * @param query 검색어
   */
  const search = useCallback(
    async (query: string) => {
      if (!query.trim()) {
        setSchools([]);
        setError(null);
        return;
      }

      setLoading(true);
      setError(null);
      try {
        const results = await searchSchools(query, options.type);
        setSchools(results);
      } catch (e) {
        const err = e instanceof Error ? e : new Error("학교 검색 실패");
        setError(err);
        console.error("[useSchoolSearch] 학교 검색 실패:", err);
        setSchools([]);
      } finally {
        setLoading(false);
      }
    },
    [options.type]
  );

  /**
   * ID로 학교 조회
   * 
   * @param id 학교 ID
   * @returns 학교 객체 또는 null
   */
  const getById = useCallback(async (id: string): Promise<School | null> => {
    if (!id.trim()) {
      return null;
    }

    setLoading(true);
    setError(null);
    try {
      const school = await getSchoolById(id);
      return school;
    } catch (e) {
      const err = e instanceof Error ? e : new Error("학교 조회 실패");
      setError(err);
      console.error("[useSchoolSearch] 학교 조회 실패:", err);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * 이름으로 학교 조회
   * 
   * @param name 학교명
   * @param type 학교 타입 (옵션, 훅 옵션보다 우선)
   * @returns 학교 객체 또는 null (학교가 없으면 임시 객체 반환)
   */
  const getByName = useCallback(
    async (name: string, type?: SchoolType): Promise<School | null> => {
      if (!name.trim()) {
        return null;
      }

      setLoading(true);
      setError(null);
      try {
        const schoolType = type || options.type;
        const school = await getSchoolByName(name, schoolType);
        
        if (school) {
          return school;
        } else {
          // 학교명이 DB에 없으면 임시로 설정
          return {
            id: "",
            name: name,
            type: schoolType || "대학교",
            region: null,
          };
        }
      } catch (e) {
        const err = e instanceof Error ? e : new Error("학교 조회 실패");
        setError(err);
        console.error("[useSchoolSearch] 학교 조회 실패:", err);
        return null;
      } finally {
        setLoading(false);
      }
    },
    [options.type]
  );

  /**
   * 검색 결과 초기화
   */
  const clear = useCallback(() => {
    setSchools([]);
    setError(null);
  }, []);

  return {
    schools,
    loading,
    error,
    search,
    getById,
    getByName,
    clear,
  };
}
</file>

<file path="useScoreFilter.ts">
import { useMemo } from "react";

/**
 * 성적 필터링 및 정렬 공통 훅
 * 
 * ScoreCardGrid와 MockScoreCardGrid의 중복 로직을 추출한 훅입니다.
 */

type ScoreWithInfo<T> = {
  score: T;
  subjectGroupName: string;
  subjectName: string;
  subjectTypeName: string;
};

type FilterConfig = {
  grade?: string;
  semester?: string;
  examType?: string;
  month?: string;
  subjectGroup: string;
  subject: string;
  subjectType: string;
};

type SortConfig<T> = {
  field: string;
  order: "asc" | "desc";
  getValue: (item: ScoreWithInfo<T>, field: string) => number | string | null;
};

/**
 * 성적 필터링 및 정렬 훅
 */
export function useScoreFilter<T>(
  scoresWithInfo: ScoreWithInfo<T>[],
  filterConfig: FilterConfig,
  sortConfig: SortConfig<T>,
  customFilters?: (item: ScoreWithInfo<T>) => boolean
) {
  // 필터링 및 정렬
  const filteredAndSortedScores = useMemo(() => {
    let filtered = [...scoresWithInfo];

    // 학년 필터링
    if (filterConfig.grade && filterConfig.grade !== "all") {
      filtered = filtered.filter(
        (item) => (item.score as { grade?: number }).grade === parseInt(filterConfig.grade!)
      );
    }

    // 학기 필터링
    if (filterConfig.semester && filterConfig.semester !== "all") {
      filtered = filtered.filter(
        (item) => (item.score as { semester?: number }).semester === parseInt(filterConfig.semester!)
      );
    }

    // 시험 유형 필터링
    if (filterConfig.examType && filterConfig.examType !== "all") {
      filtered = filtered.filter(
        (item) => (item.score as { exam_title?: string }).exam_title?.includes(filterConfig.examType!)
      );
    }

    // 회차 필터링
    if (filterConfig.month && filterConfig.month !== "all") {
      filtered = filtered.filter((item) => {
        const examDate = (item.score as { exam_date?: string }).exam_date;
        if (!examDate) return false;
        const month = (new Date(examDate).getMonth() + 1).toString();
        return month === filterConfig.month;
      });
    }

    // 교과 필터링
    if (filterConfig.subjectGroup !== "all") {
      filtered = filtered.filter(
        (item) => item.subjectGroupName === filterConfig.subjectGroup
      );
    }

    // 과목 필터링
    if (filterConfig.subject !== "all") {
      filtered = filtered.filter(
        (item) => item.subjectName === filterConfig.subject
      );
    }

    // 과목 유형 필터링
    if (filterConfig.subjectType !== "all") {
      filtered = filtered.filter(
        (item) => item.subjectTypeName === filterConfig.subjectType
      );
    }

    // 커스텀 필터 적용
    if (customFilters) {
      filtered = filtered.filter(customFilters);
    }

    // 정렬
    filtered.sort((a, b) => {
      const aValue = sortConfig.getValue(a, sortConfig.field);
      const bValue = sortConfig.getValue(b, sortConfig.field);

      if (aValue === null && bValue === null) return 0;
      if (aValue === null) return 1;
      if (bValue === null) return -1;

      if (aValue < bValue) return sortConfig.order === "asc" ? -1 : 1;
      if (aValue > bValue) return sortConfig.order === "asc" ? 1 : -1;
      return 0;
    });

    return filtered;
  }, [scoresWithInfo, filterConfig, sortConfig, customFilters]);

  // 고유한 교과, 과목 유형, 과목, 학년 목록을 단일 순회로 수집 (O(n))
  const availableOptions = useMemo(() => {
    const groups = new Set<string>();
    const types = new Set<string>();
    const subjects = new Set<string>();
    const grades = new Set<number>();

    for (const item of scoresWithInfo) {
      if (item.subjectGroupName) groups.add(item.subjectGroupName);
      if (item.subjectTypeName) types.add(item.subjectTypeName);
      if (item.subjectName) subjects.add(item.subjectName);
      const grade = (item.score as { grade?: number }).grade;
      if (grade) grades.add(grade);
    }

    return {
      subjectGroups: Array.from(groups).sort(),
      subjectTypes: Array.from(types).sort(),
      subjects: Array.from(subjects).sort(),
      grades: Array.from(grades).sort(),
    };
  }, [scoresWithInfo]);

  return {
    filteredAndSortedScores,
    availableSubjectGroups: availableOptions.subjectGroups,
    availableSubjectTypes: availableOptions.subjectTypes,
    availableSubjects: availableOptions.subjects,
    availableGrades: availableOptions.grades,
  };
}
</file>

<file path="useServerAction.ts">
"use client";

import { useTransition, useState, useCallback } from "react";
import type { ActionResponse } from "@/lib/types/actionResponse";
import { isSuccessResponse, isErrorResponse } from "@/lib/types/actionResponse";

type UseServerActionOptions<T> = {
  onSuccess?: (data?: T, message?: string) => void | Promise<void>;
  onError?: (error: string, fieldErrors?: Record<string, string[]>) => void | Promise<void>;
};

type UseServerActionReturn<T, Args extends any[]> = {
  execute: (...args: Args) => Promise<void>;
  isPending: boolean;
  data: T | undefined;
  error: string | null;
  fieldErrors: Record<string, string[]> | null;
  isSuccess: boolean;
  reset: () => void;
};

/**
 * 서버 액션을 쉽고 안전하게 호출할 수 있는 커스텀 훅
 * 
 * @template T - 성공 시 반환할 데이터 타입
 * @template Args - 서버 액션 함수의 인자 타입 배열
 * 
 * @example
 * ```tsx
 * const { execute, isPending, data, error } = useServerAction(
 *   deleteScore,
 *   {
 *     onSuccess: (data) => {
 *       toast.success("성적이 삭제되었습니다.");
 *       router.refresh();
 *     },
 *     onError: (error) => {
 *       toast.error(error);
 *     },
 *   }
 * );
 * 
 * <button onClick={() => execute(scoreId)} disabled={isPending}>
 *   {isPending ? "삭제 중..." : "삭제"}
 * </button>
 * ```
 */
export function useServerAction<T = void, Args extends any[] = any[]>(
  action: (...args: Args) => Promise<ActionResponse<T>>,
  options?: UseServerActionOptions<T>
): UseServerActionReturn<T, Args> {
  const [isPending, startTransition] = useTransition();
  const [data, setData] = useState<T | undefined>(undefined);
  const [error, setError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<Record<string, string[]> | null>(null);
  const [isSuccess, setIsSuccess] = useState(false);

  const execute = useCallback(
    async (...args: Args) => {
      // 상태 초기화
      setError(null);
      setFieldErrors(null);
      setIsSuccess(false);
      setData(undefined);

      startTransition(async () => {
        try {
          const result = await action(...args);

          if (isSuccessResponse(result)) {
            // 성공 처리
            setData(result.data);
            setIsSuccess(true);

            // 성공 콜백 실행
            if (options?.onSuccess) {
              await options.onSuccess(result.data, result.message);
            }
          } else if (isErrorResponse(result)) {
            // 에러 처리
            const errorMessage = result.error || result.message || "처리에 실패했습니다.";
            setError(errorMessage);
            setFieldErrors(result.fieldErrors || result.validationErrors || null);
            setIsSuccess(false);

            // 에러 콜백 실행
            if (options?.onError) {
              await options.onError(errorMessage, result.fieldErrors || result.validationErrors);
            }
          }
        } catch (err) {
          // 예상치 못한 에러 처리
          const errorMessage = err instanceof Error ? err.message : "예상치 못한 오류가 발생했습니다.";
          setError(errorMessage);
          setFieldErrors(null);
          setIsSuccess(false);

          // 에러 콜백 실행
          if (options?.onError) {
            await options.onError(errorMessage);
          }
        }
      });
    },
    [action, options]
  );

  const reset = useCallback(() => {
    setData(undefined);
    setError(null);
    setFieldErrors(null);
    setIsSuccess(false);
  }, []);

  return {
    execute,
    isPending,
    data,
    error,
    fieldErrors,
    isSuccess,
    reset,
  };
}
</file>

<file path="useServerForm.ts">
"use client";

import { useActionState, useEffect } from "react";
import type { ActionResponse } from "@/lib/types/actionResponse";
import { isSuccessResponse, isErrorResponse } from "@/lib/types/actionResponse";

type UseServerFormOptions<T> = {
  onSuccess?: (data?: T, message?: string) => void | Promise<void>;
  onError?: (error: string, fieldErrors?: Record<string, string[]>) => void | Promise<void>;
};

type UseServerFormReturn<T> = {
  action: (formData: FormData) => Promise<ActionResponse<T>>;
  state: ActionResponse<T> | null;
  isPending: boolean;
  fieldErrors: Record<string, string[]> | null;
  isSuccess: boolean;
  error: string | null;
  data: T | undefined;
};

/**
 * HTML Form 요소와 함께 작동하는 서버 액션 훅
 * 
 * @template T - 성공 시 반환할 데이터 타입
 * 
 * @example
 * ```tsx
 * const { action, state, isPending, fieldErrors } = useServerForm(
 *   createBlock,
 *   null,
 *   {
 *     onSuccess: (data) => {
 *       toast.success("블록이 생성되었습니다.");
 *       router.refresh();
 *     },
 *     onError: (error, fieldErrors) => {
 *       toast.error(error);
 *     },
 *   }
 * );
 * 
 * <form action={action}>
 *   <input name="name" />
 *   {fieldErrors?.name && <span>{fieldErrors.name[0]}</span>}
 *   <button type="submit" disabled={isPending}>
 *     {isPending ? "제출 중..." : "제출"}
 *   </button>
 * </form>
 * ```
 */
export function useServerForm<T = void>(
  serverAction: (formData: FormData) => Promise<ActionResponse<T>>,
  initialState: ActionResponse<T> | null = null,
  options?: UseServerFormOptions<T>
): UseServerFormReturn<T> {
  const [state, formAction, isPending] = useActionState(
    async (
      _prev: ActionResponse<T> | null,
      formData: FormData
    ): Promise<ActionResponse<T>> => {
      return await serverAction(formData);
    },
    initialState
  );

  // 상태에서 필드 추출
  const fieldErrors = state && isErrorResponse(state)
    ? (state.fieldErrors || state.validationErrors || null)
    : null;

  const error = state && isErrorResponse(state)
    ? (state.error || state.message || null)
    : null;

  const data = state && isSuccessResponse(state)
    ? state.data
    : undefined;

  const isSuccess = state ? isSuccessResponse(state) : false;

  // 성공/에러 콜백 실행
  useEffect(() => {
    if (!state) return;

    if (isSuccessResponse(state)) {
      if (options?.onSuccess) {
        options.onSuccess(state.data, state.message);
      }
    } else if (isErrorResponse(state)) {
      if (options?.onError) {
        const errorMessage = state.error || state.message || "처리에 실패했습니다.";
        options.onError(errorMessage, state.fieldErrors || state.validationErrors);
      }
    }
  }, [state, options]);

  return {
    action: formAction as (formData: FormData) => Promise<ActionResponse<T>>,
    state,
    isPending,
    fieldErrors,
    isSuccess,
    error,
    data,
  };
}
</file>

<file path="useStudentContents.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { studentContentsQueryOptions } from "@/lib/query-options/studentContents";

type UseStudentContentsOptions = {
  studentId: string;
  enabled?: boolean;
};

/**
 * 학생 콘텐츠 목록 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: contents, isLoading } = useStudentContents({
 *   studentId: "student-123",
 * });
 * 
 * // contents.books, contents.lectures, contents.custom 사용
 * ```
 * 
 * @param options - 조회 옵션
 * @returns React Query 쿼리 결과
 */
export function useStudentContents({
  studentId,
  enabled = true,
}: UseStudentContentsOptions) {
  return useTypedQuery({
    ...studentContentsQueryOptions(studentId),
    enabled: enabled && !!studentId,
  });
}
</file>

<file path="useSubjectSelection.ts">
"use client";

import { useState, useEffect, useCallback } from "react";
import { getSubjectGroupsWithSubjectsAction } from "@/lib/domains/subject";
import type { Subject, SubjectGroup } from "@/lib/data/subjects";
import type { CurriculumRevision } from "@/lib/data/contentMetadata";

type UseSubjectSelectionOptions = {
  curriculumRevisions: CurriculumRevision[];
  initialRevisionId?: string;
  initialGroupId?: string;
  initialSubjectId?: string;
  onInitialLoad?: (revisionId: string) => Promise<void>;
};

export function useSubjectSelection({
  curriculumRevisions,
  initialRevisionId = "",
  initialGroupId = "",
  initialSubjectId = "",
  onInitialLoad,
}: UseSubjectSelectionOptions) {
  const [selectedRevisionId, setSelectedRevisionId] = useState<string>(initialRevisionId);
  const [selectedGroupId, setSelectedGroupId] = useState<string>(initialGroupId);
  const [selectedSubjectId, setSelectedSubjectId] = useState<string>(initialSubjectId);
  const [selectedSubjects, setSelectedSubjects] = useState<Subject[]>([]);
  const [subjectGroups, setSubjectGroups] = useState<(SubjectGroup & { subjects: Subject[] })[]>([]);
  const [loadingGroups, setLoadingGroups] = useState(false);

  // 초기 데이터 로드
  useEffect(() => {
    if (initialRevisionId && onInitialLoad) {
      onInitialLoad(initialRevisionId);
    } else if (initialRevisionId) {
      loadSubjectGroups(initialRevisionId);
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // 교과 그룹 로드 함수
  const loadSubjectGroups = useCallback(async (revisionId: string) => {
    if (!revisionId) {
      setSubjectGroups([]);
      setSelectedSubjects([]);
      return;
    }

    setLoadingGroups(true);
    try {
      const groups = await getSubjectGroupsWithSubjectsAction(revisionId);
      setSubjectGroups(groups);

      // 초기 그룹/과목 설정
      if (initialGroupId) {
        const currentGroup = groups.find(g => g.id === initialGroupId);
        if (currentGroup) {
          setSelectedSubjects(currentGroup.subjects || []);
          
          // 초기 과목 설정
          if (initialSubjectId) {
            const foundSubject = currentGroup.subjects.find(s => s.id === initialSubjectId);
            if (foundSubject) {
              setSelectedSubjectId(initialSubjectId);
            }
          }
        }
      }
    } catch (error) {
      console.error("교과 그룹 조회 실패:", error);
      setSubjectGroups([]);
    } finally {
      setLoadingGroups(false);
    }
  }, [initialGroupId, initialSubjectId]);

  // 개정교육과정 선택 핸들러
  const handleCurriculumRevisionChange = useCallback(async (e: React.ChangeEvent<HTMLSelectElement>) => {
    const revisionName = e.target.value;
    const selectedRevision = curriculumRevisions.find(r => r.name === revisionName);
    
    // 교과 그룹과 과목 선택 초기화 (먼저 수행)
    setSelectedGroupId("");
    setSelectedSubjectId("");
    setSelectedSubjects([]);
    
    if (selectedRevision) {
      // 상태를 먼저 업데이트하여 필드 활성화
      setSelectedRevisionId(selectedRevision.id);
      setLoadingGroups(true);
      
      try {
        await loadSubjectGroups(selectedRevision.id);
      } catch (error) {
        console.error("교과 그룹 로드 실패:", error);
        setSubjectGroups([]);
      } finally {
        setLoadingGroups(false);
      }
    } else {
      setSelectedRevisionId("");
      setSubjectGroups([]);
      setLoadingGroups(false);
    }
  }, [curriculumRevisions, loadSubjectGroups]);

  // 교과 그룹 선택 핸들러
  const handleSubjectGroupChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    const groupId = e.target.value;
    setSelectedGroupId(groupId);
    setSelectedSubjectId(""); // 과목 선택 초기화
    
    if (groupId) {
      const group = subjectGroups.find(g => g.id === groupId);
      setSelectedSubjects(group?.subjects || []);
    } else {
      setSelectedSubjects([]);
    }
  }, [subjectGroups]);

  // 과목 선택 핸들러
  const handleSubjectChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    const subjectName = e.target.value;
    const selectedSubject = selectedSubjects.find(s => s.name === subjectName);
    setSelectedSubjectId(selectedSubject?.id || "");
  }, [selectedSubjects]);

  // FormData에 과목 정보 추가 헬퍼
  const addSubjectDataToFormData = useCallback((formData: FormData) => {
    if (selectedGroupId) {
      const selectedGroup = subjectGroups.find(g => g.id === selectedGroupId);
      if (selectedGroup) {
        formData.set("subject_group_id", selectedGroup.id);
        formData.set("subject_category", selectedGroup.name);
      }
    }
    if (selectedSubjectId) {
      const selectedSubject = selectedSubjects.find(s => s.id === selectedSubjectId);
      if (selectedSubject) {
        formData.set("subject", selectedSubject.name);
      }
    }
    if (selectedRevisionId) {
      formData.set("curriculum_revision_id", selectedRevisionId);
    }
    if (selectedSubjectId) {
      formData.set("subject_id", selectedSubjectId);
    }
  }, [selectedGroupId, selectedSubjectId, selectedRevisionId, subjectGroups, selectedSubjects]);

  return {
    selectedRevisionId,
    selectedGroupId,
    selectedSubjectId,
    selectedSubjects,
    subjectGroups,
    loadingGroups,
    handleCurriculumRevisionChange,
    handleSubjectGroupChange,
    handleSubjectChange,
    addSubjectDataToFormData,
    // 내부 상태 업데이트를 위한 setter (필요한 경우)
    setSelectedRevisionId,
    setSelectedGroupId,
    setSelectedSubjectId,
    setSelectedSubjects,
  };
}
</file>

<file path="useTodayPlans.ts">
"use client";

import { useTypedQuery } from "@/lib/hooks/useTypedQuery";
import { todayPlansQueryOptions } from "@/lib/query-options/todayPlans";
import type { TodayPlansResponse } from "@/lib/data/todayPlans";

type UseTodayPlansOptions = {
  studentId: string;
  tenantId: string | null;
  date: string;
  camp?: boolean;
  includeProgress?: boolean;
  enabled?: boolean;
  initialData?: TodayPlansResponse;
};

/**
 * Today Plans 조회 훅
 * 
 * @example
 * ```typescript
 * const { data: todayPlans, isLoading, error } = useTodayPlans({
 *   studentId: "student-123",
 *   tenantId: "tenant-456",
 *   date: "2025-01-01",
 *   camp: false,
 *   includeProgress: true,
 * });
 * ```
 * 
 * @param options - 조회 옵션
 * @returns React Query 쿼리 결과
 */
export function useTodayPlans({
  studentId,
  tenantId,
  date,
  camp = false,
  includeProgress = true,
  enabled = true,
  initialData,
}: UseTodayPlansOptions) {
  return useTypedQuery({
    ...todayPlansQueryOptions(studentId, tenantId, date, {
      camp,
      includeProgress,
    }),
    enabled: enabled && !!studentId && !!date,
    initialData,
  });
}
</file>

<file path="useTypedQuery.ts">
/**
 * 타입 안전한 useQuery 래퍼
 * 
 * queryOptions 패턴을 사용하여 타입 안전성을 향상시킨 useQuery 훅
 * 
 * TanStack Query v5의 queryOptions를 활용하여 타입 안전성을 향상시킵니다.
 */

import { useQuery, queryOptions, type UseQueryOptions, type UseQueryResult } from "@tanstack/react-query";
import type { QueryKey } from "@tanstack/react-query";

/**
 * 타입 안전한 useQuery 훅
 * 
 * queryOptions를 사용하여 타입 안전성을 향상시킵니다.
 * 
 * @example
 * ```typescript
 * const planOptions = queryOptions({
 *   queryKey: ['plans', studentId, planDate],
 *   queryFn: async () => {
 *     return await getPlansForStudent({ studentId, planDate });
 *   },
 *   staleTime: 1000 * 60,
 * });
 * 
 * const { data, isLoading } = useTypedQuery(planOptions);
 * // data는 자동으로 Plan[] | undefined로 추론됨
 * ```
 */
export function useTypedQuery<
  TQueryFnData = unknown,
  TError = Error,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey
>(
  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>
): UseQueryResult<TData, TError> {
  return useQuery(options);
}

/**
 * queryOptions를 re-export하여 편의성 향상
 */
export { queryOptions };
</file>

<file path="useUndoRedo.ts">
/**
 * useUndoRedo 훅
 *
 * 범용 Undo/Redo 스택을 제공합니다.
 * 키보드 단축키 (Ctrl/Cmd + Z, Ctrl/Cmd + Shift + Z) 지원을 포함합니다.
 *
 * @module lib/hooks/useUndoRedo
 */

"use client";

import { useState, useCallback, useEffect, useMemo, useRef } from "react";

// ============================================================================
// 타입 정의
// ============================================================================

/**
 * 히스토리 엔트리
 */
export interface HistoryEntry<T> {
  /** 상태 스냅샷 */
  state: T;
  /** 타임스탬프 */
  timestamp: number;
  /** 액션 설명 (선택적) */
  description?: string;
}

/**
 * Undo/Redo 훅 옵션
 */
export interface UseUndoRedoOptions<T> {
  /** 초기 상태 */
  initialState: T;
  /** 최대 히스토리 길이 (기본값: 50) */
  maxHistoryLength?: number;
  /** 키보드 단축키 활성화 (기본값: true) */
  enableKeyboardShortcuts?: boolean;
  /** 상태 비교 함수 (변경 감지용) */
  compare?: (a: T, b: T) => boolean;
  /** Undo 시 콜백 */
  onUndo?: (state: T, description?: string) => void;
  /** Redo 시 콜백 */
  onRedo?: (state: T, description?: string) => void;
  /** 히스토리 변경 시 콜백 */
  onChange?: (state: T) => void;
}

/**
 * Undo/Redo 훅 반환값
 */
export interface UseUndoRedoResult<T> {
  /** 현재 상태 */
  state: T;
  /** 상태 업데이트 (히스토리에 추가) */
  setState: (newState: T | ((prev: T) => T), description?: string) => void;
  /** Undo 실행 */
  undo: () => void;
  /** Redo 실행 */
  redo: () => void;
  /** Undo 가능 여부 */
  canUndo: boolean;
  /** Redo 가능 여부 */
  canRedo: boolean;
  /** 히스토리 초기화 */
  reset: (newState?: T) => void;
  /** 현재 히스토리 */
  history: HistoryEntry<T>[];
  /** 현재 히스토리 인덱스 */
  historyIndex: number;
  /** 특정 히스토리 인덱스로 이동 */
  goToHistory: (index: number) => void;
  /** Undo 히스토리 (이전 상태들) */
  undoHistory: HistoryEntry<T>[];
  /** Redo 히스토리 (되돌린 상태들) */
  redoHistory: HistoryEntry<T>[];
}

// ============================================================================
// 상수
// ============================================================================

const DEFAULT_MAX_HISTORY_LENGTH = 50;

// ============================================================================
// 유틸리티
// ============================================================================

/**
 * 기본 상태 비교 함수 (얕은 비교)
 */
function defaultCompare<T>(a: T, b: T): boolean {
  if (a === b) return true;
  if (typeof a !== "object" || typeof b !== "object") return false;
  if (a === null || b === null) return false;
  return JSON.stringify(a) === JSON.stringify(b);
}

// ============================================================================
// 훅
// ============================================================================

/**
 * Undo/Redo 훅
 *
 * @example
 * ```tsx
 * const {
 *   state,
 *   setState,
 *   undo,
 *   redo,
 *   canUndo,
 *   canRedo,
 * } = useUndoRedo({
 *   initialState: { count: 0 },
 *   onUndo: (state) => console.log('Undo:', state),
 * });
 *
 * return (
 *   <div>
 *     <p>Count: {state.count}</p>
 *     <button onClick={() => setState({ count: state.count + 1 }, 'Increment')}>
 *       +1
 *     </button>
 *     <button onClick={undo} disabled={!canUndo}>Undo</button>
 *     <button onClick={redo} disabled={!canRedo}>Redo</button>
 *   </div>
 * );
 * ```
 */
export function useUndoRedo<T>(
  options: UseUndoRedoOptions<T>
): UseUndoRedoResult<T> {
  const {
    initialState,
    maxHistoryLength = DEFAULT_MAX_HISTORY_LENGTH,
    enableKeyboardShortcuts = true,
    compare = defaultCompare,
    onUndo,
    onRedo,
    onChange,
  } = options;

  // 히스토리 상태
  const [history, setHistory] = useState<HistoryEntry<T>[]>([
    { state: initialState, timestamp: Date.now() },
  ]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // Refs for callbacks to avoid stale closures
  const onUndoRef = useRef(onUndo);
  const onRedoRef = useRef(onRedo);
  const onChangeRef = useRef(onChange);

  useEffect(() => {
    onUndoRef.current = onUndo;
    onRedoRef.current = onRedo;
    onChangeRef.current = onChange;
  }, [onUndo, onRedo, onChange]);

  // 현재 상태
  const state = useMemo(() => history[historyIndex].state, [history, historyIndex]);

  // 상태 업데이트
  const setState = useCallback(
    (newState: T | ((prev: T) => T), description?: string) => {
      setHistory((prevHistory) => {
        const currentState = prevHistory[historyIndex].state;
        const resolvedState =
          typeof newState === "function"
            ? (newState as (prev: T) => T)(currentState)
            : newState;

        // 상태가 변경되지 않았으면 무시
        if (compare(currentState, resolvedState)) {
          return prevHistory;
        }

        // 현재 인덱스 이후의 히스토리 제거 (redo 불가능하게)
        const newHistory = prevHistory.slice(0, historyIndex + 1);

        // 새 상태 추가
        newHistory.push({
          state: resolvedState,
          timestamp: Date.now(),
          description,
        });

        // 최대 길이 제한
        while (newHistory.length > maxHistoryLength) {
          newHistory.shift();
        }

        return newHistory;
      });

      setHistoryIndex((prev) => {
        const newIndex = Math.min(prev + 1, maxHistoryLength - 1);
        return newIndex;
      });

      // onChange 콜백
      const resolvedState =
        typeof newState === "function"
          ? (newState as (prev: T) => T)(history[historyIndex].state)
          : newState;
      onChangeRef.current?.(resolvedState);
    },
    [historyIndex, compare, maxHistoryLength, history]
  );

  // Undo
  const undo = useCallback(() => {
    if (historyIndex <= 0) return;

    const newIndex = historyIndex - 1;
    const entry = history[newIndex];

    setHistoryIndex(newIndex);
    onUndoRef.current?.(entry.state, entry.description);
    onChangeRef.current?.(entry.state);
  }, [historyIndex, history]);

  // Redo
  const redo = useCallback(() => {
    if (historyIndex >= history.length - 1) return;

    const newIndex = historyIndex + 1;
    const entry = history[newIndex];

    setHistoryIndex(newIndex);
    onRedoRef.current?.(entry.state, entry.description);
    onChangeRef.current?.(entry.state);
  }, [historyIndex, history]);

  // 특정 히스토리로 이동
  const goToHistory = useCallback(
    (index: number) => {
      if (index < 0 || index >= history.length) return;
      setHistoryIndex(index);
      onChangeRef.current?.(history[index].state);
    },
    [history]
  );

  // 초기화
  const reset = useCallback(
    (newState?: T) => {
      const resetState = newState ?? initialState;
      setHistory([{ state: resetState, timestamp: Date.now() }]);
      setHistoryIndex(0);
      onChangeRef.current?.(resetState);
    },
    [initialState]
  );

  // 키보드 단축키
  useEffect(() => {
    if (!enableKeyboardShortcuts) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
      const modifier = isMac ? e.metaKey : e.ctrlKey;

      if (modifier && e.key === "z") {
        e.preventDefault();
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
      }

      // Windows/Linux: Ctrl + Y for redo
      if (!isMac && e.ctrlKey && e.key === "y") {
        e.preventDefault();
        redo();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [enableKeyboardShortcuts, undo, redo]);

  // 계산된 값들
  const canUndo = historyIndex > 0;
  const canRedo = historyIndex < history.length - 1;
  const undoHistory = useMemo(
    () => history.slice(0, historyIndex),
    [history, historyIndex]
  );
  const redoHistory = useMemo(
    () => history.slice(historyIndex + 1),
    [history, historyIndex]
  );

  return {
    state,
    setState,
    undo,
    redo,
    canUndo,
    canRedo,
    reset,
    history,
    historyIndex,
    goToHistory,
    undoHistory,
    redoHistory,
  };
}

/**
 * Undo/Redo 상태 표시 컴포넌트용 훅
 *
 * @example
 * ```tsx
 * const { undoLabel, redoLabel } = useUndoRedoLabels(undoHistory, redoHistory);
 * // undoLabel: "실행 취소: 증가"
 * // redoLabel: "다시 실행: 감소"
 * ```
 */
export function useUndoRedoLabels<T>(
  undoHistory: HistoryEntry<T>[],
  redoHistory: HistoryEntry<T>[]
): { undoLabel: string; redoLabel: string } {
  const undoLabel = useMemo(() => {
    if (undoHistory.length === 0) return "실행 취소";
    const lastEntry = undoHistory[undoHistory.length - 1];
    return lastEntry.description
      ? `실행 취소: ${lastEntry.description}`
      : "실행 취소";
  }, [undoHistory]);

  const redoLabel = useMemo(() => {
    if (redoHistory.length === 0) return "다시 실행";
    const firstEntry = redoHistory[0];
    return firstEntry.description
      ? `다시 실행: ${firstEntry.description}`
      : "다시 실행";
  }, [redoHistory]);

  return { undoLabel, redoLabel };
}
</file>

<file path="useWeeklyOptimization.ts">
/**
 * useWeeklyOptimization 훅
 *
 * 주간 학습 최적화를 위한 분석 데이터를 제공합니다.
 * - 일일 최적 학습량 계산
 * - 휴식 권장 요일 제안
 * - 간격 반복 콘텐츠 스케줄 생성
 *
 * @module lib/hooks/useWeeklyOptimization
 */

import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useMemo, useCallback } from "react";
import {
  getAdaptiveScheduleAnalysis,
  getWeakSubjectReinforcement,
} from "@/lib/domains/plan/actions/plan-groups/adaptiveAnalysis";
import type {
  LearningPatternAnalysis,
  DayOfWeekPerformance,
  SubjectPerformance,
} from "@/lib/domains/plan/services/adaptiveScheduler";

// ============================================================================
// 타입 정의
// ============================================================================

/**
 * 간격 반복 스케줄 아이템
 */
export interface ContentSchedule {
  /** 과목명 */
  subject: string;
  /** 권장 학습 일자 (YYYY-MM-DD 형식) */
  recommendedDate: string;
  /** 권장 이유 */
  reason: string;
  /** 우선순위 (1이 가장 높음) */
  priority: number;
  /** 복습 간격 (일) */
  intervalDays: number;
}

/**
 * 주간 최적화 결과
 */
export interface WeeklyOptimizationResult {
  /** 일일 최적 학습량 (콘텐츠 수) */
  idealDailyLoad: number;
  /** 휴식 권장 요일 (YYYY-MM-DD 형식) */
  restDays: string[];
  /** 간격 반복 콘텐츠 스케줄 */
  spacedRepetition: ContentSchedule[];
  /** 원본 패턴 분석 데이터 */
  patterns: LearningPatternAnalysis | null;
  /** 최적 학습 시간대 */
  optimalTimePeriod: string | null;
  /** 최적 학습 요일 */
  optimalDayOfWeek: number | null;
  /** 취약 과목 목록 */
  weakSubjects: SubjectPerformance[];
}

/**
 * 훅 옵션
 */
export interface UseWeeklyOptimizationOptions {
  /** 분석할 과거 일수 (기본값: 30일) */
  daysBack?: number;
  /** 목표 완료율 (기본값: 80%) */
  targetCompletionRate?: number;
  /** 자동 조회 활성화 (기본값: true) */
  enabled?: boolean;
}

// ============================================================================
// 상수
// ============================================================================

const QUERY_KEY_BASE = "weeklyOptimization";
const DEFAULT_DAYS_BACK = 30;
const DEFAULT_TARGET_COMPLETION_RATE = 80;
const STALE_TIME = 5 * 60 * 1000; // 5분
const GC_TIME = 30 * 60 * 1000; // 30분

// 요일 라벨 (0 = 일요일)
const DAY_LABELS = ["일", "월", "화", "수", "목", "금", "토"];

// 휴식 권장 기준 완료율 (이 수치 이하면 휴식 권장)
const REST_DAY_THRESHOLD = 50;

// 간격 반복 기본 간격 (일)
const SPACED_REPETITION_INTERVALS = [1, 3, 7, 14, 30];

// ============================================================================
// 유틸리티 함수
// ============================================================================

/**
 * 일일 최적 학습량 계산
 * 완료율과 평균 진행률을 기반으로 적정 학습량을 산정
 */
function calculateIdealDailyLoad(patterns: LearningPatternAnalysis): number {
  const { overallCompletionRate, dayOfWeekPerformance } = patterns;

  // 요일별 총 플랜 수의 평균 계산
  const totalPlansPerDay =
    dayOfWeekPerformance.length > 0
      ? dayOfWeekPerformance.reduce((sum, d) => sum + d.totalPlans, 0) /
        dayOfWeekPerformance.length
      : 0;

  // 완료율이 낮으면 학습량 감소, 높으면 유지 또는 약간 증가
  let loadMultiplier = 1.0;
  if (overallCompletionRate < 50) {
    loadMultiplier = 0.7; // 30% 감소
  } else if (overallCompletionRate < 70) {
    loadMultiplier = 0.85; // 15% 감소
  } else if (overallCompletionRate >= 90) {
    loadMultiplier = 1.1; // 10% 증가
  }

  // 최소 1개, 최대 10개로 제한
  const idealLoad = Math.round(totalPlansPerDay * loadMultiplier);
  return Math.max(1, Math.min(10, idealLoad || 3));
}

/**
 * 휴식 권장 요일 계산
 * 완료율이 낮은 요일을 휴식일로 권장
 */
function calculateRestDays(
  dayOfWeekPerformance: DayOfWeekPerformance[]
): string[] {
  const today = new Date();
  const restDays: string[] = [];

  // 완료율이 낮은 요일 찾기
  const lowPerformanceDays = dayOfWeekPerformance
    .filter((d) => d.completionRate < REST_DAY_THRESHOLD && d.totalPlans >= 3)
    .map((d) => d.dayOfWeek);

  // 앞으로 2주간의 해당 요일을 휴식일로 지정
  for (let i = 0; i < 14; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dayOfWeek = date.getDay();

    if (lowPerformanceDays.includes(dayOfWeek)) {
      restDays.push(date.toISOString().slice(0, 10));
    }
  }

  return restDays;
}

/**
 * 간격 반복 스케줄 생성
 * 취약 과목을 기반으로 복습 스케줄 생성
 */
function generateSpacedRepetitionSchedule(
  weakSubjects: SubjectPerformance[],
  optimalDayOfWeek: number | null
): ContentSchedule[] {
  const today = new Date();
  const schedules: ContentSchedule[] = [];

  weakSubjects.forEach((subject, index) => {
    // 우선순위에 따라 간격 설정 (취약할수록 자주 복습)
    const intervalIndex = Math.min(
      index,
      SPACED_REPETITION_INTERVALS.length - 1
    );
    const interval = SPACED_REPETITION_INTERVALS[intervalIndex];

    // 복습 일자 계산 (최적 요일을 고려)
    let recommendedDate = new Date(today);
    recommendedDate.setDate(today.getDate() + interval);

    // 최적 요일이 있으면 가장 가까운 해당 요일로 조정
    if (optimalDayOfWeek !== null) {
      const currentDay = recommendedDate.getDay();
      const daysUntilOptimal = (optimalDayOfWeek - currentDay + 7) % 7;
      if (daysUntilOptimal > 0 && daysUntilOptimal <= 3) {
        recommendedDate.setDate(recommendedDate.getDate() + daysUntilOptimal);
      }
    }

    schedules.push({
      subject: subject.subject,
      recommendedDate: recommendedDate.toISOString().slice(0, 10),
      reason: `완료율 ${subject.completionRate}%로 보강이 필요합니다.`,
      priority: index + 1,
      intervalDays: interval,
    });
  });

  return schedules;
}

// ============================================================================
// 훅
// ============================================================================

/**
 * 주간 학습 최적화 훅
 *
 * @example
 * ```tsx
 * const {
 *   idealDailyLoad,
 *   restDays,
 *   spacedRepetition,
 *   isLoading,
 *   refetch
 * } = useWeeklyOptimization(studentId);
 *
 * // 일일 학습량 표시
 * <p>오늘 권장 학습량: {idealDailyLoad}개</p>
 *
 * // 휴식일 표시
 * {restDays.includes(today) && <Badge>오늘은 휴식일이에요</Badge>}
 *
 * // 복습 스케줄 표시
 * {spacedRepetition.map(s => (
 *   <div key={s.subject}>
 *     {s.subject}: {s.recommendedDate}에 복습
 *   </div>
 * ))}
 * ```
 */
export function useWeeklyOptimization(
  studentId: string | null,
  options: UseWeeklyOptimizationOptions = {}
) {
  const {
    daysBack = DEFAULT_DAYS_BACK,
    targetCompletionRate = DEFAULT_TARGET_COMPLETION_RATE,
    enabled = true,
  } = options;

  const queryClient = useQueryClient();

  // 적응형 스케줄 분석 쿼리
  const analysisQuery = useQuery({
    queryKey: [QUERY_KEY_BASE, "analysis", studentId, daysBack] as const,
    queryFn: async () => {
      if (!studentId) return null;
      const result = await getAdaptiveScheduleAnalysis(studentId, daysBack);
      if (!result.success) {
        throw new Error(result.error || "분석에 실패했습니다.");
      }
      return result.data ?? null;
    },
    staleTime: STALE_TIME,
    gcTime: GC_TIME,
    enabled: enabled && !!studentId,
  });

  // 취약 과목 강화 쿼리
  const reinforcementQuery = useQuery({
    queryKey: [
      QUERY_KEY_BASE,
      "reinforcement",
      studentId,
      daysBack,
      targetCompletionRate,
    ] as const,
    queryFn: async () => {
      if (!studentId) return null;
      const result = await getWeakSubjectReinforcement(
        studentId,
        daysBack,
        targetCompletionRate
      );
      if (!result.success) {
        throw new Error(result.error || "강화 스케줄 생성에 실패했습니다.");
      }
      return result.data ?? null;
    },
    staleTime: STALE_TIME,
    gcTime: GC_TIME,
    enabled: enabled && !!studentId,
  });

  // 최적화 결과 계산
  const optimizationResult = useMemo((): WeeklyOptimizationResult => {
    const analysis = analysisQuery.data;
    const patterns = analysis?.patterns ?? null;

    if (!patterns) {
      return {
        idealDailyLoad: 3, // 기본값
        restDays: [],
        spacedRepetition: [],
        patterns: null,
        optimalTimePeriod: null,
        optimalDayOfWeek: null,
        weakSubjects: [],
      };
    }

    const idealDailyLoad = calculateIdealDailyLoad(patterns);
    const restDays = calculateRestDays(patterns.dayOfWeekPerformance);
    const spacedRepetition = generateSpacedRepetitionSchedule(
      patterns.weakSubjects,
      patterns.optimalDayOfWeek?.dayOfWeek ?? null
    );

    return {
      idealDailyLoad,
      restDays,
      spacedRepetition,
      patterns,
      optimalTimePeriod: patterns.optimalTimePeriod?.label ?? null,
      optimalDayOfWeek: patterns.optimalDayOfWeek?.dayOfWeek ?? null,
      weakSubjects: patterns.weakSubjects,
    };
  }, [analysisQuery.data]);

  // 데이터 새로고침
  const refetch = useCallback(async () => {
    await Promise.all([
      analysisQuery.refetch(),
      reinforcementQuery.refetch(),
    ]);
  }, [analysisQuery, reinforcementQuery]);

  // 캐시 무효화
  const invalidate = useCallback(async () => {
    await queryClient.invalidateQueries({
      queryKey: [QUERY_KEY_BASE],
    });
  }, [queryClient]);

  return {
    // 최적화 결과
    ...optimizationResult,

    // 쿼리 상태
    isLoading: analysisQuery.isLoading || reinforcementQuery.isLoading,
    isError: analysisQuery.isError || reinforcementQuery.isError,
    error: analysisQuery.error || reinforcementQuery.error,

    // 원본 데이터
    analysis: analysisQuery.data,
    reinforcement: reinforcementQuery.data,

    // 권장사항
    recommendations: analysisQuery.data?.recommendations ?? [],

    // 액션
    refetch,
    invalidate,
  };
}

// ============================================================================
// 유틸리티 훅
// ============================================================================

/**
 * 오늘이 휴식일인지 확인하는 훅
 */
export function useIsRestDay(studentId: string | null) {
  const { restDays, isLoading } = useWeeklyOptimization(studentId);
  const today = new Date().toISOString().slice(0, 10);

  return {
    isRestDay: restDays.includes(today),
    isLoading,
  };
}

/**
 * 특정 날짜의 최적화 정보를 가져오는 훅
 */
export function useDateOptimization(
  studentId: string | null,
  date: string // YYYY-MM-DD 형식
) {
  const {
    restDays,
    spacedRepetition,
    idealDailyLoad,
    optimalTimePeriod,
    isLoading,
  } = useWeeklyOptimization(studentId);

  const scheduledSubjects = spacedRepetition
    .filter((s) => s.recommendedDate === date)
    .map((s) => s.subject);

  return {
    isRestDay: restDays.includes(date),
    scheduledSubjects,
    recommendedLoad: restDays.includes(date) ? 0 : idealDailyLoad,
    optimalTimePeriod,
    isLoading,
  };
}

/**
 * 요일별 최적화 힌트를 제공하는 훅
 */
export function useDayOfWeekHints(studentId: string | null) {
  const { patterns, isLoading } = useWeeklyOptimization(studentId);

  const hints = useMemo(() => {
    if (!patterns) return [];

    return patterns.dayOfWeekPerformance.map((d) => ({
      dayOfWeek: d.dayOfWeek,
      label: DAY_LABELS[d.dayOfWeek],
      completionRate: d.completionRate,
      averageProgress: d.averageProgress,
      isOptimal: d.dayOfWeek === patterns.optimalDayOfWeek?.dayOfWeek,
      isRestRecommended: d.completionRate < REST_DAY_THRESHOLD && d.totalPlans >= 3,
      hint: getPerformanceHint(d.completionRate),
    }));
  }, [patterns]);

  return {
    hints,
    isLoading,
  };
}

function getPerformanceHint(completionRate: number): string {
  if (completionRate >= 90) return "최상의 학습 효율!";
  if (completionRate >= 70) return "좋은 학습 흐름입니다";
  if (completionRate >= 50) return "조금 더 집중해보세요";
  return "이 요일은 휴식이 좋을 수 있어요";
}
</file>

</files>
