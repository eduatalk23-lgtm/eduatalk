# 학습일/복습일 주기 설정 (Study/Review Cycle)

## 개요

이 문서는 플랜 생성 시 학습일과 복습일의 주기 설정에 대한 규칙과 처리 로직을 정의합니다. 학습일에는 새로운 플랜을 배정하고, 복습일에는 직전 학습일 동안 배정된 플랜들을 복습하는 주기 패턴을 관리합니다.

---

## 필수 입력 항목

### 학습일 수 (Study Days)

- **형식**: 숫자 (일)
- **기본값**: `6` (6일)
- **설명**: 학습을 진행하는 연속된 일수

### 복습일 수 (Review Days)

- **형식**: 숫자 (일)
- **기본값**: `1` (1일)
- **설명**: 복습을 진행하는 연속된 일수

---

## 주기 구성 규칙

### 기본 원칙

- **1주기 = 학습일 + 복습일**
- 기본 구성: `6일 학습 + 1일 복습 = 7일 (1주기)`
- 주기는 기간 내에서 반복 적용됨

### 복습 범위

- **복습일에는 직전 학습일(6일) 동안 학습한 내용을 복습**
- 복습 대상은 직전 주기의 학습일에 배정된 플랜들

### ⚠️ 중요: 제외일 처리

**학습 제외일은 주기 계산에서 제외됨**

- 실제 날짜 기준이 아닌, **학습일과 복습일만 합쳐서 주기 길이 계산**
- 예: 6일 학습 + 1일 복습 = 7일인데, 그 사이에 제외일이 2일 있으면 실제로는 9일이 걸리지만 주기는 여전히 7일(학습일+복습일)로 계산
- 제외일은 주기 일자 카운트에 포함되지 않음

---

## 제약조건

### 입력값 검증

- **학습일 수**: 1 이상의 정수
- **복습일 수**: 0 이상의 정수 (0이면 복습일 없음)
- **주기 길이**: 학습일 수 + 복습일 수 = 주기 길이

### 주기 계산 규칙

- **학습 제외일은 주기 계산에서 제외됨** (주기 길이에 포함되지 않음)
- 주기 일자 번호는 제외일을 건너뛰고 연속적으로 카운트됨

---

## 용도

### 1. 플랜 배정 구분

- **학습일**: 새 플랜 배정
- **복습일**: 직전 학습일 동안의 플랜 복습

### 2. 주기별 반복

- 기간 내에서 주기 패턴 반복 적용 (제외일 제외)
- 주기 패턴이 기간 종료일까지 반복됨

### 3. 학습/복습 구분

- 날짜별로 학습일/복습일 자동 구분
- 주기 일자 번호로 현재 주기 내 위치 파악

### 4. 복습 범위

- 복습일에는 직전 주기의 학습일(6일) 동안 배정된 플랜들을 복습
- 제외일은 복습 범위 계산에서 제외됨

---

## 주기 계산 예시

### 시나리오: 제외일이 포함된 경우

#### 입력값

- **기간**: `2025-01-01 ~ 2025-01-31`
- **학습일 수**: `6일`
- **복습일 수**: `1일`
- **제외일**: `2025-01-05` (휴가)

#### 날짜별 구분

| 날짜         | 유형   | 주기 일자  | 설명             |
| ------------ | ------ | ---------- | ---------------- |
| `2025-01-01` | 학습일 | 주기 1일차 | 1주기 시작       |
| `2025-01-02` | 학습일 | 주기 2일차 |                  |
| `2025-01-03` | 학습일 | 주기 3일차 |                  |
| `2025-01-04` | 학습일 | 주기 4일차 |                  |
| `2025-01-05` | 제외일 | -          | 주기 계산 제외   |
| `2025-01-06` | 학습일 | 주기 5일차 | 제외일 이후 계속 |
| `2025-01-07` | 학습일 | 주기 6일차 |                  |
| `2025-01-08` | 복습일 | 주기 7일차 | 1주기 완료       |
| `2025-01-09` | 학습일 | 주기 1일차 | 2주기 시작       |

#### 결과

- 실제로는 8일이 걸렸지만, 주기는 학습일 6일 + 복습일 1일 = **7일로 계산됨**
- 제외일(`2025-01-05`)은 주기 계산에서 완전히 제외됨
- 주기 일자 번호는 제외일을 건너뛰고 연속적으로 카운트됨

### 시나리오: 복습일이 없는 경우

#### 입력값

- **학습일 수**: `7일`
- **복습일 수**: `0일`

#### 결과

- 주기 길이: 7일 (학습일만)
- 복습일 없이 계속 학습일만 진행
- 주기 개념은 유지되지만 복습일은 없음

---

## 고려사항

### 1. 제외일 처리

- 제외일은 주기 계산에서 완전히 제외됨
- 주기 일자 카운트에 포함되지 않음
- 제외일 이후에도 주기 패턴이 계속되며, 주기 일자 번호는 이어서 카운트됨

### 2. 주기 연속성

- 제외일 이후에도 주기 패턴이 계속됨
- 주기 일자 번호는 제외일을 건너뛰고 연속적으로 카운트됨
- 주기 경계는 학습일과 복습일의 합으로만 결정됨

### 3. 복습 범위

- 복습일에는 직전 주기의 학습일(6일) 동안 배정된 플랜만 복습
- 제외일은 복습 범위 계산에서 제외됨
- 복습 대상은 실제 학습일(제외일 제외)에 배정된 플랜들

### 4. 주기 경계 처리

- 주기 경계는 학습일과 복습일의 합으로만 결정됨
- 제외일이 주기 경계에 있어도 주기 계산에는 영향 없음
- 주기 완료 후 다음 주기는 즉시 시작됨

---

## 데이터 구조

### TypeScript 타입 정의

```typescript
type StudyReviewCycle = {
  study_days: number; // 학습일 수 (기본값: 6)
  review_days: number; // 복습일 수 (기본값: 1)
};
```

### 주기 계산 함수 시그니처

```typescript
/**
 * 날짜가 학습일인지 복습일인지 판단
 * @param date - 판단할 날짜 (YYYY-MM-DD)
 * @param cycle - 학습일/복습일 주기 설정
 * @param periodStart - 기간 시작일
 * @param exclusions - 제외일 목록
 * @returns 날짜 유형 ('study' | 'review' | 'exclusion')
 */
function getDateType(
  date: string,
  cycle: StudyReviewCycle,
  periodStart: string,
  exclusions: string[]
): "study" | "review" | "exclusion";

/**
 * 주기 내 일자 번호 계산
 * @param date - 계산할 날짜 (YYYY-MM-DD)
 * @param cycle - 학습일/복습일 주기 설정
 * @param periodStart - 기간 시작일
 * @param exclusions - 제외일 목록
 * @returns 주기 내 일자 번호 (1부터 시작)
 */
function getCycleDayNumber(
  date: string,
  cycle: StudyReviewCycle,
  periodStart: string,
  exclusions: string[]
): number;
```

---

## 구현 로직

### 주기 계산 알고리즘

1. **기간 내 날짜 순회**

   - `periodStart`부터 `periodEnd`까지 날짜를 순회
   - 제외일은 건너뜀

2. **주기 일자 카운트**

   - 제외일을 제외한 날짜만 카운트
   - 카운트가 `study_days` 이하면 학습일
   - 카운트가 `study_days + 1` 이상 `study_days + review_days` 이하면 복습일
   - 카운트가 `study_days + review_days`를 초과하면 다음 주기 시작 (카운트 리셋)

3. **주기 경계 처리**
   - 주기 완료 후 카운트를 1로 리셋
   - 다음 주기 시작

### 예시 구현 (의사코드)

```typescript
function calculateCycleDays(
  periodStart: Date,
  periodEnd: Date,
  cycle: StudyReviewCycle,
  exclusions: string[]
): Map<string, { type: "study" | "review"; cycleDay: number }> {
  const result = new Map();
  let cycleDay = 0;
  const cycleLength = cycle.study_days + cycle.review_days;

  for (let date = periodStart; date <= periodEnd; date = addDays(date, 1)) {
    const dateStr = formatDate(date);

    // 제외일 체크
    if (exclusions.includes(dateStr)) {
      continue; // 제외일은 주기 계산에서 제외
    }

    cycleDay++;

    // 주기 경계 처리
    if (cycleDay > cycleLength) {
      cycleDay = 1;
    }

    // 학습일/복습일 구분
    const type = cycleDay <= cycle.study_days ? "study" : "review";

    result.set(dateStr, { type, cycleDay });
  }

  return result;
}
```

---

## 검증 규칙

### 필수 검증

1. ✅ `study_days >= 1` (학습일 수는 1 이상)
2. ✅ `review_days >= 0` (복습일 수는 0 이상)
3. ✅ 주기 길이 = `study_days + review_days` (최소 1 이상)

### 선택 검증

1. ⚠️ 주기 길이가 너무 짧지 않은지 확인 (권장: 최소 3일)
2. ⚠️ 주기 길이가 너무 길지 않은지 확인 (권장: 최대 14일)

---

## 참고사항

- 모든 날짜는 `YYYY-MM-DD` 형식 사용
- 주기 계산은 제외일을 완전히 제외하고 진행
- 복습일이 0이면 복습일 없이 학습일만 진행
- 주기 패턴은 기간 종료일까지 반복 적용됨
