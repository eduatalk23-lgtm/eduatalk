This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
attendance.ts
auth.ts
autoApprove.ts
button.tsx
cache.ts
campTemplateValidation.ts
content-selection.ts
contentDetailsUtils.ts
cssVariables.ts
darkMode.ts
databaseFallback.ts
date.ts
defaultBlockSet.ts
Dialog.tsx
duration.ts
EmptyState.tsx
ErrorState.tsx
excel.ts
formatGradeLevel.ts
formatNumber.ts
FormCheckbox.tsx
formData.ts
FormInput.tsx
FormMessage.tsx
FormSubmitButton.tsx
getBaseUrl.ts
getEmailRedirectUrl.ts
guards.ts
index.ts
InstallButton.tsx
InstallPrompt.tsx
lecture.ts
LoadingSkeleton.tsx
migrationStatus.ts
perfLog.ts
performance.ts
phoneMasking.ts
plan-generation.ts
plan.ts
planDataMerger.ts
planGroupAdapters.ts
planGroupDataSync.ts
planGroupLock.ts
planGroupTransform.ts
planStatusUtils.ts
planUtils.ts
planVersionUtils.ts
rangeValidation.ts
scheduleCache.ts
schedulerOptionsMerge.ts
schedulerSettings.ts
schedulerSettingsMerge.ts
SchoolMultiSelect.tsx
SchoolSelect.tsx
schoolYear.ts
scoreDashboard.ts
scoreInput.ts
scroll.ts
SectionCard.tsx
SectionHeader.tsx
SkeletonForm.tsx
spacing.ts
StickySaveButton.tsx
studentFormUtils.ts
studentPhoneUtils.ts
studentProfile.ts
subjectAllocation.ts
supabaseClientSelector.ts
supabaseErrorHandler.ts
terms.ts
ThemeToggle.tsx
themeUtils.ts
TimeRangeInput.tsx
timerUtils.ts
ToastProvider.tsx
wizard.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="autoApprove.ts">
import type { AutoApproveSettings, ParentRelation } from "@/app/(admin)/actions/tenantSettingsActions";

/**
 * 자동 승인 조건 확인
 * @param settings 자동 승인 설정
 * @param studentTenantId 학생의 테넌트 ID
 * @param parentTenantId 학부모의 테넌트 ID
 * @param relation 요청한 관계
 * @returns 조건 만족 여부
 */
export function checkAutoApproveConditions(
  settings: AutoApproveSettings,
  studentTenantId: string | null,
  parentTenantId: string | null,
  relation: ParentRelation
): boolean {
  // 자동 승인이 비활성화되어 있으면 false
  if (!settings.enabled) {
    return false;
  }

  // sameTenantOnly 조건 확인
  if (settings.conditions.sameTenantOnly) {
    // 학생과 학부모가 같은 테넌트가 아니면 false
    if (studentTenantId !== parentTenantId) {
      return false;
    }
  }

  // allowedRelations 조건 확인
  if (!settings.conditions.allowedRelations.includes(relation)) {
    return false;
  }

  // 모든 조건 만족
  return true;
}
</file>

<file path="cache.ts">
/**
 * 클라이언트 사이드 캐싱 유틸리티
 * 브라우저의 sessionStorage를 활용한 간단한 캐싱
 */

export type CacheEntry<T> = {
  data: T;
  timestamp: number;
  ttl: number; // Time to live in milliseconds
};

const CACHE_PREFIX = "app_cache_";

export function setCache<T>(key: string, data: T, ttl: number = 1000 * 60 * 5): void {
  if (typeof window === "undefined") return;

  try {
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl,
    };
    sessionStorage.setItem(`${CACHE_PREFIX}${key}`, JSON.stringify(entry));
  } catch (error) {
    // sessionStorage가 가득 찬 경우 무시
    console.warn("[cache] 캐시 저장 실패:", error);
  }
}

export function getCache<T>(key: string): T | null {
  if (typeof window === "undefined") return null;

  try {
    const item = sessionStorage.getItem(`${CACHE_PREFIX}${key}`);
    if (!item) return null;

    const entry: CacheEntry<T> = JSON.parse(item);
    const now = Date.now();

    // TTL 확인
    if (now - entry.timestamp > entry.ttl) {
      sessionStorage.removeItem(`${CACHE_PREFIX}${key}`);
      return null;
    }

    return entry.data;
  } catch (error) {
    console.warn("[cache] 캐시 읽기 실패:", error);
    return null;
  }
}

export function clearCache(key?: string): void {
  if (typeof window === "undefined") return;

  try {
    if (key) {
      sessionStorage.removeItem(`${CACHE_PREFIX}${key}`);
    } else {
      // 모든 캐시 삭제
      const keys = Object.keys(sessionStorage);
      keys.forEach((k) => {
        if (k.startsWith(CACHE_PREFIX)) {
          sessionStorage.removeItem(k);
        }
      });
    }
  } catch (error) {
    console.warn("[cache] 캐시 삭제 실패:", error);
  }
}

/**
 * 캐시 키 생성 헬퍼
 */
export function createCacheKey(...parts: (string | number | null | undefined)[]): string {
  return parts.filter(Boolean).join(":");
}
</file>

<file path="campTemplateValidation.ts">
import { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";
import { CampTemplate } from "@/lib/types/plan";

export type ChecklistItem = {
  id: string;
  label: string;
  checked: boolean;
  description?: string;
  category: "basic" | "template_data" | "wizard_data";
};

/**
 * 캠프 템플릿 필수요소 체크리스트 생성
 */
export function getCampTemplateChecklist(template: CampTemplate): ChecklistItem[] {
  const items: ChecklistItem[] = [];
  
  // 기본 정보 필수 항목
  items.push({
    id: "name",
    label: "템플릿명",
    checked: !!template.name && template.name.trim().length > 0,
    description: "템플릿의 이름을 입력해주세요",
    category: "basic",
  });

  items.push({
    id: "program_type",
    label: "프로그램 유형",
    checked: !!template.program_type,
    description: "프로그램 유형을 선택해주세요 (윈터캠프, 썸머캠프, 파이널캠프, 기타)",
    category: "basic",
  });

  // 템플릿 데이터 검증
  const templateData = template.template_data as Partial<WizardData> | null;
  const hasTemplateData = !!templateData;

  items.push({
    id: "template_data",
    label: "템플릿 데이터",
    checked: hasTemplateData,
    description: "템플릿 데이터가 필요합니다",
    category: "template_data",
  });

  if (hasTemplateData) {
    const lockedFields = templateData.templateLockedFields?.step1 || {};
    
    // 학생 입력 허용 필드 확인 헬퍼
    const isStudentInputAllowed = (fieldName: string): boolean => {
      const allowFieldName = `allow_student_${fieldName}` as keyof typeof lockedFields;
      return lockedFields[allowFieldName] === true;
    };

    // 기간 정보 (학생 입력 허용이 아닐 때만 필수)
    if (!isStudentInputAllowed("period")) {
      items.push({
        id: "period",
        label: "학습 기간",
        checked: !!(
          templateData.period_start &&
          templateData.period_end &&
          templateData.period_start.trim().length > 0 &&
          templateData.period_end.trim().length > 0
        ),
        description: "학습 시작일과 종료일을 설정해주세요",
        category: "wizard_data",
      });
    }

    // 블록 세트는 기본값 옵션이 추가되어 체크리스트에서 제외

    // 스케줄러 유형 (학생 입력 허용이 아닐 때만 필수)
    if (!isStudentInputAllowed("scheduler_type")) {
      items.push({
        id: "scheduler_type",
        label: "스케줄러 유형",
        checked: !!templateData.scheduler_type && templateData.scheduler_type.trim().length > 0,
        description: "스케줄러 유형을 선택해주세요",
        category: "wizard_data",
      });
    }

    // 학생 수준 항목이 삭제되어 체크리스트에서 제외
    // 과목 배정은 학생 입력폼 제출 후 관리자 영역이므로 체크리스트에서 제외
  }

  return items;
}

/**
 * 체크리스트 완료율 계산
 */
export function getChecklistCompletion(items: ChecklistItem[]): {
  completed: number;
  total: number;
  percentage: number;
} {
  const completed = items.filter((item) => item.checked).length;
  const total = items.length;
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

  return { completed, total, percentage };
}

/**
 * 카테고리별로 그룹화
 */
export function groupChecklistByCategory(items: ChecklistItem[]): {
  basic: ChecklistItem[];
  template_data: ChecklistItem[];
  wizard_data: ChecklistItem[];
} {
  return {
    basic: items.filter((item) => item.category === "basic"),
    template_data: items.filter((item) => item.category === "template_data"),
    wizard_data: items.filter((item) => item.category === "wizard_data"),
  };
}
</file>

<file path="contentDetailsUtils.ts">
/**
 * 콘텐츠 상세 정보 관련 유틸리티 함수
 * 콘텐츠 타입 확인, API 엔드포인트 생성, 응답 데이터 변환 로직 통합
 */

export type ContentType = "book" | "lecture" | "custom";

export type ContentDetail = {
  id: string;
  page_number?: number;
  episode_number?: number;
  major_unit?: string | null;
  minor_unit?: string | null;
  title?: string | null;
};

export type ContentMetadata = {
  subject?: string | null;
  semester?: string | null;
  revision?: string | null;
  difficulty_level?: string | null;
  publisher?: string | null;
  platform?: string | null;
};

export type ContentDetailsResponse = {
  details?: ContentDetail[];
  episodes?: ContentDetail[];
  total_pages?: number | null;
  total_episodes?: number | null;
  metadata?: ContentMetadata;
};

/**
 * 콘텐츠 ID가 교재인지 확인
 * @param contentId 콘텐츠 ID
 * @param bookIdSet 교재 ID Set (O(1) 조회를 위해)
 * @returns 교재 여부
 */
export function isBookContent(
  contentId: string,
  bookIdSet: Set<string>
): boolean {
  return bookIdSet.has(contentId);
}

/**
 * 콘텐츠 타입 결정
 * @param contentId 콘텐츠 ID
 * @param bookIdSet 교재 ID Set
 * @param lectureIdSet 강의 ID Set (선택적)
 * @returns 콘텐츠 타입
 */
export function getContentType(
  contentId: string,
  bookIdSet: Set<string>,
  lectureIdSet?: Set<string>
): ContentType {
  if (bookIdSet.has(contentId)) {
    return "book";
  }
  if (lectureIdSet && lectureIdSet.has(contentId)) {
    return "lecture";
  }
  // 기본값은 book (하위 호환성)
  return "book";
}

/**
 * 학생 콘텐츠 상세 정보 API 엔드포인트 생성
 * @param contentType 콘텐츠 타입
 * @param contentId 콘텐츠 ID
 * @param options 옵션
 * @returns API 엔드포인트 URL
 */
export function getStudentContentDetailsEndpoint(
  contentType: ContentType,
  contentId: string,
  options?: {
    includeMetadata?: boolean;
    studentId?: string;
  }
): string {
  const params = new URLSearchParams({
    contentType,
    contentId,
  });

  if (options?.includeMetadata) {
    params.set("includeMetadata", "true");
  }

  if (options?.studentId) {
    params.set("student_id", options.studentId);
  }

  return `/api/student-content-details?${params.toString()}`;
}

/**
 * 마스터 콘텐츠 상세 정보 API 엔드포인트 생성
 * @param contentType 콘텐츠 타입
 * @param contentId 콘텐츠 ID
 * @param options 옵션
 * @returns API 엔드포인트 URL
 */
export function getMasterContentDetailsEndpoint(
  contentType: ContentType,
  contentId: string,
  options?: {
    includeMetadata?: boolean;
  }
): string {
  const params = new URLSearchParams({
    contentType,
    contentId,
  });

  if (options?.includeMetadata) {
    params.set("includeMetadata", "true");
  }

  return `/api/master-content-details?${params.toString()}`;
}

/**
 * 배치 API 요청 데이터 생성
 * @param contents 콘텐츠 목록
 * @param bookIdSet 교재 ID Set
 * @param includeMetadata 메타데이터 포함 여부
 * @returns 배치 API 요청 본문
 */
export function createBatchRequest(
  contents: Array<{ content_id: string }>,
  bookIdSet: Set<string>,
  includeMetadata = false
): {
  contents: Array<{ contentId: string; contentType: "book" | "lecture" }>;
  includeMetadata: boolean;
} {
  return {
    contents: contents.map((content) => ({
      contentId: content.content_id,
      contentType: isBookContent(content.content_id, bookIdSet)
        ? ("book" as const)
        : ("lecture" as const),
    })),
    includeMetadata,
  };
}

/**
 * 배치 API 응답 데이터 변환
 * @param batchResponse 배치 API 응답
 * @param contentId 콘텐츠 ID
 * @param contentType 콘텐츠 타입
 * @returns 변환된 상세 정보
 */
export function transformBatchResponse(
  batchResponse: Record<
    string,
    {
      details?: ContentDetail[];
      episodes?: ContentDetail[];
      total_pages?: number | null;
      total_episodes?: number | null;
      metadata?: ContentMetadata;
    }
  >,
  contentId: string,
  contentType: ContentType
): ContentDetailsResponse | null {
  const contentData = batchResponse[contentId];
  if (!contentData) {
    return null;
  }

  if (contentType === "book") {
    return {
      details: contentData.details || [],
      total_pages: contentData.total_pages ?? null,
      metadata: contentData.metadata,
    };
  } else if (contentType === "lecture") {
    return {
      episodes: contentData.episodes || [],
      total_episodes: contentData.total_episodes ?? null,
      metadata: contentData.metadata,
    };
  }

  return null;
}

/**
 * 개별 API 응답 데이터 변환
 * @param response API 응답
 * @param contentType 콘텐츠 타입
 * @returns 변환된 상세 정보
 */
export function transformSingleResponse(
  response: {
    details?: ContentDetail[];
    episodes?: ContentDetail[];
    total_pages?: number | null;
    total_episodes?: number | null;
    metadata?: ContentMetadata;
  },
  contentType: ContentType
): ContentDetailsResponse {
  if (contentType === "book") {
    return {
      details: response.details || [],
      total_pages: response.total_pages ?? null,
      metadata: response.metadata,
    };
  } else {
    return {
      episodes: response.episodes || [],
      total_episodes: response.total_episodes ?? null,
      metadata: response.metadata,
    };
  }
}
</file>

<file path="cssVariables.ts">
import type { CSSProperties } from "react";

/**
 * 동적 너비를 위한 스타일 생성
 * 인라인 스타일을 최소화하면서 동적 값을 처리
 */
export function createWidthStyle(width: number): CSSProperties {
  return { width: `${width}%` };
}

/**
 * 동적 높이를 위한 스타일 생성
 */
export function createHeightStyle(height: number, minHeight?: string): CSSProperties {
  const style: CSSProperties = { height: `${height}%` };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  return style;
}

/**
 * 동적 위치를 위한 스타일 생성
 */
export function createPositionStyle(
  top?: number,
  left?: number,
  right?: number,
  bottom?: number
): CSSProperties {
  const style: CSSProperties = {};
  if (top !== undefined) style.top = `${top}%`;
  if (left !== undefined) style.left = `${left}%`;
  if (right !== undefined) style.right = `${right}%`;
  if (bottom !== undefined) style.bottom = `${bottom}%`;
  return style;
}

/**
 * 픽셀 단위 높이를 위한 스타일 생성
 * 타임라인 등 동적 높이 계산이 필요한 경우 사용
 */
export function createHeightPxStyle(height: number, minHeight?: string): CSSProperties {
  const style: CSSProperties = { height: `${height}px` };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  return style;
}

/**
 * 픽셀 단위 위치를 위한 스타일 생성
 * 타임라인 등 동적 위치 계산이 필요한 경우 사용
 */
export function createPositionPxStyle(
  top?: number,
  left?: number,
  right?: number,
  bottom?: number
): CSSProperties {
  const style: CSSProperties = {};
  if (top !== undefined) style.top = `${top}px`;
  if (left !== undefined) style.left = `${left}px`;
  if (right !== undefined) style.right = `${right}px`;
  if (bottom !== undefined) style.bottom = `${bottom}px`;
  return style;
}

/**
 * 블록 위치 및 크기 스타일 생성 (픽셀 단위)
 * 타임라인 블록 렌더링에 최적화된 헬퍼 함수
 */
export function createBlockStyle(
  top: number,
  height: number,
  minHeight?: string
): CSSProperties {
  const style: CSSProperties = {
    top: `${top}px`,
    height: `${height}px`,
  };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  return style;
}
</file>

<file path="darkMode.ts">
import { cn } from "@/lib/cn";

/**
 * 다크모드 색상 클래스 유틸리티
 * 하드코딩된 색상을 일관되게 관리하기 위한 헬퍼 함수들
 */

// 배경색
export const bgSurface = "bg-white dark:bg-gray-800";
export const bgPage = "bg-gray-50 dark:bg-gray-900";
export const bgHover = "hover:bg-gray-50 dark:hover:bg-gray-800";
export const bgHoverStrong = "hover:bg-gray-100 dark:hover:bg-gray-700";

// 텍스트 색상
export const textPrimary = "text-gray-900 dark:text-gray-100";
export const textSecondary = "text-gray-700 dark:text-gray-200";
export const textTertiary = "text-gray-600 dark:text-gray-400";
export const textMuted = "text-gray-500 dark:text-gray-400";

// 테두리
export const borderDefault = "border-gray-200 dark:border-gray-700";
export const borderInput = "border-gray-300 dark:border-gray-700";
export const divideDefault = "divide-gray-200 dark:divide-gray-700";

// 인라인 버튼 스타일 (가장 많이 사용되는 패턴)
export function inlineButtonBase(className?: string): string {
  return cn(
    "inline-flex items-center justify-center rounded-lg border transition",
    "bg-white dark:bg-gray-800",
    "text-gray-700 dark:text-gray-200",
    "border-gray-300 dark:border-gray-700",
    "hover:bg-gray-50 dark:hover:bg-gray-700",
    className
  );
}

export function inlineButtonSecondary(className?: string): string {
  return cn(
    "inline-flex items-center justify-center rounded-lg border transition",
    "bg-gray-100 dark:bg-gray-800",
    "text-gray-900 dark:text-gray-100",
    "border-gray-300 dark:border-gray-700",
    "hover:bg-gray-200 dark:hover:bg-gray-700",
    className
  );
}

// 테이블 행 스타일
export const tableRowHover = "hover:bg-gray-50 dark:hover:bg-gray-800";
export const tableRowBase = cn(tableRowHover, "transition-colors");

// 카드 스타일
export const cardBase = cn(
  "rounded-xl border shadow-sm",
  bgSurface,
  borderDefault
);

/**
 * 카드 스타일 패턴 (계획에 따른 추가 패턴)
 */
export const cardStyles = {
  base: cn(
    "rounded-xl border shadow-sm",
    "border-gray-200 dark:border-gray-700",
    "bg-white dark:bg-gray-800"
  ),
  hover: "transition-shadow hover:shadow-md",
  padding: {
    sm: "p-4",
    md: "p-5 md:p-6",
    lg: "p-6 md:p-8",
  },
};

/**
 * 텍스트 색상 패턴 (계획에 따른 추가 패턴)
 */
export const textStyles = {
  primary: "text-gray-900 dark:text-gray-100",
  secondary: "text-gray-600 dark:text-gray-400",
  tertiary: "text-gray-500 dark:text-gray-500",
  muted: "text-gray-400 dark:text-gray-500",
};

/**
 * 보더 색상 패턴 (계획에 따른 추가 패턴)
 */
export const borderStyles = {
  default: "border-gray-200 dark:border-gray-700",
  light: "border-gray-100 dark:border-gray-800",
  medium: "border-gray-300 dark:border-gray-600",
};

/**
 * 배경 색상 패턴 (계획에 따른 추가 패턴)
 */
export const bgStyles = {
  white: "bg-white dark:bg-gray-800",
  gray: "bg-gray-50 dark:bg-gray-900",
  card: "bg-white dark:bg-gray-800",
};

// 상태 색상 유틸리티

/**
 * 목표 상태 색상 (Goal Progress용)
 */
export const goalStatusColors: Record<string, string> = {
  scheduled: "bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200",
  in_progress: "bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300",
  completed: "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300",
  failed: "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300",
};

/**
 * 플랜 상태 색상 (Plan Status용)
 */
export const planStatusColors: Record<string, string> = {
  active: "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300",
  paused: "bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300",
  completed: "bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-300",
  cancelled: "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300",
};

/**
 * 위험도 레벨 색상 (Admin Dashboard용)
 */
export const riskLevelColors: Record<string, string> = {
  high: "bg-red-500 dark:bg-red-600 text-white",
  medium: "bg-yellow-500 dark:bg-yellow-600 text-white",
  low: "bg-green-500 dark:bg-green-600 text-white",
};

/**
 * 위험도 점수에 따른 색상 클래스 반환
 * @param riskScore 위험도 점수 (0-100)
 * @returns 다크모드를 포함한 Tailwind 클래스 문자열
 */
export function getRiskColorClasses(riskScore: number): string {
  if (riskScore >= 70) {
    return "text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-800";
  }
  if (riskScore >= 50) {
    return "text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-900/30 border-orange-200 dark:border-orange-800";
  }
  return "text-yellow-600 dark:text-yellow-400 bg-yellow-50 dark:bg-yellow-900/30 border-yellow-200 dark:border-yellow-800";
}

/**
 * 위험도 섹션용 그라디언트 배경 (Admin Dashboard용)
 */
export const riskSectionGradient = cn(
  "rounded-xl border border-red-200 dark:border-red-800",
  "bg-gradient-to-br from-red-50 to-red-100/50",
  "dark:from-red-900/30 dark:to-red-800/20",
  "p-5 md:p-6 shadow-sm"
);
</file>

<file path="databaseFallback.ts">
/**
 * 데이터베이스 컬럼 누락 시 fallback 처리를 위한 유틸리티 함수
 * 
 * PostgreSQL 에러 코드 42703 (undefined_column)을 처리하기 위한 공통 함수
 */

/**
 * 컬럼 누락 에러인지 확인
 */
export function isColumnMissingError(error: any): boolean {
  return error?.code === "42703";
}

/**
 * 컬럼 누락 시 fallback 쿼리를 실행하는 헬퍼 함수
 * 
 * @param query 원본 쿼리 함수
 * @param fallbackQuery fallback 쿼리 함수 (컬럼 제외)
 * @param missingColumn 누락된 컬럼 이름 (로깅용)
 * @returns 쿼리 결과
 */
export async function withColumnFallback<T>(
  query: () => Promise<{ data: T | null; error: any }>,
  fallbackQuery: () => Promise<{ data: T | null; error: any }>,
  missingColumn: string
): Promise<{ data: T | null; error: any }> {
  const result = await query();
  
  if (isColumnMissingError(result.error)) {
    if (process.env.NODE_ENV === "development") {
      console.warn(`[withColumnFallback] ${missingColumn} 컬럼이 없어 fallback 사용`);
    }
    return await fallbackQuery();
  }
  
  return result;
}

/**
 * block_index를 동적으로 할당하는 헬퍼 함수
 * 
 * @param blocks 블록 배열 (start_time 필수)
 * @param groupBy 그룹화 함수 (예: day_of_week별로 그룹화)
 * @returns block_index가 할당된 블록 배열
 */
export function assignBlockIndex<T extends { start_time: string }>(
  blocks: T[],
  groupBy?: (block: T) => number
): Array<T & { block_index: number }> {
  if (blocks.length === 0) {
    return [];
  }

  // 그룹화가 필요한 경우
  if (groupBy) {
    const blocksByGroup = new Map<number, T[]>();
    blocks.forEach((block) => {
      const groupKey = groupBy(block);
      if (!blocksByGroup.has(groupKey)) {
        blocksByGroup.set(groupKey, []);
      }
      blocksByGroup.get(groupKey)!.push(block);
    });

    return Array.from(blocksByGroup.entries()).flatMap(([_, groupBlocks]) =>
      groupBlocks
        .sort((a, b) => a.start_time.localeCompare(b.start_time))
        .map((block, index) => ({
          ...block,
          block_index: index + 1,
        }))
    );
  }

  // 그룹화가 필요 없는 경우 (전체를 하나의 그룹으로 처리)
  return blocks
    .sort((a, b) => a.start_time.localeCompare(b.start_time))
    .map((block, index) => ({
      ...block,
      block_index: index + 1,
    }));
}

/**
 * student_block_schedule 조회 시 block_index fallback 처리
 * 
 * @param queryClient Supabase 클라이언트
 * @param filters 조회 필터
 * @returns 블록 데이터 (block_index 포함)
 */
export async function fetchBlocksWithFallback(
  queryClient: any,
  filters: {
    block_set_id?: string | null;
    student_id: string;
    day_of_week?: number;
  }
): Promise<{
  data: Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
    block_index: number;
  }> | null;
  error: any;
}> {
  const baseQuery = queryClient
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_index")
    .eq("student_id", filters.student_id);

  if (filters.block_set_id) {
    baseQuery.eq("block_set_id", filters.block_set_id);
  }
  if (filters.day_of_week !== undefined) {
    baseQuery.eq("day_of_week", filters.day_of_week);
  }

  let { data, error } = await baseQuery;

  // block_index 컬럼이 없는 경우 fallback
  if (isColumnMissingError(error)) {
    const fallbackQuery = queryClient
      .from("student_block_schedule")
      .select("id, day_of_week, start_time, end_time")
      .eq("student_id", filters.student_id);

    if (filters.block_set_id) {
      fallbackQuery.eq("block_set_id", filters.block_set_id);
    }
    if (filters.day_of_week !== undefined) {
      fallbackQuery.eq("day_of_week", filters.day_of_week);
    }

    fallbackQuery
      .order("day_of_week", { ascending: true })
      .order("start_time", { ascending: true });

    const fallbackResult = await fallbackQuery;

    if (fallbackResult.data) {
      // day_of_week별로 그룹화하여 block_index 재할당
      data = assignBlockIndex(fallbackResult.data as any[], (block) => block.day_of_week);
    }
    error = fallbackResult.error;
  }

  return { data, error };
}
</file>

<file path="date.ts">
/**
 * 날짜 관련 유틸리티
 *
 * UI 컴포넌트에서 사용하던 날짜 관련 로직을 추출했습니다.
 */

/**
 * 오늘 날짜의 연/월/일 반환
 */
export function getTodayParts(): { year: number; month: number; day: number } {
  const today = new Date();
  return {
    year: today.getFullYear(),
    month: today.getMonth() + 1,
    day: today.getDate(),
  };
}

/**
 * 날짜 문자열(YYYY-MM-DD)을 연/월/일로 파싱
 */
export function parseDateString(
  dateStr: string
): { year: number; month: number; day: number } {
  if (!dateStr) return getTodayParts();
  const [year, month, day] = dateStr.split("-").map(Number);
  return { year, month, day };
}

/**
 * 연/월/일을 날짜 문자열(YYYY-MM-DD)로 변환
 */
export function formatDateString(
  year: number,
  month: number,
  day: number
): string {
  const monthStr = String(month).padStart(2, "0");
  const dayStr = String(day).padStart(2, "0");
  return `${year}-${monthStr}-${dayStr}`;
}

/**
 * 해당 월의 마지막 일 계산 (윤년 고려)
 */
export function getDaysInMonth(year: number, month: number): number {
  return new Date(year, month, 0).getDate();
}

/**
 * 두 날짜 사이의 일 수 계산
 */
export function getDaysDifference(startDate: string, endDate: string): number {
  const start = new Date(startDate);
  const end = new Date(endDate);
  return Math.floor((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
}

/**
 * 두 날짜 사이의 주 수 계산
 */
export function getWeeksDifference(startDate: string, endDate: string): number {
  const days = getDaysDifference(startDate, endDate);
  return Math.floor(days / 7);
}

/**
 * 시작 날짜와 주 수로 종료 날짜 계산
 * 타임존 문제를 방지하기 위해 YYYY-MM-DD 문자열을 직접 파싱합니다.
 */
export function calculateEndDate(startDate: string, weeks: number): string {
  // YYYY-MM-DD 형식 문자열을 직접 파싱하여 타임존 문제 방지
  const startParts = parseDateString(startDate);
  const start = new Date(startParts.year, startParts.month - 1, startParts.day);
  
  const end = new Date(start);
  end.setDate(start.getDate() + weeks * 7);
  return formatDateFromDate(end);
}

/**
 * Date 객체를 YYYY-MM-DD 문자열로 변환
 */
export function formatDateFromDate(date: Date): string {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return formatDateString(year, month, day);
}

/**
 * 날짜 문자열에 일수를 더하거나 빼기 (타임존 문제 방지)
 * @param dateStr YYYY-MM-DD 형식의 날짜 문자열
 * @param days 더하거나 빼고 싶은 일수 (음수 가능)
 * @returns YYYY-MM-DD 형식의 날짜 문자열
 */
export function addDaysToDate(dateStr: string, days: number): string {
  const parts = parseDateString(dateStr);
  const date = new Date(parts.year, parts.month - 1, parts.day);
  date.setDate(date.getDate() + days);
  return formatDateFromDate(date);
}

/**
 * 특정 날짜까지 D-day 계산
 */
export function calculateDday(targetDate: string): number {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const target = new Date(targetDate);
  target.setHours(0, 0, 0, 0);
  return Math.ceil((target.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
}

/**
 * 날짜 유효성 검사
 */
export function isValidDateString(dateStr: string): boolean {
  if (!dateStr) return false;
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(dateStr)) return false;

  const [year, month, day] = dateStr.split("-").map(Number);
  const date = new Date(year, month - 1, day);

  return (
    date.getFullYear() === year &&
    date.getMonth() === month - 1 &&
    date.getDate() === day
  );
}

/**
 * 시작 날짜와 종료 날짜 유효성 검사 (시작 <= 종료)
 */
export function isValidDateRange(startDate: string, endDate: string): boolean {
  if (!isValidDateString(startDate) || !isValidDateString(endDate)) {
    return false;
  }
  return new Date(startDate) <= new Date(endDate);
}

/**
 * 주어진 날짜가 오늘 이후인지 확인
 */
export function isFutureDate(dateStr: string): boolean {
  if (!isValidDateString(dateStr)) return false;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const target = new Date(dateStr);
  target.setHours(0, 0, 0, 0);
  return target >= today;
}

/**
 * 요일 번호를 한글 요일로 변환 (0: 일요일)
 */
export function getDayOfWeekName(dayNumber: number): string {
  const days = ["일", "월", "화", "수", "목", "금", "토"];
  return days[dayNumber] ?? "";
}

/**
 * 날짜에서 요일 번호 추출 (0: 일요일)
 */
export function getDayOfWeek(dateStr: string): number {
  const date = new Date(dateStr);
  return date.getDay();
}
</file>

<file path="defaultBlockSet.ts">
/**
 * 기본 블록 세트 유틸리티
 * 템플릿 모드에서 블록 세트가 없을 때 사용되는 기본값
 */

export type DefaultBlock = {
  day_of_week: number; // 0(일) ~ 6(토)
  start_time: string; // "HH:mm"
  end_time: string; // "HH:mm"
};

/**
 * 기본 블록 세트 정보 반환
 * 월~일 10:00~19:00
 */
export function getDefaultBlocks(): DefaultBlock[] {
  return [
    { day_of_week: 1, start_time: "10:00", end_time: "19:00" }, // 월
    { day_of_week: 2, start_time: "10:00", end_time: "19:00" }, // 화
    { day_of_week: 3, start_time: "10:00", end_time: "19:00" }, // 수
    { day_of_week: 4, start_time: "10:00", end_time: "19:00" }, // 목
    { day_of_week: 5, start_time: "10:00", end_time: "19:00" }, // 금
    { day_of_week: 6, start_time: "10:00", end_time: "19:00" }, // 토
    { day_of_week: 0, start_time: "10:00", end_time: "19:00" }, // 일
  ];
}

/**
 * 기본 블록 세트 이름
 */
export const DEFAULT_BLOCK_SET_NAME = "기본 블록 세트";
</file>

<file path="duration.ts">
/**
 * 시간 단위 변환 유틸리티
 * 
 * DB에는 초 단위로 저장되고, UI에서는 분 단위로 표시/입력됨
 */

/**
 * 초를 분으로 변환 (반올림)
 * @param seconds 초 단위 시간
 * @returns 분 단위 시간 (반올림)
 */
export function secondsToMinutes(seconds: number | null | undefined): number | null {
  if (seconds === null || seconds === undefined) {
    return null;
  }
  return Math.round(seconds / 60);
}

/**
 * 분을 초로 변환
 * @param minutes 분 단위 시간
 * @returns 초 단위 시간
 */
export function minutesToSeconds(minutes: number | null | undefined): number | null {
  if (minutes === null || minutes === undefined) {
    return null;
  }
  return minutes * 60;
}
</file>

<file path="excel.ts">
/**
 * Excel 파일 처리 유틸리티
 * xlsx 라이브러리를 사용하여 Excel 파일을 읽고 쓸 수 있는 함수들을 제공합니다.
 */

import * as XLSX from "xlsx";

/**
 * 데이터를 Excel 파일로 변환하여 Buffer 반환
 * @param sheets 시트별 데이터 (시트명: 데이터 배열)
 * @returns Excel 파일 Buffer
 */
export function exportToExcel(sheets: Record<string, any[]>): Buffer {
  const workbook = XLSX.utils.book_new();

  // 각 시트를 워크북에 추가
  for (const [sheetName, data] of Object.entries(sheets)) {
    if (data.length === 0) {
      // 빈 시트도 생성 (헤더만)
      const worksheet = XLSX.utils.aoa_to_sheet([[]]);
      XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
    } else {
      // 데이터가 있는 경우
      const worksheet = XLSX.utils.json_to_sheet(data);
      XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
    }
  }

  // Excel 파일을 Buffer로 변환
  const excelBuffer = XLSX.write(workbook, {
    type: "buffer",
    bookType: "xlsx",
  });

  return excelBuffer;
}

/**
 * Excel 파일을 파싱하여 데이터 추출
 * @param fileBuffer Excel 파일 Buffer
 * @returns 시트별 데이터 (시트명: 데이터 배열)
 */
export function parseExcelFile(
  fileBuffer: Buffer
): Record<string, any[]> {
  const workbook = XLSX.read(fileBuffer, { type: "buffer" });
  const result: Record<string, any[]> = {};

  // 각 시트를 순회하며 데이터 추출
  for (const sheetName of workbook.SheetNames) {
    const worksheet = workbook.Sheets[sheetName];
    const data = XLSX.utils.sheet_to_json(worksheet, {
      raw: false, // 날짜 등을 문자열로 변환
      defval: null, // 빈 셀은 null로 처리
    });
    result[sheetName] = data;
  }

  return result;
}

/**
 * Excel 파일 검증
 * @param fileBuffer Excel 파일 Buffer
 * @param requiredSheets 필수 시트명 배열
 * @returns 검증 결과
 */
export function validateExcelFile(
  fileBuffer: Buffer,
  requiredSheets: string[] = []
): { valid: boolean; error?: string } {
  try {
    const workbook = XLSX.read(fileBuffer, { type: "buffer" });

    // 필수 시트 확인
    if (requiredSheets.length > 0) {
      const missingSheets = requiredSheets.filter(
        (sheet) => !workbook.SheetNames.includes(sheet)
      );
      if (missingSheets.length > 0) {
        return {
          valid: false,
          error: `필수 시트가 없습니다: ${missingSheets.join(", ")}`,
        };
      }
    }

    return { valid: true };
  } catch (error) {
    return {
      valid: false,
      error: `Excel 파일을 읽을 수 없습니다: ${error instanceof Error ? error.message : "알 수 없는 오류"}`,
    };
  }
}

/**
 * 빈 양식 Excel 파일 생성
 * @param sheets 시트별 헤더 정보 (시트명: 헤더 배열)
 * @returns Excel 파일 Buffer
 */
export function generateTemplateExcel(
  sheets: Record<string, string[]>
): Buffer {
  const workbook = XLSX.utils.book_new();

  // 각 시트를 워크북에 추가 (헤더만)
  for (const [sheetName, headers] of Object.entries(sheets)) {
    const worksheet = XLSX.utils.aoa_to_sheet([headers]);
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  // Excel 파일을 Buffer로 변환
  const excelBuffer = XLSX.write(workbook, {
    type: "buffer",
    bookType: "xlsx",
  });

  return excelBuffer;
}

/**
 * 데이터 배열을 Excel 시트 형식으로 변환 (헤더 포함)
 * @param data 데이터 배열
 * @param headers 헤더 배열 (선택사항, 없으면 객체 키 사용)
 * @returns Excel 시트 데이터
 */
export function convertDataToSheet(
  data: any[],
  headers?: string[]
): any[][] {
  if (data.length === 0) {
    return headers ? [headers] : [];
  }

  // 헤더 결정
  const firstItem = data[0];
  if (!firstItem) {
    return headers ? [headers] : [];
  }
  const sheetHeaders = headers || Object.keys(firstItem);

  // 헤더 행
  const rows: any[][] = [sheetHeaders];

  // 데이터 행
  for (const row of data) {
    const values = sheetHeaders.map((header) => {
      const value = row[header];
      // null, undefined는 빈 문자열로 변환
      if (value === null || value === undefined) {
        return "";
      }
      // 날짜 객체는 ISO 문자열로 변환
      if (value instanceof Date) {
        return value.toISOString();
      }
      return value;
    });
    rows.push(values);
  }

  return rows;
}

/**
 * Excel 파일에서 FormData로 변환
 * @param fileBuffer Excel 파일 Buffer
 * @returns FormData (file 필드에 Blob 포함)
 */
export function excelBufferToFormData(fileBuffer: Buffer): FormData {
  const formData = new FormData();
  // Buffer를 Uint8Array로 변환하여 Blob에 전달
  const blob = new Blob([new Uint8Array(fileBuffer)], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  });
  formData.append("file", blob, "upload.xlsx");
  return formData;
}
</file>

<file path="formatGradeLevel.ts">
/**
 * 학년 범위를 포맷팅하는 유틸리티 함수
 * @param gradeMin 최소 학년 (1-3)
 * @param gradeMax 최대 학년 (1-3)
 * @returns 포맷팅된 학년 문자열 (예: "1학년", "1-2학년", "1-3학년")
 */
export function formatGradeLevel(
  gradeMin: number | null,
  gradeMax: number | null
): string | null {
  if (!gradeMin && !gradeMax) {
    return null;
  }

  if (gradeMin && gradeMax) {
    if (gradeMin === gradeMax) {
      return `${gradeMin}학년`;
    }
    return `${gradeMin}-${gradeMax}학년`;
  }

  if (gradeMin) {
    return `${gradeMin}학년`;
  }

  if (gradeMax) {
    return `${gradeMax}학년`;
  }

  return null;
}
</file>

<file path="formatNumber.ts">
/**
 * 숫자를 소수점 첫 번째 자리까지만 표시 (필요없으면 안 나오게)
 * @param value 포맷팅할 숫자
 * @returns 소수점 첫 번째 자리까지만 표시된 문자열 (정수면 소수점 제거)
 */
export function formatNumber(value: number): string {
  const formatted = value.toFixed(1);
  // .0으로 끝나는 경우 정수로 표시
  if (formatted.endsWith(".0")) {
    return formatted.slice(0, -2);
  }
  return formatted;
}

/**
 * 숫자를 소수점 2자리로 포맷팅 (0 제거)
 * @param value 포맷팅할 숫자
 * @returns 소수점 2자리로 포맷팅된 문자열 (불필요한 0 제거)
 * @deprecated formatNumber을 사용하세요 (소수점 첫 번째 자리까지만 표시)
 */
export function formatNumberClean(value: number): string {
  const formatted = value.toFixed(2);
  // .00으로 끝나는 경우 정수로 표시
  if (formatted.endsWith(".00")) {
    return formatted.slice(0, -3);
  }
  // .0으로 끝나는 경우 한 자리만 표시
  if (formatted.endsWith("0") && formatted.includes(".")) {
    return formatted.slice(0, -1);
  }
  return formatted;
}
</file>

<file path="formData.ts">
/**
 * FormData 파싱 유틸리티
 *
 * Server Actions에서 FormData를 파싱할 때 사용합니다.
 */

/**
 * FormData 값을 문자열로 변환 (빈 문자열 대체)
 */
export function parseFormString(value: FormDataEntryValue | null): string {
  return String(value ?? "").trim();
}

/**
 * FormData 값을 문자열로 변환 (빈 값은 null 반환)
 */
export function parseFormStringOrNull(
  value: FormDataEntryValue | null
): string | null {
  const str = parseFormString(value);
  return str || null;
}

/**
 * FormData 값을 숫자로 변환
 */
export function parseFormNumber(value: FormDataEntryValue | null): number {
  const str = parseFormString(value);
  const num = Number(str);
  return isNaN(num) ? 0 : num;
}

/**
 * FormData 값을 숫자로 변환 (빈 값은 null 반환)
 */
export function parseFormNumberOrNull(
  value: FormDataEntryValue | null
): number | null {
  const str = parseFormString(value);
  if (!str) return null;
  const num = Number(str);
  return isNaN(num) ? null : num;
}

/**
 * FormData 값을 불리언으로 변환
 */
export function parseFormBoolean(value: FormDataEntryValue | null): boolean {
  const str = parseFormString(value).toLowerCase();
  return str === "true" || str === "1" || str === "yes" || str === "on";
}

/**
 * FormData에서 여러 값을 추출 (체크박스 그룹 등)
 */
export function parseFormArray(formData: FormData, key: string): string[] {
  const values = formData.getAll(key);
  return values.map((v) => String(v).trim()).filter(Boolean);
}

/**
 * FormData를 일반 객체로 변환
 */
export function formDataToObject(formData: FormData): Record<string, string> {
  const result: Record<string, string> = {};
  formData.forEach((value, key) => {
    result[key] = String(value);
  });
  return result;
}
</file>

<file path="getBaseUrl.ts">
/**
 * BASE_URL 유틸리티 함수
 * 환경 변수 또는 런타임에서 기본 URL을 가져옵니다.
 */

/**
 * 서버 사이드에서 BASE_URL을 가져옵니다.
 * @param headers - Next.js headers 객체 (선택사항)
 * @returns BASE_URL 문자열
 */
export function getBaseUrl(headers?: Headers): string {
  // 1. 환경 변수 우선 사용
  if (process.env.NEXT_PUBLIC_BASE_URL) {
    return process.env.NEXT_PUBLIC_BASE_URL;
  }

  // 2. 서버 사이드: headers에서 호스트 추출
  if (typeof window === "undefined") {
    if (headers) {
      const host = headers.get("host");
      const protocol = headers.get("x-forwarded-proto") || "http";
      if (host) {
        return `${protocol}://${host}`;
      }
    }
    // 기본값: 개발 환경
    return process.env.NODE_ENV === "production"
      ? "https://yourdomain.com" // 프로덕션 기본값 (환경 변수 설정 권장)
      : "http://localhost:3000";
  }

  // 3. 클라이언트 사이드: window.location 사용
  return window.location.origin;
}

/**
 * 클라이언트 사이드에서 BASE_URL을 가져옵니다.
 * @returns BASE_URL 문자열
 */
export function getBaseUrlClient(): string {
  // 환경 변수 우선
  if (process.env.NEXT_PUBLIC_BASE_URL) {
    return process.env.NEXT_PUBLIC_BASE_URL;
  }

  // window.location 사용
  if (typeof window !== "undefined") {
    return window.location.origin;
  }

  // 기본값
  return "http://localhost:3000";
}
</file>

<file path="getEmailRedirectUrl.ts">
/**
 * 이메일 인증 리다이렉트 URL 유틸리티
 * Supabase 이메일 인증 링크의 리다이렉트 URL을 생성합니다.
 */

import { headers } from "next/headers";
import { getBaseUrl } from "./getBaseUrl";

/**
 * 이메일 인증 리다이렉트 URL 생성
 * 
 * 프로덕션 환경에서 이메일 인증 링크가 올바른 도메인으로 리다이렉트되도록 합니다.
 * 
 * @returns 이메일 인증 콜백 URL (예: https://yourdomain.com/auth/callback)
 */
export async function getEmailRedirectUrl(): Promise<string> {
  const headersList = await headers();
  const baseUrl = getBaseUrl(headersList);
  return `${baseUrl}/auth/callback`;
}
</file>

<file path="index.ts">
/**
 * 공통 유틸리티 함수 모음
 *
 * 이 파일은 프로젝트 전체에서 사용하는 공통 유틸리티 함수를 내보냅니다.
 */

// FormData 관련 유틸리티
export {
  parseFormString,
  parseFormStringOrNull,
  parseFormNumber,
  parseFormNumberOrNull,
  parseFormBoolean,
  parseFormArray,
  formDataToObject,
} from "./formData";

// 날짜 관련 유틸리티
export {
  getTodayParts,
  parseDateString,
  formatDateString,
  formatDateFromDate,
  getDaysInMonth,
  getDaysDifference,
  getWeeksDifference,
  calculateEndDate,
  calculateDday,
  isValidDateString,
  isValidDateRange,
  isFutureDate,
  getDayOfWeekName,
  getDayOfWeek,
} from "./date";

// 숫자 포맷팅
export { formatNumber, formatNumberClean } from "./formatNumber";

// 캐시 관련
export { setCache, getCache, clearCache, createCacheKey, type CacheEntry } from "./cache";

// BASE_URL 관련
export { getBaseUrl, getBaseUrlClient } from "./getBaseUrl";
export { getEmailRedirectUrl } from "./getEmailRedirectUrl";
</file>

<file path="index.ts">
/**
 * 공통 유틸리티 함수 모음
 *
 * 이 파일은 프로젝트 전체에서 사용하는 공통 유틸리티 함수를 내보냅니다.
 */

// FormData 관련 유틸리티
export {
  parseFormString,
  parseFormStringOrNull,
  parseFormNumber,
  parseFormNumberOrNull,
  parseFormBoolean,
  parseFormArray,
  formDataToObject,
} from "./formData";

// 날짜 관련 유틸리티
export {
  getTodayParts,
  parseDateString,
  formatDateString,
  formatDateFromDate,
  getDaysInMonth,
  getDaysDifference,
  getWeeksDifference,
  calculateEndDate,
  calculateDday,
  isValidDateString,
  isValidDateRange,
  isFutureDate,
  getDayOfWeekName,
  getDayOfWeek,
} from "./date";

// 숫자 포맷팅
export { formatNumber, formatNumberClean } from "./formatNumber";

// 캐시 관련
export { setCache, getCache, clearCache, createCacheKey, type CacheEntry } from "./cache";

// BASE_URL 관련
export { getBaseUrl, getBaseUrlClient } from "./getBaseUrl";
export { getEmailRedirectUrl } from "./getEmailRedirectUrl";
</file>

<file path="migrationStatus.ts">
/**
 * 마이그레이션 상태 확인 및 캐싱 유틸리티
 * 
 * 데이터베이스 컬럼 존재 여부를 확인하고 캐싱하여 불필요한 재시도를 방지합니다.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { logError } from "@/lib/errors/handler";

/**
 * 마이그레이션 상태 캐시
 * 컬럼 이름을 키로, 존재 여부를 값으로 저장 (TTL: 5분)
 */
const migrationStatusCache = new Map<
  string,
  { exists: boolean; timestamp: number }
>();

const CACHE_TTL = 5 * 60 * 1000; // 5분

/**
 * 캐시에서 컬럼 존재 여부 확인
 */
function getCachedStatus(columnName: string): boolean | null {
  const cached = migrationStatusCache.get(columnName);
  if (!cached) {
    return null;
  }

  // TTL 체크
  const now = Date.now();
  if (now - cached.timestamp > CACHE_TTL) {
    migrationStatusCache.delete(columnName);
    return null;
  }

  return cached.exists;
}

/**
 * 캐시에 컬럼 존재 여부 저장
 */
function setCachedStatus(columnName: string, exists: boolean): void {
  migrationStatusCache.set(columnName, {
    exists,
    timestamp: Date.now(),
  });
}

/**
 * 특정 테이블의 컬럼 존재 여부 확인
 * 
 * @param tableName 테이블 이름
 * @param columnName 컬럼 이름
 * @returns 컬럼이 존재하면 true, 없으면 false
 */
export async function checkColumnExists(
  tableName: string,
  columnName: string
): Promise<boolean> {
  // 캐시 확인
  const cached = getCachedStatus(`${tableName}.${columnName}`);
  if (cached !== null) {
    return cached;
  }

  const supabase = await createSupabaseServerClient();

  try {
    // 컬럼이 존재하는지 확인하기 위해 실제 쿼리 실행
    // 에러 코드 42703은 컬럼이 없을 때 발생
    const { error } = await supabase
      .from(tableName)
      .select(columnName)
      .limit(1);

    if (error && error.code === "42703") {
      // 컬럼이 없음
      setCachedStatus(`${tableName}.${columnName}`, false);
      return false;
    }

    // 컬럼이 있거나 다른 에러
    if (error) {
      // 다른 에러인 경우 로깅하지만 존재 여부는 알 수 없음
      // 일단 존재한다고 가정하고 캐시하지 않음
      if (process.env.NODE_ENV === "development") {
        logError(error, {
          function: "checkColumnExists",
          level: "warn",
          tableName,
          columnName,
        });
      }
      return true; // 안전하게 존재한다고 가정
    }

    // 에러가 없으면 컬럼이 존재함
    setCachedStatus(`${tableName}.${columnName}`, true);
    return true;
  } catch (error) {
    // 예상치 못한 에러
    logError(error, {
      function: "checkColumnExists",
      tableName,
      columnName,
    });
    return true; // 안전하게 존재한다고 가정
  }
}

/**
 * 여러 컬럼의 존재 여부를 한 번에 확인
 * 
 * @param tableName 테이블 이름
 * @param columnNames 컬럼 이름 배열
 * @returns 컬럼 이름을 키로, 존재 여부를 값으로 하는 Map
 */
export async function checkColumnsExist(
  tableName: string,
  columnNames: string[]
): Promise<Map<string, boolean>> {
  const results = new Map<string, boolean>();

  // 병렬로 확인
  const checks = columnNames.map(async (columnName) => {
    const exists = await checkColumnExists(tableName, columnName);
    results.set(columnName, exists);
  });

  await Promise.all(checks);

  return results;
}

/**
 * 캐시 초기화 (테스트용)
 */
export function clearMigrationStatusCache(): void {
  migrationStatusCache.clear();
}
</file>

<file path="perfLog.ts">
/**
 * 성능 로깅 유틸리티
 * NEXT_PUBLIC_PERF_DEBUG=true일 때만 상세 로그 출력
 */

const PERF_DEBUG =
  process.env.NEXT_PUBLIC_PERF_DEBUG === "true" ||
  process.env.NODE_ENV === "development";

/**
 * 타이머 상태 추적을 위한 Map
 * 같은 라벨로 여러 번 호출되는 것을 방지
 */
const activeTimers = new Map<string, number>();

/**
 * 성능 로그 출력 (디버그 모드에서만)
 * @param label 로그 레이블
 * @param msOrFn 시간(ms) 또는 실행할 함수
 */
export function perfLog(label: string, msOrFn?: number | (() => void)) {
  if (!PERF_DEBUG) return;

  if (typeof msOrFn === "number") {
    console.log(`${label}: ${msOrFn.toFixed(3)}ms`);
    return;
  }

  if (typeof msOrFn === "function") {
    // 고유한 라벨 생성 (중복 방지)
    const uniqueLabel = `${label}_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    console.time(uniqueLabel);
    try {
      msOrFn();
    } finally {
      console.timeEnd(uniqueLabel);
    }
  }
}

/**
 * 성능 타이머 (디버그 모드에서만)
 * 서버 컴포넌트 환경에서도 안전하게 동작하도록 항상 고유한 라벨을 생성합니다.
 * @param label 타이머 레이블
 * @returns end() 메서드를 가진 객체
 */
export function perfTime(label: string) {
  if (!PERF_DEBUG) {
    return {
      end() {
        // 디버그 모드가 아니면 아무것도 하지 않음
      },
    };
  }

  // 항상 고유한 라벨 생성 (타임스탬프 + 랜덤 문자열)
  // 서버 컴포넌트에서 각 요청마다 새로운 컨텍스트가 생성되므로
  // activeTimers Map에 의존하지 않고 항상 고유한 라벨을 생성
  const timestamp = Date.now();
  const randomStr = Math.random().toString(36).substring(2, 9);
  const uniqueLabel = `${label}_${timestamp}_${randomStr}`;

  let timerStarted = false;
  try {
    console.time(uniqueLabel);
    timerStarted = true;
  } catch (error) {
    // console.time이 실패해도 계속 진행
    console.warn(`[perfTime] Failed to start timer for "${uniqueLabel}":`, error);
  }

  return {
    end() {
      if (timerStarted) {
        try {
          console.timeEnd(uniqueLabel);
        } catch (error) {
          // console.timeEnd가 실패해도 무시 (타이머가 시작되지 않았을 수 있음)
          // 개발 환경에서만 경고 출력
          if (process.env.NODE_ENV === "development") {
            console.warn(
              `[perfTime] Failed to end timer for "${uniqueLabel}":`,
              error
            );
          }
        }
      }
    },
  };
}
</file>

<file path="performance.ts">
/**
 * 성능 최적화 유틸리티
 */

/**
 * 디바운스 함수
 * 연속된 호출을 지연시켜 마지막 호출만 실행
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };

    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}

/**
 * 쓰로틀 함수
 * 일정 시간 간격으로만 함수 실행
 */
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false;

  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

/**
 * 이미지 지연 로딩을 위한 Intersection Observer 설정
 */
export function createImageObserver(
  callback: (entries: IntersectionObserverEntry[]) => void,
  options?: IntersectionObserverInit
): IntersectionObserver | null {
  if (typeof window === "undefined" || !("IntersectionObserver" in window)) {
    return null;
  }

  return new IntersectionObserver(callback, {
    rootMargin: "50px",
    threshold: 0.01,
    ...options,
  });
}

/**
 * 가상 스크롤을 위한 아이템 높이 계산
 */
export function calculateVirtualScrollHeight(
  itemCount: number,
  itemHeight: number,
  containerHeight: number
): {
  startIndex: number;
  endIndex: number;
  totalHeight: number;
  offsetY: number;
} {
  const totalHeight = itemCount * itemHeight;
  const scrollTop = 0; // 실제로는 스크롤 위치를 전달받아야 함

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(containerHeight / itemHeight) + 1,
    itemCount
  );

  const offsetY = startIndex * itemHeight;

  return {
    startIndex,
    endIndex,
    totalHeight,
    offsetY,
  };
}

/**
 * 메모이제이션 헬퍼 (간단한 버전)
 */
export function memoize<T extends (...args: any[]) => any>(
  fn: T,
  getKey?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>();

  return ((...args: Parameters<T>) => {
    const key = getKey ? getKey(...args) : JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as T;
}
</file>

<file path="phoneMasking.ts">
/**
 * 전화번호 마스킹 처리
 * 앞 3자리와 뒤 4자리만 표시, 중간은 마스킹
 * 
 * @param phone - 마스킹할 전화번호
 * @returns 마스킹된 전화번호 (예: "010-****-1234")
 */
export function maskPhoneNumber(phone: string): string {
  if (!phone || phone.length < 4) {
    return phone;
  }

  // 하이픈 제거
  const cleaned = phone.replace(/-/g, "");
  
  if (cleaned.length <= 4) {
    return "****";
  }

  // 앞 3자리와 뒤 4자리만 표시, 중간은 마스킹
  const start = cleaned.slice(0, 3);
  const end = cleaned.slice(-4);
  const masked = cleaned.slice(3, -4).replace(/\d/g, "*");

  return `${start}-${masked}-${end}`;
}
</file>

<file path="planDataMerger.ts">
/**
 * 템플릿 데이터와 학생 입력 데이터를 병합하는 유틸리티
 */

import type { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";

/**
 * 템플릿 데이터와 학생 입력 데이터를 병합합니다.
 * 
 * 병합 규칙:
 * 1. 템플릿 데이터를 기본값으로 사용
 * 2. 학생 입력 데이터가 있으면 우선 적용
 * 3. 제외일과 학원 일정은 템플릿 기본값 + 학생 추가 항목으로 병합
 * 4. 잠금 필드가 있는 경우 템플릿 값 유지
 * 
 * @param templateData 템플릿 데이터
 * @param studentInput 학생 입력 데이터
 * @param templateBlockSetId 템플릿 블록 세트 ID (옵션)
 * @returns 병합된 WizardData
 */
export function mergeTemplateDataWithStudentInput(
  templateData: Partial<WizardData>,
  studentInput: Partial<WizardData>,
  templateBlockSetId?: string | null
): Partial<WizardData> {
  // 템플릿 제외일 추출 (source가 "template"인 항목)
  const templateExclusions = (templateData.exclusions || []).filter(
    (e) => e.source === "template"
  );

  // 템플릿 학원 일정 추출 (source가 "template"인 항목)
  const templateAcademySchedules = (templateData.academy_schedules || []).filter(
    (s) => s.source === "template"
  );

  // 학생 입력 제외일 (템플릿 제외일 제외, 중복 제거)
  const studentExclusions = (studentInput.exclusions || []).filter(
    (e) =>
      e.source !== "template" &&
      !templateExclusions.some(
        (te) => te.exclusion_date === e.exclusion_date
      )
  );

  // 학생 입력 학원 일정 (템플릿 학원 일정 제외)
  const studentAcademySchedules = (studentInput.academy_schedules || []).filter(
    (s) => s.source !== "template"
  );

  // 병합된 데이터 생성
  const mergedData: Partial<WizardData> = {
    ...templateData,
    // 학생이 입력하는 필드는 studentInput 우선
    name: studentInput.name || templateData.name || "",
    plan_purpose: studentInput.plan_purpose || templateData.plan_purpose || "",
    scheduler_type:
      studentInput.scheduler_type || templateData.scheduler_type || "1730_timetable",
    period_start: studentInput.period_start || templateData.period_start || "",
    period_end: studentInput.period_end || templateData.period_end || "",
    block_set_id: studentInput.block_set_id || templateBlockSetId || "",
    // 제외일: 템플릿 기본값 + 학생 추가 제외일
    exclusions: [...templateExclusions, ...studentExclusions],
    // 학원 일정: 템플릿 기본값 + 학생 추가 학원 일정
    academy_schedules: [...templateAcademySchedules, ...studentAcademySchedules],
    // 학생 콘텐츠는 학생 입력만 사용
    student_contents: studentInput.student_contents || [],
    // 추천 콘텐츠는 템플릿 데이터 사용
    recommended_contents: templateData.recommended_contents || [],
    // 캠프 모드: 전략과목/취약과목 설정은 관리자 검토 후 설정하므로 undefined
    subject_allocations: undefined,
    student_level:
      studentInput.student_level || templateData.student_level || "medium",
    // 기타 필드들도 studentInput 우선
    time_settings: studentInput.time_settings || templateData.time_settings,
    scheduler_options:
      studentInput.scheduler_options || templateData.scheduler_options,
    study_review_cycle:
      studentInput.study_review_cycle || templateData.study_review_cycle,
    // 템플릿 잠금 필드 정보 유지
    templateLockedFields: templateData.templateLockedFields,
  };

  return mergedData;
}

/**
 * 템플릿 잠금 필드를 적용합니다.
 * 잠금 필드가 설정된 경우 템플릿 값을 유지하고 학생 입력을 무시합니다.
 * 
 * @param templateData 템플릿 데이터
 * @param studentInput 학생 입력 데이터
 * @param lockedFields 잠금 필드 설정
 * @returns 잠금 필드가 적용된 데이터
 */
export function applyTemplateLockedFields(
  templateData: Partial<WizardData>,
  studentInput: Partial<WizardData>,
  lockedFields?: WizardData["templateLockedFields"]
): Partial<WizardData> {
  if (!lockedFields) {
    return studentInput;
  }

  const result: Partial<WizardData> = { ...studentInput };

  // Step 1 잠금 필드 적용
  if (lockedFields.step1) {
    const step1 = lockedFields.step1 as any; // 타입 추론 오류 회피

    // 필드 고정
    if (step1.name === true) {
      result.name = templateData.name || "";
    }
    if (step1.plan_purpose === true) {
      result.plan_purpose = templateData.plan_purpose || "";
    }
    if (step1.scheduler_type === true) {
      result.scheduler_type = templateData.scheduler_type || "1730_timetable";
    }
    if (step1.period_start === true) {
      result.period_start = templateData.period_start || "";
    }
    if (step1.period_end === true) {
      result.period_end = templateData.period_end || "";
    }
    if (step1.block_set_id === true) {
      result.block_set_id = templateData.block_set_id || "";
    }
    if (step1.student_level === true) {
      result.student_level = templateData.student_level;
    }
    if (step1.subject_allocations === true) {
      result.subject_allocations = templateData.subject_allocations;
    }
    if (step1.study_review_cycle === true) {
      result.study_review_cycle = templateData.study_review_cycle;
    }
  }

  // Step 2 잠금 필드 적용
  if (lockedFields.step2) {
    const step2 = lockedFields.step2 as any; // 타입 추론 오류 회피

    // 제외일 고정
    if (step2.exclusions === true) {
      result.exclusions = templateData.exclusions || [];
    } else if (step2.exclusion_items && step2.exclusion_items.length > 0) {
      // 특정 제외일만 고정
      const templateExclusions = (templateData.exclusions || []).filter((e) =>
        step2.exclusion_items!.includes(e.exclusion_date)
      );
      const studentExclusions = (studentInput.exclusions || []).filter(
        (e) => !step2.exclusion_items!.includes(e.exclusion_date)
      );
      result.exclusions = [...templateExclusions, ...studentExclusions];
    }

    // 학원 일정 고정
    if (step2.academy_schedules === true) {
      result.academy_schedules = templateData.academy_schedules || [];
    } else if (step2.academy_schedule_items && step2.academy_schedule_items.length > 0) {
      // 특정 학원 일정만 고정 (구현 필요 시 추가)
      result.academy_schedules = studentInput.academy_schedules || [];
    }

    // 시간 설정 고정
    if (step2.time_settings === true) {
      result.time_settings = templateData.time_settings;
    } else if (
      step2.time_settings_fields &&
      step2.time_settings_fields.length > 0
    ) {
      // 특정 시간 설정 필드만 고정 (구현 필요 시 추가)
      result.time_settings = studentInput.time_settings || templateData.time_settings;
    }
  }

  // Step 3 잠금 필드 적용
  if (lockedFields.step3) {
    const step3 = lockedFields.step3 as any; // 타입 추론 오류 회피

    // 학생 콘텐츠 고정
    if (step3.student_contents === true) {
      result.student_contents = templateData.student_contents || [];
    } else if (
      step3.student_content_items &&
      step3.student_content_items.length > 0
    ) {
      // 특정 콘텐츠만 고정 (구현 필요 시 추가)
      result.student_contents = studentInput.student_contents || [];
    }
  }

  return result;
}

/**
 * 병합된 데이터의 유효성을 검증합니다.
 * 
 * @param mergedData 병합된 데이터
 * @returns 검증 에러 메시지 배열 (빈 배열이면 유효함)
 */
export function validateMergedData(
  mergedData: Partial<WizardData>
): string[] {
  const errors: string[] = [];

  // 필수 필드 검증
  if (!mergedData.name || mergedData.name.trim() === "") {
    errors.push("플랜 이름을 입력해주세요.");
  }

  if (!mergedData.period_start) {
    errors.push("시작일을 입력해주세요.");
  }

  if (!mergedData.period_end) {
    errors.push("종료일을 입력해주세요.");
  }

  if (mergedData.period_start && mergedData.period_end) {
    const start = new Date(mergedData.period_start);
    const end = new Date(mergedData.period_end);
    if (start > end) {
      errors.push("시작일이 종료일보다 늦을 수 없습니다.");
    }
  }

  // 블록 세트 검증
  // plan_type은 WizardData에 없으므로 block_set_id만 체크
  if (!mergedData.block_set_id) {
    errors.push("블록 세트를 선택해주세요.");
  }

  // 콘텐츠 검증
  const totalContents =
    (mergedData.student_contents?.length || 0) +
    (mergedData.recommended_contents?.length || 0);
  if (totalContents === 0) {
    errors.push("최소 1개 이상의 콘텐츠를 선택해주세요.");
  }

  return errors;
}
</file>

<file path="planGroupAdapters.ts">
/**
 * PlanGroup → WizardData 변환 어댑터
 * 
 * Phase 5.3에서 구현
 * DetailView에서 Step 컴포넌트를 재사용하기 위한 타입 변환
 */

import type { PlanGroup, PlanExclusion, AcademySchedule } from "@/lib/types/plan";
import type { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";

/**
 * PlanGroup을 WizardData로 변환
 * 
 * @param group - 플랜 그룹
 * @param exclusions - 제외일 목록
 * @param academySchedules - 학원 일정 목록
 * @param contents - 콘텐츠 목록 (선택)
 * @param templateBlocks - 템플릿 블록 목록 (선택)
 * @param templateBlockSetName - 템플릿 블록세트 이름 (선택)
 * @returns WizardData 형식
 */
export function planGroupToWizardData(
  group: PlanGroup,
  exclusions: PlanExclusion[] = [],
  academySchedules: AcademySchedule[] = [],
  contents?: Array<any>,
  templateBlocks?: Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
  }>,
  templateBlockSetName?: string | null
): WizardData {
  // scheduler_options에서 time_settings 추출
  const schedulerOptions = (group.scheduler_options as any) || {};
  const timeSettings = schedulerOptions.time_settings;

  // 콘텐츠 분리 (학생/추천)
  let studentContents: any[] = [];
  let recommendedContents: any[] = [];
  
  if (contents && contents.length > 0) {
    const { studentContents: student, recommendedContents: recommended } = 
      contentsToWizardFormat(
        contents.map((c: any) => ({
          id: c.id || c.content_id,
          content_id: c.content_id,
          content_type: c.content_type,
          start_range: c.start_range,
          end_range: c.end_range,
          contentTitle: c.contentTitle || c.title || "알 수 없음",
          contentSubtitle: c.contentSubtitle || c.subject_category || null,
          isRecommended: c.isRecommended || c.is_recommended || false,
        }))
      );
    studentContents = student;
    recommendedContents = recommended;
  }

  return {
    // Step 1: 기본 정보
    name: group.name || "",
    plan_purpose: (group.plan_purpose as any) || "",
    scheduler_type: (group.scheduler_type as any) || "",
    scheduler_options: {
      study_days: schedulerOptions.study_days,
      review_days: schedulerOptions.review_days,
    },
    period_start: group.period_start,
    period_end: group.period_end,
    target_date: group.target_date || undefined,
    block_set_id: group.block_set_id || "",

    // Step 2: 제외일 및 학원 일정
    exclusions: exclusions.map((e) => ({
      exclusion_date: e.exclusion_date,
      exclusion_type: e.exclusion_type as any,
      reason: e.reason || undefined,
      source: "student",
    })),
    academy_schedules: academySchedules.map((a) => ({
      day_of_week: a.day_of_week,
      start_time: a.start_time,
      end_time: a.end_time,
      academy_name: a.academy_name || undefined,
      subject: a.subject || undefined,
      travel_time: a.travel_time || undefined,
    })),
    time_settings: timeSettings,
    non_study_time_blocks: [],

    // Step 3: 콘텐츠
    student_contents: studentContents,
    recommended_contents: recommendedContents,

    // Step 4+: 기타 (선택)
    subject_allocations: [],
  };
}

/**
 * WizardData를 PlanGroup 생성 데이터로 변환
 * 
 * @param data - WizardData
 * @returns PlanGroup 생성에 필요한 데이터
 */
export function wizardDataToPlanGroupCreationData(data: WizardData) {
  return {
    name: data.name,
    plan_purpose: data.plan_purpose,
    scheduler_type: data.scheduler_type,
    scheduler_options: {
      ...data.scheduler_options,
      time_settings: data.time_settings,
    },
    period_start: data.period_start,
    period_end: data.period_end,
    target_date: data.target_date,
    block_set_id: data.block_set_id,
    exclusions: data.exclusions,
    academy_schedules: data.academy_schedules,
    non_study_time_blocks: data.non_study_time_blocks,
    student_contents: data.student_contents,
    recommended_contents: data.recommended_contents,
    subject_allocations: data.subject_allocations,
  };
}

/**
 * PlanContent 배열을 학생/추천 콘텐츠로 분리하여 WizardData 형식으로 변환
 * 
 * @param contents - PlanContent 배열
 * @returns 학생 콘텐츠와 추천 콘텐츠
 */
export function contentsToWizardFormat(
  contents: Array<{
    id: string;
    content_id: string;
    content_type: "book" | "lecture" | "custom";
    start_range: number;
    end_range: number;
    contentTitle: string;
    contentSubtitle: string | null;
    isRecommended: boolean;
  }>
) {
  const studentContents = contents
    .filter((c) => !c.isRecommended)
    .map((c) => ({
      content_id: c.content_id,
      content_type: c.content_type,
      start_range: c.start_range,
      end_range: c.end_range,
      subject_category: c.contentSubtitle || undefined,
      title: c.contentTitle,
    }));

  const recommendedContents = contents
    .filter((c) => c.isRecommended)
    .map((c) => ({
      content_id: c.content_id,
      content_type: c.content_type,
      start_range: c.start_range,
      end_range: c.end_range,
      subject_category: c.contentSubtitle || undefined,
      title: c.contentTitle,
      is_auto_recommended: false,
    }));

  return { studentContents, recommendedContents };
}
</file>

<file path="planGroupDataSync.ts">
/**
 * WizardData와 PlanGroupCreationData 간 데이터 동기화 및 변환 유틸리티
 * 데이터 일관성을 보장하기 위한 중앙화된 변환 로직
 */

import type { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";
import type {
  PlanGroupCreationData,
  PlanPurpose,
  SchedulerType,
  PlanContentInput,
  ExclusionType,
} from "@/lib/types/plan";
import { PlanGroupError, PlanGroupErrorCodes } from "@/lib/errors/planGroupErrors";
import { mergeTimeSettingsSafely } from "@/lib/utils/schedulerOptionsMerge";

/**
 * WizardData를 PlanGroupCreationData로 변환
 * 데이터 일관성을 보장하고 중복 저장을 방지합니다.
 */
export function syncWizardDataToCreationData(
  wizardData: WizardData
): PlanGroupCreationData {
  try {
    // 1. scheduler_options 구성
    const schedulerOptions: Record<string, unknown> = {
      ...(wizardData.scheduler_options || {}),
    };

    // study_review_cycle을 scheduler_options에 병합
    if (wizardData.study_review_cycle) {
      schedulerOptions.study_days = wizardData.study_review_cycle.study_days;
      schedulerOptions.review_days = wizardData.study_review_cycle.review_days;
    } else if (wizardData.scheduler_options?.study_days || wizardData.scheduler_options?.review_days) {
      // scheduler_options에 이미 있는 경우 그대로 사용
      schedulerOptions.study_days = wizardData.scheduler_options.study_days;
      schedulerOptions.review_days = wizardData.scheduler_options.review_days;
    }

    // time_settings를 scheduler_options에 안전하게 병합 (보호 필드 자동 보호)
    let finalSchedulerOptions = schedulerOptions;
    if (wizardData.time_settings) {
      finalSchedulerOptions = mergeTimeSettingsSafely(schedulerOptions, wizardData.time_settings);
    }

    // subject_allocations와 content_allocations를 scheduler_options에 저장
    if (wizardData.subject_allocations) {
      finalSchedulerOptions.subject_allocations = wizardData.subject_allocations;
    }
    if (wizardData.content_allocations) {
      finalSchedulerOptions.content_allocations = wizardData.content_allocations;
    }
    if (wizardData.student_level) {
      finalSchedulerOptions.student_level = wizardData.student_level;
    }

    // 2. daily_schedule 유효성 검증 및 필터링
    const periodStart = new Date(wizardData.period_start);
    const periodEnd = new Date(wizardData.period_end);
    
    // 추가 기간이 있으면 유효한 기간 범위 확장
    let validStart = periodStart;
    let validEnd = periodEnd;
    
    if (wizardData.additional_period_reallocation) {
      const additionalStart = new Date(wizardData.additional_period_reallocation.period_start);
      const additionalEnd = new Date(wizardData.additional_period_reallocation.period_end);
      
      // 유효한 기간: 원래 기간 + 추가 기간
      validStart = periodStart < additionalStart ? periodStart : additionalStart;
      validEnd = periodEnd > additionalEnd ? periodEnd : additionalEnd;
    }
    
    const validatedDailySchedule = wizardData.daily_schedule?.filter(
      (schedule) => {
        try {
          const scheduleDate = new Date(schedule.date);

          return (
            scheduleDate >= validStart &&
            scheduleDate <= validEnd &&
            schedule.study_hours >= 0
          );
        } catch {
          return false;
        }
      }
    );

    // 3. 콘텐츠 데이터 검증 및 변환
    const allContents = [
      ...wizardData.student_contents,
      ...wizardData.recommended_contents,
    ];

    // 중복 콘텐츠 검증
    const contentKeys = new Set<string>();
    const duplicateContents: string[] = [];
    
    allContents.forEach((content, index) => {
      const key = `${content.content_type}:${content.content_id}`;
      if (contentKeys.has(key)) {
        duplicateContents.push(`콘텐츠 ${index + 1}`);
      }
      contentKeys.add(key);
    });

    if (duplicateContents.length > 0) {
      throw new PlanGroupError(
        `중복된 콘텐츠가 있습니다: ${duplicateContents.join(', ')}`,
        PlanGroupErrorCodes.DATA_INCONSISTENCY,
        '중복된 콘텐츠가 선택되었습니다. 확인해주세요.',
        true
      );
    }

    // 4. PlanGroupCreationData 구성
    // plan_purpose 변환: 빈 문자열은 null, "모의고사(수능)"은 "모의고사"로 변환
    const wizardPlanPurpose = wizardData.plan_purpose as string;
    const normalizedPlanPurpose: PlanPurpose | null =
      !wizardPlanPurpose || wizardPlanPurpose === ""
        ? null
        : wizardPlanPurpose === "모의고사(수능)"
          ? "모의고사"
          : (wizardPlanPurpose as PlanPurpose);

    // scheduler_type 변환: 빈 문자열은 null
    const wizardSchedulerType = wizardData.scheduler_type as string; // Cast to string for empty check
    const normalizedSchedulerType: SchedulerType | null =
      !wizardSchedulerType || wizardSchedulerType === ""
        ? null
        : (wizardSchedulerType as SchedulerType);

    const creationData: PlanGroupCreationData = {
      name: wizardData.name || null,
      plan_purpose: normalizedPlanPurpose || "모의고사", // Default fallback if null
      scheduler_type: normalizedSchedulerType || "1730_timetable", // Default fallback if null
      scheduler_options:
        Object.keys(finalSchedulerOptions).length > 0 ? finalSchedulerOptions : null,
      period_start: wizardData.period_start || new Date().toISOString().split('T')[0], // Fallback to today
      period_end: wizardData.period_end || new Date().toISOString().split('T')[0],
      target_date: wizardData.target_date || null,
      block_set_id: wizardData.block_set_id || null,
      contents: allContents.map((c, idx) => {
        // PlanContentInput 타입에 맞게 구성
        // master_content_id 설정
        let masterContentId: string | null = null;
        // 1. WizardData에서 명시적으로 설정된 경우 우선 사용
        if ("master_content_id" in c && c.master_content_id) {
          masterContentId = c.master_content_id;
        } else {
          // 2. 추천 콘텐츠인 경우: content_id 자체가 마스터 콘텐츠 ID
          const isRecommended = wizardData.recommended_contents.some(
            (rc) => rc.content_id === c.content_id && rc.content_type === c.content_type
          );
          if (isRecommended) {
            masterContentId = c.content_id;
          }
        }

        const contentItem: PlanContentInput & {
          is_auto_recommended?: boolean;
          recommendation_source?: "auto" | "admin" | "template" | null;
          recommendation_reason?: string | null;
          recommendation_metadata?: any;
        } = {
          content_type: c.content_type,
          content_id: c.content_id,
          start_range: c.start_range,
          end_range: c.end_range,
          start_detail_id: "start_detail_id" in c ? (c.start_detail_id ?? null) : null,
          end_detail_id: "end_detail_id" in c ? (c.end_detail_id ?? null) : null,
          display_order: idx,
          ...(masterContentId ? { master_content_id: masterContentId } : {}),
        };

        // 자동 추천 관련 필드 추가
        // Step 4에서 자동 배정된 콘텐츠는 is_auto_recommended: true, recommendation_source: "auto"로 설정됨
        // 이 플래그들은 DB에 저장되어 관리자 일괄 적용 기능과 구분됨
        if ("is_auto_recommended" in c && c.is_auto_recommended !== undefined) {
          contentItem.is_auto_recommended = c.is_auto_recommended;
        }
        if ("recommendation_source" in c && c.recommendation_source) {
          contentItem.recommendation_source = (c.recommendation_source as any) as "auto" | "admin" | "template" | null;
        }
        if ("recommendation_reason" in c && c.recommendation_reason) {
          contentItem.recommendation_reason = typeof c.recommendation_reason === 'string' ? c.recommendation_reason : null;
        }
        if ("recommendation_metadata" in c && c.recommendation_metadata) {
          contentItem.recommendation_metadata = c.recommendation_metadata;
        }

        return contentItem;
      }),
      exclusions: wizardData.exclusions.map((e) => ({
        exclusion_date: e.exclusion_date,
        exclusion_type: e.exclusion_type as ExclusionType,
        reason: e.reason || null,
      })),
      academy_schedules: wizardData.academy_schedules.map((s) => ({
        day_of_week: s.day_of_week,
        start_time: s.start_time,
        end_time: s.end_time,
        academy_name: s.academy_name || undefined,
        subject: s.subject || undefined,
        travel_time: s.travel_time,
      })),
      // 1730 Timetable 추가 필드
      study_review_cycle: wizardData.study_review_cycle,
      student_level: wizardData.student_level,
      subject_allocations: wizardData.subject_allocations,
      subject_constraints: wizardData.subject_constraints
        ? {
            ...wizardData.subject_constraints,
            required_subjects: wizardData.subject_constraints.required_subjects?.map(
              (req) => ({
                subject_category: req.subject_category,
                subject: req.subject_category, // fallback
                min_count: req.min_count,
                subjects_by_curriculum: req.subjects_by_curriculum
                  ?.filter((s) => s.subject_id) // subject_id가 있는 것만 필터링
                  .map((s) => ({
                    curriculum_revision_id: s.curriculum_revision_id,
                    subject_id: s.subject_id!, // 필터링했으므로 non-null assertion 가능
                    subject_name: s.subject_name,
                  })),
              })
            ),
          }
        : undefined,
      additional_period_reallocation: wizardData.additional_period_reallocation,
      non_study_time_blocks: wizardData.non_study_time_blocks,
      // Step 2.5에서 생성된 일별 스케줄 정보
      daily_schedule: validatedDailySchedule || null,
    };

    return creationData;
  } catch (error) {
    if (error instanceof PlanGroupError) {
      throw error;
    }
    throw new PlanGroupError(
      `데이터 변환 실패: ${error instanceof Error ? error.message : String(error)}`,
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      '데이터 변환 중 오류가 발생했습니다. 페이지를 새로고침해주세요.',
      false,
      { wizardData: JSON.stringify(wizardData) }
    );
  }
}

/**
 * PlanGroupCreationData (또는 PlanGroup + 관련 데이터)를 WizardData로 변환
 * 데이터베이스에서 조회한 플랜 그룹 데이터를 위저드에서 사용할 수 있는 형식으로 변환합니다.
 */
export function syncCreationDataToWizardData(data: {
  group: {
    id: string;
    name: string | null;
    plan_purpose: string | null;
    scheduler_type: string | null;
    scheduler_options?: any;
    period_start: string;
    period_end: string;
    target_date: string | null;
    block_set_id: string | null;
    daily_schedule?: any;
    subject_constraints?: any;
    additional_period_reallocation?: any;
    non_study_time_blocks?: any;
    study_hours?: any;
    self_study_hours?: any;
    plan_type?: string | null;
    camp_template_id?: string | null;
  };
  contents: Array<{
    content_type: "book" | "lecture" | "custom";
    content_id: string;
    start_range: number;
    end_range: number;
    start_detail_id?: string | null; // 시작 범위 상세 정보 ID
    end_detail_id?: string | null; // 종료 범위 상세 정보 ID
    display_order: number;
    is_auto_recommended?: boolean;
    recommendation_source?: string | null;
    recommendation_reason?: string | null;
    title?: string; // 콘텐츠 제목
    subject_category?: string; // 과목 카테고리
    master_content_id?: string | null; // 마스터 콘텐츠 ID
  }>;
  exclusions: Array<{
    exclusion_date: string;
    exclusion_type: string;
    reason: string | null;
  }>;
  academySchedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string | null;
    subject?: string | null;
    travel_time?: number | null;
  }>;
}): WizardData {
  try {
    const { group, contents, exclusions, academySchedules } = data;

    // scheduler_options에서 time_settings 추출
    const schedulerOptions = (group.scheduler_options as any) || {};
    const timeSettings: WizardData["time_settings"] = {
      lunch_time: schedulerOptions.lunch_time,
      camp_study_hours: schedulerOptions.camp_study_hours,
      camp_self_study_hours: schedulerOptions.camp_self_study_hours,
      designated_holiday_hours: schedulerOptions.designated_holiday_hours,
      use_self_study_with_blocks: schedulerOptions.use_self_study_with_blocks,
      enable_self_study_for_holidays: schedulerOptions.enable_self_study_for_holidays,
      enable_self_study_for_study_days: schedulerOptions.enable_self_study_for_study_days,
    };

    // time_settings 필드 중 하나라도 값이 있으면 포함
    const hasTimeSettings =
      timeSettings.lunch_time !== undefined ||
      timeSettings.camp_study_hours !== undefined ||
      timeSettings.camp_self_study_hours !== undefined ||
      timeSettings.designated_holiday_hours !== undefined ||
      timeSettings.use_self_study_with_blocks !== undefined ||
      timeSettings.enable_self_study_for_holidays !== undefined ||
      timeSettings.enable_self_study_for_study_days !== undefined;

    // scheduler_options에서 time_settings 필드 제거
    const {
      lunch_time,
      camp_study_hours,
      camp_self_study_hours,
      designated_holiday_hours,
      use_self_study_with_blocks,
      enable_self_study_for_holidays,
      enable_self_study_for_study_days,
      study_days,
      review_days,
      student_level,
      subject_allocations,
      content_allocations,
      ...schedulerOptionsWithoutTimeSettings
    } = schedulerOptions;

    // 콘텐츠 분류: is_auto_recommended가 true이거나 recommendation_source가 있는 경우 추천 콘텐츠
    // - is_auto_recommended: true, recommendation_source: "auto" → Step 4에서 자동 배정된 콘텐츠
    // - is_auto_recommended: false, recommendation_source: "admin" → 관리자가 일괄 적용한 콘텐츠
    // - 둘 다 없으면 → 학생이 직접 등록한 콘텐츠 (student_contents)
    const studentContents: WizardData["student_contents"] = [];
    const recommendedContents: WizardData["recommended_contents"] = [];

    contents.forEach((c) => {
      const contentItem = {
        content_type: c.content_type as "book" | "lecture",
        content_id: c.content_id,
        start_range: c.start_range,
        end_range: c.end_range,
        // 상세 정보 ID 포함
      ...((c.start_detail_id) ? { start_detail_id: c.start_detail_id } : {}),
        ...((c.end_detail_id) ? { end_detail_id: c.end_detail_id } : {}),
        // title과 subject_category가 있으면 포함
        ...((c.title) ? { title: c.title } : {}),
        ...((c.subject_category) ? { subject_category: c.subject_category } : {}),
        // master_content_id가 있으면 포함 (마스터에서 가져온 교재/강의 표시용)
        ...("master_content_id" in c && c.master_content_id ? { master_content_id: c.master_content_id } : {}),
      };

      if (c.is_auto_recommended || c.recommendation_source) {
        recommendedContents.push({
          ...contentItem,
          is_auto_recommended: c.is_auto_recommended ?? false,
          recommendation_source: (c.recommendation_source as any) ?? null,
          recommendation_reason: c.recommendation_reason ?? null,
        });
      } else {
        studentContents.push(contentItem);
      }
    });

    // WizardData 구성
    // plan_purpose 변환: null은 빈 문자열로, PlanPurpose는 그대로 사용
    const wizardPlanPurpose: WizardData["plan_purpose"] =
      group.plan_purpose === null ? "" : (group.plan_purpose as WizardData["plan_purpose"]);

    // scheduler_type 변환: null은 빈 문자열로, SchedulerType은 그대로 사용
    const wizardSchedulerType: WizardData["scheduler_type"] =
      group.scheduler_type === null ? "" : (group.scheduler_type as WizardData["scheduler_type"]);

    const wizardData: WizardData = {
      name: group.name || "",
      plan_purpose: wizardPlanPurpose,
      scheduler_type: wizardSchedulerType,
      scheduler_options:
        Object.keys(schedulerOptionsWithoutTimeSettings).length > 0
          ? schedulerOptionsWithoutTimeSettings
          : undefined,
      period_start: group.period_start,
      period_end: group.period_end,
      target_date: group.target_date || undefined,
      block_set_id: group.block_set_id || "",
      exclusions: exclusions.map((e) => ({
        exclusion_date: e.exclusion_date,
        exclusion_type: e.exclusion_type as ExclusionType,
        reason: e.reason || undefined,
      })),
      academy_schedules: academySchedules.map((s) => ({
        day_of_week: s.day_of_week,
        start_time: s.start_time,
        end_time: s.end_time,
        academy_name: s.academy_name || undefined,
        subject: s.subject || undefined,
        travel_time: s.travel_time || undefined,
      })),
      time_settings: hasTimeSettings ? timeSettings : undefined,
      student_contents: studentContents,
      recommended_contents: recommendedContents,
      // 1730 Timetable 추가 필드
      study_review_cycle:
        study_days || review_days
          ? {
              study_days: study_days || 6,
              review_days: review_days || 1,
            }
          : undefined,
      student_level: student_level,
      subject_allocations: subject_allocations,
      content_allocations: content_allocations,
      subject_constraints: group.subject_constraints || undefined,
      additional_period_reallocation: group.additional_period_reallocation || undefined,
      non_study_time_blocks: group.non_study_time_blocks || undefined,
      daily_schedule: group.daily_schedule || undefined,
    };

    return wizardData;
  } catch (error) {
    throw new PlanGroupError(
      `데이터 변환 실패: ${error instanceof Error ? error.message : String(error)}`,
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      "데이터 변환 중 오류가 발생했습니다. 페이지를 새로고침해주세요.",
      false,
      { data: JSON.stringify(data) }
    );
  }
}

/**
 * 데이터 일관성 검증
 */
export function validateDataConsistency(
  wizardData: WizardData
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // 1. 기간 검증
  if (wizardData.period_start && wizardData.period_end) {
    const start = new Date(wizardData.period_start);
    const end = new Date(wizardData.period_end);
    if (start >= end) {
      errors.push('시작일은 종료일보다 이전이어야 합니다.');
    }
  }

  // 2. daily_schedule과 period 일치 검증
  if (wizardData.daily_schedule) {
    const periodStart = new Date(wizardData.period_start);
    const periodEnd = new Date(wizardData.period_end);
    
    // 추가 기간이 있으면 유효한 기간 범위 확장
    let validStart = periodStart;
    let validEnd = periodEnd;
    
    if (wizardData.additional_period_reallocation) {
      const additionalStart = new Date(wizardData.additional_period_reallocation.period_start);
      const additionalEnd = new Date(wizardData.additional_period_reallocation.period_end);
      
      // 유효한 기간: 원래 기간 + 추가 기간
      validStart = periodStart < additionalStart ? periodStart : additionalStart;
      validEnd = periodEnd > additionalEnd ? periodEnd : additionalEnd;
    }
    
    const invalidSchedules = wizardData.daily_schedule.filter((schedule) => {
      const scheduleDate = new Date(schedule.date);
      return scheduleDate < validStart || scheduleDate > validEnd;
    });

    if (invalidSchedules.length > 0) {
      errors.push(
        `${invalidSchedules.length}개의 스케줄이 플랜 기간 밖에 있습니다.`
      );
    }
  }

  // 3. study_review_cycle과 scheduler_options 일치 검증
  if (wizardData.scheduler_type === '1730_timetable') {
    const studyDays =
      wizardData.study_review_cycle?.study_days ||
      wizardData.scheduler_options?.study_days;
    const reviewDays =
      wizardData.study_review_cycle?.review_days ||
      wizardData.scheduler_options?.review_days;

    if (studyDays && reviewDays) {
      if (studyDays + reviewDays > 7) {
        errors.push('학습일 수와 복습일 수의 합은 7일 이하여야 합니다.');
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
</file>

<file path="planGroupLock.ts">
/**
 * 플랜 그룹 단위 Advisory Lock 유틸리티
 * 
 * 재조정 기능에서 동시성 제어를 위해 사용됩니다.
 * Postgres Advisory Lock을 사용하여 동일 플랜 그룹에 대한
 * 동시 재조정 요청을 방지합니다.
 * 
 * @module lib/utils/planGroupLock
 */

import type { SupabaseClient } from '@supabase/supabase-js';

// ============================================
// Lock 키 생성
// ============================================

/**
 * 플랜 그룹 ID를 기반으로 Advisory Lock 키 생성
 * 
 * Postgres Advisory Lock은 bigint를 사용하므로,
 * UUID를 해시하여 숫자로 변환합니다.
 * 
 * @param groupId 플랜 그룹 ID (UUID)
 * @returns Advisory Lock 키 (bigint)
 */
export function getPlanGroupLockKey(groupId: string): number {
  // UUID를 해시하여 숫자로 변환
  // 간단한 해시 함수 사용 (FNV-1a 변형)
  let hash = 2166136261;
  for (let i = 0; i < groupId.length; i++) {
    hash ^= groupId.charCodeAt(i);
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  
  // 양수로 변환 (Postgres Advisory Lock은 bigint 사용)
  return Math.abs(hash >>> 0);
}

// ============================================
// Lock 획득/해제
// ============================================

/**
 * 플랜 그룹 단위 Advisory Lock 획득
 * 
 * 주의: Supabase에서는 Advisory Lock을 직접 지원하지 않으므로,
 * 대신 plan_groups 테이블에 SELECT FOR UPDATE를 사용합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param groupId 플랜 그룹 ID
 * @returns Lock 획득 성공 여부
 * 
 * @throws {Error} Lock 획득 실패 시
 */
export async function acquirePlanGroupLock(
  supabase: SupabaseClient,
  groupId: string
): Promise<boolean> {
  try {
    // SELECT FOR UPDATE로 행 레벨 락 획득
    // 트랜잭션 내에서만 유효
    const { data, error } = await supabase
      .from('plan_groups')
      .select('id')
      .eq('id', groupId)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') {
        // 플랜 그룹이 존재하지 않음
        throw new Error(`Plan group not found: ${groupId}`);
      }
      throw new Error(`Failed to acquire lock: ${error.message}`);
    }
    
    // 실제로는 트랜잭션 내에서 SELECT FOR UPDATE를 사용해야 하지만,
    // Supabase 클라이언트에서는 직접 지원하지 않으므로
    // 여기서는 단순히 존재 여부만 확인
    // 실제 락은 트랜잭션 래퍼에서 처리
    return true;
  } catch (error) {
    console.error('[planGroupLock] Lock 획득 실패:', error);
    return false;
  }
}

/**
 * 플랜 그룹 단위 Advisory Lock 시도 (논블로킹)
 * 
 * Lock을 즉시 획득할 수 없으면 false를 반환합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param groupId 플랜 그룹 ID
 * @returns Lock 획득 성공 여부
 */
export async function tryAcquirePlanGroupLock(
  supabase: SupabaseClient,
  groupId: string
): Promise<boolean> {
  const lockKey = getPlanGroupLockKey(groupId);
  
  // Advisory Lock 시도 (논블로킹)
  const { data, error } = await supabase.rpc('pg_try_advisory_xact_lock', {
    key: lockKey,
  });
  
  if (error) {
    // Lock 획득 실패
    return false;
  }
  
  // data는 boolean (true = 획득 성공, false = 획득 실패)
  return data === true;
}

// ============================================
// Lock 상태 확인
// ============================================

/**
 * 플랜 그룹 Lock 상태 확인
 * 
 * @param supabase Supabase 클라이언트
 * @param groupId 플랜 그룹 ID
 * @returns Lock 보유 여부
 */
export async function isPlanGroupLocked(
  supabase: SupabaseClient,
  groupId: string
): Promise<boolean> {
  const lockKey = getPlanGroupLockKey(groupId);
  
  // Advisory Lock 상태 확인
  const { data, error } = await supabase.rpc('pg_advisory_lock_held', {
    key: lockKey,
  });
  
  if (error) {
    return false;
  }
  
  return data === true;
}
</file>

<file path="planGroupTransform.ts">
/**
 * 플랜 그룹 데이터 변환 유틸리티
 * 
 * 데이터베이스의 PlanGroup 형식을 WizardData 형식으로 변환하는 함수들
 */

import type { PlanGroup, PlanContent, PlanExclusion, AcademySchedule, SchedulerOptions, TimeSettings } from "@/lib/types/plan";
import { classifyPlanContents } from "@/lib/data/planContents";
import { logError } from "@/lib/errors/handler";

/**
 * WizardData 타입 (PlanGroupWizard에서 사용)
 */
export type PartialWizardData = {
  groupId?: string;
  name: string;
  plan_purpose: string;
  scheduler_type: string;
  scheduler_options?: SchedulerOptions;
  time_settings?: {
    lunch_time?: { start: string; end: string };
    camp_study_hours?: { start: string; end: string };
    camp_self_study_hours?: { start: string; end: string };
    designated_holiday_hours?: { start: string; end: string };
    use_self_study_with_blocks?: boolean;
    enable_self_study_for_holidays?: boolean;
    enable_self_study_for_study_days?: boolean;
  };
  period_start: string;
  period_end: string;
  target_date?: string;
  block_set_id: string;
  student_contents: Array<{
    content_type: "book" | "lecture" | "custom";
    content_id: string;
    start_range: number;
    end_range: number;
    title?: string;
    subject_category?: string;
  }>;
  recommended_contents: Array<{
    content_type: "book" | "lecture" | "custom";
    content_id: string;
    start_range: number;
    end_range: number;
    title?: string;
    subject_category?: string;
  }>;
  exclusions: Array<{
    exclusion_date: string;
    exclusion_type: "휴가" | "개인사정" | "휴일지정" | "기타";
    reason?: string;
  }>;
  academy_schedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string;
    subject?: string;
    travel_time?: number;
  }>;
  study_review_cycle?: {
    study_days: number;
    review_days: number;
  };
  student_level?: "high" | "medium" | "low";
  subject_allocations?: Array<{
    subject_id: string;
    subject_name: string;
    subject_type: "strategy" | "weakness";
    weekly_days?: number;
  }>;
  subject_constraints?: {
    required_subjects?: string[];
    excluded_subjects?: string[];
    constraint_handling: "strict" | "warning" | "auto_fix";
  };
  additional_period_reallocation?: {
    period_start: string;
    period_end: string;
    type: "additional_review";
    original_period_start: string;
    original_period_end: string;
    subjects?: string[];
    review_of_review_factor?: number;
  };
  non_study_time_blocks?: Array<{
    type: "아침식사" | "점심식사" | "저녁식사" | "수면" | "기타";
    start_time: string;
    end_time: string;
    day_of_week?: number[];
    description?: string;
  }>;
};

/**
 * PlanGroup 데이터를 WizardData 형식으로 변환
 * 
 * @param group 플랜 그룹 데이터
 * @param contents 플랜 콘텐츠 목록
 * @param exclusions 제외일 목록
 * @param academySchedules 학원 일정 목록
 * @param studentId 학생 ID (콘텐츠 분류에 사용)
 * @returns WizardData 형식의 초기 데이터
 */
export async function transformPlanGroupToWizardData(
  group: PlanGroup,
  contents: PlanContent[],
  exclusions: PlanExclusion[],
  academySchedules: AcademySchedule[],
  studentId: string
): Promise<PartialWizardData> {
  // 콘텐츠 분류 (통합 함수 사용)
  const { studentContents, recommendedContents } = await classifyPlanContents(contents, studentId);

  // 캠프 플랜인 경우 템플릿의 block_set_id 조회
  let blockSetId = group.block_set_id || "";
  if (group.plan_type === "camp" && group.camp_template_id && !blockSetId) {
    try {
      const { getTemplateBlockSetId } = await import("@/lib/plan/blocks");
      const schedulerOptions = (group.scheduler_options as (SchedulerOptions & Partial<TimeSettings>) | null) ?? {};
      const templateBlockSetId = await getTemplateBlockSetId(
        group.camp_template_id,
        schedulerOptions as Record<string, unknown>
      );
      if (templateBlockSetId) {
        blockSetId = templateBlockSetId;
      }
    } catch (error) {
      logError(error, {
        function: "transformPlanGroupToWizardData",
        campTemplateId: group.camp_template_id,
        groupId: group.id,
      });
    }
  }

  // scheduler_options에서 time_settings 추출
  const schedulerOptions = (group.scheduler_options as (SchedulerOptions & Partial<TimeSettings>) | null) ?? {};
  const timeSettings = {
    lunch_time: schedulerOptions.lunch_time,
    camp_study_hours: schedulerOptions.camp_study_hours,
    camp_self_study_hours: schedulerOptions.camp_self_study_hours,
    designated_holiday_hours: schedulerOptions.designated_holiday_hours,
    use_self_study_with_blocks: schedulerOptions.use_self_study_with_blocks,
    enable_self_study_for_holidays: schedulerOptions.enable_self_study_for_holidays,
    enable_self_study_for_study_days: schedulerOptions.enable_self_study_for_study_days,
  };

  // time_settings 필드 중 하나라도 값이 있으면 포함
  const hasTimeSettings =
    timeSettings.lunch_time !== undefined ||
    timeSettings.camp_study_hours !== undefined ||
    timeSettings.camp_self_study_hours !== undefined ||
    timeSettings.designated_holiday_hours !== undefined ||
    timeSettings.use_self_study_with_blocks !== undefined ||
    timeSettings.enable_self_study_for_holidays !== undefined ||
    timeSettings.enable_self_study_for_study_days !== undefined;

  // scheduler_options에서 time_settings 필드 제거
  const {
    lunch_time,
    camp_study_hours,
    camp_self_study_hours,
    designated_holiday_hours,
    use_self_study_with_blocks,
    enable_self_study_for_holidays,
    enable_self_study_for_study_days,
    ...schedulerOptionsWithoutTimeSettings
  } = schedulerOptions;

  // 초기 데이터 구성
  return {
    groupId: group.id,
    name: group.name || "",
    plan_purpose: group.plan_purpose || "",
    scheduler_type: group.scheduler_type || "",
    scheduler_options:
      Object.keys(schedulerOptionsWithoutTimeSettings).length > 0
        ? schedulerOptionsWithoutTimeSettings
        : undefined,
    time_settings: hasTimeSettings ? timeSettings : undefined,
    period_start: group.period_start,
    period_end: group.period_end,
    target_date: group.target_date || undefined,
    block_set_id: blockSetId,
    student_contents: studentContents.map((c) => {
      // 원본 contents 배열에서 content_id로 매칭하여 start_detail_id와 end_detail_id 가져오기
      const originalContent = contents.find(
        (orig) => orig.content_id === c.content_id || orig.content_id === c.masterContentId
      );
      return {
        content_type: c.content_type as "book" | "lecture" | "custom",
        content_id: c.masterContentId || c.content_id, // 추천 콘텐츠의 경우 원본 마스터 콘텐츠 ID 사용
        start_range: c.start_range,
        end_range: c.end_range,
        start_detail_id: originalContent?.start_detail_id ?? null,
        end_detail_id: originalContent?.end_detail_id ?? null,
        title: c.title,
        subject_category: c.subject_category || undefined,  // 변경: null → undefined
      };
    }),
    recommended_contents: recommendedContents.map((c) => {
      // 원본 contents 배열에서 content_id로 매칭하여 start_detail_id와 end_detail_id 가져오기
      const originalContent = contents.find((orig) => orig.content_id === c.content_id);
      return {
        content_type: c.content_type as "book" | "lecture" | "custom",
        content_id: c.content_id, // 이미 마스터 콘텐츠 ID
        start_range: c.start_range,
        end_range: c.end_range,
        start_detail_id: originalContent?.start_detail_id ?? null,
        end_detail_id: originalContent?.end_detail_id ?? null,
        title: c.title,
        subject_category: c.subject_category || undefined,  // 변경: null → undefined
        // 자동 추천 정보 포함
        is_auto_recommended: c.is_auto_recommended ?? false,
        recommendation_source: c.recommendation_source ?? null,
        recommendation_reason: c.recommendation_reason ?? null,
        recommendation_metadata: c.recommendation_metadata ?? null,
      };
    }),
    // 제외일 변환: 캠프 플랜인 경우 템플릿 제외일인지 확인하여 source/is_locked 설정
    exclusions: await (async () => {
      // 캠프 플랜인 경우 템플릿 데이터 조회
      let templateExclusions: Array<{ exclusion_date: string }> = [];
      if (group.plan_type === "camp" && group.camp_template_id) {
        try {
          const { getCampTemplate } = await import("@/lib/data/campTemplates");
          const template = await getCampTemplate(group.camp_template_id);
          if (template?.template_data?.exclusions) {
            templateExclusions = template.template_data.exclusions;
          }
          // 템플릿이 없으면 빈 배열로 처리 (정상적인 상황일 수 있음)
        } catch (error) {
          console.error("[planGroupTransform] 템플릿 데이터 조회 실패", {
            camp_template_id: group.camp_template_id,
            error,
          });
        }
      }

      // 날짜 비교를 위해 정규화 (YYYY-MM-DD 형식으로 통일)
      const normalizeDate = (date: string) => {
        if (!date) return "";
        // 이미 YYYY-MM-DD 형식이면 그대로 반환
        if (/^\d{4}-\d{2}-\d{2}$/.test(date)) return date;
        // Date 객체로 변환 후 YYYY-MM-DD 형식으로 변환
        const d = new Date(date);
        if (isNaN(d.getTime())) return date;
        return d.toISOString().slice(0, 10);
      };

      const templateExclusionDates = new Set(
        templateExclusions.map((te) => normalizeDate(te.exclusion_date))
      );

      return exclusions.map((e) => {
        const normalizedDate = normalizeDate(e.exclusion_date);
        const isTemplateExclusion = templateExclusionDates.has(normalizedDate);
        return {
          exclusion_date: e.exclusion_date,
          exclusion_type: e.exclusion_type as "휴가" | "개인사정" | "휴일지정" | "기타",
          reason: e.reason || undefined,
          // 캠프 플랜이고 템플릿 제외일인 경우 source와 is_locked 설정
          ...(isTemplateExclusion
            ? {
                source: "template" as const,
                is_locked: true,
              }
            : {}),
        };
      });
    })(),
    // 학원 일정 변환: 캠프 플랜인 경우 템플릿 학원 일정인지 확인하여 source/is_locked 설정
    academy_schedules: await (async () => {
      // 캠프 플랜인 경우 템플릿 데이터 조회
      let templateAcademySchedules: Array<{
        day_of_week: number;
        start_time: string;
        end_time: string;
      }> = [];
      if (group.plan_type === "camp" && group.camp_template_id) {
        try {
          const { getCampTemplate } = await import("@/lib/data/campTemplates");
          const template = await getCampTemplate(group.camp_template_id);
          if (template?.template_data?.academy_schedules) {
            templateAcademySchedules = template.template_data.academy_schedules;
          }
          // 템플릿이 없으면 빈 배열로 처리 (정상적인 상황일 수 있음)
        } catch (error) {
          console.error("[planGroupTransform] 템플릿 데이터 조회 실패 (academy_schedules)", {
            camp_template_id: group.camp_template_id,
            error,
          });
        }
      }

      // 템플릿 학원 일정을 Set으로 변환 (비교용)
      const templateScheduleKeys = new Set(
        templateAcademySchedules.map(
          (s) => `${s.day_of_week}-${s.start_time}-${s.end_time}`
        )
      );

      return academySchedules.map((s) => {
        const scheduleKey = `${s.day_of_week}-${s.start_time}-${s.end_time}`;
        const isTemplateSchedule = templateScheduleKeys.has(scheduleKey);
        return {
          day_of_week: s.day_of_week,
          start_time: s.start_time,
          end_time: s.end_time,
          academy_name: s.academy_name || undefined,
          subject: s.subject || undefined,
          travel_time: undefined, // TODO: travel_time 저장/로드 추가 필요
          // 캠프 플랜이고 템플릿 학원 일정인 경우 source와 is_locked 설정
          ...(isTemplateSchedule
            ? {
                source: "template" as const,
                is_locked: true,
              }
            : {}),
        };
      });
    })(),
    // 1730 Timetable 추가 필드
    study_review_cycle:
      schedulerOptions.study_days || schedulerOptions.review_days
        ? {
            study_days: schedulerOptions.study_days || 6,
            review_days: schedulerOptions.review_days || 1,
          }
        : undefined,
    student_level: schedulerOptions.student_level,
    subject_allocations: schedulerOptions.subject_allocations,
    subject_constraints: group.subject_constraints
      ? (group.subject_constraints as PartialWizardData["subject_constraints"])
      : undefined,
    additional_period_reallocation: group.additional_period_reallocation || undefined,
    non_study_time_blocks: group.non_study_time_blocks || undefined,
  };
}
</file>

<file path="planStatusUtils.ts">
/**
 * 플랜 상태 관련 유틸리티 함수
 * 
 * 재조정 기능에서 플랜 상태를 판단하는 데 사용됩니다.
 * 
 * @module lib/utils/planStatusUtils
 */

// ============================================
// 타입 정의
// ============================================

/**
 * 플랜 상태 타입
 * - pending: 대기 중 (아직 시작하지 않음)
 * - in_progress: 진행 중 (시작했지만 완료하지 않음)
 * - completed: 완료됨 (학습 완료)
 * - canceled: 취소됨
 */
export type PlanStatus = 'pending' | 'in_progress' | 'completed' | 'canceled';

/**
 * 플랜 상태가 포함된 객체 타입
 */
export interface PlanWithStatus {
  status: PlanStatus;
  is_active?: boolean;
  actual_start_time?: string | null;
  actual_end_time?: string | null;
}

// ============================================
// 상태 판단 함수
// ============================================

/**
 * 재조정 대상 여부 판단
 * 
 * 재조정 가능한 플랜:
 * - status가 'pending' 또는 'in_progress'
 * - is_active가 true (또는 undefined/null)
 * 
 * @param plan 플랜 객체
 * @returns 재조정 가능 여부
 */
export function isReschedulable(plan: PlanWithStatus): boolean {
  const { status, is_active } = plan;
  
  // 완료되거나 취소된 플랜은 재조정 불가
  if (status === 'completed' || status === 'canceled') {
    return false;
  }
  
  // 비활성화된 플랜은 재조정 불가
  if (is_active === false) {
    return false;
  }
  
  // pending 또는 in_progress 상태만 재조정 가능
  return status === 'pending' || status === 'in_progress';
}

/**
 * 완료 플랜 여부 (재조정 제외 대상)
 * 
 * @param plan 플랜 객체
 * @returns 완료 여부
 */
export function isCompletedPlan(plan: PlanWithStatus): boolean {
  return plan.status === 'completed';
}

/**
 * 롤백 가능 여부 (새 플랜이 아직 시작하지 않음)
 * 
 * 롤백 가능 조건:
 * - status가 'pending' (아직 시작하지 않음)
 * 
 * @param plan 플랜 객체
 * @returns 롤백 가능 여부
 */
export function isRollbackable(plan: PlanWithStatus): boolean {
  return plan.status === 'pending';
}

/**
 * 진행 중 플랜 여부
 * 
 * @param plan 플랜 객체
 * @returns 진행 중 여부
 */
export function isInProgressPlan(plan: PlanWithStatus): boolean {
  return plan.status === 'in_progress';
}

/**
 * 대기 중 플랜 여부
 * 
 * @param plan 플랜 객체
 * @returns 대기 중 여부
 */
export function isPendingPlan(plan: PlanWithStatus): boolean {
  return plan.status === 'pending';
}

/**
 * 취소된 플랜 여부
 * 
 * @param plan 플랜 객체
 * @returns 취소 여부
 */
export function isCanceledPlan(plan: PlanWithStatus): boolean {
  return plan.status === 'canceled';
}

// ============================================
// 상태 변환 함수
// ============================================

/**
 * actual_start_time과 actual_end_time을 기반으로 상태 추론
 * 
 * @param plan 플랜 객체
 * @returns 추론된 상태
 */
export function inferStatusFromTimes(plan: {
  actual_start_time?: string | null;
  actual_end_time?: string | null;
}): PlanStatus {
  if (plan.actual_end_time) {
    return 'completed';
  }
  if (plan.actual_start_time) {
    return 'in_progress';
  }
  return 'pending';
}

/**
 * 상태에 따른 한글 라벨 반환
 * 
 * @param status 플랜 상태
 * @returns 한글 라벨
 */
export function getStatusLabel(status: PlanStatus): string {
  const labels: Record<PlanStatus, string> = {
    pending: '대기',
    in_progress: '진행중',
    completed: '완료',
    canceled: '취소',
  };
  return labels[status] || status;
}

/**
 * 상태에 따른 색상 클래스 반환 (Tailwind CSS)
 * 
 * @param status 플랜 상태
 * @returns 색상 클래스
 */
export function getStatusColorClass(status: PlanStatus): string {
  const colors: Record<PlanStatus, string> = {
    pending: 'text-gray-600 bg-gray-100',
    in_progress: 'text-blue-600 bg-blue-100',
    completed: 'text-green-600 bg-green-100',
    canceled: 'text-red-600 bg-red-100',
  };
  return colors[status] || 'text-gray-600 bg-gray-100';
}
</file>

<file path="planUtils.ts">
/**
 * 플랜 관련 유틸리티 함수
 * @module lib/utils/planUtils
 * @see docs/refactoring/03_phase_todo_list.md [P1-4], [P1-8]
 */

import {
  DUMMY_NON_LEARNING_CONTENT_ID,
  DUMMY_SELF_STUDY_CONTENT_ID,
  DUMMY_CONTENT_IDS,
  DUMMY_CONTENT_METADATA,
  PLAN_COMPLETION_CRITERIA,
  DUMMY_CONTENT_AGGREGATION_POLICY,
  type DummyContentId,
} from "@/lib/constants/plan";

// ============================================
// 더미 콘텐츠 판별 함수
// ============================================

/**
 * 주어진 content_id가 더미 콘텐츠인지 확인
 *
 * @param contentId - 확인할 콘텐츠 ID
 * @returns 더미 콘텐츠 여부
 *
 * @example
 * ```typescript
 * if (isDummyContent(plan.content_id)) {
 *   // 더미 콘텐츠 처리
 * }
 * ```
 */
export function isDummyContent(
  contentId: string | null | undefined
): contentId is DummyContentId {
  if (!contentId) return false;
  return (DUMMY_CONTENT_IDS as readonly string[]).includes(contentId);
}

/**
 * 주어진 content_id가 비학습 항목인지 확인
 *
 * @param contentId - 확인할 콘텐츠 ID
 * @returns 비학습 항목 여부
 */
export function isNonLearningContent(
  contentId: string | null | undefined
): boolean {
  return contentId === DUMMY_NON_LEARNING_CONTENT_ID;
}

/**
 * 주어진 content_id가 자율학습 항목인지 확인
 *
 * @param contentId - 확인할 콘텐츠 ID
 * @returns 자율학습 항목 여부
 */
export function isSelfStudyContent(
  contentId: string | null | undefined
): boolean {
  return contentId === DUMMY_SELF_STUDY_CONTENT_ID;
}

/**
 * 더미 콘텐츠의 메타데이터 반환
 *
 * @param contentId - 콘텐츠 ID
 * @returns 더미 콘텐츠 메타데이터 또는 null
 */
export function getDummyContentMetadata(contentId: string | null | undefined) {
  if (!contentId || !isDummyContent(contentId)) return null;
  return DUMMY_CONTENT_METADATA[contentId];
}

// ============================================
// 플랜 완료 판별 함수
// ============================================

/**
 * 플랜 완료 판별에 필요한 최소 필드
 */
export type PlanCompletionFields = {
  actual_end_time?: string | null;
  progress?: number | null;
};

/**
 * 주어진 플랜이 완료되었는지 확인
 *
 * 완료 기준 (OR 조건):
 * 1. actual_end_time이 설정됨 (타이머 완료)
 * 2. progress >= 100 (진행률 완료)
 *
 * @param plan - 확인할 플랜 (actual_end_time, progress 필드 포함)
 * @returns 완료 여부
 *
 * @example
 * ```typescript
 * const completedPlans = plans.filter(plan => isCompletedPlan(plan));
 * const completionRate = completedPlans.length / plans.length;
 * ```
 */
export function isCompletedPlan(plan: PlanCompletionFields): boolean {
  // 기본 기준: actual_end_time 설정됨
  if (plan.actual_end_time !== null && plan.actual_end_time !== undefined) {
    return true;
  }

  // 대체 기준: progress >= 100
  if (
    plan.progress !== null &&
    plan.progress !== undefined &&
    plan.progress >= PLAN_COMPLETION_CRITERIA.MIN_PROGRESS_FOR_COMPLETION
  ) {
    return true;
  }

  return false;
}

/**
 * 학습 플랜만 필터링 (더미 콘텐츠 제외)
 *
 * @param plans - 플랜 배열
 * @returns 학습 플랜만 포함된 배열
 *
 * @example
 * ```typescript
 * const learningPlans = filterLearningPlans(allPlans);
 * ```
 */
export function filterLearningPlans<
  T extends { content_id?: string | null }
>(plans: T[]): T[] {
  return plans.filter((plan) => !isDummyContent(plan.content_id));
}

/**
 * 완료된 학습 플랜 수 계산 (더미 콘텐츠 제외)
 *
 * @param plans - 플랜 배열
 * @returns 완료된 학습 플랜 수
 */
export function countCompletedLearningPlans<
  T extends PlanCompletionFields & { content_id?: string | null }
>(plans: T[]): number {
  if (!DUMMY_CONTENT_AGGREGATION_POLICY.includeInCompletionRate) {
    // 더미 콘텐츠 제외
    return plans.filter(
      (plan) => !isDummyContent(plan.content_id) && isCompletedPlan(plan)
    ).length;
  }

  // 더미 콘텐츠 포함
  return plans.filter((plan) => isCompletedPlan(plan)).length;
}

/**
 * 학습 플랜 완료율 계산
 *
 * @param plans - 플랜 배열
 * @returns 완료율 (0-100)
 */
export function calculateCompletionRate<
  T extends PlanCompletionFields & { content_id?: string | null }
>(plans: T[]): number {
  let totalPlans: T[];
  let completedCount: number;

  if (!DUMMY_CONTENT_AGGREGATION_POLICY.includeInCompletionRate) {
    // 더미 콘텐츠 제외
    totalPlans = filterLearningPlans(plans);
    completedCount = totalPlans.filter((plan) => isCompletedPlan(plan)).length;
  } else {
    // 더미 콘텐츠 포함
    totalPlans = plans;
    completedCount = plans.filter((plan) => isCompletedPlan(plan)).length;
  }

  if (totalPlans.length === 0) return 0;
  return Math.round((completedCount / totalPlans.length) * 100);
}

// ============================================
// 상수 재내보내기 (편의성)
// ============================================

export {
  DUMMY_NON_LEARNING_CONTENT_ID,
  DUMMY_SELF_STUDY_CONTENT_ID,
  DUMMY_CONTENT_IDS,
  DUMMY_CONTENT_METADATA,
  PLAN_COMPLETION_CRITERIA,
  DUMMY_CONTENT_AGGREGATION_POLICY,
};
</file>

<file path="planVersionUtils.ts">
/**
 * 플랜 버전 관리 유틸리티 함수
 * 
 * 재조정 기능에서 플랜 버전을 관리하는 데 사용됩니다.
 * 
 * @module lib/utils/planVersionUtils
 */

import type { SupabaseClient } from '@supabase/supabase-js';

// ============================================
// 타입 정의
// ============================================

/**
 * 플랜 버전 정보
 */
export interface PlanVersionInfo {
  version_group_id: string;
  version: number;
  is_active: boolean;
}

/**
 * 플랜 버전 히스토리
 */
export interface PlanVersionHistory {
  id: string;
  version: number;
  is_active: boolean;
  created_at: string;
  plan_data: any; // 플랜 전체 데이터
}

// ============================================
// 버전 관리 함수
// ============================================

/**
 * 최신 버전 플랜 조회
 * 
 * version_group_id로 그룹화된 플랜 중 최신 버전(가장 높은 version)을 조회합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param versionGroupId 버전 그룹 ID
 * @returns 최신 버전 플랜 또는 null
 */
export async function getLatestVersionPlan(
  supabase: SupabaseClient,
  versionGroupId: string
): Promise<any | null> {
  const { data, error } = await supabase
    .from('student_plan')
    .select('*')
    .eq('version_group_id', versionGroupId)
    .order('version', { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error('[planVersionUtils] 최신 버전 조회 실패:', error);
    return null;
  }

  return data;
}

/**
 * 활성 버전 플랜 조회
 * 
 * version_group_id로 그룹화된 플랜 중 is_active = true인 플랜을 조회합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param versionGroupId 버전 그룹 ID
 * @returns 활성 버전 플랜 또는 null
 */
export async function getActiveVersionPlan(
  supabase: SupabaseClient,
  versionGroupId: string
): Promise<any | null> {
  const { data, error } = await supabase
    .from('student_plan')
    .select('*')
    .eq('version_group_id', versionGroupId)
    .eq('is_active', true)
    .maybeSingle();

  if (error) {
    console.error('[planVersionUtils] 활성 버전 조회 실패:', error);
    return null;
  }

  return data;
}

/**
 * 새 버전 생성
 * 
 * 기존 플랜을 기반으로 새 버전을 생성합니다.
 * 
 * @param originalPlan 원본 플랜
 * @param changes 변경 사항
 * @returns 새 버전 플랜 데이터
 */
export function createNewVersion(
  originalPlan: any,
  changes: Partial<any>
): any {
  // 최신 버전 번호 계산
  const newVersion = (originalPlan.version || 1) + 1;

  return {
    ...originalPlan,
    ...changes,
    id: undefined, // 새 ID 생성
    version_group_id: originalPlan.version_group_id || originalPlan.id,
    version: newVersion,
    is_active: true,
    created_at: undefined, // 새 생성 시간
    updated_at: undefined, // 새 업데이트 시간
  };
}

/**
 * 버전 히스토리 조회
 * 
 * version_group_id로 그룹화된 모든 버전을 조회합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param versionGroupId 버전 그룹 ID
 * @returns 버전 히스토리 목록
 */
export async function getVersionHistory(
  supabase: SupabaseClient,
  versionGroupId: string
): Promise<any[]> {
  const { data, error } = await supabase
    .from('student_plan')
    .select('*')
    .eq('version_group_id', versionGroupId)
    .order('version', { ascending: false });

  if (error) {
    console.error('[planVersionUtils] 버전 히스토리 조회 실패:', error);
    return [];
  }

  return data || [];
}

/**
 * 버전 그룹의 최대 버전 번호 조회
 * 
 * @param supabase Supabase 클라이언트
 * @param versionGroupId 버전 그룹 ID
 * @returns 최대 버전 번호 (없으면 0)
 */
export async function getMaxVersion(
  supabase: SupabaseClient,
  versionGroupId: string
): Promise<number> {
  const { data, error } = await supabase
    .from('student_plan')
    .select('version')
    .eq('version_group_id', versionGroupId)
    .order('version', { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error || !data) {
    return 0;
  }

  return data.version || 0;
}

/**
 * 버전 그룹 ID 초기화
 * 
 * 기존 플랜에 version_group_id가 없으면 초기화합니다.
 * 
 * @param supabase Supabase 클라이언트
 * @param planId 플랜 ID
 * @returns 초기화된 version_group_id
 */
export async function initializeVersionGroup(
  supabase: SupabaseClient,
  planId: string
): Promise<string | null> {
  // 기존 플랜 조회
  const { data: plan, error } = await supabase
    .from('student_plan')
    .select('id, version_group_id, version')
    .eq('id', planId)
    .single();

  if (error || !plan) {
    console.error('[planVersionUtils] 플랜 조회 실패:', error);
    return null;
  }

  // 이미 version_group_id가 있으면 그대로 반환
  if (plan.version_group_id) {
    return plan.version_group_id;
  }

  // version_group_id 초기화 (자기 자신의 ID 사용)
  const { error: updateError } = await supabase
    .from('student_plan')
    .update({
      version_group_id: plan.id,
      version: plan.version || 1,
    })
    .eq('id', planId);

  if (updateError) {
    console.error('[planVersionUtils] version_group_id 초기화 실패:', updateError);
    return null;
  }

  return plan.id;
}
</file>

<file path="rangeValidation.ts">
/**
 * 범위 유효성 검사 유틸리티 함수
 * ContentRangeInput과 RangeSettingModal에서 공통 사용
 */

export type ContentType = "book" | "lecture";

export type RangeValidationResult = {
  valid: boolean;
  error?: string;
  startNum?: number;
  endNum?: number;
};

/**
 * 범위 입력 유효성 검사
 * @param start 시작 범위 (문자열 또는 숫자)
 * @param end 종료 범위 (문자열 또는 숫자)
 * @param maxValue 최대값 (총 페이지수 또는 회차)
 * @param contentType 콘텐츠 타입
 * @returns 유효성 검사 결과
 */
export function validateRangeInput(
  start: string | null | undefined,
  end: string | null | undefined,
  maxValue?: number | null,
  contentType: ContentType = "book"
): RangeValidationResult {
  // 빈 값 체크
  if (!start || start.trim() === "" || !end || end.trim() === "") {
    return {
      valid: false,
      error: "시작과 종료 범위를 모두 입력해주세요.",
    };
  }

  const startNum = Number(start);
  const endNum = Number(end);

  // 숫자 유효성
  if (isNaN(startNum) || isNaN(endNum) || startNum <= 0 || endNum <= 0) {
    return {
      valid: false,
      error: "1 이상의 올바른 숫자를 입력해주세요.",
    };
  }

  // 범위 유효성
  if (startNum > endNum) {
    return {
      valid: false,
      error: "시작 범위가 종료 범위보다 클 수 없습니다.",
    };
  }

  // 최대값 검증
  if (maxValue && (startNum > maxValue || endNum > maxValue)) {
    return {
      valid: false,
      error: `범위는 최대 ${maxValue}${contentType === "book" ? "페이지" : "회차"}까지 입력할 수 있습니다.`,
    };
  }

  return {
    valid: true,
    startNum,
    endNum,
  };
}

/**
 * 범위 선택 유효성 검사 (상세 정보가 있을 때)
 * @param startDetailId 시작 상세 정보 ID
 * @param endDetailId 종료 상세 정보 ID
 * @param startIndex 시작 인덱스
 * @param endIndex 종료 인덱스
 * @returns 유효성 검사 결과
 */
export function validateRangeSelection(
  startDetailId: string | null | undefined,
  endDetailId: string | null | undefined,
  startIndex: number,
  endIndex: number
): RangeValidationResult {
  if (!startDetailId || !endDetailId) {
    return {
      valid: false,
      error: "시작과 종료 범위를 모두 선택해주세요.",
    };
  }

  if (startIndex === -1 || endIndex === -1) {
    return {
      valid: false,
      error: "선택한 범위 정보를 찾을 수 없습니다.",
    };
  }

  if (startIndex > endIndex) {
    return {
      valid: false,
      error: "시작이 종료보다 뒤에 있습니다. 범위를 다시 선택해주세요.",
    };
  }

  return {
    valid: true,
  };
}
</file>

<file path="scheduleCache.ts">
/**
 * 스케줄 계산 결과 캐싱 유틸리티
 */

import type { ScheduleAvailabilityResult } from "@/lib/scheduler/calculateAvailableDates";

/**
 * 스케줄 계산 입력 파라미터 타입
 */
export type ScheduleCalculationParams = {
  periodStart: string;
  periodEnd: string;
  blockSetId: string;
  exclusions: Array<{
    exclusion_date: string;
    exclusion_type: string;
    reason?: string;
  }>;
  academySchedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string;
    subject?: string;
    travel_time?: number;
  }>;
  schedulerType: "1730_timetable";
  schedulerOptions?: any;
  timeSettings?: any;
};

/**
 * 캐시 키 생성 함수
 */
function generateCacheKey(params: ScheduleCalculationParams): string {
  return JSON.stringify({
    periodStart: params.periodStart,
    periodEnd: params.periodEnd,
    blockSetId: params.blockSetId,
    exclusions: (params.exclusions || []).map((e) => ({
      exclusion_date: e.exclusion_date,
      exclusion_type: e.exclusion_type,
      reason: e.reason,
    })),
    academySchedules: (params.academySchedules || []).map((s) => ({
      day_of_week: s.day_of_week,
      start_time: s.start_time,
      end_time: s.end_time,
      academy_name: s.academy_name,
      subject: s.subject,
      travel_time: s.travel_time,
    })),
    schedulerType: params.schedulerType,
    schedulerOptions: params.schedulerOptions,
    timeSettings: params.timeSettings,
  });
}

/**
 * 캐시 결과 타입 (타임스탬프 포함)
 */
export type CacheResultWithTimestamp = {
  result: ScheduleAvailabilityResult;
  timestamp: number;
  isFromCache: boolean;
};

/**
 * 스케줄 계산 결과 캐시
 */
class ScheduleCache {
  private cache: Map<string, { result: ScheduleAvailabilityResult; timestamp: number }> = new Map();
  private readonly TTL = 5 * 60 * 1000; // 5분

  /**
   * 캐시에서 결과 조회
   */
  get(params: ScheduleCalculationParams): ScheduleAvailabilityResult | null {
    const key = generateCacheKey(params);
    const cached = this.cache.get(key);

    if (!cached) {
      return null;
    }

    // TTL 체크
    const now = Date.now();
    if (now - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.result;
  }

  /**
   * 캐시에서 결과 조회 (타임스탬프 포함)
   */
  getWithTimestamp(params: ScheduleCalculationParams): CacheResultWithTimestamp | null {
    const key = generateCacheKey(params);
    const cached = this.cache.get(key);

    if (!cached) {
      return null;
    }

    // TTL 체크
    const now = Date.now();
    if (now - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }

    return {
      result: cached.result,
      timestamp: cached.timestamp,
      isFromCache: true,
    };
  }

  /**
   * 캐시에 결과 저장
   */
  set(params: ScheduleCalculationParams, result: ScheduleAvailabilityResult): void {
    const key = generateCacheKey(params);
    this.cache.set(key, {
      result,
      timestamp: Date.now(),
    });

    // 캐시 크기 제한 (최대 10개)
    if (this.cache.size > 10) {
      // 가장 오래된 항목 제거
      const oldestKey = Array.from(this.cache.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp)[0][0];
      this.cache.delete(oldestKey);
    }
  }

  /**
   * 특정 파라미터의 캐시 무효화
   */
  invalidate(params: ScheduleCalculationParams): void {
    const key = generateCacheKey(params);
    this.cache.delete(key);
  }

  /**
   * 캐시 초기화
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * 만료된 항목 정리
   */
  cleanup(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.TTL) {
        this.cache.delete(key);
      }
    }
  }
}

// 싱글톤 인스턴스
export const scheduleCache = new ScheduleCache();

// 주기적으로 만료된 항목 정리 (5분마다)
if (typeof window !== "undefined") {
  setInterval(() => {
    scheduleCache.cleanup();
  }, 5 * 60 * 1000);
}
</file>

<file path="schedulerOptionsMerge.ts">
/**
 * 스케줄러 옵션 병합 유틸리티
 * time_settings 병합 시 보호 필드를 안전하게 처리합니다.
 */

import { PlanGroupError, PlanGroupErrorCodes, ErrorUserMessages } from "@/lib/errors/planGroupErrors";
import type { SchedulerOptions, TimeSettings } from "@/lib/types/plan";

/**
 * 병합 시 보호해야 할 필드 목록
 * 이 필드들은 time_settings 병합 시 덮어쓰이지 않도록 보호됩니다.
 */
const PROTECTED_FIELDS = ["template_block_set_id", "camp_template_id"];

/**
 * time_settings를 scheduler_options에 안전하게 병합합니다.
 * 보호 필드는 병합 후에도 유지됩니다.
 *
 * 보호 필드 목록: `template_block_set_id`, `camp_template_id`
 * 이 필드들은 time_settings에 포함되어 있어도 병합 후 원래 값이 유지됩니다.
 *
 * @param schedulerOptions - 기존 scheduler_options 객체
 * @param timeSettings - 병합할 time_settings 객체 (null 또는 undefined 가능)
 * @returns 병합된 scheduler_options 객체
 * @throws PlanGroupError - 입력값이 유효하지 않은 경우
 *
 * @example
 * ```typescript
 * const schedulerOptions = {
 *   study_days: 6,
 *   review_days: 1,
 *   template_block_set_id: "protected-id",
 * };
 * const timeSettings = {
 *   lunch_time: { start: "12:00", end: "13:00" },
 *   template_block_set_id: "should-not-overwrite",
 * };
 *
 * const merged = mergeTimeSettingsSafely(schedulerOptions, timeSettings);
 * // 결과: {
 * //   study_days: 6,
 * //   review_days: 1,
 * //   lunch_time: { start: "12:00", end: "13:00" },
 * //   template_block_set_id: "protected-id" // 보호 필드 유지
 * // }
 * ```
 */
export function mergeTimeSettingsSafely(
  schedulerOptions: SchedulerOptions & Partial<TimeSettings> & Record<string, unknown>,
  timeSettings: Partial<TimeSettings> | null | undefined
): SchedulerOptions & Partial<TimeSettings> & Record<string, unknown> {
  // 입력값 검증
  if (schedulerOptions === null || schedulerOptions === undefined) {
    throw new PlanGroupError(
      "schedulerOptions는 null 또는 undefined일 수 없습니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, timeSettings }
    );
  }

  if (typeof schedulerOptions !== "object" || Array.isArray(schedulerOptions)) {
    throw new PlanGroupError(
      "schedulerOptions는 객체여야 합니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, timeSettings }
    );
  }

  if (!timeSettings) {
    return schedulerOptions;
  }

  if (typeof timeSettings !== "object" || Array.isArray(timeSettings)) {
    throw new PlanGroupError(
      "timeSettings는 객체여야 합니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, timeSettings }
    );
  }

  try {
    // 보호 필드 추출 (schedulerOptions에 존재하는 경우만)
    const protectedFields = Object.fromEntries(
      PROTECTED_FIELDS
        .filter((key) => schedulerOptions[key] !== undefined)
        .map((key) => [key, schedulerOptions[key]])
    );

    // 병합 (보호 필드 제외)
    const merged = {
      ...schedulerOptions,
      ...timeSettings,
      ...protectedFields, // 보호 필드 재적용
    };

    return merged;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new PlanGroupError(
      `time_settings 병합 중 오류가 발생했습니다: ${errorMessage}`,
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, timeSettings, originalError: errorMessage }
    );
  }
}

/**
 * study_review_cycle을 scheduler_options에 병합합니다.
 *
 * study_review_cycle의 `study_days`와 `review_days` 값을 scheduler_options에 병합합니다.
 * 기존 scheduler_options의 다른 필드는 유지됩니다.
 *
 * @param schedulerOptions - 기존 scheduler_options 객체
 * @param studyReviewCycle - 병합할 study_review_cycle 객체 (null 또는 undefined 가능)
 * @returns 병합된 scheduler_options 객체
 * @throws PlanGroupError - 입력값이 유효하지 않은 경우
 *
 * @example
 * ```typescript
 * const schedulerOptions = {
 *   student_level: "high",
 *   study_days: 6, // 기존 값
 * };
 * const studyReviewCycle = {
 *   study_days: 5,
 *   review_days: 2,
 * };
 *
 * const merged = mergeStudyReviewCycle(schedulerOptions, studyReviewCycle);
 * // 결과: {
 * //   student_level: "high",
 * //   study_days: 5, // 업데이트됨
 * //   review_days: 2, // 추가됨
 * // }
 * ```
 */
export function mergeStudyReviewCycle(
  schedulerOptions: SchedulerOptions,
  studyReviewCycle: { study_days: number; review_days: number } | null | undefined
): SchedulerOptions {
  // 입력값 검증
  if (schedulerOptions === null || schedulerOptions === undefined) {
    throw new PlanGroupError(
      "schedulerOptions는 null 또는 undefined일 수 없습니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, studyReviewCycle }
    );
  }

  if (typeof schedulerOptions !== "object" || Array.isArray(schedulerOptions)) {
    throw new PlanGroupError(
      "schedulerOptions는 객체여야 합니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, studyReviewCycle }
    );
  }

  if (!studyReviewCycle) {
    return schedulerOptions;
  }

  // studyReviewCycle 검증
  if (typeof studyReviewCycle !== "object" || Array.isArray(studyReviewCycle)) {
    throw new PlanGroupError(
      "studyReviewCycle은 객체여야 합니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, studyReviewCycle }
    );
  }

  if (typeof studyReviewCycle.study_days !== "number" || typeof studyReviewCycle.review_days !== "number") {
    throw new PlanGroupError(
      "studyReviewCycle.study_days와 review_days는 숫자여야 합니다.",
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, studyReviewCycle }
    );
  }

  try {
    return {
      ...schedulerOptions,
      study_days: studyReviewCycle.study_days,
      review_days: studyReviewCycle.review_days,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new PlanGroupError(
      `study_review_cycle 병합 중 오류가 발생했습니다: ${errorMessage}`,
      PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED,
      ErrorUserMessages[PlanGroupErrorCodes.DATA_TRANSFORMATION_FAILED],
      false,
      { schedulerOptions, studyReviewCycle, originalError: errorMessage }
    );
  }
}
</file>

<file path="schedulerSettingsMerge.ts">
/**
 * 스케줄러 설정 병합 유틸리티
 * 
 * 전역(기관) → 템플릿 → 플랜그룹 순으로 설정 병합
 * 하위 레벨 설정이 상위 레벨을 오버라이드
 */

import {
  DEFAULT_SCHEDULER_SETTINGS,
  type SchedulerSettings,
  type PartialSchedulerSettings,
  type StudyReviewRatio,
} from "@/lib/types/schedulerSettings";

/**
 * 두 개의 부분 설정을 병합
 * target이 source를 오버라이드
 */
function mergePartialSettings(
  source: PartialSchedulerSettings,
  target: PartialSchedulerSettings
): PartialSchedulerSettings {
  return {
    ...source,
    ...target,
    // study_review_ratio는 개별 필드 병합
    study_review_ratio: {
      ...(source.study_review_ratio || {}),
      ...(target.study_review_ratio || {}),
    },
  };
}

/**
 * 전역 → 템플릿 → 플랜그룹 순으로 설정 병합
 * 
 * @param globalSettings 전역 설정 (tenant_scheduler_settings)
 * @param templateSettings 템플릿 설정 (camp_templates.template_data.scheduler_settings)
 * @param groupSettings 플랜그룹 설정 (plan_groups.scheduler_options)
 * @returns 병합된 최종 설정
 */
export function mergeSchedulerSettings(
  globalSettings: PartialSchedulerSettings | null,
  templateSettings: PartialSchedulerSettings | null,
  groupSettings: PartialSchedulerSettings | null
): SchedulerSettings {
  // 1. 기본값으로 시작
  let merged: PartialSchedulerSettings = { ...DEFAULT_SCHEDULER_SETTINGS };

  // 2. 전역 설정 병합
  if (globalSettings) {
    merged = mergePartialSettings(merged, globalSettings);
  }

  // 3. 템플릿 설정 병합
  if (templateSettings) {
    merged = mergePartialSettings(merged, templateSettings);
  }

  // 4. 플랜그룹 설정 병합
  if (groupSettings) {
    merged = mergePartialSettings(merged, groupSettings);
  }

  // 5. 최종 타입 보장 (study_review_ratio는 필수)
  return {
    study_review_ratio: {
      study_days:
        merged.study_review_ratio?.study_days ||
        DEFAULT_SCHEDULER_SETTINGS.study_review_ratio.study_days,
      review_days:
        merged.study_review_ratio?.review_days ||
        DEFAULT_SCHEDULER_SETTINGS.study_review_ratio.review_days,
    },
    weak_subject_focus:
      merged.weak_subject_focus ||
      DEFAULT_SCHEDULER_SETTINGS.weak_subject_focus,
    review_scope: merged.review_scope || DEFAULT_SCHEDULER_SETTINGS.review_scope,
    lunch_time: merged.lunch_time || DEFAULT_SCHEDULER_SETTINGS.lunch_time,
    study_hours: merged.study_hours || DEFAULT_SCHEDULER_SETTINGS.study_hours,
    self_study_hours: merged.self_study_hours,
  };
}

/**
 * TenantSchedulerSettings DB 레코드를 PartialSchedulerSettings로 변환
 */
export function dbToPartialSettings(
  dbSettings: {
    default_study_days: number;
    default_review_days: number;
    default_weak_subject_focus?: string;
    default_review_scope?: string;
    default_lunch_time?: { start: string; end: string };
    default_study_hours?: { start: string; end: string };
    default_self_study_hours?: { start: string; end: string };
  } | null
): PartialSchedulerSettings | null {
  if (!dbSettings) return null;

  return {
    study_review_ratio: {
      study_days: dbSettings.default_study_days,
      review_days: dbSettings.default_review_days,
    },
    weak_subject_focus: dbSettings.default_weak_subject_focus as
      | "low"
      | "medium"
      | "high"
      | undefined,
    review_scope: dbSettings.default_review_scope as "full" | "partial" | undefined,
    lunch_time: dbSettings.default_lunch_time,
    study_hours: dbSettings.default_study_hours,
    self_study_hours: dbSettings.default_self_study_hours,
  };
}

/**
 * PlanGroup scheduler_options를 PartialSchedulerSettings로 변환
 */
export function planGroupOptionsToPartialSettings(options: {
  study_days?: number;
  review_days?: number;
  weak_subject_focus?: string | boolean;
  review_scope?: string;
  lunch_time?: { start: string; end: string };
  camp_study_hours?: { start: string; end: string };
  self_study_hours?: { start: string; end: string };
} | null): PartialSchedulerSettings | null {
  if (!options) return null;

  const partial: PartialSchedulerSettings = {};

  if (options.study_days !== undefined || options.review_days !== undefined) {
    partial.study_review_ratio = {} as StudyReviewRatio;
    if (options.study_days !== undefined) {
      partial.study_review_ratio.study_days = options.study_days;
    }
    if (options.review_days !== undefined) {
      partial.study_review_ratio.review_days = options.review_days;
    }
  }

  if (options.weak_subject_focus !== undefined) {
    partial.weak_subject_focus = options.weak_subject_focus as
      | "low"
      | "medium"
      | "high"
      | boolean;
  }

  if (options.review_scope !== undefined) {
    partial.review_scope = options.review_scope as "full" | "partial";
  }

  if (options.lunch_time) {
    partial.lunch_time = options.lunch_time;
  }

  // camp_study_hours는 study_hours로 매핑
  if (options.camp_study_hours) {
    partial.study_hours = options.camp_study_hours;
  }

  if (options.self_study_hours) {
    partial.self_study_hours = options.self_study_hours;
  }

  return Object.keys(partial).length > 0 ? partial : null;
}

/**
 * SchedulerSettings를 PlanGroup scheduler_options 형식으로 변환
 */
export function settingsToPlanGroupOptions(settings: SchedulerSettings) {
  return {
    study_days: settings.study_review_ratio.study_days,
    review_days: settings.study_review_ratio.review_days,
    weak_subject_focus: settings.weak_subject_focus,
    review_scope: settings.review_scope,
    lunch_time: settings.lunch_time,
    camp_study_hours: settings.study_hours,
    self_study_hours: settings.self_study_hours,
  };
}
</file>

<file path="schoolYear.ts">
/**
 * 학년도 계산 헬퍼 함수
 * 
 * 현재 날짜를 기준으로 학년도를 계산합니다.
 * 한국의 학년도는 3월부터 시작하므로, 3월~12월은 해당 연도, 1월~2월은 전년도입니다.
 * 
 * 클라이언트와 서버 모두에서 사용 가능한 순수 함수입니다.
 * 
 * @param date - 기준 날짜 (기본값: 현재 날짜)
 * @returns 학년도 (예: 2024)
 * 
 * @example
 * ```ts
 * // 현재 날짜 기준
 * const year = calculateSchoolYear(); // 2024
 * 
 * // 특정 날짜 기준
 * const year = calculateSchoolYear(new Date('2024-03-01')); // 2024
 * const year = calculateSchoolYear(new Date('2024-02-28')); // 2023
 * ```
 */
export function calculateSchoolYear(date: Date = new Date()): number {
  const year = date.getFullYear();
  const month = date.getMonth() + 1; // 1~12

  // 3월~12월: 해당 연도, 1월~2월: 전년도
  if (month >= 3) {
    return year;
  } else {
    return year - 1;
  }
}
</file>

<file path="scroll.ts">
/**
 * 스크롤을 페이지 상단으로 이동시키는 유틸리티 함수
 */
export function scrollToTop() {
  if (typeof window !== "undefined") {
    window.scrollTo({ top: 0, left: 0, behavior: "instant" });
  }
}

/**
 * 특정 필드로 스크롤 이동
 * @param fieldId 필드 ID (data-field-id 속성 값)
 */
export function scrollToField(fieldId: string): void {
  if (typeof window === "undefined") return;

  try {
    // data-field-id 속성을 가진 요소 검색
    const fieldElement = document.querySelector(
      `[data-field-id="${fieldId}"]`
    ) as HTMLElement | null;

    if (!fieldElement) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`[scrollToField] 필드를 찾을 수 없습니다: ${fieldId}`);
      }
      return;
    }

    // 부드러운 스크롤로 요소를 뷰포트 중앙에 배치
    fieldElement.scrollIntoView({
      behavior: "smooth",
      block: "center",
    });

    // 포커스 가능한 요소는 포커스 설정 (스크롤 완료 후)
    const focusableElements = [
      "input",
      "button",
      "select",
      "textarea",
      "a",
    ];
    const tagName = fieldElement.tagName.toLowerCase();

    if (focusableElements.includes(tagName)) {
      setTimeout(() => {
        if (fieldElement.focus && typeof fieldElement.focus === "function") {
          fieldElement.focus();
        }
      }, 300);
    } else {
      // 포커스 가능한 자식 요소 찾기
      const focusableChild = fieldElement.querySelector(
        focusableElements.join(", ")
      ) as HTMLElement | null;

      if (focusableChild && focusableChild.focus) {
        setTimeout(() => {
          focusableChild.focus();
        }, 300);
      }
    }
  } catch (error) {
    if (process.env.NODE_ENV === "development") {
      console.error(`[scrollToField] 오류 발생:`, error);
    }
  }
}
</file>

<file path="spacing.ts">
/**
 * 표준 spacing 값 정의
 * Spacing-First 정책에 따라 gap을 사용한 간격 관리
 */
export const spacing = {
  section: "gap-6", // 섹션 간 간격
  card: "gap-4", // 카드 내부 간격
  form: "gap-3", // 폼 필드 간격
  page: "gap-8", // 페이지 레벨 간격
  small: "gap-2", // 작은 간격
  medium: "gap-4", // 중간 간격
  large: "gap-6", // 큰 간격
} as const;

/**
 * 반응형 spacing 값
 */
export const responsiveSpacing = {
  section: "gap-4 md:gap-6", // 섹션 간 간격 (반응형)
  card: "gap-3 md:gap-4", // 카드 내부 간격 (반응형)
  page: "gap-6 md:gap-8", // 페이지 레벨 간격 (반응형)
} as const;
</file>

<file path="studentFormUtils.ts">
/**
 * 학생 폼 관련 유틸리티 함수
 */

/**
 * 학교 타입 감지 (중학교/고등학교)
 */
export function detectSchoolType(
  school: string | null | undefined
): "중학교" | "고등학교" | "" {
  if (!school || typeof school !== "string") return "";
  if (school.includes("중") || school.includes("중학교")) return "중학교";
  if (school.includes("고") || school.includes("고등학교")) return "고등학교";
  return "";
}

/**
 * 학년을 숫자 형식으로 변환 (중3/고1 -> 숫자만)
 */
export function parseGradeNumber(
  grade: string | number | null | undefined
): string {
  if (!grade) return "";
  if (typeof grade === "number") return grade.toString();
  if (typeof grade === "string") {
    const match = grade.match(/\d+/);
    return match ? match[0] : grade;
  }
  return "";
}

/**
 * 학년을 표시 형식으로 변환 (숫자 -> 중3/고1 형식)
 */
export function formatGradeDisplay(
  grade: string | null | undefined,
  schoolType?: "중학교" | "고등학교" | ""
): string {
  if (!grade || grade.trim() === "") return "";
  
  const gradeNum = parseInt(grade, 10);
  if (isNaN(gradeNum) || gradeNum < 1 || gradeNum > 3) return grade;
  
  if (schoolType === "중학교") {
    return `중${gradeNum}학년`;
  }
  if (schoolType === "고등학교") {
    return `고${gradeNum}학년`;
  }
  return `${gradeNum}학년`;
}

/**
 * 전화번호에서 숫자만 추출
 */
export function extractPhoneDigits(phone: string): string {
  return phone.replace(/\D/g, "");
}

/**
 * 전화번호 정규화 (최종 저장 형식: 010-1234-5678)
 * - 숫자만 추출
 * - 010으로 시작하는 10~11자리만 허용
 * - 010-1234-5678 형식으로 변환
 */
export function normalizePhoneNumber(phone: string): string | null {
  if (!phone || phone.trim() === "") return null; // 빈 값은 null 반환
  
  const cleaned = extractPhoneDigits(phone);
  
  // 010으로 시작하는지 확인
  if (!cleaned.startsWith("010")) {
    return null; // 유효하지 않음
  }
  
  // 10~11자리 확인
  if (cleaned.length === 10) {
    // 010-123-4567 형식 (10자리)
    return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, "$1-$2-$3");
  }
  
  if (cleaned.length === 11) {
    // 010-1234-5678 형식 (11자리)
    return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3");
  }
  
  // 길이가 맞지 않으면 null 반환
  return null;
}

/**
 * 전화번호 실시간 포맷팅 (입력 중 포맷팅)
 * - 숫자만 추출
 * - 입력 중에도 포맷팅 적용
 * - 010으로 시작하지 않으면 원본 반환 (입력 중일 수 있음)
 */
export function formatPhoneNumber(phone: string): string {
  const cleaned = extractPhoneDigits(phone);
  
  // 010으로 시작하지 않으면 원본 반환 (입력 중일 수 있음)
  if (cleaned.length > 0 && !cleaned.startsWith("010")) {
    // 010으로 시작하지 않지만 입력 중일 수 있으므로 포맷팅만 적용
    if (cleaned.length <= 3) {
      return cleaned;
    }
    if (cleaned.length <= 7) {
      return cleaned.replace(/(\d{3})(\d+)/, "$1-$2");
    }
    if (cleaned.length <= 11) {
      return cleaned.replace(/(\d{3})(\d{4})(\d+)/, "$1-$2-$3");
    }
    return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3");
  }
  
  // 010으로 시작하는 경우
  if (cleaned.length === 0) {
    return "";
  }
  
  if (cleaned.length <= 3) {
    return cleaned;
  }
  
  if (cleaned.length <= 7) {
    return cleaned.replace(/(\d{3})(\d+)/, "$1-$2");
  }
  
  if (cleaned.length === 10) {
    // 010-123-4567 형식
    return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, "$1-$2-$3");
  }
  
  if (cleaned.length === 11) {
    // 010-1234-5678 형식
    return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3");
  }
  
  // 11자리 초과는 앞 11자리만 포맷팅
  if (cleaned.length > 11) {
    return cleaned.slice(0, 11).replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3");
  }
  
  // 그 외는 원본 반환
  return phone;
}

/**
 * 전화번호 유효성 검증
 * - 010으로 시작하는 10~11자리만 허용
 * - 빈 값은 유효 (선택사항)
 */
export function validatePhoneNumber(phone: string): { valid: boolean; error?: string } {
  if (!phone || phone.trim() === "") {
    return { valid: true }; // 선택사항이므로 빈 값은 유효
  }
  
  const cleaned = extractPhoneDigits(phone);
  
  // 010으로 시작하는지 확인
  if (!cleaned.startsWith("010")) {
    return { 
      valid: false, 
      error: "010으로 시작하는 휴대폰 번호만 입력 가능합니다" 
    };
  }
  
  // 10~11자리 확인
  if (cleaned.length < 10) {
    return { 
      valid: false, 
      error: "전화번호는 10자리 이상 입력해주세요" 
    };
  }
  
  if (cleaned.length > 11) {
    return { 
      valid: false, 
      error: "전화번호는 11자리 이하로 입력해주세요" 
    };
  }
  
  // 010으로 시작하고 10~11자리면 유효
  return { valid: true };
}

/**
 * 폼 필드별 유효성 검증
 */
export type ValidationErrors = Partial<Record<keyof {
  name: string;
  school_id: string;
  grade: string;
  birth_date: string;
  gender: string;
  phone: string;
  mother_phone: string;
  father_phone: string;
  exam_year: string;
  curriculum_revision: string;
  desired_university_ids: string;
  desired_university_1: string;
  desired_university_2: string;
  desired_university_3: string;
  desired_career_field: string;
}, string>>;

export function validateFormField(
  field: string,
  value: string
): string | null {
  switch (field) {
    case "name":
      if (!value.trim()) return "이름을 입력해주세요";
      if (value.trim().length < 2) return "이름은 2자 이상 입력해주세요";
      if (value.trim().length > 20) return "이름은 20자 이하로 입력해주세요";
      break;
    case "phone":
    case "mother_phone":
    case "father_phone":
      if (value) {
        const validation = validatePhoneNumber(value);
        if (!validation.valid) {
          return validation.error || "올바른 전화번호 형식이 아닙니다 (010-1234-5678)";
        }
      }
      break;
    case "birth_date":
      if (!value) return "생년월일을 선택해주세요";
      const birthYear = new Date(value).getFullYear();
      const currentYear = new Date().getFullYear();
      if (birthYear < 2000 || birthYear > currentYear) {
        return "올바른 생년월일을 선택해주세요";
      }
      break;
    case "grade":
      if (!value) return "학년을 입력해주세요";
      const gradeNum = parseInt(value, 10);
      if (isNaN(gradeNum) || gradeNum < 1 || gradeNum > 3) {
        return "학년은 1-3 사이의 숫자여야 합니다";
      }
      break;
  }
  return null;
}
</file>

<file path="studentPhoneUtils.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

export type StudentPhoneData = {
  id: string;
  name: string | null;
  phone: string | null;
  mother_phone: string | null;
  father_phone: string | null;
};

/**
 * 단일 학생의 전화번호 정보 조회
 * students 테이블과 student_profiles 테이블을 조인하여 조회
 */
export async function getStudentPhones(
  studentId: string
): Promise<StudentPhoneData | null> {
  const supabase = await createSupabaseServerClient();

  // 1. students 테이블에서 기본 정보 조회
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id, name")
    .eq("id", studentId)
    .maybeSingle();

  if (studentError || !student) {
    return null;
  }

  // 2. student_profiles 테이블에서 전화번호 조회
  let profile: {
    phone?: string | null;
    mother_phone?: string | null;
    father_phone?: string | null;
  } | null = null;
  try {
    const { data: profileData } = await supabase
      .from("student_profiles")
      .select("phone, mother_phone, father_phone")
      .eq("id", studentId)
      .maybeSingle();

    profile = profileData;
  } catch {
    // student_profiles 테이블이 없거나 조회 실패 시 무시
  }

  // 3. 결과 병합 (student_profiles 우선)
  return {
    id: student.id,
    name: student.name,
    phone: profile?.phone ?? null,
    mother_phone: profile?.mother_phone ?? null,
    father_phone: profile?.father_phone ?? null,
  };
}

/**
 * 여러 학생의 전화번호 정보 일괄 조회
 */
export async function getStudentPhonesBatch(
  studentIds: string[]
): Promise<StudentPhoneData[]> {
  if (studentIds.length === 0) {
    return [];
  }

  const supabase = await createSupabaseServerClient();

  // 1. students 테이블에서 기본 정보 일괄 조회
  const { data: students, error: studentsError } = await supabase
    .from("students")
    .select("id, name")
    .in("id", studentIds);

  if (studentsError || !students) {
    return [];
  }

  // 2. student_profiles 테이블에서 전화번호 일괄 조회
  let profiles: Array<{
    id: string;
    phone?: string | null;
    mother_phone?: string | null;
    father_phone?: string | null;
  }> = [];
  try {
    const { data: profilesData } = await supabase
      .from("student_profiles")
      .select("id, phone, mother_phone, father_phone")
      .in("id", studentIds);

    if (profilesData) {
      profiles = profilesData;
    }
  } catch {
    // student_profiles 테이블이 없거나 조회 실패 시 무시
  }

  // 3. 결과 병합 (student_profiles 우선)
  return students.map((student) => {
    const profile = profiles.find((p) => p.id === student.id);
    return {
      id: student.id,
      name: student.name,
      phone: profile?.phone ?? null,
      mother_phone: profile?.mother_phone ?? null,
      father_phone: profile?.father_phone ?? null,
    };
  });
}
</file>

<file path="studentProfile.ts">
/**
 * 학생 프로필 관련 유틸리티 함수
 */

/**
 * 학년 문자열에서 숫자 추출
 * 예: "중3" -> 3, "고2" -> 2
 */
function extractGradeNumber(grade: string | null | undefined): number | null {
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return null;
  }
  const match = grade.match(/\d+/);
  return match ? parseInt(match[0], 10) : null;
}

/**
 * 입시년도 자동 계산
 * @param grade 학년 (예: "중3", "고1", "고2", "고3")
 * @returns 입시년도 (예: 2025, 2026)
 */
export function calculateExamYear(grade: string | null | undefined, schoolType?: "중학교" | "고등학교"): number {
  const currentYear = new Date().getFullYear();
  
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return currentYear + 1; // 기본값: 내년
  }

  // 숫자만 있는 경우와 중3/고1 형식 모두 처리
  let gradeNumber: number | null;
  if (/^\d+$/.test(grade.trim())) {
    // 숫자만 있는 경우
    gradeNumber = parseInt(grade.trim(), 10);
  } else {
    // 중3/고1 형식인 경우
    gradeNumber = extractGradeNumber(grade);
  }
  
  // schoolType이 있으면 사용
  const isMiddleSchool = schoolType === "중학교" || grade.includes("중");

  if (!gradeNumber) {
    return currentYear + 1; // 기본값: 내년
  }

  if (isMiddleSchool || grade.includes("중")) {
    // 중3 → 고등학교 입학 후 3년 = 현재년도 + 4년
    // 중2 → 현재년도 + 5년
    // 중1 → 현재년도 + 6년
    return currentYear + (7 - gradeNumber);
  }

  // 고등학교 (기본값)
  // 고1 → 현재년도 + 3년
  // 고2 → 현재년도 + 2년
  // 고3 → 현재년도 + 1년
  return currentYear + (4 - gradeNumber);
}

/**
 * 생년월일로 입학년도 계산 (초등학교 입학 기준)
 * @param birthDate 생년월일 (YYYY-MM-DD 형식)
 * @returns 초등학교 입학년도
 */
export function calculateEntranceYear(birthDate: string | null | undefined): number {
  if (!birthDate || typeof birthDate !== "string") {
    const currentYear = new Date().getFullYear();
    return currentYear - 6; // 기본값: 현재년도 - 6년
  }
  const year = parseInt(birthDate.split("-")[0], 10);
  // 만 6세 기준으로 입학 (3월 기준)
  return year + 6;
}

/**
 * 개정교육과정 자동 계산
 * 학년 정보를 우선시하여 계산합니다. (개인 사정: 유급, 조기입학 등 반영)
 * @param grade 현재 학년 (예: "중3", "고1")
 * @param birthDate 생년월일 (YYYY-MM-DD 형식, 선택사항 - 참고용)
 * @param schoolType 학교 유형 (중학교 또는 고등학교)
 * @returns 개정교육과정 ("2009 개정", "2015 개정", "2022 개정")
 */
export function calculateCurriculumRevision(
  grade: string | null | undefined,
  birthDate?: string | null,
  schoolType?: "중학교" | "고등학교"
): "2009 개정" | "2015 개정" | "2022 개정" {
  const currentYear = new Date().getFullYear();
  
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return "2022 개정"; // 기본값
  }

  const gradeNumber = extractGradeNumber(grade);

  if (!gradeNumber) {
    return "2022 개정"; // 기본값
  }

  // 학년 정보를 우선시하여 입학년도 계산 (개인 사정 반영)
  let schoolStartYear: number;
  
  if (grade.includes("중")) {
    // 중학교 입학년도 = 현재년도 - (학년 - 1)
    // 예: 2025년 중3 → 2025 - (3 - 1) = 2023년 중1 입학
    schoolStartYear = currentYear - (gradeNumber - 1);
  } else if (grade.includes("고")) {
    // 고등학교 입학년도 = 현재년도 - (학년 - 1)
    // 예: 2025년 고2 → 2025 - (2 - 1) = 2024년 고1 입학
    schoolStartYear = currentYear - (gradeNumber - 1);
  } else {
    return "2022 개정"; // 기본값
  }

  // 생년월일이 있으면 검증 (참고용)
  if (birthDate) {
    const birthYear = parseInt(birthDate.split("-")[0], 10);
    const expectedEntranceYear = birthYear + 6; // 만 6세 입학 기준
    const expectedSchoolStartYear = grade.includes("중") 
      ? expectedEntranceYear + 6  // 초등학교 6년 후
      : expectedEntranceYear + 9; // 초등학교 6년 + 중학교 3년 후
    
    // 차이가 2년 이상이면 경고 (개인 사정 가능성)
    const diff = Math.abs(schoolStartYear - expectedSchoolStartYear);
    if (diff >= 2) {
      console.warn(
        `[calculateCurriculumRevision] 학년과 생년월일이 크게 다릅니다. ` +
        `학년 기준: ${schoolStartYear}년, 생년월일 기준: ${expectedSchoolStartYear}년 ` +
        `(차이: ${diff}년). 학년 정보를 우선 사용합니다.`
      );
    }
  }

  // 중학교 개정교육과정 판단
  if (grade.includes("중")) {
    // 2022 개정: 2025년 중1부터
    if (schoolStartYear >= 2025) return "2022 개정";
    // 2015 개정: 2018년 중1부터
    if (schoolStartYear >= 2018) return "2015 개정";
    return "2009 개정";
  }

  // 고등학교 개정교육과정 판단
  // 2022 개정: 2025년 고1부터
  if (schoolStartYear >= 2025) return "2022 개정";
  // 2015 개정: 2018년 고1부터
  if (schoolStartYear >= 2018) return "2015 개정";
  return "2009 개정";
}

/**
 * 학년 선택 옵션 (중3 ~ 고3) - 숫자 형식으로 저장
 */
export const GRADE_OPTIONS = [
  { value: "3", label: "중3", schoolType: "중학교" },
  { value: "1", label: "고1", schoolType: "고등학교" },
  { value: "2", label: "고2", schoolType: "고등학교" },
  { value: "3", label: "고3", schoolType: "고등학교" },
] as const;

/**
 * 학년을 표시 형식으로 변환 (숫자 -> 중3/고1 형식)
 */
export function formatGradeDisplay(grade: string | null | undefined, schoolType?: "중학교" | "고등학교"): string {
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return "";
  }
  
  const gradeNum = parseInt(grade, 10);
  if (isNaN(gradeNum)) {
    return grade; // 이미 형식화된 경우 그대로 반환
  }
  
  // schoolType이 있으면 사용, 없으면 grade 값으로 추론
  if (schoolType === "중학교" || grade.includes("중")) {
    return `중${gradeNum}`;
  } else if (schoolType === "고등학교" || grade.includes("고")) {
    return `고${gradeNum}`;
  }
  
  // 기본값: 고등학교로 가정
  return `고${gradeNum}`;
}

/**
 * 학년을 숫자 형식으로 변환 (중3/고1 -> 숫자만)
 */
export function parseGradeNumber(grade: string | null | undefined): string {
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return "";
  }
  
  const match = grade.match(/\d+/);
  return match ? match[0] : "";
}

/**
 * 학년 숫자만 추출 (예: "중3" -> "3", "고2" -> "2")
 */
export function extractGradeNumberOnly(grade: string | null | undefined): string {
  if (!grade || typeof grade !== "string" || grade.trim() === "") {
    return "";
  }
  const match = grade.match(/\d+/);
  return match ? match[0] : "";
}

/**
 * 성별 선택 옵션
 */
export const GENDER_OPTIONS = [
  { value: "남", label: "남" },
  { value: "여", label: "여" },
] as const;

/**
 * 개정교육과정 선택 옵션
 */
export const CURRICULUM_REVISION_OPTIONS = [
  { value: "2009 개정", label: "2009 개정" },
  { value: "2015 개정", label: "2015 개정" },
  { value: "2022 개정", label: "2022 개정" },
] as const;

/**
 * 희망 진로 계열 선택 옵션
 */
export const CAREER_FIELD_OPTIONS = [
  { value: "인문계열", label: "인문계열" },
  { value: "사회계열", label: "사회계열" },
  { value: "자연계열", label: "자연계열" },
  { value: "공학계열", label: "공학계열" },
  { value: "의약계열", label: "의약계열" },
  { value: "예체능계열", label: "예체능계열" },
  { value: "교육계열", label: "교육계열" },
  { value: "농업계열", label: "농업계열" },
  { value: "해양계열", label: "해양계열" },
  { value: "기타", label: "기타" },
] as const;
</file>

<file path="subjectAllocation.ts">
/**
 * 전략과목/취약과목 할당 관련 유틸리티 함수
 * 
 * UI와 서버 로직에서 공통으로 사용하는 함수들을 제공합니다.
 */

/**
 * 콘텐츠별 할당 타입
 */
export type ContentAllocation = {
  content_type: "book" | "lecture" | "custom";
  content_id: string;
  subject_type: "strategy" | "weakness";
  weekly_days?: number;
};

/**
 * 교과별 할당 타입
 */
export type SubjectAllocation = {
  subject_id?: string;
  subject_name: string;
  subject_type: "strategy" | "weakness";
  weekly_days?: number;
};

/**
 * 콘텐츠 정보 타입
 */
export type ContentInfo = {
  content_type: string;
  content_id: string;
  subject_category?: string | null;
  subject?: string | null;
  subject_id?: string;
};

/**
 * 할당 결과 타입
 */
export type AllocationResult = {
  subject_type: "strategy" | "weakness";
  weekly_days?: number;
  source: "content" | "subject" | "default";
};

/**
 * 문자열 정규화 (대소문자 무시, 공백 제거)
 */
function normalizeString(str: string): string {
  return str.toLowerCase().trim().replace(/\s+/g, " ");
}

/**
 * 부분 매칭 검사 (대소문자 무시, 공백 정규화)
 */
function isPartialMatch(str1: string, str2: string): boolean {
  const normalized1 = normalizeString(str1);
  const normalized2 = normalizeString(str2);
  return normalized1.includes(normalized2) || normalized2.includes(normalized1);
}

/**
 * weekly_days 값 검증
 */
function validateWeeklyDays(weeklyDays: number | undefined): boolean {
  if (weeklyDays === undefined) return true;
  return weeklyDays === 2 || weeklyDays === 3 || weeklyDays === 4;
}

/**
 * 할당 데이터 유효성 검증
 */
export function validateAllocations(
  contentAllocations?: ContentAllocation[],
  subjectAllocations?: SubjectAllocation[]
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // content_allocations 검증
  if (contentAllocations) {
    contentAllocations.forEach((alloc, index) => {
      if (!alloc.content_type || !alloc.content_id) {
        errors.push(`content_allocations[${index}]: content_type 또는 content_id가 없습니다.`);
      }
      if (alloc.subject_type !== "strategy" && alloc.subject_type !== "weakness") {
        errors.push(`content_allocations[${index}]: 잘못된 subject_type입니다: ${alloc.subject_type}`);
      }
      if (alloc.subject_type === "strategy" && !validateWeeklyDays(alloc.weekly_days)) {
        errors.push(
          `content_allocations[${index}]: 전략과목은 weekly_days가 2, 3, 4 중 하나여야 합니다. (현재: ${alloc.weekly_days})`
        );
      }
    });
  }

  // subject_allocations 검증
  if (subjectAllocations) {
    subjectAllocations.forEach((alloc, index) => {
      if (!alloc.subject_name) {
        errors.push(`subject_allocations[${index}]: subject_name이 없습니다.`);
      }
      if (alloc.subject_type !== "strategy" && alloc.subject_type !== "weakness") {
        errors.push(`subject_allocations[${index}]: 잘못된 subject_type입니다: ${alloc.subject_type}`);
      }
      if (alloc.subject_type === "strategy" && !validateWeeklyDays(alloc.weekly_days)) {
        errors.push(
          `subject_allocations[${index}]: 전략과목은 weekly_days가 2, 3, 4 중 하나여야 합니다. (현재: ${alloc.weekly_days})`
        );
      }
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * 콘텐츠의 전략/취약 설정을 가져오는 통합 함수
 * 
 * 우선순위:
 * 1. content_allocations (콘텐츠별 설정)
 * 2. subject_allocations (교과별 설정)
 *    - subject_id로 매칭 (가장 정확)
 *    - subject_name과 subject_category 정확 일치
 *    - subject_name에 subject_category가 포함되는지 확인 (부분 매칭)
 *    - subject 필드도 매칭 조건에 포함
 * 3. 기본값 (취약과목)
 * 
 * @param content - 콘텐츠 정보
 * @param contentAllocations - 콘텐츠별 설정 (선택사항)
 * @param subjectAllocations - 교과별 설정 (선택사항)
 * @param enableLogging - 상세 로깅 활성화 여부 (기본값: 개발 환경에서만)
 * @returns 전략/취약 설정 및 주당 배정 일수, 출처 정보
 */
export function getEffectiveAllocation(
  content: ContentInfo,
  contentAllocations?: ContentAllocation[],
  subjectAllocations?: SubjectAllocation[],
  enableLogging: boolean = process.env.NODE_ENV === "development"
): AllocationResult {
  const log = (message: string, data?: unknown) => {
    if (enableLogging) {
      console.log(`[getEffectiveAllocation] ${message}`, data || "");
    }
  };

  log("시작", {
    content_id: content.content_id,
    content_type: content.content_type,
    subject_category: content.subject_category,
    subject: content.subject,
    subject_id: content.subject_id,
  });

  // 1순위: 콘텐츠별 설정
  if (contentAllocations && contentAllocations.length > 0) {
    const contentAlloc = contentAllocations.find(
      (a) => a.content_type === content.content_type && a.content_id === content.content_id
    );
    if (contentAlloc) {
      log("콘텐츠별 설정 매칭 성공", {
        content_id: content.content_id,
        subject_type: contentAlloc.subject_type,
        weekly_days: contentAlloc.weekly_days,
      });
      return {
        subject_type: contentAlloc.subject_type,
        weekly_days: contentAlloc.weekly_days,
        source: "content",
      };
    }
    log("콘텐츠별 설정 매칭 실패", {
      content_id: content.content_id,
      available_content_allocations: contentAllocations.length,
    });
  }

  // 2순위: 교과별 설정 (폴백)
  if (subjectAllocations && subjectAllocations.length > 0) {
    // 2-1: subject_id로 매칭 (가장 정확)
    if (content.subject_id) {
      const subjectAlloc = subjectAllocations.find(
        (a) => a.subject_id && a.subject_id === content.subject_id
      );
      if (subjectAlloc) {
        log("교과별 설정 매칭 성공 (subject_id)", {
          subject_id: content.subject_id,
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
        });
        return {
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
          source: "subject",
        };
      }
      log("교과별 설정 매칭 실패 (subject_id)", {
        subject_id: content.subject_id,
        available_subject_allocations: subjectAllocations.length,
      });
    }

    // 2-2: subject_name과 subject_category 정확 일치
    if (content.subject_category) {
      const subjectAlloc = subjectAllocations.find(
        (a) => normalizeString(a.subject_name) === normalizeString(content.subject_category!)
      );
      if (subjectAlloc) {
        log("교과별 설정 매칭 성공 (정확 일치)", {
          subject_category: content.subject_category,
          subject_name: subjectAlloc.subject_name,
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
        });
        return {
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
          source: "subject",
        };
      }
    }

    // 2-3: subject_name에 subject_category가 포함되는지 확인 (부분 매칭)
    if (content.subject_category) {
      const subjectAlloc = subjectAllocations.find((a) =>
        isPartialMatch(a.subject_name, content.subject_category!)
      );
      if (subjectAlloc) {
        log("교과별 설정 매칭 성공 (부분 매칭 - subject_category)", {
          subject_category: content.subject_category,
          subject_name: subjectAlloc.subject_name,
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
        });
        return {
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
          source: "subject",
        };
      }
    }

    // 2-4: subject 필드도 매칭 조건에 포함
    if (content.subject) {
      const subjectAlloc = subjectAllocations.find(
        (a) =>
          normalizeString(a.subject_name) === normalizeString(content.subject!) ||
          isPartialMatch(a.subject_name, content.subject!)
      );
      if (subjectAlloc) {
        log("교과별 설정 매칭 성공 (subject 필드)", {
          subject: content.subject,
          subject_name: subjectAlloc.subject_name,
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
        });
        return {
          subject_type: subjectAlloc.subject_type,
          weekly_days: subjectAlloc.weekly_days,
          source: "subject",
        };
      }
    }

    log("교과별 설정 매칭 실패 (모든 조건)", {
      subject_category: content.subject_category,
      subject: content.subject,
      subject_id: content.subject_id,
      available_subject_allocations: subjectAllocations.map((a) => ({
        subject_id: a.subject_id,
        subject_name: a.subject_name,
      })),
    });
  }

  // 3순위: 기본값 (취약과목)
  log("기본값 사용 (취약과목)", {
    content_id: content.content_id,
  });
  return {
    subject_type: "weakness",
    weekly_days: undefined,
    source: "default",
  };
}
</file>

<file path="supabaseClientSelector.ts">
/**
 * Supabase 클라이언트 선택 유틸리티
 * RLS 우회가 필요한 작업을 위한 공통 함수 제공
 * 
 * @deprecated 이 파일의 함수들은 lib/supabase/clientSelector.ts로 이동되었습니다.
 * 새로운 코드는 lib/supabase/clientSelector.ts를 사용하세요.
 */

// 재export를 통해 기존 import 경로 유지
export {
  getSupabaseClientForRLSBypass,
  getSupabaseClientForStudentOperation,
  getClientForRLSBypass,
} from "@/lib/supabase/clientSelector";
</file>

<file path="supabaseErrorHandler.ts">
import type { PostgrestError } from "@supabase/supabase-js";

/**
 * Supabase 쿼리 에러 처리 유틸리티
 * 컬럼이 존재하지 않는 경우(42703) 자동 재시도 지원
 */
export async function handleSupabaseQuery<T>(
  queryFn: () => Promise<{ data: T | null; error: PostgrestError | null }>,
  fallback: T,
  options?: { retryOnColumnError?: boolean }
): Promise<T> {
  try {
    let { data, error } = await queryFn();

    // 컬럼이 존재하지 않는 경우 재시도
    if (error?.code === "42703" && options?.retryOnColumnError) {
      // 기본 쿼리로 재시도 (student_id 필터 제거)
      ({ data, error } = await queryFn());
    }

    if (error) {
      console.error("[Supabase Query Error]", {
        code: error.code,
        message: error.message,
        details: error.details,
        hint: error.hint,
        error,
      });
      return fallback;
    }

    return data ?? fallback;
  } catch (error) {
    console.error("[Supabase Query Exception]", error);
    return fallback;
  }
}

/**
 * Supabase 쿼리 에러 처리 (배열 반환)
 */
export async function handleSupabaseQueryArray<T>(
  queryFn: () => Promise<{ data: T[] | null; error: PostgrestError | null }>,
  fallback: T[] = [],
  options?: { retryOnColumnError?: boolean }
): Promise<T[]> {
  try {
    let { data, error } = await queryFn();

    // 컬럼이 존재하지 않는 경우 재시도
    if (error?.code === "42703" && options?.retryOnColumnError) {
      ({ data, error } = await queryFn());
    }

    if (error) {
      // 에러 객체가 비어있는 경우를 대비한 안전한 로깅
      const errorInfo = {
        code: error?.code || "UNKNOWN",
        message: error?.message || "Unknown error",
        details: error?.details || null,
        hint: error?.hint || null,
        error: error ? JSON.stringify(error, Object.getOwnPropertyNames(error)) : "Empty error object",
      };
      console.error("[Supabase Query Error]", errorInfo);
      return fallback;
    }

    return data ?? fallback;
  } catch (error) {
    console.error("[Supabase Query Exception]", {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });
    return fallback;
  }
}

/**
 * Supabase 쿼리 에러 처리 (단일 항목 반환)
 */
export async function handleSupabaseQuerySingle<T>(
  queryFn: () => Promise<{ data: T | null; error: PostgrestError | null }>,
  fallback: T | null = null,
  options?: { retryOnColumnError?: boolean }
): Promise<T | null> {
  try {
    let { data, error } = await queryFn();

    // 컬럼이 존재하지 않는 경우 재시도
    if (error?.code === "42703" && options?.retryOnColumnError) {
      ({ data, error } = await queryFn());
    }

    if (error) {
      // 에러 객체가 비어있는 경우를 대비한 안전한 로깅
      const errorInfo = {
        code: error?.code || "UNKNOWN",
        message: error?.message || "Unknown error",
        details: error?.details || null,
        hint: error?.hint || null,
        error: error || null,
      };
      console.error("[Supabase Query Error]", errorInfo);
      return fallback;
    }

    return data ?? fallback;
  } catch (error) {
    console.error("[Supabase Query Exception]", error);
    return fallback;
  }
}
</file>

<file path="themeUtils.ts">
/**
 * 테마 관련 유틸리티 클래스
 * 자주 사용되는 다크모드 클래스 조합을 제공합니다.
 * 
 * 주의: 3곳 이상에서 사용되는 패턴만 여기에 정의합니다.
 * 과도한 추상화를 지양합니다.
 */

/**
 * 카드 스타일 클래스 조합
 * 배경색과 테두리를 포함합니다.
 */
export const themeClasses = {
  /**
   * 기본 카드 스타일 (배경 + 테두리)
   * 예: bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700
   */
  card: "bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700",
  
  /**
   * 카드 배경만
   */
  cardBg: "bg-white dark:bg-gray-800",
  
  /**
   * 카드 테두리만
   */
  cardBorder: "border-gray-200 dark:border-gray-700",
  
  /**
   * 주요 텍스트 색상
   */
  textPrimary: "text-gray-900 dark:text-gray-100",
  
  /**
   * 보조 텍스트 색상
   */
  textSecondary: "text-gray-600 dark:text-gray-400",
  
  /**
   * 3차 텍스트 색상
   */
  textTertiary: "text-gray-500 dark:text-gray-500",
  
  /**
   * 네비게이션 배경
   */
  navBg: "bg-white dark:bg-gray-800",
  
  /**
   * 네비게이션 테두리
   */
  navBorder: "border-gray-200 dark:border-gray-700",
} as const;
</file>

<file path="timerUtils.ts">
/**
 * Drift-free Timer Utilities
 * 
 * 서버 시간과 클라이언트 시간의 차이를 보정하여 정확한 시간 계산을 보장합니다.
 */

/**
 * 초를 HH:MM:SS 형식으로 포맷팅
 * 
 * @param totalSeconds 총 초
 * @returns HH:MM:SS 또는 MM:SS 형식 문자열
 */
export function formatSecondsToHHMMSS(totalSeconds: number): string {
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const secs = totalSeconds % 60;

  if (hours > 0) {
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  }
  return `${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
}

export type TimerStatus = "NOT_STARTED" | "RUNNING" | "PAUSED" | "COMPLETED";

export type PlanTimerState = {
  /** 서버 기준 상태 */
  status: TimerStatus;
  /** 누적된 학습 시간 (초) */
  accumulatedSeconds: number;
  /** 마지막 시작 시각 (UTC ISO 타임스탬프, RUNNING일 때만 존재) */
  startedAt: string | null;
  /** 클라이언트에 전달할 초기 경과 시간 (초) */
  initialDuration: number;
  /** 클라이언트에 전달할 초기 실행 상태 */
  isInitiallyRunning: boolean;
};

/**
 * 서버 시간 오프셋 계산
 * 
 * @param serverNow 서버 현재 시간 (밀리초)
 * @param clientNow 클라이언트 현재 시간 (밀리초, 기본값: Date.now())
 * @returns 서버 시간 오프셋 (밀리초)
 */
export function calculateServerTimeOffset(
  serverNow: number,
  clientNow: number = Date.now()
): number {
  return serverNow - clientNow;
}

/**
 * Drift-free 시간 계산
 * 
 * @param startedAt 시작 시각 (밀리초, 서버 시간 기준)
 * @param baseAccumulated 시작 시점의 누적 시간 (초)
 * @param timeOffset 서버 시간 오프셋 (밀리초)
 * @param now 현재 시간 (밀리초, 기본값: Date.now())
 * @returns 현재 경과 시간 (초)
 */
export function calculateDriftFreeSeconds(
  startedAt: number | null,
  baseAccumulated: number,
  timeOffset: number,
  now: number = Date.now()
): number {
  if (!startedAt) {
    return baseAccumulated;
  }

  const serverNow = now + timeOffset;
  const elapsed = Math.floor((serverNow - startedAt) / 1000);
  return baseAccumulated + elapsed;
}

/**
 * 플랜의 타이머 초기 상태를 계산합니다.
 * 
 * @param plan 플랜 정보
 * @param activeSession 활성 세션 정보 (선택)
 * @param serverNow 서버 현재 시간 (밀리초)
 * @param clientNow 클라이언트 현재 시간 (밀리초, 기본값: Date.now())
 * @returns 타이머 초기 상태
 */
export function computeInitialTimerState(
  plan: {
    actual_start_time: string | null | undefined;
    actual_end_time: string | null | undefined;
    total_duration_seconds: number | null | undefined;
    paused_duration_seconds: number | null | undefined;
  },
  serverNow: number,
  activeSession?: {
    started_at: string;
    paused_at?: string | null;
    resumed_at?: string | null;
    paused_duration_seconds?: number | null;
  } | null,
  clientNow: number = Date.now()
): PlanTimerState {
  // 완료된 경우
  if (plan.actual_end_time && plan.total_duration_seconds !== null && plan.total_duration_seconds !== undefined) {
    return {
      status: "COMPLETED",
      accumulatedSeconds: plan.total_duration_seconds,
      startedAt: null,
      initialDuration: plan.total_duration_seconds,
      isInitiallyRunning: false,
    };
  }

  // 시작하지 않은 경우
  if (!plan.actual_start_time) {
    return {
      status: "NOT_STARTED",
      accumulatedSeconds: 0,
      startedAt: null,
      initialDuration: 0,
      isInitiallyRunning: false,
    };
  }

  const startMs = new Date(plan.actual_start_time).getTime();
  if (!Number.isFinite(startMs)) {
    return {
      status: "NOT_STARTED",
      accumulatedSeconds: 0,
      startedAt: null,
      initialDuration: 0,
      isInitiallyRunning: false,
    };
  }

  // 활성 세션이 있고 일시정지 중인 경우
  if (activeSession && activeSession.paused_at && !activeSession.resumed_at) {
    const pausedAtMs = new Date(activeSession.paused_at).getTime();
    if (Number.isFinite(pausedAtMs)) {
      // 일시정지 시점까지의 경과 시간 계산
      const elapsedUntilPause = Math.floor((pausedAtMs - startMs) / 1000);
      const sessionPausedDuration = activeSession.paused_duration_seconds || 0;
      const planPausedDuration = plan.paused_duration_seconds || 0;
      const accumulatedSeconds = Math.max(0, elapsedUntilPause - sessionPausedDuration - planPausedDuration);

      return {
        status: "PAUSED",
        accumulatedSeconds,
        startedAt: null, // 일시정지 중이므로 startedAt은 null
        initialDuration: accumulatedSeconds,
        isInitiallyRunning: false,
      };
    }
  }

  // 실행 중인 경우
  if (activeSession && activeSession.started_at) {
    const sessionStartMs = new Date(activeSession.started_at).getTime();
    if (Number.isFinite(sessionStartMs)) {
      // 서버 시간 기준으로 계산
      const timeOffset = calculateServerTimeOffset(serverNow, clientNow);
      const serverNowAdjusted = clientNow + timeOffset;
      const elapsed = Math.floor((serverNowAdjusted - sessionStartMs) / 1000);
      const sessionPausedDuration = activeSession.paused_duration_seconds || 0;
      const planPausedDuration = plan.paused_duration_seconds || 0;
      const accumulatedSeconds = Math.max(0, elapsed - sessionPausedDuration - planPausedDuration);

      return {
        status: "RUNNING",
        accumulatedSeconds,
        startedAt: activeSession.started_at,
        initialDuration: accumulatedSeconds,
        isInitiallyRunning: true,
      };
    }
  }

  // 활성 세션이 없지만 플랜이 시작된 경우
  const timeOffset = calculateServerTimeOffset(serverNow, clientNow);
  const serverNowAdjusted = clientNow + timeOffset;
  const elapsed = Math.floor((serverNowAdjusted - startMs) / 1000);
  const pausedDuration = plan.paused_duration_seconds || 0;
  const accumulatedSeconds = Math.max(0, elapsed - pausedDuration);

  return {
    status: "RUNNING",
    accumulatedSeconds,
    startedAt: plan.actual_start_time,
    initialDuration: accumulatedSeconds,
    isInitiallyRunning: true,
  };
}
</file>

<file path="attendance.ts">
/**
 * 출석 SMS 설정 타입 정의
 */

/**
 * 학원 기본 출석 SMS 설정
 */
export type AttendanceSMSSettings = {
  attendance_sms_check_in_enabled: boolean;
  attendance_sms_check_out_enabled: boolean;
  attendance_sms_absent_enabled: boolean;
  attendance_sms_late_enabled: boolean;
  attendance_sms_student_checkin_enabled: boolean;
  attendance_sms_recipient: 'mother' | 'father' | 'both' | 'auto';
  attendance_sms_show_failure_to_user?: boolean;
};

/**
 * 학생별 출석 알림 설정
 */
export type StudentAttendanceNotificationSettings = {
  attendance_check_in_enabled: boolean | null;
  attendance_check_out_enabled: boolean | null;
  attendance_absent_enabled: boolean | null;
  attendance_late_enabled: boolean | null;
};

/**
 * 출석 기록 수정 이력
 */
export type AttendanceRecordHistory = {
  id: string;
  attendance_record_id: string;
  tenant_id: string;
  student_id: string;
  before_data: Record<string, unknown>;
  after_data: Record<string, unknown>;
  modified_by: string;
  modified_at: string;
  reason: string;
  created_at: string;
};

/**
 * 출석 기록 수정 요청
 */
export type UpdateAttendanceRecordRequest = {
  check_in_time?: string | null;
  check_out_time?: string | null;
  check_in_method?: "manual" | "qr" | "location" | "auto" | null;
  check_out_method?: "manual" | "qr" | "location" | "auto" | null;
  status?: "present" | "absent" | "late" | "early_leave" | "excused";
  notes?: string | null;
  reason: string; // 수정 사유 (필수)
};
</file>

<file path="auth.ts">
/**
 * 인증 관련 타입 정의
 */

/**
 * 회원가입 시 선택할 수 있는 역할
 */
export type SignupRole = "student" | "parent";

/**
 * 회원가입 시 user_metadata에 저장되는 데이터 타입
 */
export interface SignupMetadata {
  display_name?: string | null;
  tenant_id?: string | null;
  signup_role?: SignupRole | null;
}

/**
 * Supabase Auth User에 metadata가 포함된 타입
 */
export interface UserWithSignupMetadata {
  id: string;
  user_metadata?: SignupMetadata | null;
}

/**
 * SignupMetadata에서 특정 필드를 안전하게 추출하는 헬퍼 타입
 */
export type ExtractMetadata<T extends keyof SignupMetadata> = SignupMetadata[T];

/**
 * 약관 동의 유형
 */
export type ConsentType = "terms" | "privacy" | "marketing";

/**
 * 약관 동의 정보
 */
export interface UserConsent {
  id: string;
  user_id: string;
  consent_type: ConsentType;
  consented: boolean;
  consented_at: string;
  ip_address?: string | null;
  user_agent?: string | null;
  created_at: string;
}

/**
 * 약관 동의 저장을 위한 데이터 타입
 */
export interface ConsentData {
  terms: boolean;
  privacy: boolean;
  marketing: boolean;
}

/**
 * 약관 동의 저장 시 메타데이터
 */
export interface ConsentMetadata {
  ip_address?: string;
  user_agent?: string;
}
</file>

<file path="content-selection.ts">
/**
 * Phase 3: 콘텐츠 선택 타입 정의
 * 
 * Step3Contents + Step4RecommendedContents 통합을 위한
 * 공통 타입 및 인터페이스 정의
 */

// ============================================================================
// 기본 타입
// ============================================================================

export type ContentType = "book" | "lecture" | "custom";

export type ExclusionType = "휴가" | "개인사정" | "휴일지정" | "기타";

// ============================================================================
// 콘텐츠 관련 타입
// ============================================================================

/**
 * 선택된 콘텐츠 (학생 + 추천)
 */
export type SelectedContent = {
  content_type: ContentType;
  content_id: string;
  start_range: number;
  end_range: number;
  start_detail_id?: string | null;
  end_detail_id?: string | null;
  title?: string;
  subject_category?: string;
  master_content_id?: string | null;
  is_auto_recommended?: boolean; // 자동 배정 여부
  recommendation_source?: "auto" | "admin" | "template" | null; // 추천 소스
};

/**
 * 콘텐츠 메타데이터
 */
export type ContentMetadata = {
  subject?: string | null;
  semester?: string | null;
  revision?: string | null;
  difficulty_level?: string | null;
  publisher?: string | null;
  platform?: string | null;
};

/**
 * 콘텐츠 상세 정보 (책)
 */
export type BookDetail = {
  id: string;
  page_number: number;
  major_unit: string | null;
  minor_unit: string | null;
};

/**
 * 콘텐츠 상세 정보 (강의)
 */
export type LectureEpisode = {
  id: string;
  episode_number: number;
  episode_title: string | null;
};

/**
 * 콘텐츠 상세 정보 (통합)
 */
export type ContentDetail = BookDetail | LectureEpisode;

/**
 * 콘텐츠 범위
 */
export type ContentRange = {
  start: string;
  end: string;
  start_detail_id?: string | null;
  end_detail_id?: string | null;
};

// ============================================================================
// 추천 콘텐츠 관련 타입
// ============================================================================

/**
 * 추천 콘텐츠
 */
export type RecommendedContent = {
  id: string;
  contentType: "book" | "lecture"; // 추천 콘텐츠는 custom 타입이 될 수 없음
  title: string;
  subject_category: string | null;
  subject: string | null;
  semester: string | null;
  revision: string | null;
  publisher?: string | null;
  platform?: string | null;
  difficulty_level: string | null;
  reason: string;
  priority: number;
  scoreDetails?: {
    schoolGrade?: number | null;
    schoolAverageGrade?: number | null;
    mockPercentile?: number | null;
    mockGrade?: number | null;
    riskScore?: number;
  };
};

/**
 * 추천 설정
 */
export type RecommendationSettings = {
  selectedSubjects: Set<string>;
  recommendationCounts: Map<string, number>;
  autoAssignContents: boolean;
};

// ============================================================================
// 상태 관리 타입
// ============================================================================

/**
 * 콘텐츠 선택 전체 상태
 */
export type ContentSelectionState = {
  // 학생 콘텐츠
  studentContents: SelectedContent[];
  
  // 추천 콘텐츠
  recommendedContents: RecommendedContent[];
  selectedRecommendedIds: Set<string>;
  
  // 공통
  totalSelected: number; // student + recommended
  maxContents: number; // 9
  
  // 필수 과목
  requiredSubjects: Set<"국어" | "수학" | "영어">;
  selectedSubjects: Map<string, number>;
  
  // UI 상태
  activeTab: "student" | "recommended";
  isLoading: boolean;
  error: string | null;
};

// ============================================================================
// 컴포넌트 Props 타입
// ============================================================================

/**
 * ContentCard Props
 */
export type ContentCardProps = {
  // 콘텐츠 정보
  content: {
    id: string;
    title: string;
    subject?: string | null;
    semester?: string | null;
    difficulty?: string | null;
    publisher?: string | null;
    platform?: string | null;
  };
  
  // 상태
  selected: boolean;
  disabled?: boolean;
  readOnly?: boolean;
  
  // 범위 정보
  range?: ContentRange;
  
  // 추천 정보 (추천 콘텐츠인 경우)
  recommended?: {
    priority: number;
    reason: string;
    scoreDetails?: RecommendedContent["scoreDetails"];
  };
  
  // 이벤트 핸들러
  onToggle?: () => void;
  onRemove?: () => void;
  onEditRange?: () => void;
};

/**
 * RangeSettingModal Props
 */
export type RangeSettingModalProps = {
  // 모달 상태
  open: boolean;
  onClose: () => void;
  
  // 콘텐츠 정보
  content: {
    id: string;
    type: "book" | "lecture"; // custom 타입은 범위 설정을 지원하지 않음
    title: string;
  };
  
  // 콘텐츠 소스 구분 (추천 = 마스터, 학생 = 학생 콘텐츠)
  isRecommendedContent?: boolean;
  
  // 현재 범위
  currentRange?: ContentRange;
  
  // 저장 핸들러
  onSave: (range: ContentRange) => void;
  
  // 상태
  loading?: boolean;
  error?: string | null;
};

/**
 * ContentRangeInput Props
 */
export type ContentRangeInputProps = {
  // 콘텐츠 타입
  type: ContentType;
  
  // 상세 정보
  details: ContentDetail[];
  
  // 현재 선택 (상세 정보가 있을 때)
  startDetailId?: string | null;
  endDetailId?: string | null;
  
  // 직접 입력 값 (상세 정보가 없을 때)
  startRange?: string | null;
  endRange?: string | null;
  
  // 총 페이지수/회차 (직접 입력 시 최대값 제한용)
  totalPages?: number | null;
  totalEpisodes?: number | null;
  
  // 변경 핸들러
  onStartChange: (detailId: string) => void;
  onEndChange: (detailId: string) => void;
  
  // 직접 입력 변경 핸들러
  onStartRangeChange?: (range: string) => void;
  onEndRangeChange?: (range: string) => void;
  
  // 상태
  loading?: boolean;
  error?: string | null;
};

/**
 * ProgressIndicator Props
 */
export type ProgressIndicatorProps = {
  // 진행 상태
  current: number;
  max: number;
  
  // 필수 과목 체크
  requiredSubjects?: {
    subject: string;
    selected: boolean;
  }[];
  
  // 경고 표시
  showWarning?: boolean;
  warningMessage?: string;
};

/**
 * ContentSelectionTabs Props
 */
export type ContentSelectionTabsProps = {
  // 활성 탭
  activeTab: "student" | "recommended";
  onTabChange: (tab: "student" | "recommended") => void;
  
  // 탭별 개수
  studentCount: number;
  recommendedCount: number;
  
  // 상태
  disabled?: boolean;
};

/**
 * StudentContentsPanel Props
 */
export type StudentContentsPanelProps = {
  // 데이터
  contents: {
    books: Array<{ id: string; title: string; subtitle?: string | null; master_content_id?: string | null }>;
    lectures: Array<{ id: string; title: string; subtitle?: string | null; master_content_id?: string | null }>;
    custom: Array<{ id: string; title: string; subtitle?: string | null }>;
  };
  
  // 선택된 콘텐츠
  selectedContents: SelectedContent[];
  
  // 제한
  maxContents: number;
  currentTotal: number; // student + recommended
  
  // 이벤트 핸들러
  onUpdate: (contents: SelectedContent[]) => void;
  
  // 상태
  editable?: boolean;
  isCampMode?: boolean;
};

/**
 * RecommendedContentsPanel Props
 */
export type RecommendedContentsPanelProps = {
  // 데이터
  recommendedContents: RecommendedContent[];
  allRecommendedContents: RecommendedContent[];
  
  // 선택된 콘텐츠
  selectedContents: SelectedContent[];
  selectedRecommendedIds: Set<string>;
  
  // 제한
  maxContents: number;
  currentTotal: number; // student + recommended
  
  // 추천 설정
  settings: RecommendationSettings;
  onSettingsChange: (settings: RecommendationSettings) => void;
  
  // 이벤트 핸들러
  onUpdate: (contents: SelectedContent[]) => void;
  onRequestRecommendations: () => Promise<void>;
  
  // 상태
  isEditMode?: boolean;
  isCampMode?: boolean;
  loading?: boolean;
  hasRequestedRecommendations?: boolean;
  hasScoreData?: boolean;
  studentId?: string;
  isAdminContinueMode?: boolean;
  editable?: boolean;
};

/**
 * Step3ContentSelection Props (메인 컴포넌트)
 */
export type Step3ContentSelectionProps = {
  // WizardData
  data: {
    student_contents: SelectedContent[];
    recommended_contents: SelectedContent[];
    schedule_summary?: any;
    subject_constraints?: {
      enable_required_subjects_validation?: boolean;
      required_subjects?: Array<{
        subject_group_id: string;
        subject_category: string;
        min_count: number;
        subjects_by_curriculum?: Array<{
          curriculum_revision_id: string;
          subject_id?: string;
          subject_name?: string;
        }>;
      }>;
      excluded_subjects?: string[];
      constraint_handling?: "strict" | "warning" | "auto_fix";
    };
  };
  onUpdate: (updates: Partial<Step3ContentSelectionProps["data"]>) => void;
  
  // 콘텐츠 목록
  contents: StudentContentsPanelProps["contents"];
  
  // 추천 관련
  isEditMode?: boolean;
  isCampMode?: boolean;
  studentId?: string;
  
  // 상태
  editable?: boolean;
};

// ============================================================================
// 유틸리티 타입
// ============================================================================

/**
 * 콘텐츠 선택 검증 결과
 */
export type ValidationResult = {
  valid: boolean;
  errors: string[];
  warnings: string[];
};

/**
 * 필수 과목 체크 결과
 */
export type RequiredSubjectsCheck = {
  국어: boolean;
  수학: boolean;
  영어: boolean;
  allRequired: boolean;
};

/**
 * 콘텐츠 중복 체크 결과
 */
export type DuplicateCheck = {
  isDuplicate: boolean;
  duplicateWith?: string; // content_id
  reason?: string;
};

// ============================================================================
// API 응답 타입
// ============================================================================

/**
 * 콘텐츠 메타데이터 API 응답
 */
export type ContentMetadataResponse = ContentMetadata;

/**
 * 콘텐츠 상세 정보 API 응답
 */
export type ContentDetailsResponse = {
  details: ContentDetail[];
  type: ContentType;
};

/**
 * 추천 콘텐츠 API 응답
 */
export type RecommendedContentsResponse = {
  contents: RecommendedContent[];
  hasScoreData: boolean;
};
</file>

<file path="guards.ts">
/**
 * 타입 가드 함수
 * 런타임 타입 검증을 위한 유틸리티
 */

/**
 * 문자열이 유효한 UUID인지 확인
 */
export function isUUID(value: unknown): value is string {
  if (typeof value !== "string") {
    return false;
  }
  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(value);
}

/**
 * 값이 null이 아닌 객체인지 확인
 */
export function isNonNullObject(
  value: unknown
): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

/**
 * 값이 문자열 배열인지 확인
 */
export function isStringArray(value: unknown): value is string[] {
  return (
    Array.isArray(value) && value.every((item) => typeof item === "string")
  );
}

/**
 * 값이 숫자 배열인지 확인
 */
export function isNumberArray(value: unknown): value is number[] {
  return (
    Array.isArray(value) && value.every((item) => typeof item === "number")
  );
}

/**
 * 값이 유효한 날짜 문자열인지 확인 (YYYY-MM-DD 형식)
 */
export function isDateString(value: unknown): value is string {
  if (typeof value !== "string") {
    return false;
  }
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(value)) {
    return false;
  }
  const date = new Date(value);
  return !isNaN(date.getTime());
}

/**
 * 값이 유효한 이메일인지 확인
 */
export function isEmail(value: unknown): value is string {
  if (typeof value !== "string") {
    return false;
  }
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(value);
}

/**
 * 값이 유효한 역할(role)인지 확인
 */
export function isRole(
  value: unknown
): value is "superadmin" | "admin" | "teacher" | "student" | "parent" {
  if (typeof value !== "string") {
    return false;
  }
  const validRoles = ["superadmin", "admin", "teacher", "student", "parent"];
  return validRoles.includes(value);
}

/**
 * 값이 유효한 플랜 상태인지 확인
 */
export function isPlanStatus(
  value: unknown
): value is "draft" | "saved" | "active" | "completed" | "archived" {
  if (typeof value !== "string") {
    return false;
  }
  const validStatuses = ["draft", "saved", "active", "completed", "archived"];
  return validStatuses.includes(value);
}

/**
 * 값이 유효한 콘텐츠 타입인지 확인
 */
export function isContentType(
  value: unknown
): value is "book" | "lecture" | "custom" {
  if (typeof value !== "string") {
    return false;
  }
  const validTypes = ["book", "lecture", "custom"];
  return validTypes.includes(value);
}
</file>

<file path="lecture.ts">
/**
 * 강의 관련 TypeScript 타입 정의
 * 
 * @description 강의 스키마 리팩토링 후 타입 정의
 * @see docs/lecture-schema-refactoring.md
 * @updated 2024-11-29
 */

// ============================================
// Master Lectures (마스터 강의)
// ============================================

/**
 * 마스터 강의 데이터
 * - 공용 카탈로그 또는 테넌트 전용 커스텀 강의
 */
export interface MasterLecture {
  // ① 공통
  id: string;
  tenant_id?: string | null;  // null: 공용 카탈로그, not null: 테넌트 전용
  is_active: boolean;

  // ② 교육과정/교과 연계
  curriculum_revision_id?: string | null;
  subject_id?: string | null;
  grade_min?: number | null;  // 1-3
  grade_max?: number | null;  // 1-3
  school_type?: 'MIDDLE' | 'HIGH' | 'OTHER' | null;

  // ③ 기본 강의 정보
  title: string;
  subtitle?: string | null;
  series_name?: string | null;
  instructor?: string | null;
  platform_id?: string | null;        // 우선 사용 (FK to platforms)
  platform_name?: string | null;      // 레거시 (기존 platform)
  linked_book_id?: string | null;

  // ④ 회차/시간/난이도
  total_episodes: number;
  total_duration?: number | null;
  difficulty_level?: string | null;
  overall_difficulty?: number | null;
  target_exam_type?: string[] | null;

  // ⑤ 설명/텍스트/태그
  description?: string | null;
  toc?: string | null;
  tags?: string[] | null;

  // ⑥ 크롤링/외부 소스 메타
  source?: string | null;
  source_product_code?: string | null;
  source_url?: string | null;
  cover_image_url?: string | null;

  // ⑦ 파일/AI 분석 결과
  video_url?: string | null;
  transcript?: string | null;
  episode_analysis?: any | null;  // jsonb

  // ⑧ 레거시 컬럼 (호환성 유지)
  revision?: string | null;
  content_category?: string | null;
  // semester?: string | null; // 제거됨 (2025-02-04)
  subject?: string | null;           // TODO: subject_id 우선 사용
  subject_category?: string | null;

  // ⑨ 공통
  notes?: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * 마스터 강의 생성 요청
 */
export interface CreateMasterLectureRequest {
  tenant_id?: string | null;
  curriculum_revision_id?: string;
  subject_id?: string;
  grade_min?: number;
  grade_max?: number;
  school_type?: 'MIDDLE' | 'HIGH' | 'OTHER';
  
  title: string;
  subtitle?: string;
  series_name?: string;
  instructor?: string;
  platform_id?: string;
  linked_book_id?: string;
  
  total_episodes: number;
  total_duration?: number;
  difficulty_level?: string;
  target_exam_type?: string[];
  
  description?: string;
  toc?: string;
  tags?: string[];
  
  source?: string;
  source_product_code?: string;
  source_url?: string;
  cover_image_url?: string;
  
  notes?: string;
}

/**
 * 마스터 강의 수정 요청
 */
export type UpdateMasterLectureRequest = Partial<CreateMasterLectureRequest>;

// ============================================
// Lecture Episodes (마스터 강의 회차)
// ============================================

/**
 * 마스터 강의 회차
 */
export interface LectureEpisode {
  id: string;
  lecture_id: string;  // FK to master_lectures
  
  episode_number: number;
  episode_title?: string | null;
  duration?: number | null;
  display_order: number;
  
  // 회차별 난이도/태그
  difficulty_level?: string | null;
  difficulty_score?: number | null;
  tags?: string[] | null;
  lecture_source_url?: string | null;
  
  created_at: string;
}

/**
 * 강의 회차 생성 요청
 */
export interface CreateLectureEpisodeRequest {
  lecture_id: string;
  episode_number: number;
  title?: string;
  duration?: number;
  display_order: number;
  difficulty_level?: string;
  difficulty_score?: number;
  tags?: string[];
}

/**
 * 강의 회차 수정 요청
 */
export type UpdateLectureEpisodeRequest = Partial<Omit<CreateLectureEpisodeRequest, 'lecture_id'>>;

// ============================================
// Lectures (강의 인스턴스)
// ============================================

/**
 * 강의 인스턴스
 * - 학생/테넌트별 강의 인스턴스
 */
export interface Lecture {
  id: string;
  tenant_id: string;
  student_id?: string | null;
  
  master_lecture_id?: string | null;  // FK to master_lectures (기존 master_content_id)
  
  // 인스턴스용 표시 정보
  title?: string | null;
  nickname?: string | null;  // 사용자 정의 별명 (예: '6평 대비 패키지')
  notes?: string | null;
  
  // 진도/상태
  total_episodes?: number | null;
  completed_episodes?: number | null;
  progress?: number | null;  // 0-100
  
  linked_book_id?: string | null;
  
  // 레거시 컬럼 (호환성 유지, 향후 제거 예정)
  platform?: string | null;           // TODO: master_lectures.platform_name 사용
  subject?: string | null;            // TODO: master_lectures.subject 사용
  subject_category?: string | null;   // TODO: master_lectures.subject_category 사용
  revision?: string | null;           // TODO: master_lectures.revision 사용
  semester?: string | null;           // TODO: master_lectures.semester 사용
  chapter_info?: any | null;          // TODO: lecture_episodes 사용
  difficulty_level?: string | null;   // TODO: master_lectures.difficulty_level 사용
  latest_version?: string | null;     // 사용 안 함
  
  created_at: string;
  updated_at: string;
}

/**
 * 강의 인스턴스 생성 요청
 */
export interface CreateLectureRequest {
  tenant_id: string;
  student_id?: string;
  master_lecture_id?: string;
  
  title?: string;
  nickname?: string;
  notes?: string;
  
  total_episodes?: number;
  linked_book_id?: string;
}

/**
 * 강의 인스턴스 수정 요청
 */
export type UpdateLectureRequest = Partial<Omit<CreateLectureRequest, 'tenant_id'>>;

/**
 * 강의 진도 업데이트 요청
 */
export interface UpdateLectureProgressRequest {
  completed_episodes: number;
  progress: number;  // 0-100
}

// ============================================
// Student Lecture Episodes (학생 회차 진도)
// ============================================

/**
 * 학생 강의 회차 진도
 */
export interface StudentLectureEpisode {
  id: string;
  lecture_id: string;  // FK to lectures
  
  master_episode_id?: string | null;  // FK to lecture_episodes
  
  episode_number: number;
  title?: string | null;
  duration?: number | null;
  display_order: number;
  
  // 진도/상태
  is_completed: boolean;
  watched_seconds: number;
  last_watched_at?: string | null;
  note?: string | null;
  
  created_at: string;
}

/**
 * 학생 회차 생성 요청
 */
export interface CreateStudentLectureEpisodeRequest {
  lecture_id: string;
  master_episode_id?: string;
  
  episode_number: number;
  title?: string;
  duration?: number;
  display_order: number;
}

/**
 * 학생 회차 진도 업데이트 요청
 */
export interface UpdateStudentEpisodeProgressRequest {
  watched_seconds: number;
  is_completed: boolean;
  last_watched_at?: string;
  note?: string;
}

// ============================================
// JOIN 타입 (관계 포함)
// ============================================

/**
 * 마스터 강의 + 관계
 */
export interface MasterLectureWithRelations extends Omit<MasterLecture, 'subject' | 'platform'> {
  // 관계형 필드 (MasterLecture의 subject, platform 문자열 필드와 충돌 방지)
  curriculum_revision?: {
    id: string;
    name: string;
  } | null;
  subject?: {
    id: string;
    name: string;
  } | null;
  platform?: {
    id: string;
    name: string;
  } | null;
  linked_book?: {
    id: string;
    title: string;
  } | null;
  episodes?: LectureEpisode[];
}

/**
 * 강의 인스턴스 + 관계
 */
export interface LectureWithRelations extends Lecture {
  master_lecture?: MasterLecture | null;
  student?: {
    id: string;
    name: string;
  } | null;
  linked_book?: {
    id: string;
    title: string;
  } | null;
  episodes?: StudentLectureEpisode[];
}

/**
 * 학생 회차 + 관계
 */
export interface StudentLectureEpisodeWithRelations extends StudentLectureEpisode {
  master_episode?: LectureEpisode | null;
}

// ============================================
// 필터/검색 타입
// ============================================

/**
 * 마스터 강의 검색 필터
 */
export interface MasterLectureFilter {
  curriculum_revision_id?: string;
  subject_id?: string;
  grade_min?: number;
  grade_max?: number;
  school_type?: 'MIDDLE' | 'HIGH' | 'OTHER';
  platform_id?: string;
  difficulty_level?: string;
  target_exam_type?: string[];
  tags?: string[];
  is_active?: boolean;
  search?: string;  // title, instructor 검색
}

/**
 * 강의 인스턴스 검색 필터
 */
export interface LectureFilter {
  tenant_id?: string;
  student_id?: string;
  master_lecture_id?: string;
  search?: string;  // title, nickname 검색
}

// ============================================
// 응답 타입
// ============================================

/**
 * 페이지네이션 메타데이터
 */
export interface PaginationMeta {
  page: number;
  per_page: number;
  total: number;
  total_pages: number;
}

/**
 * 페이지네이션된 마스터 강의 응답
 */
export interface PaginatedMasterLecturesResponse {
  data: MasterLectureWithRelations[];
  meta: PaginationMeta;
}

/**
 * 페이지네이션된 강의 인스턴스 응답
 */
export interface PaginatedLecturesResponse {
  data: LectureWithRelations[];
  meta: PaginationMeta;
}
</file>

<file path="plan-generation.ts">
/**
 * 플랜 생성 관련 타입 정의
 *
 * plans.ts의 _generatePlansFromGroup, _previewPlansFromGroup 함수에서
 * 공통으로 사용하는 타입들을 정의합니다.
 *
 * @module lib/types/plan-generation
 */

import type {
  PlanGroup,
  PlanContent,
  PlanExclusion,
  AcademySchedule,
  ContentType,
} from "./plan";

// ============================================
// 스케줄 관련 타입
// ============================================

/**
 * 일 유형 (학습일, 복습일, 제외일 등)
 */
export type DayType =
  | "학습일"
  | "복습일"
  | "지정휴일"
  | "휴가"
  | "개인일정"
  | null;

/**
 * 시간 슬롯 유형
 */
export type TimeSlotType =
  | "학습시간"
  | "점심시간"
  | "학원일정"
  | "이동시간"
  | "자율학습";

/**
 * 시간 슬롯
 */
export type TimeSlot = {
  type: TimeSlotType;
  start: string; // HH:mm
  end: string; // HH:mm
  label?: string;
};

/**
 * 사용 가능 시간 범위
 */
export type AvailableTimeRange = {
  start: string; // HH:mm
  end: string; // HH:mm
};

/**
 * 날짜별 사용 가능 시간 범위 맵
 */
export type DateAvailableTimeRangesMap = Map<string, AvailableTimeRange[]>;

/**
 * 날짜별 시간 슬롯 맵
 */
export type DateTimeSlotsMap = Map<string, TimeSlot[]>;

/**
 * 날짜별 메타데이터
 */
export type DateMetadata = {
  day_type: DayType;
  week_number: number | null;
};

/**
 * 날짜별 메타데이터 맵
 */
export type DateMetadataMap = Map<string, DateMetadata>;

/**
 * 주차별 날짜 목록 맵
 */
export type WeekDatesMap = Map<number, string[]>;

// ============================================
// 콘텐츠 관련 타입
// ============================================

/**
 * 콘텐츠 ID 매핑 (마스터 -> 학생)
 */
export type ContentIdMap = Map<string, string>;

/**
 * 콘텐츠 메타데이터
 */
export type ContentMetadata = {
  title?: string | null;
  subject?: string | null;
  subject_category?: string | null;
  category?: string | null;
};

/**
 * 콘텐츠 메타데이터 맵
 */
export type ContentMetadataMap = Map<string, ContentMetadata>;

/**
 * 콘텐츠 소요시간 정보
 */
export type ContentDurationInfo = {
  content_type: ContentType;
  content_id: string;
  total_pages?: number | null;
  duration?: number | null;
  total_page_or_time?: number | null;
};

/**
 * 콘텐츠 소요시간 맵
 */
export type ContentDurationMap = Map<string, ContentDurationInfo>;

/**
 * 콘텐츠 과목 정보
 */
export type ContentSubjectInfo = {
  subject?: string | null;
  subject_category?: string | null;
};

/**
 * 콘텐츠 과목 맵
 */
export type ContentSubjectsMap = Map<string, ContentSubjectInfo>;

// ============================================
// 플랜 생성 컨텍스트 타입
// ============================================

/**
 * 플랜 그룹 데이터 로드 결과
 */
export type LoadedPlanGroupData = {
  group: PlanGroup;
  contents: PlanContent[];
  exclusions: PlanExclusion[];
  academySchedules: AcademySchedule[];
};

/**
 * 스케줄 계산 결과
 */
export type ScheduleCalculationResult = {
  dateAvailableTimeRanges: DateAvailableTimeRangesMap;
  dateTimeSlots: DateTimeSlotsMap;
  dateMetadataMap: DateMetadataMap;
  weekDatesMap: WeekDatesMap;
};

/**
 * 콘텐츠 해석 결과
 */
export type ContentResolutionResult = {
  contentIdMap: ContentIdMap;
  contentMetadataMap: ContentMetadataMap;
  contentDurationMap: ContentDurationMap;
  contentSubjects: ContentSubjectsMap;
};

/**
 * 플랜 생성 컨텍스트
 * 플랜 생성/미리보기에서 공통으로 사용하는 모든 데이터를 포함
 */
export type PlanGenerationContext = {
  // 권한 및 인증
  userId: string;
  role: "student" | "admin" | "consultant";
  tenantId: string;
  studentId: string;

  // 플랜 그룹 데이터
  planGroupData: LoadedPlanGroupData;

  // 스케줄 정보
  scheduleResult: ScheduleCalculationResult;

  // 콘텐츠 정보
  contentResolution: ContentResolutionResult;

  // 스케줄러 옵션
  schedulerOptions: {
    study_days: number;
    review_days: number;
    weak_subject_focus?: "low" | "medium" | "high" | boolean;
    review_scope?: string;
    lunch_time?: { start: string; end: string };
    camp_study_hours?: { start: string; end: string };
    self_study_hours?: { start: string; end: string };
  };
};

// ============================================
// 플랜 페이로드 타입
// ============================================

/**
 * 생성/미리보기 플랜 공통 필드
 */
export type PlanPayloadBase = {
  plan_date: string;
  block_index: number;
  content_type: ContentType;
  content_id: string;
  planned_start_page_or_time: number;
  planned_end_page_or_time: number;
  chapter: string | null;
  start_time: string | null;
  end_time: string | null;
  day_type: DayType;
  week: number | null;
  day: number | null;
  is_partial: boolean;
  is_continued: boolean;
  plan_number: number | null;
};

/**
 * 플랜 생성용 페이로드 (DB 저장용)
 */
export type GeneratePlanPayload = PlanPayloadBase & {
  tenant_id: string;
  student_id: string;
  plan_group_id: string;
  is_reschedulable: boolean;
  content_title: string | null;
  content_subject: string | null;
  content_subject_category: string | null;
  content_category: string | null;
  sequence: number | null;
};

/**
 * 플랜 미리보기용 페이로드
 */
export type PreviewPlanPayload = PlanPayloadBase & {
  content_title: string | null;
  content_subject: string | null;
  content_subject_category: string | null;
  content_category: string | null;
};

// ============================================
// 블록 관련 타입
// ============================================

/**
 * 블록 정보
 */
export type BlockInfo = {
  id: string;
  day_of_week: number;
  block_index: number;
  start_time: string;
  end_time: string;
  duration_minutes: number;
};

// ============================================
// 유틸리티 타입
// ============================================

/**
 * 플랜 번호 매핑 (논리적 플랜 키 -> 플랜 번호)
 */
export type PlanNumberMap = Map<string, number>;

/**
 * 날짜별 사용된 블록 인덱스 맵
 */
export type UsedBlockIndicesByDateMap = Map<string, Set<number>>;
</file>

<file path="plan.ts">
// 플랜 관련 타입 정의

import type { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";

/**
 * OCR 데이터 타입
 */
type OCRData = {
  text?: string;
  confidence?: number;
  bounding_boxes?: Array<{
    x: number;
    y: number;
    width: number;
    height: number;
  }>;
};

/**
 * 페이지 분석 데이터 타입
 */
type PageAnalysis = {
  difficulty?: number;
  topics?: string[];
  keywords?: string[];
  summary?: string;
  [key: string]: unknown; // 확장 가능한 필드
};

/**
 * 에피소드 분석 데이터 타입
 */
type EpisodeAnalysis = {
  duration?: number;
  difficulty?: number;
  topics?: string[];
  summary?: string;
  [key: string]: unknown; // 확장 가능한 필드
};

/**
 * 플랜 목적
 */
export type PlanPurpose = "내신대비" | "모의고사" | "수능" | "기타";

/**
 * 플랜 유형
 */
export type PlanType = "individual" | "integrated" | "camp";

/**
 * 캠프 프로그램 유형
 */
export type CampProgramType = "윈터캠프" | "썸머캠프" | "파이널캠프" | "기타";

/**
 * 캠프 초대 상태
 */
export type CampInvitationStatus = "pending" | "accepted" | "declined";

/**
 * 캠프 템플릿
 */
export type CampTemplate = {
  id: string;
  tenant_id: string;
  name: string;
  description: string | null;
  program_type: CampProgramType;
  template_data: Partial<WizardData> | null;
  status: "draft" | "active" | "archived";
  camp_start_date: string | null; // 캠프 시작일 (date)
  camp_end_date: string | null; // 캠프 종료일 (date)
  camp_location: string | null; // 캠프 장소
  created_by: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * 캠프 초대
 */
export type CampInvitation = {
  id: string;
  tenant_id: string;
  camp_template_id: string;
  student_id: string;
  status: CampInvitationStatus;
  invited_at: string;
  accepted_at: string | null;
  declined_at: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * 스케줄러 유형
 */
export type SchedulerType = "1730_timetable";

/**
 * 플랜 상태
 */
export type PlanStatus =
  | "draft"
  | "saved"
  | "active"
  | "paused"
  | "completed"
  | "cancelled";

/**
 * 제외일 유형
 */
export type ExclusionType = "휴가" | "개인사정" | "휴일지정" | "기타";

/**
 * 콘텐츠 타입
 */
export type ContentType = "book" | "lecture" | "custom";

/**
 * 플랜 그룹 (메타데이터)
 */
/**
 * 일별 스케줄 정보 (daily_schedule JSONB에 저장되는 구조)
 */
export type DailyScheduleInfo = {
  date: string; // YYYY-MM-DD 형식
  day_type: "학습일" | "복습일" | "지정휴일" | "휴가" | "개인일정";
  study_hours: number; // 학습 가능 시간 (시간 단위)
  time_slots?: Array<{
    type: "학습시간" | "점심시간" | "학원일정" | "이동시간" | "자율학습";
    start: string; // HH:mm 형식
    end: string; // HH:mm 형식
    label?: string;
  }>;
  exclusion?: {
    exclusion_date: string;
    exclusion_type: string;
    reason?: string | null;
  } | null;
  academy_schedules?: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string;
    subject?: string;
    travel_time?: number; // 이동시간 (분 단위)
  }>;
};

export type PlanGroup = {
  id: string;
  tenant_id: string;
  student_id: string;
  name: string | null;
  plan_purpose: PlanPurpose | null;
  scheduler_type: SchedulerType | null;
  scheduler_options?: SchedulerOptions | null;
  period_start: string; // date
  period_end: string; // date
  target_date: string | null; // date (D-day)
  block_set_id: string | null;
  status: PlanStatus;
  deleted_at: string | null;
  daily_schedule?: DailyScheduleInfo[] | null; // JSONB: 일별 스케줄 정보 (Step7에서 생성)
  subject_constraints?: SubjectConstraints | null; // JSONB: 교과 제약 조건
  additional_period_reallocation?: AdditionalPeriodReallocation | null; // JSONB: 추가 기간 재배치 정보
  non_study_time_blocks?: NonStudyTimeBlock[] | null; // JSONB: 학습 시간 제외 항목
  study_hours?: StudyHours | null; // JSONB: 학습 시간 설정
  self_study_hours?: SelfStudyHours | null; // JSONB: 자율학습 시간 설정
  // 캠프 관련 필드
  plan_type?: PlanType | null;
  camp_template_id?: string | null;
  camp_invitation_id?: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * 개별 플랜 항목 (기존 구조 유지 + 1730 Timetable 확장)
 */
export type Plan = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  plan_group_id: string | null; // 플랜 그룹 참조
  origin_plan_item_id?: string | null; // 원본 논리 플랜 항목 참조 (Phase 2)
  plan_date: string;
  block_index: number;
  content_type: ContentType;
  content_id: string;
  chapter?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
  completed_amount?: number | null;
  progress?: number | null;
  start_time?: string | null; // HH:mm 형식 - 플랜 생성 시 계산된 시작 시간
  end_time?: string | null; // HH:mm 형식 - 플랜 생성 시 계산된 종료 시간
  is_reschedulable: boolean;
  // 1730 Timetable 추가 필드
  cycle_day_number?: number | null; // 주기 내 일자 번호
  date_type?: "study" | "review" | "exclusion" | null; // 날짜 유형
  time_slot_type?: "study" | "self_study" | null; // 시간대 유형
  duration_info?: DurationInfo | null; // JSONB: 소요시간 정보
  review_info?: ReviewInfo | null; // JSONB: 복습일 정보
  allocation_type?: AllocationType | null; // JSONB: 배정 방식 정보
  split_info?: SplitInfo | null; // JSONB: 분할된 플랜 정보
  reallocation_info?: ReallocationInfo | null; // JSONB: 추가 기간 재배치 정보
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * 소요시간 정보
 */
export type DurationInfo = {
  base_duration: number; // 기본 소요시간 (분)
  student_level_factor: number; // 학생 수준 보정 계수
  subject_factor: number; // 과목별 보정 계수
  difficulty_factor: number; // 난이도 보정 계수
  review_factor?: number; // 복습 보정 계수 (복습일인 경우)
  review_of_review_factor?: number; // 복습의 복습 보정 계수 (추가 기간인 경우)
  final_duration: number; // 최종 소요시간 (분)
};

/**
 * 복습일 정보
 */
export type ReviewInfo = {
  previous_study_days_range: string; // 직전 학습일 범위 (예: "2025-01-01 ~ 2025-01-06")
  previous_study_duration: number; // 직전 학습일 학습 소요시간 (분)
  review_factor: number; // 복습 보정 계수
  review_duration: number; // 복습 소요시간 (분)
};

/**
 * 배정 방식 정보
 */
export type AllocationType = {
  type: "all_study_days" | "weekly_days"; // 취약과목: 전체 학습일, 전략과목: 주당 배정 일수
  weekly_days?: number; // 전략과목인 경우 주당 배정 일수 (2, 3, 4)
};

/**
 * 분할된 플랜 정보
 */
export type SplitInfo = {
  original_plan_id: string; // 원본 플랜 ID (분할된 플랜들을 연결)
  split_order: number; // 원본 플랜 내에서의 분할 순서
  total_split_count: number; // 전체 분할 개수
  total_duration: number; // 전체 소요시간 (모든 분할된 시간대의 합)
};

/**
 * 추가 기간 재배치 정보
 */
export type ReallocationInfo = {
  is_reallocated: boolean; // 재배치된 플랜 여부
  original_plan_id?: string; // 원본 플랜 ID
  original_period_start?: string; // 원본 플랜 기간 시작일
  original_period_end?: string; // 원본 플랜 기간 종료일
  review_of_review_factor?: number; // 복습의 복습 보정 계수
};

/**
 * 플랜 그룹 콘텐츠 관계 (기존 테이블)
 */
export type PlanContent = {
  id: string;
  tenant_id: string;
  plan_group_id: string; // plan_groups 참조
  content_type: ContentType;
  content_id: string;
  master_content_id?: string | null; // 마스터 콘텐츠 ID (학생 콘텐츠가 마스터 콘텐츠와 연계된 경우)
  start_range: number;
  end_range: number;
  start_detail_id?: string | null; // 시작 범위 상세 정보 ID (book_details.id 또는 lecture_episodes.id)
  end_detail_id?: string | null; // 종료 범위 상세 정보 ID (book_details.id 또는 lecture_episodes.id)
  display_order: number;
  // 자동 추천 관련 필드
  is_auto_recommended?: boolean;
  recommendation_source?: "auto" | "admin" | "template" | null;
  recommendation_reason?: string | null;
  recommendation_metadata?: {
    scoreDetails?: {
      schoolGrade?: number | null;
      schoolAverageGrade?: number | null;
      mockPercentile?: number | null;
      mockGrade?: number | null;
      riskScore?: number;
    };
    priority?: number;
  } | null;
  recommended_at?: string | null;
  recommended_by?: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * 논리 플랜 아이템 (Phase 2 신규 테이블)
 * - 플랜그룹 내 학습 계획의 "설계" 단위
 * - student_plan은 이 테이블의 항목에서 파생된 "실행" 데이터
 * @see supabase/migrations/20251209000002_create_plan_group_items.sql
 */
export type PlanGroupItem = {
  id: string;
  tenant_id: string;
  plan_group_id: string; // plan_groups 참조
  content_type: ContentType;
  content_id: string;
  master_content_id?: string | null; // 마스터 콘텐츠 참조
  // 목표 범위
  target_start_page_or_time: number;
  target_end_page_or_time: number;
  // 분할/반복 전략
  repeat_count: number; // 몇 회차로 나눌지 (기본 1)
  split_strategy: "equal" | "custom" | "auto"; // 분할 전략
  // 플래그
  is_review: boolean; // 복습 항목 여부
  is_required: boolean; // 필수 여부
  // 순서/우선순위
  priority: number; // 높을수록 우선
  display_order: number; // 표시 순서
  // 메타데이터
  metadata?: {
    /** 사용자 지정 분할 범위 (split_strategy === 'custom'일 때) */
    custom_splits?: Array<{
      start: number;
      end: number;
    }>;
    /** 기타 확장 필드 */
    [key: string]: unknown;
  } | null;
  created_at: string;
  updated_at: string;
};

/**
 * 논리 플랜 아이템 입력
 */
export type PlanGroupItemInput = {
  content_type: ContentType;
  content_id: string;
  master_content_id?: string | null;
  target_start_page_or_time: number;
  target_end_page_or_time: number;
  repeat_count?: number;
  split_strategy?: "equal" | "custom" | "auto";
  is_review?: boolean;
  is_required?: boolean;
  priority?: number;
  display_order?: number;
  metadata?: Record<string, unknown> | null;
};

/**
 * 플랜 그룹 제외일 (학생별 전역 관리)
 */
export type PlanExclusion = {
  id: string;
  tenant_id: string;
  student_id: string; // students 참조 (플랜 그룹과 분리)
  exclusion_date: string; // date
  exclusion_type: ExclusionType;
  reason: string | null;
  created_at: string;
};

/**
 * 학원 (학생별 전역 관리)
 */
export type Academy = {
  id: string;
  tenant_id: string | null;
  student_id: string; // students 참조
  name: string; // 학원명
  travel_time: number; // 기본 이동시간 (분 단위)
  created_at: string;
  updated_at: string;
};

/**
 * 학원 일정 (학원별 요일별 시간대)
 */
export type AcademySchedule = {
  id: string;
  tenant_id: string | null;
  student_id: string; // students 참조 (플랜 그룹과 분리)
  academy_id: string; // academies 참조
  day_of_week: number; // 0-6 (일-토)
  start_time: string; // time
  end_time: string; // time
  subject: string | null; // 과목 (선택사항)
  created_at: string;
  updated_at: string;
  // 하위 호환성을 위한 필드 (deprecated)
  academy_name?: string | null;
  travel_time?: number | null;
};

/**
 * 공통 콘텐츠 필드 (교재/강의 공통)
 */
export type CommonContentFields = {
  id: string;
  tenant_id: string | null; // NULL이면 전체 기관 공통
  revision: string | null; // 개정 (2015개정 등)
  content_category: string | null; // 유형
  semester: string | null; // 학기 (고3-1 등) - 학생 콘텐츠용
  title: string;
  difficulty_level: string | null; // 난이도
  notes: string | null; // 비고/메모
  updated_at: string;
  created_at: string;
};

/**
 * 마스터 콘텐츠 공통 필드 (semester 제외)
 */
export type MasterContentFields = Omit<CommonContentFields, "semester">;

/**
 * 서비스 마스터 교재
 */
export type MasterBook = MasterContentFields & {
  // 기본 상태
  is_active: boolean; // 활성화 상태
  
  // 교육과정 관련
  curriculum_revision_id: string | null; // 교육과정 개정판 ID (FK → curriculum_revisions)
  subject_id: string | null; // 과목 ID (FK → subjects)
  subject_group_id: string | null; // 교과 그룹 ID (FK → subject_groups, denormalized)
  subject_category: string | null; // 교과 그룹명 (denormalized, same as subject_groups.name)
  subject: string | null; // 과목명 (denormalized, same as subjects.name)
  grade_min: number | null; // 최소 학년 (1-3)
  grade_max: number | null; // 최대 학년 (1-3)
  school_type: string | null; // 학교 유형 (MIDDLE, HIGH, OTHER)
  
  // 교재 메타 정보
  subtitle: string | null; // 부제목
  series_name: string | null; // 시리즈명
  author: string | null; // 저자
  publisher_id: string | null; // 출판사 ID (FK → publishers)
  publisher_name: string | null; // 출판사명 (중복 저장)
  
  // ISBN 정보
  isbn_10: string | null; // ISBN-10 코드
  isbn_13: string | null; // ISBN-13 코드 (UNIQUE)
  
  // 출판 정보
  edition: string | null; // 판차
  published_date: string | null; // 출판일 (date)
  total_pages: number | null; // 총 페이지 (선택적)
  
  // 추가 교육 메타 정보
  target_exam_type: string[] | null; // 대상 시험 유형 (배열)
  
  // 설명 및 리뷰
  description: string | null; // 교재 설명
  toc: string | null; // 목차 (Table of Contents)
  publisher_review: string | null; // 출판사 리뷰
  tags: string[] | null; // 태그 (배열)
  
  // 출처 정보
  source: string | null; // 데이터 출처
  source_product_code: string | null; // 출처 상품 코드
  source_url: string | null; // 출처 URL
  cover_image_url: string | null; // 표지 이미지 URL
  
  // AI 분석 필드 (향후 확장용)
  pdf_url: string | null;
  ocr_data: OCRData | null; // JSONB
  page_analysis: PageAnalysis | null; // JSONB
  overall_difficulty: number | null; // 0.00 ~ 10.00
};

/**
 * 서비스 마스터 강의
 */
export type MasterLecture = MasterContentFields & {
  platform_name: string | null; // 플랫폼명 (레거시, platform → platform_name 변경)
  platform_id?: string | null; // 플랫폼 ID (우선 사용, FK to platforms)
  total_episodes: number; // 총 회차 (필수)
  total_duration: number | null; // 총 강의시간 (분 단위)
  linked_book_id: string | null; // 연결된 교재 ID (선택사항)
  
  // 강의 메타 정보
  instructor_name: string | null; // 강사명 (실제 DB 컬럼명)
  instructor?: string | null; // @deprecated instructor_name 사용 권장
  grade_level: string | null; // 학년 레벨
  grade_min: number | null; // 최소 학년 (1-3)
  grade_max: number | null; // 최대 학년 (1-3)
  lecture_type: string | null; // 강의 유형
  lecture_source_url: string | null; // 강의 출처 URL
  source_url: string | null; // 출처 URL (레거시)
  
  // 레거시 필드 (기존 코드 호환성 유지)
  platform?: string | null; // @deprecated platform_name 사용 권장
  subject?: string | null; // @deprecated CommonContentFields.subject 또는 subject_id 사용
  subject_category?: string | null; // @deprecated CommonContentFields.subject_category 사용
  
  // AI 분석 필드 (향후 확장용)
  video_url?: string | null;
  transcript?: string | null;
  episode_analysis?: EpisodeAnalysis | null; // JSONB
  overall_difficulty?: number | null; // 0.00 ~ 10.00
};

/**
 * 서비스 마스터 커스텀 콘텐츠
 */
export type MasterCustomContent = MasterContentFields & {
  // 커스텀 콘텐츠 특화 필드
  content_type: string | null; // 콘텐츠 유형 ('book', 'lecture', 'worksheet', 'other')
  total_page_or_time: number | null; // 총 페이지 수 또는 시간(분)
  subject: string | null; // 과목명 (denormalized)
  subject_category: string | null; // 교과 그룹명 (denormalized)
  
  // 교육과정 관련 (선택적)
  curriculum_revision_id: string | null; // 교육과정 개정판 ID (FK → curriculum_revisions)
  subject_id: string | null; // 과목 ID (FK → subjects)
  subject_group_id: string | null; // 교과 그룹 ID (FK → subject_groups, denormalized)
};

/**
 * 콘텐츠 마스터 (서비스 제공 교재/강의) - 레거시 타입 (하위 호환성)
 * @deprecated master_books, master_lectures로 분리됨. MasterBook 또는 MasterLecture 사용 권장
 */
export type ContentMaster = {
  id: string;
  tenant_id: string | null; // NULL이면 전체 공통
  content_type: "book" | "lecture";
  revision: string | null; // 개정
  content_category: string | null; // 유형
  // semester: string | null; // 학기 - 제거됨 (2025-02-04)
  subject_category: string | null; // 교과
  subject: string | null; // 과목
  title: string;
  publisher_or_academy: string | null;
  total_pages: number | null; // 교재
  total_episodes: number | null; // 강의
  difficulty_level: string | null;
  notes: string | null;
  updated_at: string;
  created_at: string;
};

/**
 * 교재 세부 정보 (대단원, 중단원, 페이지)
 */
export type BookDetail = {
  id: string;
  book_id: string; // master_books.id 참조
  major_unit: string | null; // 대단원
  minor_unit: string | null; // 중단원
  page_number: number;
  display_order: number;
  created_at: string;
};

/**
 * 강의 episode 정보
 */
export type LectureEpisode = {
  id: string;
  lecture_id: string; // master_lectures.id 참조
  episode_number: number; // 회차 번호
  episode_title: string | null; // 회차 제목 (실제 DB 컬럼명)
  title?: string | null; // 회차 제목 (호환성)
  duration: number | null; // 회차 시간 (초 단위)
  display_order: number;
  created_at: string;
  difficulty_level?: string | null;
  difficulty_score?: number | null;
  tags?: string[] | null;
  lecture_source_url?: string | null;
};

/**
 * 콘텐츠 마스터 세부 정보 (교재) - 레거시 타입 (하위 호환성)
 * @deprecated book_details로 변경됨. BookDetail 사용 권장
 */
export type ContentMasterDetail = {
  id: string;
  master_id: string;
  major_unit: string | null; // 대단원
  minor_unit: string | null; // 중단원
  page_number: number;
  display_order: number;
  created_at: string;
};

/**
 * 학습일/복습일 주기 설정
 */
export type StudyReviewCycle = {
  study_days: number; // 학습일 수 (기본값: 6)
  review_days: number; // 복습일 수 (기본값: 1)
};

/**
 * 학습 시간 설정
 */
export type StudyHours = {
  start_time: string; // HH:mm
  end_time: string; // HH:mm
};

/**
 * 자율학습 시간 설정
 */
export type SelfStudyHours = {
  enabled: boolean; // 자율학습 시간 사용 여부
  start_time: string; // HH:mm
  end_time: string; // HH:mm
  allow_on_holiday?: boolean; // 지정휴일에 자율학습 시간 배정 여부
};

/**
 * 교과 제약 조건
 */
export type RequiredSubject = {
  subject_category: string; // 교과 (예: 국어, 수학, 영어)
  subject?: string; // 세부 과목 (선택사항, 예: 화법과 작문, 미적분)
  min_count: number; // 최소 개수 (기본값: 1)
  subjects_by_curriculum?: Array<{
    curriculum_revision_id: string;
    subject_id: string;
    subject_name?: string;
  }>; // 개정교육과정별 세부 과목
};

export type SubjectConstraints = {
  required_subjects?: RequiredSubject[]; // 필수 교과/과목 목록 (위계 구조 + 개수)
  excluded_subjects?: string[]; // 제외 교과 목록
  constraint_handling: "strict" | "warning" | "auto_fix"; // 제약 조건 처리 방법
};

/**
 * 추가 기간 재배치 설정
 */
export type AdditionalPeriodReallocation = {
  period_start: string; // YYYY-MM-DD
  period_end: string; // YYYY-MM-DD
  type: "additional_review"; // 추가 복습
  original_period_start: string; // 원본 플랜 기간 시작일
  original_period_end: string; // 원본 플랜 기간 종료일
  subjects?: string[]; // 재배치할 과목 목록 (없으면 전체)
  review_of_review_factor?: number; // 복습의 복습 보정 계수 (기본값: 0.25)
};

/**
 * 학습 시간 제외 항목
 */
export type NonStudyTimeBlock = {
  type: "아침식사" | "점심식사" | "저녁식사" | "수면" | "기타";
  start_time: string; // HH:mm
  end_time: string; // HH:mm
  day_of_week?: number[]; // 요일 적용 범위 (0-6, 없으면 매일)
  description?: string; // 설명
};

/**
 * 스케줄러 옵션
 */
export type SchedulerOptions = {
  weak_subject_focus?: "low" | "medium" | "high" | boolean;
  study_days?: number; // 학습일 수 (기본값: 6)
  review_days?: number; // 복습일 수 (기본값: 1)
  student_level?: "high" | "medium" | "low";
  subject_allocations?: Array<{
    subject_id: string;
    subject_name: string;
    subject_type: "strategy" | "weakness";
    weekly_days?: number;
  }>;
  content_allocations?: Array<{
    content_type: "book" | "lecture";
    content_id: string;
    subject_type: "strategy" | "weakness";
    weekly_days?: number;
  }>;
};

/**
 * 시간 설정
 */
export type TimeSettings = {
  lunch_time?: { start: string; end: string };
  camp_study_hours?: { start: string; end: string };
  camp_self_study_hours?: { start: string; end: string };
  designated_holiday_hours?: { start: string; end: string };
  use_self_study_with_blocks?: boolean;
  // 자율학습 시간 배정 토글
  enable_self_study_for_holidays?: boolean; // 지정휴일 자율학습 시간 배정
  enable_self_study_for_study_days?: boolean; // 학습일/복습일 자율학습 시간 배정
};

/**
 * 학생 수준
 */
export type StudentLevel = "high" | "medium" | "low";

/**
 * 전략과목/취약과목 정보
 */
export type SubjectAllocation = {
  subject_id: string;
  subject_name: string;
  subject_type: "strategy" | "weakness";
  weekly_days?: number; // 전략과목인 경우: 2, 3, 4
};

/**
 * 플랜 그룹 생성 데이터
 */
export type PlanGroupCreationData = {
  name?: string | null;
  plan_purpose: PlanPurpose;
  scheduler_type: SchedulerType;
  scheduler_options?: SchedulerOptions | null;
  time_settings?: TimeSettings; // time_settings는 scheduler_options에 병합되어 저장됨
  period_start: string; // date
  period_end: string; // date
  target_date?: string | null; // date
  block_set_id?: string | null;
  contents: PlanContentInput[];
  exclusions: PlanExclusionInput[];
  academy_schedules: AcademyScheduleInput[];
  // 1730 Timetable 추가 필드
  study_review_cycle?: StudyReviewCycle; // 학습일/복습일 주기 설정
  student_level?: StudentLevel; // 학생 수준 정보 (필수)
  subject_allocations?: SubjectAllocation[]; // 전략과목/취약과목 정보 (필수)
  subject_constraints?: SubjectConstraints; // 교과 제약 조건
  additional_period_reallocation?: AdditionalPeriodReallocation; // 추가 기간 재배치 설정
  non_study_time_blocks?: NonStudyTimeBlock[]; // 학습 시간 제외 항목
  daily_schedule?: DailyScheduleInfo[] | null; // JSONB: 일별 스케줄 정보 (Step 2.5에서 생성)
  // 캠프 관련 필드
  plan_type?: PlanType;
  camp_template_id?: string | null;
  camp_invitation_id?: string | null;
};

/**
 * 플랜 콘텐츠 입력
 */
export type PlanContentInput = {
  content_type: ContentType;
  content_id: string;
  master_content_id?: string | null; // 마스터 콘텐츠 ID (학생 콘텐츠가 마스터 콘텐츠와 연계된 경우)
  start_range: number;
  end_range: number;
  start_detail_id?: string | null; // 시작 범위 상세 정보 ID (book_details.id 또는 lecture_episodes.id)
  end_detail_id?: string | null; // 종료 범위 상세 정보 ID (book_details.id 또는 lecture_episodes.id)
  display_order?: number;
};

/**
 * 플랜 제외일 입력
 */
export type PlanExclusionInput = {
  exclusion_date: string; // date
  exclusion_type: ExclusionType;
  reason?: string | null;
};

/**
 * 템플릿 잠금 필드 설정
 * 템플릿 모드에서 특정 필드를 고정하거나 학생 입력을 제한하는 설정
 */
export type TemplateLockedFields = {
  // Step 1 고정 필드
  step1?: {
    name?: boolean;
    plan_purpose?: boolean;
    scheduler_type?: boolean;
    period_start?: boolean;
    period_end?: boolean;
    block_set_id?: boolean;
    student_level?: boolean;
    subject_allocations?: boolean;
    study_review_cycle?: boolean;
    // 학생 입력 허용 필드
    allow_student_name?: boolean;
    allow_student_plan_purpose?: boolean;
    allow_student_scheduler_type?: boolean;
    allow_student_period?: boolean; // period_start, period_end 통합
    allow_student_block_set_id?: boolean;
    allow_student_student_level?: boolean;
    allow_student_subject_allocations?: boolean;
    allow_student_study_review_cycle?: boolean;
    allow_student_additional_period_reallocation?: boolean;
  };
  // Step 2 고정 필드
  step2?: {
    exclusions?: boolean; // 전체 제외일 고정
    exclusion_items?: string[]; // 특정 제외일 ID 배열 (exclusion_date 기준)
    academy_schedules?: boolean; // 전체 학원 일정 고정
    academy_schedule_items?: string[]; // 특정 학원 일정 ID 배열
    time_settings?: boolean; // 전체 시간 설정 고정
    time_settings_fields?: string[]; // 특정 시간 설정 필드 배열
    // 신규 필드
    non_study_time_blocks?: boolean; // 학습 시간 제외 항목 사용/미사용
    allow_student_exclusions?: boolean; // 학생이 제외일 입력 가능 여부
    allow_student_academy_schedules?: boolean; // 학생이 학원 일정 입력 가능 여부
    allow_student_time_settings?: boolean; // 학생이 시간 설정 입력 가능 여부
    allow_student_non_study_time_blocks?: boolean; // 학생이 학습 시간 제외 항목 입력 가능 여부
  };
  // Step 3 고정 필드
  step3?: {
    student_contents?: boolean; // 전체 학생 콘텐츠 고정
    student_content_items?: string[]; // 특정 콘텐츠 ID 배열 (content_id 기준)
  };
};

/**
 * 학원 입력
 */
export type AcademyInput = {
  name: string; // 학원명
  travel_time?: number; // 기본 이동시간 (분 단위, 기본값: 60)
};

/**
 * 학원 일정 입력 (학원별 요일별 시간대)
 */
export type AcademyScheduleInput = {
  academy_id?: string; // 기존 학원 ID (수정 시)
  academy_name?: string; // 새 학원명 (생성 시, 하위 호환성)
  day_of_week: number;
  start_time: string; // time
  end_time: string; // time
  subject?: string | null; // 과목 (선택사항)
  travel_time?: number; // 이동시간 (하위 호환성, academy의 travel_time 사용)
};

/**
 * 플랜 상태 전이 규칙
 */
export type PlanStatusTransition = {
  from: PlanStatus;
  to: PlanStatus;
  allowed: boolean;
  condition?: string; // 전이 조건 설명
};

/**
 * 플랜 필터
 */
export type PlanFilters = {
  studentId: string;
  tenantId?: string | null;
  status?: PlanStatus | PlanStatus[];
  planPurpose?: PlanPurpose;
  dateRange?: {
    start: string;
    end: string;
  };
  planDate?: string;
  contentType?: ContentType;
  includeDeleted?: boolean;
};
</file>

<file path="schedulerSettings.ts">
/**
 * 스케줄러 설정 타입 정의
 * 
 * 전역(기관) → 템플릿 → 플랜그룹 순으로 설정 상속
 */

export type SchedulerSettingsLevel = "global" | "template" | "group";

export type WeakSubjectFocus = "low" | "medium" | "high";
export type ReviewScope = "full" | "partial";

export type StudyReviewRatio = {
  study_days: number; // 1-7
  review_days: number; // 0-7
};

export type TimeRange = {
  start: string; // HH:mm format
  end: string; // HH:mm format
};

/**
 * 스케줄러 설정 (모든 레벨에서 공통)
 */
export type SchedulerSettings = {
  // 학습일/복습일 비율
  study_review_ratio: StudyReviewRatio;

  // 취약과목 집중 모드
  weak_subject_focus?: WeakSubjectFocus | boolean;

  // 복습 범위
  review_scope?: ReviewScope;

  // 시간 설정
  lunch_time?: TimeRange;
  study_hours?: TimeRange;
  self_study_hours?: TimeRange;
};

/**
 * 부분 스케줄러 설정 (오버라이드용)
 */
export type PartialSchedulerSettings = Partial<{
  study_review_ratio: Partial<StudyReviewRatio>;
  weak_subject_focus: WeakSubjectFocus | boolean;
  review_scope: ReviewScope;
  lunch_time: TimeRange;
  study_hours: TimeRange;
  self_study_hours: TimeRange;
}>;

/**
 * 상속 정보를 포함한 스케줄러 설정
 */
export type SchedulerSettingsWithInheritance = {
  settings: SchedulerSettings;
  level: SchedulerSettingsLevel;
  inherited_from?: string; // 상위 레벨 ID (tenant_id 또는 template_id)
};

/**
 * 데이터베이스 스키마 타입
 */
export type TenantSchedulerSettings = {
  id: string;
  tenant_id: string;
  default_study_days: number;
  default_review_days: number;
  default_weak_subject_focus: WeakSubjectFocus;
  default_review_scope: ReviewScope;
  default_lunch_time: TimeRange;
  default_study_hours: TimeRange;
  default_self_study_hours?: TimeRange;
  created_at: string;
  updated_at: string;
};

/**
 * 템플릿 스케줄러 설정 (template_data.scheduler_settings)
 */
export type TemplateSchedulerSettings = PartialSchedulerSettings & {
  inherit_from_global?: boolean; // true면 전역 설정 상속
};

/**
 * 플랜 그룹 스케줄러 옵션 (기존 scheduler_options 확장)
 */
export type PlanGroupSchedulerOptions = {
  study_days?: number;
  review_days?: number;
  weak_subject_focus?: WeakSubjectFocus | boolean;
  review_scope?: ReviewScope;
  
  // 기존 옵션 유지
  lunch_time?: TimeRange;
  camp_study_hours?: TimeRange;
  self_study_hours?: TimeRange;
  
  // 상속 플래그
  inherit_from_template?: boolean;
  inherit_from_global?: boolean;
};

/**
 * 기본 스케줄러 설정값
 */
export const DEFAULT_SCHEDULER_SETTINGS: SchedulerSettings = {
  study_review_ratio: {
    study_days: 6,
    review_days: 1,
  },
  weak_subject_focus: "medium",
  review_scope: "full",
  lunch_time: {
    start: "12:00",
    end: "13:00",
  },
  study_hours: {
    start: "09:00",
    end: "18:00",
  },
};

/**
 * 스케줄러 설정 유효성 검증
 */
export function validateSchedulerSettings(
  settings: Partial<SchedulerSettings>
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (settings.study_review_ratio) {
    const { study_days, review_days } = settings.study_review_ratio;
    
    if (study_days < 1 || study_days > 7) {
      errors.push("학습일은 1-7일 사이여야 합니다.");
    }
    
    if (review_days < 0 || review_days > 7) {
      errors.push("복습일은 0-7일 사이여야 합니다.");
    }
    
    if (study_days + review_days > 7) {
      errors.push("학습일 + 복습일은 7일을 초과할 수 없습니다.");
    }
  }

  if (settings.weak_subject_focus && typeof settings.weak_subject_focus === "string") {
    if (!["low", "medium", "high"].includes(settings.weak_subject_focus)) {
      errors.push("취약과목 집중 모드는 low, medium, high 중 하나여야 합니다.");
    }
  }

  if (settings.review_scope && !["full", "partial"].includes(settings.review_scope)) {
    errors.push("복습 범위는 full 또는 partial이어야 합니다.");
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
</file>

<file path="scoreDashboard.ts">
/**
 * 성적 대시보드 API 응답 타입 정의
 * 
 * 이 파일은 /api/students/[id]/score-dashboard 의 응답 구조를 정의합니다.
 * DB 스키마가 아닌 API 응답 구조를 기준으로 프론트엔드가 구현되어야 합니다.
 */

/**
 * 전략 유형
 */
export type StrategyType = "BALANCED" | "MOCK_ADVANTAGE" | "INTERNAL_ADVANTAGE";

/**
 * 학생 프로필 정보
 */
export interface StudentProfile {
  id: string;
  name: string;
  grade: number | null;
  class: number | null;
  schoolType: string | null; // school_info.school_property 값 (일반고, 특목고 등)
  schoolYear: number | null;
  termGrade: number | null; // 해당 학기의 학년
  semester: number | null;
}

/**
 * 내신 분석 결과
 */
export interface InternalAnalysis {
  totalGpa: number | null; // 전체 평균 평점
  zIndex: number | null; // Z-점수 지수
  subjectStrength: Record<string, number>; // 교과군별 GPA (예: { "국어": 3.5, "수학": 4.0 })
}

/**
 * 모의고사 분석 결과
 */
export interface MockAnalysis {
  recentExam: {
    examDate: string;
    examTitle: string;
  } | null;
  avgPercentile: number | null; // 평균 백분위
  totalStdScore: number | null; // 표준점수 합
  best3GradeSum: number | null; // 상위 3개 등급 합
}

/**
 * 수시/정시 전략 분석 결과
 */
export interface StrategyResult {
  type: StrategyType;
  message: string;
  data: {
    internalPct: number | null; // 내신 환산 백분위
    mockPct: number | null; // 모의고사 평균 백분위
    diff: number | null; // 차이
  };
}

/**
 * 성적 대시보드 API 응답
 */
export interface ScoreDashboardResponse {
  studentProfile: StudentProfile;
  internalAnalysis: InternalAnalysis;
  mockAnalysis: MockAnalysis;
  strategyResult: StrategyResult;
}

/**
 * API 호출 파라미터
 */
export interface ScoreDashboardParams {
  studentId: string;
  tenantId: string;
  termId?: string;
  grade?: number;
  semester?: number;
}
</file>

<file path="scoreInput.ts">
/**
 * 성적 입력 폼 타입 정의
 * student_internal_scores, student_mock_scores 테이블 기반
 */

import type { Database } from "@/lib/supabase/database.types";

type Tables<T extends keyof Database["public"]["Tables"]> =
  Database["public"]["Tables"][T]["Row"];
type TablesInsert<T extends keyof Database["public"]["Tables"]> =
  Database["public"]["Tables"][T]["Insert"];

// ============================================
// 내신 성적 입력 타입
// ============================================

/**
 * 내신 성적 입력 폼 데이터
 */
export type InternalScoreInputForm = {
  // 필수 필드
  subject_group_id: string;
  subject_id: string;
  subject_type_id: string;
  grade: number; // 학년 (1~3)
  semester: number; // 학기 (1~2)
  credit_hours: number; // 학점수 (예: 4)
  rank_grade: number; // 석차등급 (1~9)

  // 선택 필드
  raw_score?: number | null; // 원점수
  avg_score?: number | null; // 과목평균
  std_dev?: number | null; // 표준편차
  total_students?: number | null; // 수강자수
};

/**
 * 내신 성적 저장용 데이터 (DB Insert 타입)
 */
export type InternalScoreInsert = TablesInsert<"student_internal_scores">;

/**
 * 내신 성적 Row 타입
 */
export type InternalScore = Tables<"student_internal_scores">;

// ============================================
// 모의고사 성적 입력 타입
// ============================================

/**
 * 모의고사 성적 입력 폼 데이터
 */
export type MockScoreInputForm = {
  // 필수 필드
  exam_date: string; // 시험일 (YYYY-MM-DD)
  exam_title: string; // 시험명 (예: "3월 학력평가")
  grade: number; // 학년 (1~3)
  subject_id: string;
  subject_group_id: string;
  grade_score: number; // 등급 (1~9)

  // 선택 필드
  standard_score?: number | null; // 표준점수
  percentile?: number | null; // 백분위
  raw_score?: number | null; // 원점수
};

/**
 * 모의고사 성적 저장용 데이터 (DB Insert 타입)
 */
export type MockScoreInsert = TablesInsert<"student_mock_scores">;

/**
 * 모의고사 성적 Row 타입
 */
export type MockScore = Tables<"student_mock_scores">;

// ============================================
// API 응답 타입
// ============================================

/**
 * 성적 입력 API 응답
 */
export type ScoreInputResponse = {
  success: boolean;
  message?: string;
  error?: string;
  data?: {
    internal_scores?: InternalScore[];
    mock_scores?: MockScore[];
  };
};

/**
 * 폼 에러 타입
 */
export type ScoreInputFormErrors = {
  [key: string]: string | undefined;
};

// ============================================
// 유틸리티 타입
// ============================================

/**
 * 성적 입력 유형
 */
export type ScoreInputType = "internal" | "mock";

/**
 * 학기 정보
 */
export type TermInfo = {
  grade: number;
  semester: number;
  year?: number;
};
</file>

<file path="terms.ts">
export type TermsContentType = 'terms' | 'privacy' | 'marketing';

/**
 * 약관 내용 타입
 * 데이터베이스에서 조회된 약관 내용을 나타냅니다.
 */
export interface TermsContent {
  id: string;
  content_type: TermsContentType;
  version: number;
  title: string;
  content: string;
  is_active: boolean;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * 약관 내용 입력 타입
 * 새 약관 버전 생성 시 사용됩니다.
 */
export interface TermsContentInput {
  content_type: TermsContentType;
  title: string;
  content: string;
}

/**
 * 약관 내용 행 타입
 * 데이터베이스에서 직접 조회된 행을 나타냅니다.
 * TermsContent와 동일하지만 타입 단언을 위한 별도 타입입니다.
 */
export interface TermsContentRow {
  id: string;
  content_type: TermsContentType;
  version: number;
  title: string;
  content: string;
  is_active: boolean;
  created_by: string | null;
  created_at: string;
  updated_at: string;
}
</file>

<file path="wizard.ts">
/**
 * 플랜 그룹 위저드 관련 타입 정의
 * 타입 안전성 강화를 위한 중앙화된 타입 정의
 */

/**
 * 위저드 콘텐츠 타입 (타입 안전성 강화)
 */
export type WizardContent = {
  content_type: "book" | "lecture";
  content_id: string;
  start_range: number;
  end_range: number;
  title: string; // 필수
  subject_category: string; // 필수
  subject?: string; // 세부 과목 (선택사항, 예: 화법과 작문, 미적분)
  masterContentId?: string; // 추천 콘텐츠의 경우 원본 마스터 콘텐츠 ID
};

/**
 * 타입 가드: WizardContent인지 확인
 */
export function isValidWizardContent(content: unknown): content is WizardContent {
  if (typeof content !== "object" || content === null) {
    return false;
  }

  const c = content as Record<string, unknown>;

  return (
    (c.content_type === "book" || c.content_type === "lecture") &&
    typeof c.content_id === "string" &&
    typeof c.start_range === "number" &&
    typeof c.end_range === "number" &&
    typeof c.title === "string" &&
    typeof c.subject_category === "string" &&
    c.start_range >= 0 &&
    c.end_range > c.start_range
  );
}

/**
 * 타입 가드: WizardContent 배열인지 확인
 */
export function isValidWizardContentArray(
  contents: unknown
): contents is WizardContent[] {
  if (!Array.isArray(contents)) {
    return false;
  }

  return contents.every(isValidWizardContent);
}

/**
 * 부분적으로 유효한 WizardContent인지 확인 (타입 변환용)
 */
export function isPartialWizardContent(
  content: unknown
): content is Partial<WizardContent> & {
  content_type: "book" | "lecture";
  content_id: string;
  start_range: number;
  end_range: number;
} {
  if (typeof content !== "object" || content === null) {
    return false;
  }

  const c = content as Record<string, unknown>;

  return (
    (c.content_type === "book" || c.content_type === "lecture") &&
    typeof c.content_id === "string" &&
    typeof c.start_range === "number" &&
    typeof c.end_range === "number"
  );
}

/**
 * 부분 WizardContent를 완전한 WizardContent로 변환 (기본값 제공)
 */
export function normalizeWizardContent(
  content: Partial<WizardContent> & {
    content_type: "book" | "lecture";
    content_id: string;
    start_range: number;
    end_range: number;
  }
): WizardContent {
  return {
    ...content,
    title: content.title || "제목 없음",
    subject_category: content.subject_category || "기타",
  };
}

/**
 * WizardContent 배열을 정규화
 */
export function normalizeWizardContentArray(
  contents: unknown[]
): WizardContent[] {
  return contents
    .filter(isPartialWizardContent)
    .map(normalizeWizardContent);
}
</file>

<file path="button.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "default" | "destructive" | "outline" | "secondary" | "ghost" | "link"
  size?: "default" | "sm" | "lg" | "icon"
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = "default", size = "default", ...props }, ref) => {
    const variants = {
      default: "bg-primary text-primary-foreground hover:bg-primary/90",
      destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
      outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
      secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
      ghost: "hover:bg-accent hover:text-accent-foreground",
      link: "text-primary underline-offset-4 hover:underline",
    }
    
    const sizes = {
      default: "h-10 px-4 py-2",
      sm: "h-9 rounded-md px-3",
      lg: "h-11 rounded-md px-8",
      icon: "h-10 w-10",
    }

    const baseStyles = "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"

    return (
      <button
        className={cn(baseStyles, variants[variant], sizes[size], className)}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button }
</file>

<file path="Dialog.tsx">
"use client";

import { useEffect, useState, useRef } from "react";
import { createPortal } from "react-dom";
import { cn } from "@/lib/cn";
import Button from "@/components/atoms/Button";

export type DialogSize = "sm" | "md" | "lg" | "xl" | "2xl" | "3xl" | "4xl" | "full";

export type DialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title?: string;
  description?: string;
  children: React.ReactNode;
  variant?: "default" | "destructive";
  maxWidth?: DialogSize;
  size?: DialogSize; // maxWidth와 동일하지만 organisms/Dialog와의 호환성을 위해 추가
  showCloseButton?: boolean;
};

export function Dialog({
  open,
  onOpenChange,
  title,
  description,
  children,
  variant = "default",
  maxWidth,
  size,
  showCloseButton = false,
}: DialogProps) {
  // size와 maxWidth 중 하나만 사용 (size 우선)
  const effectiveSize = size || maxWidth || "md";
  const [mounted, setMounted] = useState(false);
  const dialogRef = useRef<HTMLDivElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);
  const titleId = title ? `dialog-title-${Math.random().toString(36).substr(2, 9)}` : undefined;
  const descriptionId = description ? `dialog-description-${Math.random().toString(36).substr(2, 9)}` : undefined;

  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  useEffect(() => {
    if (!open) {
      // 모달이 닫힐 때 이전 포커스 복원
      if (previousFocusRef.current) {
        // 짧은 지연 후 포커스 복원 (모달 애니메이션 완료 대기)
        setTimeout(() => {
          if (previousFocusRef.current && document.contains(previousFocusRef.current)) {
            previousFocusRef.current.focus();
          }
          previousFocusRef.current = null;
        }, 100);
      }
      return;
    }

    // 현재 포커스 저장
    previousFocusRef.current = document.activeElement as HTMLElement;

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        onOpenChange(false);
      }
    };

    document.addEventListener("keydown", handleEscape);
    document.body.style.overflow = "hidden";

    // 포커스 트랩: 모달 내부에 포커스가 없을 때만 첫 번째 포커스 가능한 요소로 이동
    const dialogElement = dialogRef.current;
    if (dialogElement) {
      const activeElement = document.activeElement;
      // 현재 포커스가 모달 내부에 있지 않을 때만 포커스 이동
      if (!dialogElement.contains(activeElement)) {
        const firstFocusable = dialogElement.querySelector(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        ) as HTMLElement;
        // 짧은 지연 후 포커스 이동 (모달 렌더링 완료 대기)
        setTimeout(() => {
          firstFocusable?.focus();
        }, 0);
      }
    }

    return () => {
      document.removeEventListener("keydown", handleEscape);
      document.body.style.overflow = "";
    };
  }, [open, onOpenChange]);

  if (!mounted || !open) return null;

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onOpenChange(false);
    }
  };

  return createPortal(
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4"
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      aria-describedby={descriptionId}
    >
      <div
        ref={dialogRef}
        className={cn(
          "relative w-full rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg",
          "animate-in fade-in-0 zoom-in-95 slide-in-from-left-1/2 slide-in-from-top-[48%] duration-200",
          "focus:outline-none",
          effectiveSize === "sm" && "max-w-sm",
          effectiveSize === "md" && "max-w-md",
          effectiveSize === "lg" && "max-w-lg",
          effectiveSize === "xl" && "max-w-xl",
          effectiveSize === "2xl" && "max-w-2xl",
          effectiveSize === "3xl" && "max-w-3xl",
          effectiveSize === "4xl" && "max-w-4xl",
          effectiveSize === "full" && "max-w-full"
        )}
        onClick={(e) => e.stopPropagation()}
        tabIndex={-1}
      >
        {/* Close Button */}
        {showCloseButton && (
          <button
            onClick={() => onOpenChange(false)}
            className="absolute right-4 top-4 rounded-lg p-1 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-gray-800 dark:hover:text-gray-200"
            aria-label="닫기"
          >
            <svg
              className="h-5 w-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        )}

        {(title || description) && (
          <div className="flex flex-col gap-1.5 border-b border-gray-200 dark:border-gray-700 px-6 py-4">
            {title && (
              <h2
                id={titleId}
                className={cn(
                  "text-lg font-semibold",
                  variant === "destructive" ? "text-red-900 dark:text-red-300" : "text-gray-900 dark:text-gray-100"
                )}
              >
                {title}
              </h2>
            )}
            {description && (
              <div id={descriptionId} className="text-sm text-gray-700 dark:text-gray-300">
                {description}
              </div>
            )}
          </div>
        )}
        <div className="flex flex-col h-full max-h-[90vh]">{children}</div>
      </div>
    </div>,
    document.body
  );
}

export type DialogContentProps = {
  children: React.ReactNode;
  className?: string;
};

export function DialogContent({ children, className }: DialogContentProps) {
  return <div className={cn("px-6 py-4", className)}>{children}</div>;
}

export type DialogFooterProps = {
  children: React.ReactNode;
  className?: string;
};

export function DialogFooter({ children, className }: DialogFooterProps) {
  return (
    <div
      className={cn(
        "flex flex-col-reverse gap-2 border-t border-gray-200 dark:border-gray-700 px-6 py-4 sm:flex-row sm:justify-end",
        className
      )}
    >
      {children}
    </div>
  );
}

// ============================================
// ConfirmDialog 컴포넌트
// ============================================

export type ConfirmDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description?: string;
  confirmLabel?: string;
  cancelLabel?: string;
  onConfirm: () => void;
  variant?: "default" | "destructive";
  isLoading?: boolean;
};

export function ConfirmDialog({
  open,
  onOpenChange,
  title,
  description,
  confirmLabel = "확인",
  cancelLabel = "취소",
  onConfirm,
  variant = "default",
  isLoading = false,
}: ConfirmDialogProps) {
  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title={title}
      description={description}
      variant={variant}
      size="sm"
    >
      <DialogFooter>
        <Button
          variant="outline"
          onClick={() => onOpenChange(false)}
          disabled={isLoading}
        >
          {cancelLabel}
        </Button>
        <Button
          variant={variant === "destructive" ? "destructive" : "primary"}
          onClick={onConfirm}
          isLoading={isLoading}
        >
          {confirmLabel}
        </Button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="EmptyState.tsx">
import Link from "next/link";

type EmptyStateProps = {
  title: string;
  description: string;
  actionLabel?: string;
  actionHref?: string;
  icon?: string;
};

export function EmptyState({
  title,
  description,
  actionLabel,
  actionHref,
  icon = "📭",
}: EmptyStateProps) {
  return (
    <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-12 text-center">
      <div className="mx-auto flex flex-col gap-4 max-w-md">
        <div className="text-6xl">{icon}</div>
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold text-gray-900">{title}</h3>
          <p className="text-sm text-gray-500">{description}</p>
        </div>
        {actionLabel && actionHref && (
          <Link
            href={actionHref}
            className="inline-flex items-center justify-center rounded-lg bg-indigo-600 px-6 py-3 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            {actionLabel}
          </Link>
        )}
      </div>
    </div>
  );
}
</file>

<file path="ErrorState.tsx">
"use client";

import { memo } from "react";
import Link from "next/link";
import { cn } from "@/lib/cn";
import Button from "@/components/atoms/Button";

export type ErrorStateProps = {
  title?: string;
  message?: string;
  description?: string; // message와 description 통합 (message 우선)
  actionHref?: string; // Link용
  actionLabel?: string;
  onRetry?: () => void; // Button onClick용
  retryLabel?: string;
  icon?: string;
  className?: string;
};

function ErrorStateComponent({
  title = "오류가 발생했습니다",
  message,
  description = "요청을 처리하는 중 문제가 발생했습니다. 잠시 후 다시 시도해주세요.",
  actionHref,
  actionLabel,
  onRetry,
  retryLabel = "다시 시도",
  icon = "⚠️",
  className,
}: ErrorStateProps) {
  // message가 있으면 message를 우선 사용, 없으면 description 사용
  const displayMessage = message || description;

  return (
    <div
      className={cn(
        "rounded-xl border border-red-200 bg-red-50 p-8 md:p-12 text-center",
        className
      )}
    >
      <div className="mx-auto flex flex-col gap-4 max-w-md">
        <div className="text-5xl md:text-6xl">{icon}</div>
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold text-red-900">{title}</h3>
          <p className="text-sm text-red-700">{displayMessage}</p>
        </div>
        {/* actionHref가 있으면 Link 사용, onRetry가 있으면 Button 사용 */}
        {actionLabel && actionHref && (
          <Link
            href={actionHref}
            className="inline-flex items-center justify-center rounded-lg bg-red-600 px-6 py-3 text-sm font-semibold text-white transition hover:bg-red-700"
          >
            {actionLabel}
          </Link>
        )}
        {onRetry && !actionHref && (
          <Button variant="destructive" onClick={onRetry}>
            {retryLabel}
          </Button>
        )}
      </div>
    </div>
  );
}

export const ErrorState = memo(ErrorStateComponent);
export default ErrorState;
</file>

<file path="FormCheckbox.tsx">
import { memo } from "react";
import { cn } from "@/lib/cn";

export interface FormCheckboxProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label: string | React.ReactNode;
  error?: string;
  description?: string;
}

const FormCheckbox = memo(function FormCheckbox({
  label,
  error,
  description,
  className,
  id,
  ...props
}: FormCheckboxProps) {
  const inputId = id || props.name;
  const errorId = error ? `${inputId}-error` : undefined;
  const describedBy = [errorId].filter(Boolean).join(" ") || undefined;

  return (
    <div className="flex flex-col gap-1">
      <label
        htmlFor={inputId}
        className={cn(
          "flex items-start gap-2 cursor-pointer",
          props.disabled && "cursor-not-allowed opacity-50"
        )}
      >
        <input
          id={inputId}
          type="checkbox"
          className={cn(
            "mt-0.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600",
            error && "border-red-500",
            className
          )}
          aria-invalid={error ? "true" : undefined}
          aria-describedby={describedBy}
          {...props}
        />
        <div className="flex flex-col gap-0.5">
          <span className="text-sm text-gray-700">{label}</span>
          {description && (
            <span className="text-xs text-gray-500">{description}</span>
          )}
        </div>
      </label>
      {error && (
        <span id={errorId} className="text-xs text-red-600" role="alert">
          {error}
        </span>
      )}
    </div>
  );
});

export default FormCheckbox;
</file>

<file path="FormInput.tsx">
import { memo } from "react";
import { cn } from "@/lib/cn";

export interface FormInputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label: string;
  error?: string;
}

const FormInput = memo(function FormInput({
  label,
  error,
  className,
  id,
  ...props
}: FormInputProps) {
  const inputId = id || props.name;
  const errorId = error ? `${inputId}-error` : undefined;
  const describedBy = errorId || undefined;

  return (
    <label htmlFor={inputId} className="flex flex-col gap-1 text-sm">
      {label}
      <input
        id={inputId}
        className={cn(
          "rounded border px-3 py-2",
          "text-[var(--text-primary)] placeholder:text-[var(--text-placeholder)]",
          error && "border-red-500",
          className
        )}
        aria-invalid={error ? "true" : undefined}
        aria-describedby={describedBy}
        {...props}
      />
      {error && (
        <span id={errorId} className="text-xs text-red-600" role="alert">
          {error}
        </span>
      )}
    </label>
  );
});

export default FormInput;
</file>

<file path="FormMessage.tsx">
import { memo, useMemo } from "react";
import { cn } from "@/lib/cn";

export interface FormMessageProps {
  type?: "error" | "success" | "info";
  message: string;
  className?: string;
}

const FormMessage = memo(function FormMessage({
  type = "info",
  message,
  className,
}: FormMessageProps) {
  const styles = useMemo(
    () => ({
      error: "bg-red-50 text-red-700",
      success: "bg-green-50 text-green-700",
      info: "bg-blue-50 text-blue-700",
    }),
    []
  );

  return (
    <p className={cn("rounded px-3 py-2 text-sm", styles[type], className)}>
      {message}
    </p>
  );
});

export default FormMessage;
</file>

<file path="FormSubmitButton.tsx">
"use client";

import { useFormStatus } from "react-dom";
import { cn } from "@/lib/cn";

export interface FormSubmitButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  pendingText?: string;
  defaultText: string;
}

export default function FormSubmitButton({
  pendingText,
  defaultText,
  className,
  disabled,
  ...props
}: FormSubmitButtonProps) {
  const { pending } = useFormStatus();

  return (
    <button
      type="submit"
      disabled={pending || disabled}
      className={cn(
        "rounded bg-black px-4 py-2 text-white disabled:opacity-50",
        className
      )}
      {...props}
    >
      {pending ? pendingText || "처리 중..." : defaultText}
    </button>
  );
}
</file>

<file path="index.ts">
/**
 * UI Components (Legacy)
 *
 * 이 파일은 기존 components/ui/ 컴포넌트들을 export합니다.
 * 새로운 코드에서는 @/components/atoms, @/components/molecules, @/components/organisms를 직접 사용하세요.
 *
 * @deprecated 이 export는 하위 호환성을 위해 유지됩니다.
 * 새로운 코드에서는 Atomic Design 패턴을 따라 import하세요:
 *
 * @example
 * // 새로운 방식 (권장)
 * import { Button, Badge } from "@/components/atoms";
 * import { Card, FormField } from "@/components/molecules";
 * import { Dialog, DataTable } from "@/components/organisms";
 *
 * // 기존 방식 (하위 호환)
 * import { Badge, Card, Dialog } from "@/components/ui";
 */

// ============================================
// Atoms로 마이그레이션된 컴포넌트
// ============================================

// Badge → atoms/Badge (개선됨)
export { Badge } from "../atoms/Badge";

// LoadingSkeleton → atoms/Skeleton (개선됨)
export { LoadingSkeleton } from "./LoadingSkeleton";

// ProgressBar → atoms/ProgressBar (개선됨)
export { ProgressBar } from "../atoms/ProgressBar";

// ============================================
// Molecules로 마이그레이션된 컴포넌트
// ============================================

// Card → molecules/Card (개선됨)
export { Card, CardHeader, CardContent, CardFooter } from "../molecules/Card";

// EmptyState → molecules/EmptyState (개선됨)
export { EmptyState } from "./EmptyState";

// ErrorState → molecules/ErrorState (개선됨)
export { ErrorState } from "./ErrorState";

// FormInput → molecules/FormField (개선됨)
export { default as FormInput } from "./FormInput";

// SectionHeader → molecules/SectionHeader (개선됨)
export { SectionHeader } from "./SectionHeader";

// Toast → molecules/Toast (개선됨)
export { Toast } from "../molecules/Toast";

// ============================================
// Organisms로 마이그레이션된 컴포넌트
// ============================================

// Dialog → organisms/Dialog (개선됨)
export { Dialog, DialogContent, DialogFooter } from "./Dialog";

// ToastProvider → organisms/ToastContainer (개선됨)
export { ToastProvider, useToast } from "./ToastProvider";

// ============================================
// 아직 마이그레이션되지 않은 컴포넌트
// ============================================

// Form 관련 (기존 유지)
export { default as FormMessage } from "./FormMessage";
export { default as FormSubmitButton } from "./FormSubmitButton";

// 도메인 특화 컴포넌트 (기존 유지)
export { default as SchoolSelect } from "./SchoolSelect";
export { default as SchoolMultiSelect } from "./SchoolMultiSelect";
export { TimeRangeInput } from "./TimeRangeInput";
export { SkeletonForm } from "./SkeletonForm";

// 설정 페이지 컴포넌트
export { SectionCard } from "./SectionCard";
export { StickySaveButton } from "./StickySaveButton";
</file>

<file path="index.ts">
/**
 * UI Components (Legacy)
 *
 * 이 파일은 기존 components/ui/ 컴포넌트들을 export합니다.
 * 새로운 코드에서는 @/components/atoms, @/components/molecules, @/components/organisms를 직접 사용하세요.
 *
 * @deprecated 이 export는 하위 호환성을 위해 유지됩니다.
 * 새로운 코드에서는 Atomic Design 패턴을 따라 import하세요:
 *
 * @example
 * // 새로운 방식 (권장)
 * import { Button, Badge } from "@/components/atoms";
 * import { Card, FormField } from "@/components/molecules";
 * import { Dialog, DataTable } from "@/components/organisms";
 *
 * // 기존 방식 (하위 호환)
 * import { Badge, Card, Dialog } from "@/components/ui";
 */

// ============================================
// Atoms로 마이그레이션된 컴포넌트
// ============================================

// Badge → atoms/Badge (개선됨)
export { Badge } from "../atoms/Badge";

// LoadingSkeleton → atoms/Skeleton (개선됨)
export { LoadingSkeleton } from "./LoadingSkeleton";

// ProgressBar → atoms/ProgressBar (개선됨)
export { ProgressBar } from "../atoms/ProgressBar";

// ============================================
// Molecules로 마이그레이션된 컴포넌트
// ============================================

// Card → molecules/Card (개선됨)
export { Card, CardHeader, CardContent, CardFooter } from "../molecules/Card";

// EmptyState → molecules/EmptyState (개선됨)
export { EmptyState } from "./EmptyState";

// ErrorState → molecules/ErrorState (개선됨)
export { ErrorState } from "./ErrorState";

// FormInput → molecules/FormField (개선됨)
export { default as FormInput } from "./FormInput";

// SectionHeader → molecules/SectionHeader (개선됨)
export { SectionHeader } from "./SectionHeader";

// Toast → molecules/Toast (개선됨)
export { Toast } from "../molecules/Toast";

// ============================================
// Organisms로 마이그레이션된 컴포넌트
// ============================================

// Dialog → organisms/Dialog (개선됨)
export { Dialog, DialogContent, DialogFooter } from "./Dialog";

// ToastProvider → organisms/ToastContainer (개선됨)
export { ToastProvider, useToast } from "./ToastProvider";

// ============================================
// 아직 마이그레이션되지 않은 컴포넌트
// ============================================

// Form 관련 (기존 유지)
export { default as FormMessage } from "./FormMessage";
export { default as FormSubmitButton } from "./FormSubmitButton";

// 도메인 특화 컴포넌트 (기존 유지)
export { default as SchoolSelect } from "./SchoolSelect";
export { default as SchoolMultiSelect } from "./SchoolMultiSelect";
export { TimeRangeInput } from "./TimeRangeInput";
export { SkeletonForm } from "./SkeletonForm";

// 설정 페이지 컴포넌트
export { SectionCard } from "./SectionCard";
export { StickySaveButton } from "./StickySaveButton";
</file>

<file path="InstallButton.tsx">
"use client";

import { Download, Share2, Check } from "lucide-react";
import { useInstallPrompt } from "@/lib/hooks/useInstallPrompt";
import { cn } from "@/lib/cn";
import Button from "@/components/atoms/Button";

import type { ButtonVariant, ButtonSize } from "@/components/atoms/Button";

interface InstallButtonProps {
  variant?: ButtonVariant;
  size?: ButtonSize;
  className?: string;
  showIcon?: boolean;
}

/**
 * PWA 설치 버튼 컴포넌트
 * 수동으로 설치를 트리거할 때 사용합니다.
 */
export default function InstallButton({
  variant = "primary",
  size = "md",
  className,
  showIcon = true,
}: InstallButtonProps) {
  const { isInstallable, isInstalled, isIOS, install } = useInstallPrompt();

  // 이미 설치되었거나 설치 불가능한 경우 버튼 숨김
  if (isInstalled || (!isInstallable && !isIOS)) {
    return null;
  }

  const handleClick = async () => {
    if (isIOS) {
      // iOS는 자동 설치 불가능하므로 안내 메시지 표시
      alert(
        "iOS Safari에서 설치하려면:\n\n1. 하단 공유 버튼(□↑) 클릭\n2. '홈 화면에 추가' 선택"
      );
      return;
    }

    await install();
  };

  return (
    <Button
      onClick={handleClick}
      variant={variant}
      size={size}
      className={cn(className)}
    >
      <div className="flex items-center gap-2">
        {showIcon &&
          (isIOS ? (
            <Share2 className="w-4 h-4" />
          ) : (
            <Download className="w-4 h-4" />
          ))}
        <span>{isInstalled ? "설치됨" : isIOS ? "설치 안내" : "앱 설치하기"}</span>
        {isInstalled && <Check className="w-4 h-4" />}
      </div>
    </Button>
  );
}
</file>

<file path="InstallPrompt.tsx">
"use client";

import { useEffect, useState } from "react";
import { X, Download, Share2 } from "lucide-react";
import { useInstallPrompt } from "@/lib/hooks/useInstallPrompt";
import { cn } from "@/lib/cn";

interface InstallPromptProps {
  className?: string;
}

/**
 * PWA 설치 프롬프트 배너 컴포넌트
 * 자동으로 표시되며, 사용자가 닫거나 설치하면 숨겨집니다.
 */
export default function InstallPrompt({ className }: InstallPromptProps) {
  const { isInstallable, isInstalled, isIOS, install } = useInstallPrompt();
  const [isDismissed, setIsDismissed] = useState(false);
  const [hasSeenPrompt, setHasSeenPrompt] = useState(false);

  useEffect(() => {
    // 로컬 스토리지에서 이전에 본 기록 확인
    const seen = localStorage.getItem("pwa-install-prompt-seen");
    if (seen === "true") {
      setHasSeenPrompt(true);
    }
  }, []);

  // 이미 설치되었거나 닫혔거나 이미 본 경우 표시하지 않음
  if (isInstalled || isDismissed || hasSeenPrompt || !isInstallable) {
    return null;
  }

  const handleDismiss = () => {
    setIsDismissed(true);
    localStorage.setItem("pwa-install-prompt-seen", "true");
  };

  const handleInstall = async () => {
    await install();
    localStorage.setItem("pwa-install-prompt-seen", "true");
  };

  return (
    <div
      className={cn(
        "fixed bottom-0 left-0 right-0 z-50 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-800 shadow-lg",
        "animate-in slide-in-from-bottom duration-300",
        className
      )}
    >
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between gap-4">
          <div className="flex flex-col gap-1 flex-1">
            <div className="flex items-center gap-2">
              {isIOS ? (
                <Share2 className="w-5 h-5 text-blue-600 dark:text-blue-400" />
              ) : (
                <Download className="w-5 h-5 text-blue-600 dark:text-blue-400" />
              )}
              <h3 className="text-sm font-semibold text-gray-900 dark:text-gray-100">
                앱 설치하기
              </h3>
            </div>
            <p className="text-xs text-gray-600 dark:text-gray-400">
              {isIOS
                ? "홈 화면에 추가하여 더 빠르게 접근하세요"
                : "홈 화면에 추가하여 오프라인에서도 사용하세요"}
            </p>
          </div>

          <div className="flex items-center gap-2">
            {!isIOS && (
              <button
                onClick={handleInstall}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors"
              >
                설치
              </button>
            )}
            <button
              onClick={handleDismiss}
              className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
              aria-label="닫기"
            >
              <X className="w-5 h-5" />
            </button>
          </div>
        </div>

        {isIOS && (
          <div className="flex flex-col gap-3 pt-3 border-t border-gray-200 dark:border-gray-800">
            <div className="flex items-start gap-2 text-xs text-gray-600 dark:text-gray-400">
              <Share2 className="w-4 h-4 mt-0.5 flex-shrink-0" />
              <div className="flex flex-col gap-1">
                <p className="font-medium">설치 방법:</p>
                <ol className="list-decimal list-inside flex flex-col gap-1 ml-2">
                  <li>하단 공유 버튼 <Share2 className="w-3 h-3 inline" /> 클릭</li>
                  <li>&quot;홈 화면에 추가&quot; 선택</li>
                </ol>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="LoadingSkeleton.tsx">
/**
 * Suspense fallback 전용 로딩 컴포넌트
 * Suspense 경계에서 사용되는 기본 로딩 상태
 */
export function SuspenseFallback() {
  return (
    <div className="flex items-center justify-center py-8">
      <div className="animate-pulse flex flex-col gap-4 w-full max-w-md">
        <div className="h-4 w-3/4 rounded bg-gray-200 mx-auto"></div>
        <div className="h-4 w-1/2 rounded bg-gray-200 mx-auto"></div>
        <div className="h-4 w-5/6 rounded bg-gray-200 mx-auto"></div>
      </div>
    </div>
  );
}

/**
 * 기본 로딩 스켈레톤
 */
export function LoadingSkeleton({ variant = "default" }: { variant?: "default" | "card" | "table" | "page" | "schedule" | "tab" | "form" }) {
  switch (variant) {
    case "card":
      return <CardSkeleton />;
    case "table":
      return <TableSkeleton />;
    case "page":
      return <PageSkeleton />;
    case "schedule":
      return <ScheduleSkeleton />;
    case "tab":
      return <TabSkeleton />;
    case "form":
      return <FormSkeleton />;
    default:
      return (
        <div className="animate-pulse flex flex-col gap-4">
          <div className="h-4 w-3/4 rounded bg-gray-200"></div>
          <div className="h-4 w-1/2 rounded bg-gray-200"></div>
          <div className="h-4 w-5/6 rounded bg-gray-200"></div>
        </div>
      );
  }
}

/**
 * 카드 형태 스켈레톤
 */
export function CardSkeleton() {
  return (
    <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <div className="animate-pulse flex flex-col gap-4">
        <div className="h-6 w-1/3 rounded bg-gray-200"></div>
        <div className="h-4 w-full rounded bg-gray-200"></div>
        <div className="h-4 w-2/3 rounded bg-gray-200"></div>
      </div>
    </div>
  );
}

/**
 * 테이블 형태 스켈레톤
 */
export function TableSkeleton({ rows = 5 }: { rows?: number }) {
  return (
    <div className="rounded-xl border border-gray-200 bg-white shadow-sm">
      <div className="animate-pulse">
        <div className="border-b border-gray-200 p-4">
          <div className="h-4 w-1/4 rounded bg-gray-200"></div>
        </div>
        {Array.from({ length: rows }).map((_, i) => (
          <div key={i} className="border-b border-gray-100 p-4">
            <div className="flex gap-4">
              <div className="h-4 w-1/4 rounded bg-gray-200"></div>
              <div className="h-4 w-1/4 rounded bg-gray-200"></div>
              <div className="h-4 w-1/4 rounded bg-gray-200"></div>
              <div className="h-4 w-1/4 rounded bg-gray-200"></div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

/**
 * 페이지 전체 스켈레톤
 */
function PageSkeleton() {
  return (
    <div className="animate-pulse flex flex-col gap-6">
      <div className="h-8 w-1/3 rounded bg-gray-200"></div>
      <div className="flex flex-col gap-4">
        <div className="h-4 w-full rounded bg-gray-200"></div>
        <div className="h-4 w-5/6 rounded bg-gray-200"></div>
        <div className="h-4 w-4/6 rounded bg-gray-200"></div>
      </div>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
        {[1, 2, 3].map((i) => (
          <div key={i} className="h-32 rounded-lg bg-gray-200"></div>
        ))}
      </div>
    </div>
  );
}

/**
 * 스케줄 형태 스켈레톤
 */
function ScheduleSkeleton() {
  return (
    <div className="flex flex-col gap-4">
      <div className="h-6 w-48 animate-pulse rounded bg-gray-200" />
      <div className="rounded-lg border border-gray-200 bg-white">
        <div className="border-b border-gray-200 bg-gray-50 px-4 py-3">
          <div className="h-5 w-32 animate-pulse rounded bg-gray-200" />
        </div>
        <div className="max-h-[600px] flex flex-col gap-2 overflow-y-auto p-4">
          {[1, 2, 3, 4, 5].map((i) => (
            <div key={i} className="flex flex-col gap-2 border-b border-gray-100 pb-4 last:border-b-0">
              <div className="h-12 w-full animate-pulse rounded bg-gray-100" />
              <div className="ml-4 flex flex-col gap-2">
                <div className="h-16 w-full animate-pulse rounded bg-gray-50" />
                <div className="h-16 w-full animate-pulse rounded bg-gray-50" />
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/**
 * 탭 형태 스켈레톤
 */
function TabSkeleton() {
  return (
    <div className="flex flex-col gap-4">
      <div className="h-8 w-48 animate-pulse rounded bg-gray-200" />
      <div className="flex flex-col gap-3">
        <div className="h-32 w-full animate-pulse rounded-lg bg-gray-200" />
        <div className="h-64 w-full animate-pulse rounded-lg bg-gray-200" />
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="h-24 w-full animate-pulse rounded-lg bg-gray-200" />
          <div className="h-24 w-full animate-pulse rounded-lg bg-gray-200" />
        </div>
      </div>
    </div>
  );
}

/**
 * 폼 형태 스켈레톤
 */
function FormSkeleton() {
  return (
    <div className="animate-pulse flex flex-col gap-4">
      {[1, 2, 3, 4, 5, 6, 7].map((i) => (
        <div key={i} className="flex flex-col gap-2">
          <div className="h-4 w-24 bg-gray-200 rounded" />
          <div className="h-10 w-full bg-gray-200 rounded-lg" />
        </div>
      ))}
    </div>
  );
}
</file>

<file path="SchoolMultiSelect.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { cn } from "@/lib/cn";
import {
  getSchoolById,
  searchSchools,
  type School,
} from "@/app/(student)/actions/schoolActions";

type SchoolMultiSelectProps = {
  value?: string[]; // 선택된 학교 ID 배열
  onChange: (value: string[]) => void; // 선택된 학교 ID 배열 변경
  type?: "중학교" | "고등학교" | "대학교";
  placeholder?: string;
  className?: string;
  disabled?: boolean;
  maxCount?: number; // 최대 선택 개수 (기본값: 3)
  onSchoolSelect?: (school: School) => void; // 학교 선택 시 추가 처리
};

export default function SchoolMultiSelect({
  value = [],
  onChange,
  type,
  placeholder = "대학교를 검색하세요",
  className,
  disabled = false,
  maxCount = 3,
  onSchoolSelect,
}: SchoolMultiSelectProps) {
  const [isSearchMode, setIsSearchMode] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [schools, setSchools] = useState<School[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedSchools, setSelectedSchools] = useState<School[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);

  // 외부 클릭 시 닫기
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    }

    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }
  }, [isOpen]);

  // 검색 모드로 전환 시 검색 입력 필드에 포커스
  useEffect(() => {
    if (isSearchMode && searchInputRef.current) {
      searchInputRef.current.focus();
    }
  }, [isSearchMode]);

  // 검색어 변경 시 자동 검색 (디바운스)
  useEffect(() => {
    if (!isSearchMode || disabled) {
      return;
    }

    if (searchQuery.trim().length >= 1) {
      const timeoutId = setTimeout(() => {
        handleSearchSchools(searchQuery);
      }, 300); // 디바운스

      return () => clearTimeout(timeoutId);
    } else {
      setSchools([]);
    }
  }, [searchQuery, isSearchMode, disabled]);

  // 이전 value 배열을 추적하여 중복 조회 방지
  const previousValueRef = useRef<string[]>([]);

  // value가 변경되면 학교 정보 조회
  useEffect(() => {
    // 배열 내용이 실제로 변경되었는지 확인
    const currentValueStr = JSON.stringify(value?.sort() || []);
    const previousValueStr = JSON.stringify(previousValueRef.current.sort());

    if (currentValueStr === previousValueStr) {
      return;
    }

    previousValueRef.current = value || [];

    if (value && value.length > 0) {
      // 이미 선택된 학교들의 ID와 비교하여 불필요한 조회 방지
      const currentIds = selectedSchools
        .map((s) => s.id)
        .filter((id): id is string => !!id)
        .sort();
      const newIds = [...value].sort();

      const currentIdsStr = JSON.stringify(currentIds);
      const newIdsStr = JSON.stringify(newIds);

      if (currentIdsStr !== newIdsStr) {
        fetchSchoolsByIds(value);
      }
    } else {
      setSelectedSchools([]);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]);

  async function fetchSchoolsByIds(schoolIds: string[]) {
    try {
      const schools = await Promise.all(
        schoolIds.map((id) => getSchoolById(id))
      );
      const validSchools = schools.filter(
        (school): school is School => school !== null
      );
      setSelectedSchools(validSchools);
    } catch (error) {
      console.error("학교 정보 조회 실패:", error);
    }
  }

  async function handleSearchSchools(query: string) {
    setLoading(true);
    try {
      const results = await searchSchools(query, type);
      // 이미 선택된 학교는 제외
      const filteredResults = results.filter(
        (school) => !selectedSchools.some((selected) => selected.id === school.id)
      );
      setSchools(filteredResults);
    } catch (error) {
      console.error("학교 검색 실패:", error);
      setSchools([]);
    } finally {
      setLoading(false);
    }
  }

  async function handleSelect(school: School) {
    // 최대 개수 체크
    if (selectedSchools.length >= maxCount) {
      return;
    }

    // 이미 선택된 학교인지 확인
    if (selectedSchools.some((s) => s.id === school.id)) {
      return;
    }

    const newSelectedSchools = [...selectedSchools, school];
    setSelectedSchools(newSelectedSchools);

    // ID 배열로 변환하여 onChange 호출
    const newIds = newSelectedSchools
      .map((s) => s.id)
      .filter((id): id is string => !!id);
    onChange(newIds);

    setSearchQuery("");
    setIsOpen(false);
    setIsSearchMode(false);

    // 학교 선택 콜백 호출
    if (onSchoolSelect) {
      onSchoolSelect(school);
    }
  }

  function handleRemove(schoolId: string) {
    const newSelectedSchools = selectedSchools.filter(
      (s) => s.id !== schoolId
    );
    setSelectedSchools(newSelectedSchools);
    const newIds = newSelectedSchools
      .map((s) => s.id)
      .filter((id): id is string => !!id);
    onChange(newIds);
  }

  function handleClear() {
    setSelectedSchools([]);
    onChange([]);
    setSearchQuery("");
    setIsOpen(false);
    setIsSearchMode(false);
  }

  function handleSearchClick() {
    if (disabled) return;
    // 최대 개수에 도달했으면 검색 불가
    if (selectedSchools.length >= maxCount) {
      return;
    }
    setIsOpen(true);
    setIsSearchMode(true);
    setSearchQuery("");
    setSchools([]);
    // 검색 입력 필드에 포커스
    setTimeout(() => {
      searchInputRef.current?.focus();
    }, 0);
  }

  function handleSearchSubmit() {
    if (!searchQuery.trim() || loading) return;
    handleSearchSchools(searchQuery);
  }

  function handleSearchKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Enter") {
      e.preventDefault();
      handleSearchSubmit();
    } else if (e.key === "Escape") {
      setIsOpen(false);
      setIsSearchMode(false);
      setSearchQuery("");
      setSchools([]);
    }
  }

  const canAddMore = selectedSchools.length < maxCount;

  // 순위별 스타일 정의
  const getRankStyles = (rank: number) => {
    switch (rank) {
      case 1: // 1순위
        return {
          badge: "bg-gradient-to-br from-amber-500 to-amber-600 text-white font-semibold shadow-md",
          card: "bg-gradient-to-r from-amber-50 to-indigo-50 border-2 border-amber-300 shadow-md",
          icon: "text-amber-600",
        };
      case 2: // 2순위
        return {
          badge: "bg-gradient-to-br from-gray-400 to-gray-500 text-white font-semibold shadow-sm",
          card: "bg-gradient-to-r from-gray-50 to-indigo-50 border border-gray-300 shadow-sm",
          icon: "text-gray-600",
        };
      case 3: // 3순위
        return {
          badge: "bg-gradient-to-br from-amber-700 to-amber-800 text-white font-semibold shadow-sm",
          card: "bg-gradient-to-r from-amber-50/50 to-indigo-50 border border-amber-200 shadow-sm",
          icon: "text-amber-700",
        };
      default:
        return {
          badge: "bg-indigo-200 text-indigo-800",
          card: "bg-indigo-50 border border-indigo-200",
          icon: "text-indigo-600",
        };
    }
  };

  return (
    <div ref={containerRef} className={cn("relative flex flex-col gap-3", className)}>
      {/* 선택된 학교 목록 */}
      {selectedSchools.length > 0 && (
        <div className="flex flex-wrap gap-3">
          {selectedSchools.map((school, index) => {
            const rank = index + 1;
            const styles = getRankStyles(rank);
            return (
              <div
                key={school.id || school.name}
                className={cn(
                  "group flex items-center gap-2 rounded-xl px-4 py-2.5 text-sm transition-all",
                  "hover:shadow-lg hover:scale-[1.02]",
                  styles.card
                )}
              >
                {/* 순위 배지 */}
                <div
                  className={cn(
                    "flex h-7 w-7 shrink-0 items-center justify-center rounded-full text-xs font-bold",
                    styles.badge
                  )}
                  aria-label={`${rank}순위`}
                >
                  {rank === 1 && (
                    <svg
                      className="h-4 w-4"
                      fill="currentColor"
                      viewBox="0 0 20 20"
                      aria-hidden="true"
                    >
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                    </svg>
                  )}
                  {rank !== 1 && rank}
                </div>
                {/* 학교 이름 */}
                <span className="font-medium text-gray-900">{school.name}</span>
                {/* 삭제 버튼 */}
                {!disabled && (
                  <button
                    type="button"
                    onClick={() => handleRemove(school.id || "")}
                    className={cn(
                      "ml-auto shrink-0 rounded-full p-1 transition-colors",
                      "hover:bg-white/60 focus:outline-none focus:ring-2 focus:ring-offset-1",
                      styles.icon
                    )}
                    aria-label={`${school.name} 제거`}
                  >
                    <svg
                      className="h-4 w-4"
                      fill="none"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                )}
              </div>
            );
          })}
        </div>
      )}

      <div className="flex gap-2">
        {/* 검색 입력 필드 */}
        <div className="relative flex-1">
          <input
            type="text"
            value=""
            readOnly
            placeholder={
              canAddMore
                ? placeholder
                : `최대 ${maxCount}개까지 선택 가능합니다`
            }
            disabled={disabled || !canAddMore}
            className={cn(
              "w-full rounded-lg border border-gray-300 px-3 py-2 bg-gray-50 text-gray-900 cursor-default",
              "disabled:bg-gray-100 disabled:text-gray-500",
              !canAddMore && "text-gray-400"
            )}
          />
          {selectedSchools.length > 0 && !disabled && (
            <button
              type="button"
              onClick={handleClear}
              className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <svg
                className="h-4 w-4"
                fill="none"
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>
        {/* 검색 버튼 */}
        <button
          type="button"
          onClick={handleSearchClick}
          disabled={disabled || !canAddMore}
          className={cn(
            "flex items-center justify-center rounded-lg border border-gray-300 px-3 py-2 text-gray-700 transition-colors",
            "hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-200",
            "disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed"
          )}
        >
          <svg
            className="h-4 w-4"
            fill="none"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </button>
      </div>

      {/* 검색 드롭다운 메뉴 */}
      {isOpen && !disabled && isSearchMode && canAddMore && (
        <div className="absolute z-50 top-1 w-full rounded-lg border border-gray-200 bg-white shadow-lg">
          {/* 검색 입력 필드 */}
          <div className="border-b border-gray-200 p-3">
            <div className="flex gap-2">
              <input
                ref={searchInputRef}
                type="text"
                value={searchQuery}
                onChange={(e) => {
                  if (disabled) return;
                  setSearchQuery(e.target.value);
                }}
                onKeyDown={handleSearchKeyDown}
                placeholder="대학교명을 입력하세요"
                disabled={disabled}
                className="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200 disabled:bg-gray-100 disabled:text-gray-500"
              />
              {loading && (
                <div className="flex items-center justify-center px-3">
                  <svg
                    className="h-4 w-4 animate-spin text-gray-400"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    />
                  </svg>
                </div>
              )}
              <button
                type="button"
                onClick={() => {
                  setIsOpen(false);
                  setIsSearchMode(false);
                  setSearchQuery("");
                  setSchools([]);
                }}
                className="flex items-center justify-center rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-700 transition-colors hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-200"
              >
                <svg
                  className="h-4 w-4"
                  fill="none"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
          </div>
          {/* 검색 결과 */}
          <div className="max-h-60 overflow-auto">
            {loading ? (
              <div className="flex items-center justify-center px-4 py-6">
                <svg
                  className="h-5 w-5 animate-spin text-gray-400"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                  />
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  />
                </svg>
                <span className="text-sm text-gray-500">검색 중...</span>
              </div>
            ) : schools.length > 0 ? (
              <ul className="py-1">
                {schools.map((school) => (
                  <li
                    key={school.id || school.name}
                    onClick={() => handleSelect(school)}
                    className={cn(
                      "cursor-pointer px-4 py-2 text-sm hover:bg-indigo-50"
                    )}
                  >
                    <div className="flex items-center justify-between gap-2">
                      <div className="flex-1">
                        <div className="font-medium text-gray-900">
                          {school.name}
                        </div>
                        <div className="flex items-center gap-2">
                          {school.region && (
                            <span className="text-xs text-gray-500">
                              {school.region}
                            </span>
                          )}
                          {/* 캠퍼스 정보 표시 */}
                          {school.name.includes("캠퍼스") && (
                            <span className="text-xs text-blue-600 font-medium">
                              {school.name.match(/(.+캠퍼스)/)?.[0] || ""}
                            </span>
                          )}
                        </div>
                      </div>
                      {school.type && (
                        <span className="text-xs font-medium text-indigo-600 whitespace-nowrap">
                          {school.type === "중학교"
                            ? "중등"
                            : school.type === "고등학교"
                            ? "고등"
                            : school.type === "대학교"
                            ? "대학"
                            : ""}
                        </span>
                      )}
                    </div>
                  </li>
                ))}
              </ul>
            ) : searchQuery.trim().length > 0 ? (
              <div className="px-4 py-3 text-center text-sm text-gray-500">
                검색 결과가 없습니다. 다른 검색어를 시도해보세요.
              </div>
            ) : (
              <div className="px-4 py-3 text-center text-sm text-gray-500">
                대학교명을 입력하고 검색하세요.
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="SchoolSelect.tsx">
"use client";

/**
 * 학교 검색/선택 컴포넌트
 *
 * 새 테이블 구조 기반:
 * - all_schools_view를 통한 통합 검색
 * - 읽기 전용 (자동 등록 비활성화)
 */

import { useState, useEffect, useRef } from "react";
import { cn } from "@/lib/cn";
import {
  getSchoolById,
  getSchoolByName,
  searchSchools,
  type School,
} from "@/app/(student)/actions/schoolActions";

type SchoolSelectProps = {
  value?: string;
  onChange: (value: string) => void;
  type?: "중학교" | "고등학교" | "대학교";
  placeholder?: string;
  className?: string;
  disabled?: boolean;
  onSchoolSelect?: (school: School) => void;
};

export default function SchoolSelect({
  value,
  onChange,
  type,
  placeholder = "학교를 검색하세요",
  className,
  disabled = false,
  onSchoolSelect,
}: SchoolSelectProps) {
  const [isSearchMode, setIsSearchMode] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [schools, setSchools] = useState<School[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedSchool, setSelectedSchool] = useState<School | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);

  // 외부 클릭 시 닫기
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    }

    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }
  }, [isOpen]);

  // 검색 모드로 전환 시 검색 입력 필드에 포커스
  useEffect(() => {
    if (isSearchMode && searchInputRef.current) {
      searchInputRef.current.focus();
    }
  }, [isSearchMode]);

  // 검색어 변경 시 자동 검색 (디바운스)
  useEffect(() => {
    if (!isSearchMode || disabled) {
      return;
    }

    if (searchQuery.trim().length >= 1) {
      const timeoutId = setTimeout(() => {
        handleSearchSchools(searchQuery);
      }, 300);

      return () => clearTimeout(timeoutId);
    } else {
      setSchools([]);
    }
  }, [searchQuery, isSearchMode, disabled]);

  // 이전 value를 추적하여 중복 조회 방지
  const previousValueRef = useRef<string | undefined>(undefined);

  // value가 변경되면 학교 정보 조회
  useEffect(() => {
    // value가 변경되지 않았으면 조회하지 않음
    if (value === previousValueRef.current) {
      return;
    }

    previousValueRef.current = value;

    if (value && value.trim()) {
      // 이미 선택된 학교의 ID나 이름과 동일하면 조회하지 않음
      if (
        selectedSchool &&
        (selectedSchool.id === value.trim() ||
          selectedSchool.name === value.trim())
      ) {
        return;
      }

      // 통합 ID 형식인지 확인 (SCHOOL_123 또는 UNIV_456)
      const isUnifiedId = /^(SCHOOL_|UNIV_)\d+$/.test(value);
      if (isUnifiedId) {
        fetchSchoolById(value);
      } else {
        // 학교명으로 조회
        fetchSchoolByName(value);
      }
    } else if (!value) {
      setSelectedSchool(null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]);

  async function fetchSchoolById(schoolId: string) {
    try {
      const school = await getSchoolById(schoolId);
      if (school) {
        setSelectedSchool(school);
      }
    } catch (error) {
      console.error("학교 정보 조회 실패:", error);
    }
  }

  async function fetchSchoolByName(schoolName: string) {
    try {
      const school = await getSchoolByName(schoolName, type);
      if (school) {
        setSelectedSchool(school);
      } else {
        // 학교명이 DB에 없으면 임시로 설정
        setSelectedSchool({
          id: "",
          name: schoolName,
          type: type || "대학교",
          region: null,
        });
      }
    } catch (error) {
      console.error("학교 정보 조회 실패:", error);
    }
  }

  async function handleSearchSchools(query: string) {
    setLoading(true);
    try {
      const results = await searchSchools(query, type);
      setSchools(results);
    } catch (error) {
      console.error("학교 검색 실패:", error);
      setSchools([]);
    } finally {
      setLoading(false);
    }
  }

  function handleSelect(school: School) {
    setSelectedSchool(school);
    onChange(school.id || school.name); // ID가 있으면 ID, 없으면 이름
    setSearchQuery("");
    setIsOpen(false);
    setIsSearchMode(false);

    if (onSchoolSelect) {
      onSchoolSelect(school);
    }
  }

  function handleClear() {
    setSelectedSchool(null);
    onChange("");
    setSearchQuery("");
    setIsOpen(false);
    setIsSearchMode(false);
  }

  function handleSearchClick() {
    if (disabled) return;
    setIsOpen(true);
    setIsSearchMode(true);
    setSearchQuery("");
    setSchools([]);
    setTimeout(() => {
      searchInputRef.current?.focus();
    }, 0);
  }

  function handleSearchKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Enter") {
      e.preventDefault();
    } else if (e.key === "Escape") {
      setIsOpen(false);
      setIsSearchMode(false);
      setSearchQuery("");
      setSchools([]);
    }
  }

  return (
    <div ref={containerRef} className={cn("relative", className)}>
      <div className="flex gap-2">
        {/* 선택된 학교명 표시 */}
        <div className="relative flex-1">
          <input
            ref={inputRef}
            type="text"
            value={selectedSchool ? selectedSchool.name : value || ""}
            readOnly
            placeholder={placeholder}
            disabled={disabled}
            className={cn(
              "w-full rounded-lg border border-gray-300 px-3 py-2 bg-gray-50 text-gray-900 cursor-default",
              "disabled:bg-gray-100 disabled:text-gray-500",
              !selectedSchool && !value && "text-gray-400"
            )}
          />
          {selectedSchool && !disabled && (
            <button
              type="button"
              onClick={handleClear}
              className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <svg
                className="h-4 w-4"
                fill="none"
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>
        {/* 검색 버튼 */}
        <button
          type="button"
          onClick={handleSearchClick}
          disabled={disabled}
          className={cn(
            "flex items-center justify-center rounded-lg border border-gray-300 px-3 py-2 text-gray-700 transition-colors",
            "hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-200",
            "disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed"
          )}
        >
          <svg
            className="h-4 w-4"
            fill="none"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </button>
      </div>

      {/* 검색 드롭다운 */}
      {isOpen && !disabled && isSearchMode && (
        <div className="absolute z-50 top-full w-full rounded-lg border border-gray-200 bg-white shadow-lg">
          {/* 검색 입력 */}
          <div className="border-b border-gray-200 p-3">
            <div className="flex gap-2">
              <input
                ref={searchInputRef}
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={handleSearchKeyDown}
                placeholder="학교명을 입력하세요"
                disabled={disabled}
                className="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
              />
              {loading && (
                <div className="flex items-center justify-center px-3">
                  <svg
                    className="h-4 w-4 animate-spin text-gray-400"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    />
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    />
                  </svg>
                </div>
              )}
              <button
                type="button"
                onClick={() => {
                  setIsOpen(false);
                  setIsSearchMode(false);
                  setSearchQuery("");
                  setSchools([]);
                }}
                className="flex items-center justify-center rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-700 hover:bg-gray-50"
              >
                <svg
                  className="h-4 w-4"
                  fill="none"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
          </div>
          {/* 검색 결과 */}
          <div className="max-h-60 overflow-auto">
            {loading ? (
              <div className="flex items-center justify-center px-4 py-6">
                <svg
                  className="h-5 w-5 animate-spin text-gray-400"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                  />
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  />
                </svg>
                <span className="text-sm text-gray-500">검색 중...</span>
              </div>
            ) : schools.length > 0 ? (
              <ul className="py-1">
                {schools.map((school) => (
                  <li
                    key={school.id || school.name}
                    onClick={() => handleSelect(school)}
                    className={cn(
                      "cursor-pointer px-4 py-2 text-sm hover:bg-indigo-50",
                      selectedSchool?.id === school.id && "bg-indigo-100"
                    )}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex-1">
                        <div className="font-medium text-gray-900">{school.name}</div>
                        {school.region && (
                          <div className="text-xs text-gray-500">
                            {school.region}
                          </div>
                        )}
                      </div>
                      {school.type && (
                        <span className="whitespace-nowrap text-xs font-medium text-indigo-600">
                          {school.type === "중학교"
                            ? "중등"
                            : school.type === "고등학교"
                            ? "고등"
                            : school.type === "대학교"
                            ? "대학"
                            : ""}
                        </span>
                      )}
                    </div>
                  </li>
                ))}
              </ul>
            ) : searchQuery.trim().length > 0 ? (
              <div className="px-4 py-3 text-center text-sm text-gray-500">
                검색 결과가 없습니다.
              </div>
            ) : (
              <div className="px-4 py-3 text-center text-sm text-gray-500">
                학교명을 입력하세요.
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="SectionCard.tsx">
"use client";

import { ReactNode } from "react";
import { Card, CardHeader, CardContent } from "@/components/molecules/Card";
import { cn } from "@/lib/cn";

type SectionCardProps = {
  title: string;
  description?: string;
  children: ReactNode;
  className?: string;
  headerAction?: ReactNode;
};

export function SectionCard({
  title,
  description,
  children,
  className,
  headerAction,
}: SectionCardProps) {
  return (
    <Card className={cn("flex flex-col gap-4", className)}>
      <CardHeader
        title={title}
        description={description}
        action={headerAction}
      />
      <CardContent className="flex flex-col gap-4">{children}</CardContent>
    </Card>
  );
}
</file>

<file path="SectionHeader.tsx">
import { ReactNode } from "react";
import Link from "next/link";
import { cn } from "@/lib/cn";

type SectionHeaderProps = {
  title: string;
  description?: string;
  actionLabel?: string;
  actionHref?: string;
  action?: ReactNode;
  className?: string;
  level?: "h1" | "h2";
  size?: "sm" | "md" | "lg";
};

const sizeClasses = {
  sm: {
    title: "text-body-2-bold",
    description: "text-body-2",
  },
  md: {
    title: "text-h2",
    description: "text-body-2",
  },
  lg: {
    title: "text-h1",
    description: "text-body-1",
  },
};

export function SectionHeader({
  title,
  description,
  actionLabel,
  actionHref,
  action,
  className = "",
  level = "h2",
  size,
}: SectionHeaderProps) {
  const HeadingTag = level === "h1" ? "h1" : "h2";
  
  // size prop이 없으면 level 기반으로 결정
  const effectiveSize = size ?? (level === "h1" ? "lg" : "md");
  
  const headingClassName = cn(
    sizeClasses[effectiveSize].title,
    "text-text-primary"
  );
  
  const descriptionClassName = cn(
    sizeClasses[effectiveSize].description,
    "text-text-secondary"
  );

  return (
    <div className={cn("flex items-start justify-between gap-4", className)}>
      <div className="flex flex-col gap-1">
        <HeadingTag className={headingClassName}>{title}</HeadingTag>
        {description && (
          <p className={descriptionClassName}>{description}</p>
        )}
      </div>
      {actionLabel && actionHref && (
        <Link
          href={actionHref}
          className="text-body-2 font-medium text-primary-600 hover:text-primary-700"
        >
          {actionLabel} →
        </Link>
      )}
      {action && <div className="flex-shrink-0">{action}</div>}
    </div>
  );
}
</file>

<file path="SkeletonForm.tsx">
/**
 * 폼 로딩 스켈레톤 UI
 */
export function SkeletonForm() {
  return (
    <div className="animate-pulse flex flex-col gap-4">
      {[1, 2, 3, 4, 5, 6, 7].map((i) => (
        <div key={i} className="flex flex-col gap-2">
          <div className="h-4 w-24 bg-gray-200 rounded" />
          <div className="h-10 w-full bg-gray-200 rounded-lg" />
        </div>
      ))}
    </div>
  );
}
</file>

<file path="StickySaveButton.tsx">
"use client";

import { ReactNode } from "react";
import { cn } from "@/lib/cn";

type StickySaveButtonProps = {
  hasChanges: boolean;
  isSaving: boolean;
  onSubmit: () => void;
  onCancel?: () => void;
  submitLabel?: string;
  cancelLabel?: string;
  disabled?: boolean;
  children?: ReactNode;
};

export function StickySaveButton({
  hasChanges,
  isSaving,
  onSubmit,
  onCancel,
  submitLabel = "저장하기",
  cancelLabel = "취소",
  disabled = false,
  children,
}: StickySaveButtonProps) {
  if (!hasChanges && !children) {
    return null;
  }

  return (
    <div className="sticky bottom-0 z-10 border-t border-gray-200 bg-white px-6 py-4 shadow-lg md:px-8">
      <div className="mx-auto flex max-w-2xl items-center justify-between gap-4">
        {hasChanges && (
          <p className="text-sm text-gray-500">
            변경사항이 있습니다. 저장하지 않으면 변경사항이 사라집니다.
          </p>
        )}
        {children && <div className="flex-1">{children}</div>}
        <div className="flex gap-3">
          {onCancel && (
            <button
              type="button"
              onClick={onCancel}
              disabled={isSaving}
              className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {cancelLabel}
            </button>
          )}
          <button
            type="button"
            onClick={onSubmit}
            disabled={disabled || isSaving || !hasChanges}
            className={cn(
              "rounded-lg px-4 py-2 text-sm font-medium text-white transition",
              disabled || isSaving || !hasChanges
                ? "bg-gray-400 cursor-not-allowed"
                : "bg-indigo-600 hover:bg-indigo-700"
            )}
          >
            {isSaving ? "저장 중..." : submitLabel}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="ThemeToggle.tsx">
"use client";

import { useTheme } from "next-themes";
import { useEffect, useState } from "react";
import { Moon, Sun } from "lucide-react";
import Button from "@/components/atoms/Button";

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // hydration mismatch 방지
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <Button variant="ghost" size="sm" className="w-10 h-10 p-0">
        <Sun className="h-5 w-5" />
      </Button>
    );
  }

  return (
    <Button
      variant="ghost"
      size="sm"
      className="w-10 h-10 p-0"
      onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
      aria-label="테마 전환"
    >
      {theme === "dark" ? (
        <Sun className="h-5 w-5" />
      ) : (
        <Moon className="h-5 w-5" />
      )}
    </Button>
  );
}
</file>

<file path="TimeRangeInput.tsx">
"use client";

import { useState } from "react";

type TimeRange = {
  start: string;
  end: string;
};

type TimeRangeInputProps = {
  label: string;
  description?: string;
  value?: TimeRange;
  onChange: (range: TimeRange) => void;
  defaultStart: string;
  defaultEnd: string;
  required?: boolean;
  disabled?: boolean;
};

export function TimeRangeInput({
  label,
  description,
  value,
  onChange,
  defaultStart,
  defaultEnd,
  required = false,
  disabled = false,
}: TimeRangeInputProps) {
  const start = value?.start || defaultStart;
  const end = value?.end || defaultEnd;
  const isUsingDefault = start === defaultStart && end === defaultEnd;

  const handleStartChange = (newStart: string) => {
    if (newStart >= end) {
      // 시작 시간이 종료 시간보다 크거나 같으면 경고
      return;
    }
    onChange({ start: newStart, end });
  };

  const handleEndChange = (newEnd: string) => {
    if (newEnd <= start) {
      // 종료 시간이 시작 시간보다 작거나 같으면 경고
      return;
    }
    onChange({ start, end: newEnd });
  };

  const handleReset = () => {
    onChange({ start: defaultStart, end: defaultEnd });
  };

  return (
    <div className="flex flex-col gap-2">
      <div>
        <label className="text-xs font-medium text-gray-800">
          {label} {required && <span className="text-red-500">*</span>}
        </label>
        {description && (
          <p className="text-xs text-gray-600">{description}</p>
        )}
      </div>
      <div className="grid grid-cols-2 gap-3">
        <div>
          <input
            type="time"
            value={start}
            onChange={(e) => handleStartChange(e.target.value)}
            disabled={disabled}
            className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-gray-900 focus:outline-none disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-800"
          />
        </div>
        <div>
          <input
            type="time"
            value={end}
            onChange={(e) => handleEndChange(e.target.value)}
            disabled={disabled}
            className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-gray-900 focus:outline-none disabled:cursor-not-allowed disabled:bg-gray-100 disabled:text-gray-800"
          />
        </div>
      </div>
      <div className="flex items-center justify-between">
        <div className="text-xs text-gray-800">
          기본값: {defaultStart} ~ {defaultEnd}
        </div>
        {!isUsingDefault && (
          <button
            type="button"
            onClick={handleReset}
            disabled={disabled}
            className="text-xs text-gray-800 hover:text-gray-900 disabled:cursor-not-allowed disabled:opacity-50"
          >
            기본값으로 되돌리기
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="ToastProvider.tsx">
"use client";

import { createContext, useContext, useState, useCallback, ReactNode, useEffect, useMemo } from "react";
import { Toast } from "../molecules/Toast";

type ToastType = "success" | "error" | "info";

type ToastMessage = {
  id: string;
  message: string;
  type: ToastType;
  duration?: number;
};

type ToastContextType = {
  showToast: (message: string, type?: ToastType, duration?: number) => void;
  showSuccess: (message: string) => void;
  showError: (message: string) => void;
  showInfo: (message: string) => void;
};

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);
  const [isMounted, setIsMounted] = useState(false);

  // 클라이언트에서만 마운트되도록 보장
  useEffect(() => {
    setIsMounted(true);
  }, []);

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  const showToast = useCallback(
    (message: string, type: ToastType = "success", duration = 3000) => {
      const id = Math.random().toString(36).substring(2, 9);
      setToasts((prev) => [...prev, { id, message, type, duration }]);
    },
    []
  );

  const showSuccess = useCallback(
    (message: string) => showToast(message, "success"),
    [showToast]
  );

  const showError = useCallback(
    (message: string) => showToast(message, "error", 5000),
    [showToast]
  );

  const showInfo = useCallback(
    (message: string) => showToast(message, "info"),
    [showToast]
  );

  // Context value를 메모이제이션하여 불필요한 리렌더링 방지
  const contextValue = useMemo(
    () => ({
      showToast,
      showSuccess,
      showError,
      showInfo,
    }),
    [showToast, showSuccess, showError, showInfo]
  );

  return (
    <ToastContext.Provider value={contextValue}>
      {children}
      <div className="fixed top-4 right-4 z-50 flex flex-col gap-2">
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            id={toast.id}
            message={toast.message}
            variant={toast.type === "success" ? "success" : toast.type === "error" ? "error" : "info"}
            duration={toast.duration}
            onClose={removeToast}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}

export function useToast() {
  const context = useContext(ToastContext);
  if (context === undefined) {
    // 개발 환경에서만 에러를 던지고, 프로덕션에서는 기본 동작 제공
    if (process.env.NODE_ENV === "development") {
      console.error("useToast must be used within a ToastProvider");
    }
    // 기본 동작 제공 (에러를 던지지 않음)
    return {
      showToast: () => {},
      showSuccess: () => {},
      showError: (message: string) => {
        console.error("Toast Error:", message);
      },
      showInfo: () => {},
    };
  }
  return context;
}
</file>

</files>
