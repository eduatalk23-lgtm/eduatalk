This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_components/
  timer/
    StatusBadge.tsx
    TimerControls.tsx
    TimerDisplay.tsx
  AcademyScheduleManagement.tsx
  ActiveLearningWidget.tsx
  AttachGoalButton.tsx
  BlockForm.tsx
  BlockManagementContainer.tsx
  BlockManagementTabs.tsx
  BlockSetManagement.tsx
  BlockSetTabs.tsx
  BlockStatistics.tsx
  BlocksViewer.tsx
  BlockTimeline.tsx
  BookDetailsDisplay.tsx
  BookDetailsManager.tsx
  CampFlowIndicator.tsx
  CampInvitationActions.tsx
  CampInvitationCard.tsx
  CampInvitationCardNew.tsx
  CampParticipationHeader.tsx
  CircularProgress.tsx
  CompletionAnimation.tsx
  CompletionToast.tsx
  ContentActionButtons.tsx
  ContentCard.tsx
  ContentDetailTable.tsx
  ContentHeader.tsx
  ContentsList.tsx
  ContentsListClient.tsx
  ContentsListWrapper.tsx
  ContentStats.tsx
  ContentTabs.tsx
  CurrentLearningSection.tsx
  DailyPlanListView.tsx
  DailyPlanView.tsx
  DeleteContentButton.tsx
  DraggablePlanList.tsx
  ExclusionManagement.tsx
  FilterBar.tsx
  FilterDrawer.tsx
  FilterOptions.tsx
  InvalidBlockWarning.tsx
  LectureEpisodesDisplay.tsx
  LectureEpisodesManager.tsx
  MobileActionBar.tsx
  MonthlyReportSection.tsx
  Pagination.tsx
  PlanCard.tsx
  PlanDateNavigator.tsx
  PlanDetailInfo.tsx
  PlanGroupActions.tsx
  PlanGroupCard.tsx
  PlanItem.tsx
  PlanMemoModal.tsx
  PlanRangeAdjustModal.tsx
  PlanSelector.tsx
  PlanTimeline.tsx
  PlanTimer.tsx
  PlanTimerCard.tsx
  PlanViewContainer.tsx
  RecalculateButton.tsx
  RecommendationCard.tsx
  RiskIndexList.tsx
  SelectionContext.tsx
  SelectionToolbar.tsx
  SinglePlanView.tsx
  TimeCheckSection.tsx
  TimerControlButtons.tsx
  TimerLogSection.tsx
  TimestampDisplay.tsx
  TimeStatistics.tsx
  TodayAchievements.tsx
  TodayAchievementsSection.tsx
  TodayFocusPreview.tsx
  TodayGoals.tsx
  TodayHeader.tsx
  TodayPageContent.tsx
  TodayPageContext.tsx
  TodayPlanItem.tsx
  TodayPlanList.tsx
  TodayPlanListView.tsx
  TodayPlansSection.tsx
  TodayRecommendations.tsx
  ViewModeSelector.tsx
_utils/
  dateDisplay.ts
  navigationUtils.ts
  planGroupUtils.ts
[invitationId]/
  submitted/
    page.tsx
  page.tsx
[setId]/
  _components/
    BlockList.tsx
    BlockSetDetail.tsx
  page.tsx
actions/
  planMemoActions.ts
  planOrderActions.ts
  planRangeActions.ts
  sessionTimeActions.ts
  timerResetActions.ts
  todayActions.ts
admin/
  studentData.ts
books/
  [id]/
    _components/
      BookDetailsSection.tsx
      BookDetailTabs.tsx
      BookInfoSection.tsx
    edit/
      BookEditForm.tsx
      page.tsx
    page.tsx
  new/
    page.tsx
  page.tsx
calendar/
  page.tsx
config/
  configManager.ts
  defaultConfig.ts
  index.ts
  types.ts
core/
  baseRepository.ts
  errorHandler.ts
  index.ts
  queryBuilder.ts
  types.ts
lectures/
  [id]/
    _components/
      LectureDetailTabs.tsx
      LectureEpisodesSection.tsx
      LectureInfoSection.tsx
      LectureLinkedBookSection.tsx
    edit/
      LectureEditForm.tsx
      page.tsx
    page.tsx
  new/
    page.tsx
  page.tsx
master-books/
  _components/
    HierarchicalFilter.tsx
  [id]/
    _components/
      CopyMasterBookButton.tsx
    page.tsx
  page.tsx
master-custom-contents/
  [id]/
    _components/
      CopyMasterCustomContentButton.tsx
    page.tsx
  page.tsx
master-lectures/
  [id]/
    _components/
      CopyMasterLectureButton.tsx
    page.tsx
  page.tsx
patterns/
  _components/
    PatternAnalysisView.tsx
  page.tsx
plan/
  [planId]/
    _components/
      PlanExecutionForm.tsx
    page.tsx
time/
  _components/
    TimeAnalysisView.tsx
  page.tsx
today/
  page.tsx
_actions.ts
_utils.ts
admins.ts
blockSets.ts
campTemplates.ts
careerFields.ts
contentMasters.ts
contentMetadata.ts
contentRecommendation.ts
engine.ts
goalRecommendation.ts
masterContentRecommendation.ts
page.tsx
parents.ts
planContents.ts
planGroupItems.ts
planGroups.ts
schedulerSettings.ts
schools.ts
scoreDetails.ts
scoreQueries.ts
studentCareerFieldPreferences.ts
studentCareerGoals.ts
studentContents.ts
studentGoals.ts
studentPlans.ts
studentProfiles.ts
students.ts
studentScores.ts
studentSessions.ts
studentStats.ts
studentTerms.ts
studyPlanRecommendation.ts
subjectRecommendation.ts
subjects.ts
superadminDashboard.ts
tenants.ts
termsContents.ts
todayPlans.ts
userConsents.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_components/BookDetailsDisplay.tsx">
"use client";

import { useState, useMemo } from "react";
import { BookDetail } from "@/lib/types/plan";

type BookDetailsDisplayProps = {
  details: BookDetail[];
};

type GroupedDetails = {
  majorUnit: string;
  items: BookDetail[];
};

export function BookDetailsDisplay({ details }: BookDetailsDisplayProps) {
  // ëŒ€ë‹¨ì›ë³„ë¡œ ê·¸ë£¹í™”
  const groupedDetails = useMemo(() => {
    const groups = new Map<string, BookDetail[]>();

    details.forEach((detail) => {
      const majorUnit = detail.major_unit || "(ëŒ€ë‹¨ì› ì—†ìŒ)";
      if (!groups.has(majorUnit)) {
        groups.set(majorUnit, []);
      }
      groups.get(majorUnit)!.push(detail);
    });

    // display_orderë¡œ ì •ë ¬
    const sortedGroups: GroupedDetails[] = Array.from(groups.entries())
      .map(([majorUnit, items]) => ({
        majorUnit,
        items: items.sort((a, b) => {
          // ê°™ì€ ëŒ€ë‹¨ì› ë‚´ì—ì„œëŠ” display_orderë¡œ ì •ë ¬
          if (a.display_order !== b.display_order) {
            return a.display_order - b.display_order;
          }
          // display_orderê°€ ê°™ìœ¼ë©´ í˜ì´ì§€ ë²ˆí˜¸ë¡œ ì •ë ¬
          return (a.page_number || 0) - (b.page_number || 0);
        }),
      }))
      .sort((a, b) => {
        // ëŒ€ë‹¨ì› ê°„ ì •ë ¬ì€ ì²« ë²ˆì§¸ í•­ëª©ì˜ display_orderë¡œ
        const aOrder = a.items[0]?.display_order || 0;
        const bOrder = b.items[0]?.display_order || 0;
        return aOrder - bOrder;
      });

    return sortedGroups;
  }, [details]);

  // í† ê¸€ ìƒíƒœ ê´€ë¦¬ (ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë‘ í¼ì¹¨)
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(
    new Set(groupedDetails.map((g) => g.majorUnit))
  );

  const toggleGroup = (majorUnit: string) => {
    setExpandedGroups((prev) => {
      const next = new Set(prev);
      if (next.has(majorUnit)) {
        next.delete(majorUnit);
      } else {
        next.add(majorUnit);
      }
      return next;
    });
  };

  if (groupedDetails.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col gap-4 border-t pt-8">
      <h3 className="text-lg font-semibold text-gray-900">êµì¬ ëª©ì°¨</h3>
      <div className="flex flex-col gap-2">
        {groupedDetails.map((group) => {
          const isExpanded = expandedGroups.has(group.majorUnit);
          const hasMinorUnits = group.items.some((item) => item.minor_unit);

          return (
            <div
              key={group.majorUnit}
              className="rounded-md border border-gray-200 bg-white overflow-hidden"
            >
              {/* ëŒ€ë‹¨ì› í—¤ë” */}
              <div className="flex items-center gap-2 bg-gray-50 px-4 py-3 border-b border-gray-200">
                <button
                  type="button"
                  onClick={() => toggleGroup(group.majorUnit)}
                  className="flex items-center gap-2 flex-1 text-left hover:bg-gray-100 px-4 py-2 rounded-md transition"
                >
                  <span className="text-gray-500 text-sm">
                    {isExpanded ? "â–¼" : "â–¶"}
                  </span>
                  <span className="font-semibold text-gray-900">
                    {group.majorUnit === "(ëŒ€ë‹¨ì› ì—†ìŒ)" ? "ê¸°íƒ€" : group.majorUnit}
                  </span>
                  {hasMinorUnits && (
                    <span className="text-xs text-gray-500">
                      ({group.items.filter((i) => i.minor_unit).length}ê°œ ì¤‘ë‹¨ì›)
                    </span>
                  )}
                </button>
              </div>

              {/* ì¤‘ë‹¨ì› ëª©ë¡ */}
              {isExpanded && (
                <div className="divide-y divide-gray-100">
                  {group.items.length === 0 ? (
                    <div className="px-4 py-4 text-center text-sm text-gray-500">
                      ì¤‘ë‹¨ì›ì´ ì—†ìŠµë‹ˆë‹¤.
                    </div>
                  ) : (
                    group.items.map((item, itemIndex) => (
                      <div
                        key={item.id || itemIndex}
                        className="flex items-center gap-3 px-4 py-2.5 hover:bg-gray-50"
                      >
                        <span className="text-gray-400 text-sm w-6">â””</span>
                        <div className="flex-1">
                          <span className="text-sm text-gray-900">
                            {item.minor_unit || "â€”"}
                          </span>
                        </div>
                        <div className="text-sm text-gray-600 min-w-[60px] text-right">
                          {item.page_number ? `${item.page_number}p` : "â€”"}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="_components/BookDetailsManager.tsx">
"use client";

import { useState, useMemo } from "react";
import { BookDetail } from "@/lib/types/plan";

type BookDetailsManagerProps = {
  initialDetails?: BookDetail[];
  onChange?: (details: Omit<BookDetail, "id" | "created_at">[]) => void;
};

type DetailItem = Omit<BookDetail, "id" | "created_at"> & { tempId?: string };

type GroupedDetails = {
  majorUnit: string;
  items: DetailItem[];
};

export function BookDetailsManager({
  initialDetails = [],
  onChange,
}: BookDetailsManagerProps) {
  const [details, setDetails] = useState<DetailItem[]>(
    initialDetails.map((d) => ({
      book_id: d.book_id,
      major_unit: d.major_unit || "",
      minor_unit: d.minor_unit || "",
      page_number: d.page_number || 0,
      display_order: d.display_order || 0,
      tempId: d.id,
    }))
  );

  // ëŒ€ë‹¨ì›ë³„ë¡œ ê·¸ë£¹í™”
  const groupedDetails = useMemo(() => {
    const groups = new Map<string, DetailItem[]>();

    details.forEach((detail) => {
      const majorUnit = detail.major_unit || "(ëŒ€ë‹¨ì› ì—†ìŒ)";
      if (!groups.has(majorUnit)) {
        groups.set(majorUnit, []);
      }
      groups.get(majorUnit)!.push(detail);
    });

    // display_orderë¡œ ì •ë ¬
    const sortedGroups: GroupedDetails[] = Array.from(groups.entries())
      .map(([majorUnit, items]) => ({
        majorUnit,
        items: items.sort((a, b) => {
          // ê°™ì€ ëŒ€ë‹¨ì› ë‚´ì—ì„œëŠ” display_orderë¡œ ì •ë ¬
          if (a.display_order !== b.display_order) {
            return a.display_order - b.display_order;
          }
          // display_orderê°€ ê°™ìœ¼ë©´ í˜ì´ì§€ ë²ˆí˜¸ë¡œ ì •ë ¬
          return (a.page_number || 0) - (b.page_number || 0);
        }),
      }))
      .sort((a, b) => {
        // ëŒ€ë‹¨ì› ê°„ ì •ë ¬ì€ ì²« ë²ˆì§¸ í•­ëª©ì˜ display_orderë¡œ
        const aOrder = a.items[0]?.display_order || 0;
        const bOrder = b.items[0]?.display_order || 0;
        return aOrder - bOrder;
      });

    return sortedGroups;
  }, [details]);

  // í† ê¸€ ìƒíƒœ ê´€ë¦¬
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(
    new Set(groupedDetails.map((g) => g.majorUnit))
  );

  const toggleGroup = (majorUnit: string) => {
    setExpandedGroups((prev) => {
      const next = new Set(prev);
      if (next.has(majorUnit)) {
        next.delete(majorUnit);
      } else {
        next.add(majorUnit);
      }
      return next;
    });
  };

  const updateDetails = (newDetails: DetailItem[]) => {
    // display_order ì¬ê³„ì‚°
    let order = 0;
    const updated = newDetails.map((d) => ({
      ...d,
      display_order: order++,
    }));

    setDetails(updated);
    onChange?.(
      updated.map((d) => ({
        book_id: d.book_id,
        major_unit: d.major_unit || null,
        minor_unit: d.minor_unit || null,
        page_number: d.page_number || 0,
        display_order: d.display_order || 0,
      }))
    );
  };

  // ëŒ€ë‹¨ì› ì¶”ê°€
  const addMajorUnit = () => {
    const newDetail: DetailItem = {
      book_id: details[0]?.book_id || "",
      major_unit: `ëŒ€ë‹¨ì› ${groupedDetails.length + 1}`,
      minor_unit: "",
      page_number: 0,
      display_order: details.length,
      tempId: `temp-major-${Date.now()}`,
    };
    updateDetails([...details, newDetail]);
    // ìƒˆë¡œ ì¶”ê°€ëœ ëŒ€ë‹¨ì›ì€ ìë™ìœ¼ë¡œ í¼ì¹¨
    if (newDetail.major_unit) {
      setExpandedGroups((prev) => new Set([...prev, newDetail.major_unit!]));
    }
  };

  // ì¤‘ë‹¨ì› ì¶”ê°€ (íŠ¹ì • ëŒ€ë‹¨ì› ì•„ë˜)
  const addMinorUnit = (majorUnit: string) => {
    const majorUnitDetails = details.filter(
      (d) => (d.major_unit || "(ëŒ€ë‹¨ì› ì—†ìŒ)") === majorUnit
    );
    const lastPage =
      majorUnitDetails.length > 0
        ? Math.max(...majorUnitDetails.map((d) => d.page_number || 0))
        : 0;

    const newDetail: DetailItem = {
      book_id: details[0]?.book_id || "",
      major_unit: majorUnit === "(ëŒ€ë‹¨ì› ì—†ìŒ)" ? "" : majorUnit,
      minor_unit: "",
      page_number: lastPage + 1,
      display_order: details.length,
      tempId: `temp-minor-${Date.now()}`,
    };
    updateDetails([...details, newDetail]);
  };

  // í•­ëª© ì‚­ì œ
  const removeItem = (tempId: string) => {
    updateDetails(details.filter((d) => d.tempId !== tempId));
  };

  // ëŒ€ë‹¨ì› ì‚­ì œ (í•´ë‹¹ ëŒ€ë‹¨ì›ì˜ ëª¨ë“  í•­ëª© ì‚­ì œ)
  const removeMajorUnit = (majorUnit: string) => {
    updateDetails(
      details.filter((d) => (d.major_unit || "(ëŒ€ë‹¨ì› ì—†ìŒ)") !== majorUnit)
    );
  };

  // í•­ëª© ì—…ë°ì´íŠ¸
  const updateItem = (
    tempId: string,
    field: keyof DetailItem,
    value: string | number
  ) => {
    const newDetails = details.map((d) =>
      d.tempId === tempId ? { ...d, [field]: value } : d
    );
    updateDetails(newDetails);
  };

  // ëŒ€ë‹¨ì›ëª… ì—…ë°ì´íŠ¸ (í•´ë‹¹ ëŒ€ë‹¨ì›ì˜ ëª¨ë“  í•­ëª© ì—…ë°ì´íŠ¸)
  const updateMajorUnitName = (oldName: string, newName: string) => {
    const newDetails = details.map((d) =>
      (d.major_unit || "(ëŒ€ë‹¨ì› ì—†ìŒ)") === oldName
        ? { ...d, major_unit: newName }
        : d
    );
    updateDetails(newDetails);
  };

  return (
    <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-gray-50 p-4">
      <div className="flex items-center justify-between">
        <h4 className="text-sm font-semibold text-gray-900">êµì¬ ëª©ì°¨</h4>
        <button
          type="button"
          onClick={addMajorUnit}
          className="rounded-md bg-indigo-600 px-3 py-1.5 text-xs font-semibold text-white transition hover:bg-indigo-700"
        >
          + ëŒ€ë‹¨ì› ì¶”ê°€
        </button>
      </div>

      {groupedDetails.length === 0 ? (
        <p className="py-4 text-center text-sm text-gray-900">
          ëª©ì°¨ê°€ ì—†ìŠµë‹ˆë‹¤. "+ ëŒ€ë‹¨ì› ì¶”ê°€" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”.
        </p>
      ) : (
        <div className="flex flex-col gap-2">
          {groupedDetails.map((group) => {
            const isExpanded = expandedGroups.has(group.majorUnit);
            const hasMinorUnits = group.items.some((item) => item.minor_unit);

            return (
              <div
                key={group.majorUnit}
                className="rounded-md border border-gray-200 bg-white overflow-hidden"
              >
                {/* ëŒ€ë‹¨ì› í—¤ë” */}
                <div className="flex items-center gap-2 bg-gray-50 px-3 py-2 border-b border-gray-200">
                  <button
                    type="button"
                    onClick={() => toggleGroup(group.majorUnit)}
                    className="flex items-center gap-2 flex-1 text-left hover:bg-gray-100 px-3 py-2 rounded-md transition"
                  >
                    <span className="text-gray-500">
                      {isExpanded ? "â–¼" : "â–¶"}
                    </span>
                    <input
                      type="text"
                      value={group.majorUnit === "(ëŒ€ë‹¨ì› ì—†ìŒ)" ? "" : group.majorUnit}
                      onChange={(e) => {
                        const newName = e.target.value || "(ëŒ€ë‹¨ì› ì—†ìŒ)";
                        updateMajorUnitName(group.majorUnit, newName);
                      }}
                      onClick={(e) => e.stopPropagation()}
                      placeholder="ëŒ€ë‹¨ì›ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                      className="flex-1 rounded-md border border-gray-300 px-2 py-1 text-sm font-semibold text-gray-900 placeholder:text-gray-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 bg-white"
                    />
                    {hasMinorUnits && (
                      <span className="text-xs text-gray-900">
                        ({group.items.filter((i) => i.minor_unit).length}ê°œ ì¤‘ë‹¨ì›)
                      </span>
                    )}
                  </button>
                  <div className="flex gap-1">
                    <button
                      type="button"
                      onClick={(e) => {
                        e.stopPropagation();
                        addMinorUnit(group.majorUnit);
                        setExpandedGroups((prev) => new Set([...prev, group.majorUnit]));
                      }}
                      className="rounded-md border border-gray-300 bg-white px-2 py-1 text-xs font-semibold text-gray-700 transition hover:bg-gray-50"
                    >
                      + ì¤‘ë‹¨ì›
                    </button>
                    <button
                      type="button"
                      onClick={(e) => {
                        e.stopPropagation();
                        if (confirm(`"${group.majorUnit}" ëŒ€ë‹¨ì›ê³¼ ëª¨ë“  ì¤‘ë‹¨ì›ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                          removeMajorUnit(group.majorUnit);
                        }
                      }}
                      className="rounded-md border border-red-300 bg-white px-2 py-1 text-xs font-semibold text-red-600 transition hover:bg-red-50"
                    >
                      ì‚­ì œ
                    </button>
                  </div>
                </div>

                {/* ì¤‘ë‹¨ì› ëª©ë¡ */}
                {isExpanded && (
                  <div className="divide-y divide-gray-100">
                    {group.items.length === 0 ? (
                      <div className="px-3 py-4 text-center text-sm text-gray-900">
                        ì¤‘ë‹¨ì›ì´ ì—†ìŠµë‹ˆë‹¤. "+ ì¤‘ë‹¨ì›" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”.
                      </div>
                    ) : (
                      group.items.map((item, itemIndex) => (
                        <div
                          key={item.tempId || itemIndex}
                          className="flex items-center gap-3 px-3 py-2 hover:bg-gray-50"
                        >
                          <div className="flex-1 flex items-center gap-3">
                            <span className="text-gray-400 text-xs w-6">â””</span>
                            <div className="flex-1 min-w-[200px]">
                              <input
                                type="text"
                                value={item.minor_unit || ""}
                                onChange={(e) =>
                                  updateItem(
                                    item.tempId!,
                                    "minor_unit",
                                    e.target.value
                                  )
                                }
                                placeholder="ì¤‘ë‹¨ì›ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                                className="w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm text-gray-900 placeholder:text-gray-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                              />
                            </div>
                            <div className="w-24">
                              <input
                                type="number"
                                value={item.page_number || ""}
                                onChange={(e) =>
                                  updateItem(
                                    item.tempId!,
                                    "page_number",
                                    parseInt(e.target.value) || 0
                                  )
                                }
                                min="0"
                                placeholder="í˜ì´ì§€"
                                className="w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm text-gray-900 placeholder:text-gray-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                              />
                            </div>
                            <div className="text-xs text-gray-900 min-w-[40px]">
                              {item.page_number ? `${item.page_number}p` : ""}
                            </div>
                          </div>
                          <button
                            type="button"
                            onClick={() => {
                              if (confirm("ì´ ì¤‘ë‹¨ì›ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                                removeItem(item.tempId!);
                              }
                            }}
                            className="rounded-md border border-red-300 bg-white px-2 py-1 text-xs font-semibold text-red-600 transition hover:bg-red-50"
                          >
                            ì‚­ì œ
                          </button>
                        </div>
                      ))
                    )}
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}

      {/* Hidden input for form submission */}
      <input
        type="hidden"
        name="details"
        value={JSON.stringify(
          details
            .filter((d) => d.major_unit || d.minor_unit || d.page_number)
            .map((d) => ({
              major_unit: d.major_unit || null,
              minor_unit: d.minor_unit || null,
              page_number: d.page_number || 0,
              display_order: d.display_order || 0,
            }))
        )}
      />
    </div>
  );
}
</file>

<file path="_components/ContentActionButtons.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Link } from "lucide-react";
import { useRouter } from "next/navigation";

export function ContentActionButtons({ 
  contentId, 
  type,
  editHref,
  deleteAction,
  listHref
}: { 
  contentId?: string;
  type?: "book" | "lecture" | "custom";
  editHref?: string;
  deleteAction?: () => Promise<void>;
  listHref?: string;
}) {
  const router = useRouter();

  return (
    <div className="flex gap-2">
      <Button variant="outline" size="sm" onClick={() => router.push(listHref || "/plan")}>
        ëª©ë¡ìœ¼ë¡œ
      </Button>
      {editHref && (
        <Button variant="outline" size="sm" onClick={() => router.push(editHref)}>
          ìˆ˜ì •
        </Button>
      )}
      {deleteAction && (
         <form action={deleteAction}>
           <Button variant="destructive" size="sm" type="submit">
             ì‚­ì œ
           </Button>
         </form>
      )}
    </div>
  );
}
</file>

<file path="_components/ContentCard.tsx">
"use client";

import { useState, Fragment, memo } from "react";
import Link from "next/link";
import { DeleteContentButton } from "./DeleteContentButton";

type TabKey = "books" | "lectures" | "custom";

type ContentCardProps = {
  item: {
    id: string;
    title: string;
    master_content_id?: string | null;
    [key: string]: string | number | boolean | null | undefined;
  };
  activeTab: TabKey;
  onDelete: (id: string) => Promise<void>;
  detailRows: Array<{ label: string; value: string | number | null }>;
  subText: string;
  linkedBook?: { id: string; title: string } | null;
  isSelected?: boolean;
  onSelect?: (checked: boolean) => void;
};

function ContentCardComponent({
  item,
  activeTab,
  onDelete,
  detailRows,
  subText,
  linkedBook,
  isSelected = false,
  onSelect,
}: ContentCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  // ì¤‘ìš” ì •ë³´ë§Œ ë¨¼ì € í‘œì‹œ (ì²˜ìŒ 3ê°œ)
  const primaryInfo = detailRows.slice(0, 3);
  const secondaryInfo = detailRows.slice(3);

  return (
    <li className={`rounded-lg border bg-white p-4 shadow-sm ${isSelected ? "ring-2 ring-indigo-500" : ""}`}>
      <div className="flex items-start justify-between gap-4">
        {/* ì²´í¬ë°•ìŠ¤ */}
        {onSelect && (
          <div className="flex items-start pt-1">
            <input
              type="checkbox"
              checked={isSelected}
              onChange={(e) => onSelect(e.target.checked)}
              className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
              onClick={(e) => e.stopPropagation()}
            />
          </div>
        )}
        <div className="flex-1">
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2 flex-wrap">
              <p className="text-lg font-semibold text-gray-900">{item.title}</p>
              {item.master_content_id && (
                <span className="inline-flex items-center gap-1 rounded-md bg-blue-50 px-2 py-0.5 text-xs font-medium text-blue-700">
                  ğŸ“¦ ë§ˆìŠ¤í„°ì—ì„œ ê°€ì ¸ì˜´
                </span>
              )}
              {linkedBook && (
                <Link
                  href={`/contents/books/${linkedBook.id}`}
                  className="inline-flex items-center gap-1 rounded-md bg-indigo-50 px-2 py-0.5 text-xs font-medium text-indigo-700 hover:bg-indigo-100 transition"
                  onClick={(e) => e.stopPropagation()}
                >
                  ğŸ“š {linkedBook.title}
                </Link>
              )}
            </div>
            <p className="text-sm text-gray-500">{subText}</p>

            {/* ì£¼ìš” ì •ë³´ (í•­ìƒ í‘œì‹œ) */}
            <div className="flex flex-wrap gap-x-4 gap-y-1 text-xs text-gray-600">
              {primaryInfo.map((row) => (
                <span key={row.label} className="flex items-center gap-1">
                  <span className="font-medium text-gray-500">{row.label}:</span>
                  <span className="text-gray-900">{row.value ?? "â€”"}</span>
                </span>
              ))}
            </div>

            {/* ìƒì„¸ ì •ë³´ (í† ê¸€) */}
            {secondaryInfo.length > 0 && (
              <div>
                <button
                  type="button"
                  onClick={() => setIsExpanded(!isExpanded)}
                  className="text-xs text-indigo-600 hover:text-indigo-700 transition"
                >
                  {isExpanded ? "â–² ìƒì„¸ ì •ë³´ ì ‘ê¸°" : "â–¼ ìƒì„¸ ì •ë³´ ë³´ê¸°"}
                </button>
                {isExpanded && (
                  <dl className="grid gap-y-1 text-xs text-gray-600 sm:grid-cols-2">
                    {secondaryInfo.map((row) => (
                      <Fragment key={row.label}>
                        <dt className="font-medium text-gray-500">{row.label}</dt>
                        <dd className="text-gray-900">{row.value ?? "â€”"}</dd>
                      </Fragment>
                    ))}
                  </dl>
                )}
              </div>
            )}
          </div>
        </div>

        <div className="flex gap-2">
          {activeTab !== "custom" && (
            <Link
              href={`/contents/${activeTab}/${item.id}`}
              className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-3 py-1.5 text-xs font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
            >
              ìƒì„¸ë³´ê¸°
            </Link>
          )}
          <DeleteContentButton
            id={item.id}
            contentType={activeTab}
            onDelete={onDelete}
          />
        </div>
      </div>
    </li>
  );
}

export const ContentCard = memo(ContentCardComponent, (prevProps, nextProps) => {
  // itemì˜ ì£¼ìš” ì†ì„±ë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  return (
    prevProps.item.id === nextProps.item.id &&
    prevProps.item.title === nextProps.item.title &&
    prevProps.activeTab === nextProps.activeTab &&
    prevProps.isSelected === nextProps.isSelected &&
    prevProps.subText === nextProps.subText &&
    prevProps.linkedBook?.id === nextProps.linkedBook?.id &&
    // detailRows ë°°ì—´ ê¸¸ì´ì™€ ì£¼ìš” ê°’ ë¹„êµ
    prevProps.detailRows.length === nextProps.detailRows.length &&
    prevProps.detailRows.every((row, idx) => 
      row.label === nextProps.detailRows[idx]?.label &&
      row.value === nextProps.detailRows[idx]?.value
    )
  );
});
</file>

<file path="_components/ContentDetailTable.tsx">
// ê³µí†µ ì½˜í…ì¸  ìƒì„¸ ì •ë³´ í…Œì´ë¸” ì»´í¬ë„ŒíŠ¸

type DetailRow = {
  label: string;
  value: string | number | null;
  isUrl?: boolean;
};

type ContentDetailTableProps = {
  rows: DetailRow[];
};

export function ContentDetailTable({ rows }: ContentDetailTableProps) {
  return (
    <div className="grid gap-6 sm:grid-cols-2">
      {rows.map((row) => (
        <DetailRow key={row.label} label={row.label} value={row.value} isUrl={row.isUrl} />
      ))}
    </div>
  );
}

function DetailRow({
  label,
  value,
  isUrl = false,
}: {
  label: string;
  value: string | number | null | undefined;
  isUrl?: boolean;
}) {
  // null, undefined, ë¹ˆ ë¬¸ìì—´ ì²˜ë¦¬
  // ê°’ì´ ì—†ìœ¼ë©´ í•´ë‹¹ í–‰ì„ í‘œì‹œí•˜ì§€ ì•ŠìŒ (ë¹ˆ ê°’ ìˆ¨ê¹€)
  if (value === null || value === undefined || value === "") {
    return null;
  }
  
  // URLì¸ ê²½ìš° ë§í¬ë¡œ í‘œì‹œ
  const isUrlValue = isUrl || (typeof value === "string" && (value.startsWith("http://") || value.startsWith("https://")));
  
  return (
    <div className="flex flex-col gap-1">
      <p className="text-sm font-medium text-gray-500">{label}</p>
      {isUrlValue ? (
        <a
          href={String(value)}
          target="_blank"
          rel="noopener noreferrer"
          className="text-base text-indigo-600 hover:text-indigo-800 hover:underline break-all"
        >
          {String(value)}
        </a>
      ) : (
        <p className="text-base text-gray-900">{String(value)}</p>
      )}
    </div>
  );
}
</file>

<file path="_components/ContentHeader.tsx">
// ê³µí†µ ì½˜í…ì¸  í—¤ë” ì»´í¬ë„ŒíŠ¸
import Image from "next/image";

type ContentHeaderProps = {
  title: string;
  subtitle?: string;
  icon: string;
  createdAt?: string;
  coverImageUrl?: string | null;
};

export function ContentHeader({
  title,
  subtitle,
  icon,
  createdAt,
  coverImageUrl,
}: ContentHeaderProps) {
  return (
    <div className="flex flex-col gap-6">
      {coverImageUrl && (
        <div className="flex justify-center">
          <div className="relative h-48 w-32 overflow-hidden rounded-lg border border-gray-200 bg-gray-100 sm:h-64 sm:w-40">
            <Image
              src={coverImageUrl}
              alt={`${title} í‘œì§€`}
              fill
              className="object-cover"
              sizes="(max-width: 640px) 128px, 160px"
            />
          </div>
        </div>
      )}
      <div className="flex flex-col gap-2">
        <p className="text-xs font-medium uppercase tracking-wide text-gray-400">
          {icon}
        </p>
        <h1 className="text-3xl font-semibold text-gray-900">{title}</h1>
        {(subtitle || createdAt) && (
          <p className="text-sm text-gray-500">
            {subtitle && `${subtitle}`}
            {subtitle && createdAt && " â€¢ "}
            {createdAt && `ë“±ë¡ì¼ ${formatDate(createdAt)}`}
          </p>
        )}
      </div>
    </div>
  );
}

function formatDate(value: string) {
  return new Date(value).toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}
</file>

<file path="_components/ContentsList.tsx">
import { Suspense } from "react";
import Link from "next/link";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentCard } from "./ContentCard";
import { Pagination } from "./Pagination";
import {
  deleteBook,
  deleteLecture,
  deleteCustomContent,
} from "@/app/(student)/actions/contentActions";
import { ContentsListClient } from "./ContentsListClient";
import { EmptyState } from "@/components/molecules/EmptyState";

type TabKey = "books" | "lectures" | "custom";
export type ContentListItem = {
  id: string;
  title: string;
  revision?: string | null | undefined;
  semester?: string | null | undefined;
  subject_category?: string | null | undefined;
  subject?: string | null | undefined;
  publisher?: string | null | undefined;
  platform?: string | null | undefined;
  difficulty_level?: string | null | undefined;
  total_pages?: number | null | undefined;
  total_episodes?: number | null | undefined;
  duration?: number | null | undefined;
  content_type?: string | null | undefined;
  total_page_or_time?: number | null | undefined;
  linked_book_id?: string | null | undefined;
  linkedBook?: { id: string; title: string } | null;
  // ì•Œ ìˆ˜ ì—†ëŠ” í•„ë“œê°€ ìˆì„ ê²½ìš°ë¥¼ ìœ„í•œ fallback
} & Record<string, any>;

type ContentsListProps = {
  activeTab: TabKey;
  studentId: string;
  filters: {
    search?: string;
    curriculum_revision_id?: string;
    subject_group_id?: string;
    subject_id?: string;
    publisher_id?: string;
    platform_id?: string;
    difficulty?: string;
  };
  sortBy: string;
  page?: number;
};

async function ContentsListContent({
  activeTab,
  studentId,
  filters,
  sortBy,
  page = 1,
}: ContentsListProps) {
  const supabase = await createSupabaseServerClient();
  const ITEMS_PER_PAGE = 20;
  const { list, total, totalPages } = await fetchContentsByTab(
    supabase,
    activeTab,
    studentId,
    filters,
    sortBy,
    page,
    ITEMS_PER_PAGE
  );

  // ê°•ì˜ì˜ ê²½ìš° ì—°ê²°ëœ êµì¬ ì •ë³´ ì¡°íšŒ
  if (activeTab === "lectures" && list.length > 0) {
    const linkedBookIds = list
      .map((item) => item.linked_book_id)
      .filter((id): id is string => !!id);
    
    if (linkedBookIds.length > 0) {
      const { data: linkedBooks } = await supabase
        .from("books")
        .select("id, title")
        .in("id", linkedBookIds)
        .eq("student_id", studentId);
      
      const linkedBooksMap = new Map(
        (linkedBooks || []).map((book) => [book.id, book])
      );
      
      // ê° ê°•ì˜ì— ì—°ê²°ëœ êµì¬ ì •ë³´ ì¶”ê°€
      list.forEach((item) => {
        const linkedBookId = item.linked_book_id;
        if (linkedBookId && linkedBooksMap.has(linkedBookId)) {
          const linkedBook = linkedBooksMap.get(linkedBookId);
          if (linkedBook) {
            item.linkedBook = linkedBook;
          }
        }
      });
    }
  }

  if (list.length === 0) {
    const emptyStateConfig = {
      books: {
        icon: "ğŸ“š",
        title: "ë“±ë¡ëœ ì±…ì´ ì—†ìŠµë‹ˆë‹¤",
        description: "ìƒˆë¡œìš´ ì±…ì„ ë“±ë¡í•˜ì—¬ í•™ìŠµì„ ì‹œì‘í•´ë³´ì„¸ìš”.",
        actionLabel: "+ ìƒˆ êµì¬ ë“±ë¡",
        actionHref: "/contents/books/new",
      },
      lectures: {
        icon: "ğŸ§",
        title: "ë“±ë¡ëœ ê°•ì˜ê°€ ì—†ìŠµë‹ˆë‹¤",
        description: "ìƒˆë¡œìš´ ê°•ì˜ë¥¼ ë“±ë¡í•˜ì—¬ í•™ìŠµì„ ì‹œì‘í•´ë³´ì„¸ìš”.",
        actionLabel: "+ ìƒˆ ê°•ì˜ ë“±ë¡",
        actionHref: "/contents/lectures/new",
      },
      custom: {
        icon: "ğŸ“",
        title: "ë“±ë¡ëœ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ê°€ ì—†ìŠµë‹ˆë‹¤",
        description: "ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ ì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ì§ì ‘ ë“±ë¡í•´ë³´ì„¸ìš”.",
        actionLabel: "ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ ì—ì„œ ê°€ì ¸ì˜¤ê¸°",
        actionHref: "/contents/master-custom-contents",
      },
    };

    const config = emptyStateConfig[activeTab];

    return (
      <EmptyState
        icon={config.icon}
        title={config.title}
        description={config.description}
        actionLabel={config.actionLabel}
        actionHref={config.actionHref}
      />
    );
  }

  return (
    <>
      <ContentsListClient
        list={list}
        activeTab={activeTab}
        deleteBook={deleteBook}
        deleteLecture={deleteLecture}
        deleteCustomContent={deleteCustomContent}
      />
      
      {/* í˜ì´ì§€ë„¤ì´ì…˜ */}
      {totalPages > 1 && (
        <Pagination
          currentPage={page}
          totalPages={totalPages}
          totalItems={total}
          activeTab={activeTab}
          filters={filters}
          sortBy={sortBy}
        />
      )}
    </>
  );
}

function ContentsListSkeleton() {
  return (
    <ul className="grid gap-4">
      {[1, 2, 3].map((i) => (
        <li
          key={i}
          className="rounded-lg border bg-white p-4 shadow-sm animate-pulse"
        >
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1 space-y-3">
              <div className="h-6 bg-gray-200 rounded w-3/4"></div>
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
              <div className="grid gap-2 sm:grid-cols-2">
                {[1, 2, 3, 4].map((j) => (
                  <div key={j} className="h-4 bg-gray-200 rounded"></div>
                ))}
              </div>
            </div>
            <div className="flex gap-2">
              <div className="h-8 bg-gray-200 rounded w-20"></div>
              <div className="h-8 bg-gray-200 rounded w-16"></div>
            </div>
          </div>
        </li>
      ))}
    </ul>
  );
}

export function ContentsList(props: ContentsListProps) {
  return (
    <Suspense fallback={<ContentsListSkeleton />}>
      <ContentsListContent {...props} />
    </Suspense>
  );
}

type Row = { label: string; value: string | number | null };

type ContentFilters = {
  search?: string;
  curriculum_revision_id?: string;
  subject_group_id?: string;
  subject_id?: string;
  publisher_id?: string;
  platform_id?: string;
  difficulty?: string;
};

async function fetchContentsByTab(
  supabase: any,
  tab: TabKey,
  studentId: string,
  filters: ContentFilters = {},
  sortBy: string = "created_at_desc",
  page: number = 1,
  itemsPerPage: number = 20
): Promise<{ list: ContentListItem[]; total: number; totalPages: number }> {
  try {
    if (tab === "books") {
      const selectBooks = () => {
        let query = supabase
          .from("books")
          .select(
            "id,title,revision,semester,subject_category,subject,publisher,difficulty_level,total_pages,master_content_id,curriculum_revision_id,subject_group_id,subject_id,publisher_id,created_at"
          );

        // í•„í„° ì ìš©
        if (filters.search) {
          query = query.ilike("title", `%${filters.search}%`);
        }
        if (filters.curriculum_revision_id) {
          query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
        }
        if (filters.subject_group_id) {
          query = query.eq("subject_group_id", filters.subject_group_id);
        }
        if (filters.subject_id) {
          query = query.eq("subject_id", filters.subject_id);
        }
        if (filters.publisher_id) {
          query = query.eq("publisher_id", filters.publisher_id);
        }
        if (filters.difficulty) {
          query = query.eq("difficulty_level", filters.difficulty);
        }

        // ì •ë ¬
        if (sortBy === "title_asc") {
          query = query.order("title", { ascending: true });
        } else if (sortBy === "title_desc") {
          query = query.order("title", { ascending: false });
        } else if (sortBy === "difficulty_level_asc") {
          query = query.order("difficulty_level", { ascending: true });
        } else if (sortBy === "difficulty_level_desc") {
          query = query.order("difficulty_level", { ascending: false });
        } else if (sortBy === "created_at_asc") {
          query = query.order("created_at", { ascending: true });
        } else {
          // created_at_desc (ê¸°ë³¸ê°’)
          query = query.order("created_at", { ascending: false });
        }

        return query;
      };

      // ì „ì²´ ê°œìˆ˜ ì¡°íšŒ (í•„í„° ì ìš©ëœ ì¿¼ë¦¬ ì‚¬ìš©)
      const countQuery = selectBooks();
      let { count, error: countError } = await countQuery
        .eq("student_id", studentId)
        .select("*", { count: "exact", head: true });
      
      if (countError && countError.code === "42703") {
        const countQuery2 = selectBooks();
        const { count: count2 } = await countQuery2.select("*", { count: "exact", head: true });
        count = count2;
      }
      
      const total = count ?? 0;
      const totalPages = Math.ceil(total / itemsPerPage);
      const from = (page - 1) * itemsPerPage;
      const to = from + itemsPerPage - 1;

      // í˜ì´ì§€ë„¤ì´ì…˜ ì ìš©
      const dataQuery = selectBooks();
      let { data, error } = await dataQuery
        .eq("student_id", studentId)
        .range(from, to);
      
      if (error && error.code === "42703") {
        const dataQuery2 = selectBooks();
        ({ data, error } = await dataQuery2.range(from, to));
      }
      if (error) throw error;
      
      return { list: data ?? [], total, totalPages };
    }

    if (tab === "lectures") {
      const selectLectures = () => {
        let query = supabase
          .from("lectures")
          .select(
            "id,title,revision,semester,subject_category,subject,platform,difficulty_level,duration,total_episodes,linked_book_id,master_content_id,curriculum_revision_id,subject_group_id,subject_id,platform_id,created_at"
          );

        // í•„í„° ì ìš©
        if (filters.search) {
          query = query.ilike("title", `%${filters.search}%`);
        }
        if (filters.curriculum_revision_id) {
          query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
        }
        if (filters.subject_group_id) {
          query = query.eq("subject_group_id", filters.subject_group_id);
        }
        if (filters.subject_id) {
          query = query.eq("subject_id", filters.subject_id);
        }
        if (filters.platform_id) {
          query = query.eq("platform_id", filters.platform_id);
        }
        if (filters.difficulty) {
          query = query.eq("difficulty_level", filters.difficulty);
        }

        // ì •ë ¬
        if (sortBy === "title_asc") {
          query = query.order("title", { ascending: true });
        } else if (sortBy === "title_desc") {
          query = query.order("title", { ascending: false });
        } else if (sortBy === "difficulty_level_asc") {
          query = query.order("difficulty_level", { ascending: true });
        } else if (sortBy === "difficulty_level_desc") {
          query = query.order("difficulty_level", { ascending: false });
        } else if (sortBy === "created_at_asc") {
          query = query.order("created_at", { ascending: true });
        } else {
          // created_at_desc (ê¸°ë³¸ê°’)
          query = query.order("created_at", { ascending: false });
        }

        return query;
      };

      // ì „ì²´ ê°œìˆ˜ ì¡°íšŒ (í•„í„° ì ìš©ëœ ì¿¼ë¦¬ ì‚¬ìš©)
      const countQuery = selectLectures();
      let { count, error: countError } = await countQuery
        .eq("student_id", studentId)
        .select("*", { count: "exact", head: true });
      
      if (countError && countError.code === "42703") {
        const countQuery2 = selectLectures();
        const { count: count2 } = await countQuery2.select("*", { count: "exact", head: true });
        count = count2;
      }
      
      const total = count ?? 0;
      const totalPages = Math.ceil(total / itemsPerPage);
      const from = (page - 1) * itemsPerPage;
      const to = from + itemsPerPage - 1;

      // í˜ì´ì§€ë„¤ì´ì…˜ ì ìš©
      const dataQuery = selectLectures();
      let { data, error } = await dataQuery
        .eq("student_id", studentId)
        .range(from, to);
      
      if (error && error.code === "42703") {
        const dataQuery2 = selectLectures();
        ({ data, error } = await dataQuery2.range(from, to));
      }
      if (error) throw error;
      
      return { list: data ?? [], total, totalPages };
    }

    if (tab === "custom") {
      const selectCustomContents = () => {
        let query = supabase
          .from("student_custom_contents")
          .select(
            "id,title,content_type,total_page_or_time,subject,created_at"
          );

        // í•„í„° ì ìš©
        if (filters.search) {
          query = query.ilike("title", `%${filters.search}%`);
        }
        if (filters.subject_id) {
          // subject_idëŠ” student_custom_contentsì— ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ subjectë¡œ í•„í„°ë§
          // ì‹¤ì œë¡œëŠ” subject í•„ë“œë¡œë§Œ í•„í„°ë§ ê°€ëŠ¥
        }

        // ì •ë ¬
        if (sortBy === "title_asc") {
          query = query.order("title", { ascending: true });
        } else if (sortBy === "title_desc") {
          query = query.order("title", { ascending: false });
        } else if (sortBy === "created_at_asc") {
          query = query.order("created_at", { ascending: true });
        } else {
          // created_at_desc (ê¸°ë³¸ê°’)
          query = query.order("created_at", { ascending: false });
        }

        return query;
      };

      // ì „ì²´ ê°œìˆ˜ ì¡°íšŒ
      const countQuery = selectCustomContents();
      let { count, error: countError } = await countQuery
        .eq("student_id", studentId)
        .select("*", { count: "exact", head: true });
      
      if (countError && countError.code === "42703") {
        const countQuery2 = selectCustomContents();
        const { count: count2 } = await countQuery2.select("*", { count: "exact", head: true });
        count = count2;
      }
      
      const total = count ?? 0;
      const totalPages = Math.ceil(total / itemsPerPage);
      const from = (page - 1) * itemsPerPage;
      const to = from + itemsPerPage - 1;

      // í˜ì´ì§€ë„¤ì´ì…˜ ì ìš©
      const dataQuery = selectCustomContents();
      let { data, error } = await dataQuery
        .eq("student_id", studentId)
        .range(from, to);
      
      if (error && error.code === "42703") {
        const dataQuery2 = selectCustomContents();
        ({ data, error } = await dataQuery2.range(from, to));
      }
      if (error) throw error;
      
      return { list: data ?? [], total, totalPages };
    }

    return { list: [], total: 0, totalPages: 0 };
  } catch (err) {
    console.error(err);
    return { list: [], total: 0, totalPages: 0 };
  }
}

// í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•¨ìˆ˜ export
export function getDetailRows(tab: TabKey, item: ContentListItem): Row[] {
  if (tab === "books") {
    return [
      { label: "ê°œì •êµìœ¡ê³¼ì •", value: item.revision ?? null },
      { label: "êµê³¼", value: item.subject_category ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      { label: "ì¶œíŒì‚¬", value: item.publisher ?? null },
      { label: "ë‚œì´ë„", value: item.difficulty_level ?? null },
      {
        label: "ì´ í˜ì´ì§€",
        value: item.total_pages ? `${item.total_pages}p` : null,
      },
    ];
  }

  if (tab === "lectures") {
    return [
      { label: "ê°œì •êµìœ¡ê³¼ì •", value: item.revision ?? null },
      { label: "êµê³¼", value: item.subject_category ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      { label: "í”Œë«í¼", value: item.platform ?? null },
      { label: "ë‚œì´ë„", value: item.difficulty_level ?? null },
      {
        label: "ì´ íšŒì°¨",
        value: item.total_episodes ? `${item.total_episodes}íšŒ` : null,
      },
      {
        label: "ì¬ìƒ ì‹œê°„",
        value: item.duration ? `${Math.round(item.duration / 60)}ë¶„` : null,
      },
    ];
  }

  if (tab === "custom") {
    return [
      { label: "ì½˜í…ì¸  ìœ í˜•", value: item.content_type ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      {
        label: item.content_type === "book" ? "ì´ í˜ì´ì§€" : "ì´ ì‹œê°„",
        value: item.total_page_or_time
          ? item.content_type === "book"
            ? `${item.total_page_or_time}p`
            : `${item.total_page_or_time}ë¶„`
          : null,
      },
    ];
  }

  return [];
}

export function getSubText(tab: TabKey, item: ContentListItem): string {
  if (tab === "books") return item.publisher || "ì¶œíŒì‚¬ ì •ë³´ ì—†ìŒ";
  if (tab === "lectures") return item.platform || "í”Œë«í¼ ì •ë³´ ì—†ìŒ";
  if (tab === "custom") return item.content_type || "ìœ í˜• ì •ë³´ ì—†ìŒ";
  return "";
}
</file>

<file path="_components/ContentsListClient.tsx">
"use client";

import Link from "next/link";
import { ContentCard } from "./ContentCard";
import { Pagination } from "./Pagination";
import { useSelection } from "./SelectionContext";
import {
  deleteBook,
  deleteLecture,
  deleteCustomContent,
} from "@/app/(student)/actions/contentActions";
import type { ContentListItem } from "./ContentsList";

type TabKey = "books" | "lectures" | "custom";

type Row = { label: string; value: string | number | null };

type ContentsListClientProps = {
  list: ContentListItem[];
  activeTab: TabKey;
  deleteBook: (id: string) => Promise<void>;
  deleteLecture: (id: string) => Promise<void>;
  deleteCustomContent: (id: string) => Promise<void>;
};

function getDetailRows(tab: TabKey, item: ContentListItem): Row[] {
  if (tab === "books") {
    return [
      { label: "ê°œì •êµìœ¡ê³¼ì •", value: item.revision ?? null },
      { label: "í•™ë…„/í•™ê¸°", value: item.semester ?? null },
      { label: "êµê³¼", value: item.subject_category ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      { label: "ì¶œíŒì‚¬", value: item.publisher ?? null },
      { label: "ë‚œì´ë„", value: item.difficulty_level ?? null },
      {
        label: "ì´ í˜ì´ì§€",
        value: item.total_pages ? `${item.total_pages}p` : null,
      },
    ];
  }

  if (tab === "lectures") {
    return [
      { label: "ê°œì •êµìœ¡ê³¼ì •", value: item.revision ?? null },
      { label: "í•™ë…„/í•™ê¸°", value: item.semester ?? null },
      { label: "êµê³¼", value: item.subject_category ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      { label: "í”Œë«í¼", value: item.platform ?? null },
      { label: "ë‚œì´ë„", value: item.difficulty_level ?? null },
      {
        label: "ì´ íšŒì°¨",
        value: item.total_episodes ? `${item.total_episodes}íšŒ` : null,
      },
      {
        label: "ì¬ìƒ ì‹œê°„",
        value: item.duration ? `${Math.round(item.duration / 60)}ë¶„` : null,
      },
    ];
  }

  if (tab === "custom") {
    return [
      { label: "ì½˜í…ì¸  ìœ í˜•", value: item.content_type ?? null },
      { label: "ê³¼ëª©", value: item.subject ?? null },
      {
        label: item.content_type === "book" ? "ì´ í˜ì´ì§€" : "ì´ ì‹œê°„",
        value: item.total_page_or_time
          ? item.content_type === "book"
            ? `${item.total_page_or_time}p`
            : `${item.total_page_or_time}ë¶„`
          : null,
      },
    ];
  }

  return [];
}

function getSubText(tab: TabKey, item: ContentListItem): string {
  if (tab === "books") return item.publisher || "ì¶œíŒì‚¬ ì •ë³´ ì—†ìŒ";
  if (tab === "lectures") return item.platform || "í”Œë«í¼ ì •ë³´ ì—†ìŒ";
  if (tab === "custom") return item.content_type || "ìœ í˜• ì •ë³´ ì—†ìŒ";
  return "";
}

export function ContentsListClient({
  list,
  activeTab,
  deleteBook,
  deleteLecture,
  deleteCustomContent,
}: ContentsListClientProps) {
  const { selectedIds, select, selectAll } = useSelection();

  const allIds = list.map((item) => item.id);
  const allSelected = allIds.length > 0 && allIds.every((id) => selectedIds.has(id));
  const someSelected = allIds.some((id) => selectedIds.has(id));

  const getDeleteHandler = () => {
    if (activeTab === "books") return deleteBook;
    if (activeTab === "lectures") return deleteLecture;
    if (activeTab === "custom") return deleteCustomContent;
    return deleteBook;
  };

  return (
    <div className="flex flex-col gap-4">
      {/* ì „ì²´ ì„ íƒ ì²´í¬ë°•ìŠ¤ */}
      {list.length > 0 && (
        <div className="flex items-center gap-2 px-1">
          <input
            type="checkbox"
            checked={allSelected}
            ref={(input) => {
              if (input) {
                input.indeterminate = someSelected && !allSelected;
              }
            }}
            onChange={(e) => selectAll(e.target.checked, allIds)}
            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
          />
          <label 
            className="text-sm font-medium text-gray-700 cursor-pointer"
            onClick={() => selectAll(!allSelected, allIds)}
          >
            ì „ì²´ ì„ íƒ
          </label>
        </div>
      )}

      <ul className="grid gap-4">
        {list.map((item) => (
          <ContentCard
            key={item.id}
            item={item}
            activeTab={activeTab}
            onDelete={getDeleteHandler()}
            detailRows={getDetailRows(activeTab, item)}
            subText={getSubText(activeTab, item)}
            linkedBook={item.linkedBook}
            isSelected={selectedIds.has(item.id)}
            onSelect={(checked) => select(item.id, checked)}
          />
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="_components/ContentsListWrapper.tsx">
"use client";

import { SelectionProvider, useSelection } from "./SelectionContext";
import { SelectionToolbar } from "./SelectionToolbar";

type TabKey = "books" | "lectures" | "custom";

type ContentsListWrapperProps = {
  activeTab: TabKey;
  children: React.ReactNode;
};

function ContentsListContent({ children }: { children: React.ReactNode }) {
  const { selectedIds, cancel, deleteSelected, isPending } = useSelection();
  const hasSelection = selectedIds.size > 0;

  return (
    <div>
      {/* ì„ íƒ ëª¨ë“œ íˆ´ë°” */}
      {hasSelection && (
        <SelectionToolbar
          count={selectedIds.size}
          onCancel={cancel}
          onDelete={deleteSelected}
          isPending={isPending}
        />
      )}

      {children}
    </div>
  );
}

export function ContentsListWrapper({ activeTab, children }: ContentsListWrapperProps) {
  return (
    <SelectionProvider activeTab={activeTab}>
      <ContentsListContent>{children}</ContentsListContent>
    </SelectionProvider>
  );
}
</file>

<file path="_components/ContentStats.tsx">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type ContentStatsProps = {
  studentId: string;
};

export async function ContentStats({ studentId }: ContentStatsProps) {
  const supabase = await createSupabaseServerClient();

  // êµì¬ í†µê³„
  const { count: bookCount } = await supabase
    .from("books")
    .select("*", { count: "exact", head: true })
    .eq("student_id", studentId);

  // ê°•ì˜ í†µê³„
  const { count: lectureCount } = await supabase
    .from("lectures")
    .select("*", { count: "exact", head: true })
    .eq("student_id", studentId);

  // ì—°ê²°ëœ êµì¬ê°€ ìˆëŠ” ê°•ì˜ ìˆ˜
  const { count: linkedLectureCount } = await supabase
    .from("lectures")
    .select("*", { count: "exact", head: true })
    .eq("student_id", studentId)
    .not("linked_book_id", "is", null);

  // ì»¤ìŠ¤í…€ ì½˜í…ì¸  í†µê³„
  const { count: customContentCount } = await supabase
    .from("student_custom_contents")
    .select("*", { count: "exact", head: true })
    .eq("student_id", studentId);

  return (
    <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4">
      <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
        <div className="flex items-center gap-3">
          <div className="rounded-lg bg-indigo-100 p-2">
            <span className="text-2xl">ğŸ“š</span>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-600">ì´ êµì¬</p>
            <p className="text-2xl font-semibold text-gray-900">
              {bookCount ?? 0}
            </p>
          </div>
        </div>
      </div>

      <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
        <div className="flex items-center gap-3">
          <div className="rounded-lg bg-purple-100 p-2">
            <span className="text-2xl">ğŸ§</span>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-600">ì´ ê°•ì˜</p>
            <p className="text-2xl font-semibold text-gray-900">
              {lectureCount ?? 0}
            </p>
          </div>
        </div>
      </div>

      <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
        <div className="flex items-center gap-3">
          <div className="rounded-lg bg-emerald-100 p-2">
            <span className="text-2xl">ğŸ“</span>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-600">ì»¤ìŠ¤í…€ ì½˜í…ì¸ </p>
            <p className="text-2xl font-semibold text-gray-900">
              {customContentCount ?? 0}
            </p>
          </div>
        </div>
      </div>

      <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
        <div className="flex items-center gap-3">
          <div className="rounded-lg bg-green-100 p-2">
            <span className="text-2xl">ğŸ”—</span>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-600">ì—°ê²°ëœ êµì¬</p>
            <p className="text-2xl font-semibold text-gray-900">
              {linkedLectureCount ?? 0}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/ContentTabs.tsx">
"use client";

import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { cn } from "@/lib/cn";

type TabItem = {
  key: string;
  label: string;
};

type ContentTabsProps = {
  tabs: TabItem[];
  defaultTab?: string;
  className?: string;
};

export function ContentTabs({ tabs, defaultTab, className }: ContentTabsProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  if (!tabs || tabs.length === 0) return null;

  const activeTab = searchParams.get("tab") || defaultTab || tabs[0]?.key;

  const handleTabChange = (tabKey: string) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("tab", tabKey);
    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <div className={cn("border-b border-gray-200", className)}>
      <nav className="-mb-px flex gap-2" aria-label="íƒ­">
        {tabs.map((tab) => {
          const isActive = activeTab === tab.key;
          return (
            <button
              key={tab.key}
              type="button"
              onClick={() => handleTabChange(tab.key)}
              className={cn(
                "whitespace-nowrap border-b-2 px-4 py-3 text-sm font-semibold transition",
                isActive
                  ? "border-indigo-600 text-indigo-600"
                  : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
              )}
              aria-current={isActive ? "page" : undefined}
            >
              {tab.label}
            </button>
          );
        })}
      </nav>
    </div>
  );
}
</file>

<file path="_components/DeleteContentButton.tsx">
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";

type DeleteContentButtonProps = {
  id: string;
  contentType: "books" | "lectures" | "custom";
  onDelete: (id: string) => Promise<void>;
};

export function DeleteContentButton({
  id,
  contentType,
  onDelete,
}: DeleteContentButtonProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();

  const handleDelete = () => {
    if (!confirm("ì •ë§ë¡œ ì´ ì½˜í…ì¸ ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      return;
    }

    startTransition(async () => {
      try {
        await onDelete(id);
        router.refresh();
      } catch (err) {
        alert(
          err instanceof Error ? err.message : "ì½˜í…ì¸  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        );
      }
    });
  };

  return (
    <button
      type="button"
      onClick={handleDelete}
      disabled={isPending}
      className="inline-flex items-center justify-center rounded-lg border border-red-300 bg-white px-3 py-1.5 text-xs font-semibold text-red-700 transition hover:bg-red-50 disabled:cursor-not-allowed disabled:opacity-50"
    >
      {isPending ? "ì‚­ì œ ì¤‘..." : "ì‚­ì œ"}
    </button>
  );
}
</file>

<file path="_components/FilterBar.tsx">
"use client";

import Link from "next/link";

type TabKey = "books" | "lectures";

type FilterBarProps = {
  activeTab: TabKey;
  searchQuery?: string;
  subjectFilter?: string;
  subjectCategoryFilter?: string;
  semesterFilter?: string;
  revisionFilter?: string;
  publisherFilter?: string;
  platformFilter?: string;
  difficultyFilter?: string;
  sortBy: string;
  allSubjects: string[];
  allSubjectCategories: string[];
  allSemesters: string[];
  allRevisions: string[];
  allPublishers: string[];
  allPlatforms: string[];
  allDifficulties: string[];
};

export function FilterBar({
  activeTab,
  searchQuery,
  subjectFilter,
  subjectCategoryFilter,
  semesterFilter,
  revisionFilter,
  publisherFilter,
  platformFilter,
  difficultyFilter,
  sortBy,
  allSubjects,
  allSubjectCategories,
  allSemesters,
  allRevisions,
  allPublishers,
  allPlatforms,
  allDifficulties,
}: FilterBarProps) {
  const baseUrl =
    activeTab === "books" ? "/contents" : `/contents?tab=${activeTab}`;

  const hasAnyFilter =
    searchQuery ||
    subjectFilter ||
    subjectCategoryFilter ||
    semesterFilter ||
    revisionFilter ||
    publisherFilter ||
    platformFilter ||
    difficultyFilter;

  return (
    <form
      action={baseUrl}
      method="get"
      className="flex flex-wrap items-end gap-3"
    >
      {activeTab !== "books" && (
        <input type="hidden" name="tab" value={activeTab} />
      )}

      {/* ê²€ìƒ‰ */}
      <div className="flex flex-col gap-1 w-full sm:w-auto sm:min-w-[200px]">
        <label className="text-xs font-medium text-gray-700">
          ê²€ìƒ‰
        </label>
        <input
          type="text"
          name="search"
          defaultValue={searchQuery ?? ""}
          placeholder={activeTab === "books" ? "êµì¬ëª…ìœ¼ë¡œ ê²€ìƒ‰..." : "ê°•ì˜ëª…ìœ¼ë¡œ ê²€ìƒ‰..."}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        />
      </div>

      {/* ê°œì •êµìœ¡ê³¼ì • */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">
          ê°œì •êµìœ¡ê³¼ì •
        </label>
        <select
          name="revision"
          defaultValue={revisionFilter ?? ""}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="">ì „ì²´</option>
          {allRevisions.map((rev) => (
            <option key={rev} value={rev}>
              {rev}
            </option>
          ))}
        </select>
      </div>

      {/* í•™ë…„/í•™ê¸° */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">í•™ë…„/í•™ê¸°</label>
        <select
          name="semester"
          defaultValue={semesterFilter ?? ""}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="">ì „ì²´</option>
          {allSemesters.map((sem) => (
            <option key={sem} value={sem}>
              {sem}
            </option>
          ))}
        </select>
      </div>

      {/* êµê³¼ */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">êµê³¼</label>
        <select
          name="subject_category"
          defaultValue={subjectCategoryFilter ?? ""}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="">ì „ì²´</option>
          {allSubjectCategories.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
      </div>

      {/* ê³¼ëª© */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">ê³¼ëª©</label>
        <select
          name="subject"
          defaultValue={subjectFilter ?? ""}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="">ì „ì²´</option>
          {allSubjects.map((subject) => (
            <option key={subject} value={subject}>
              {subject}
            </option>
          ))}
        </select>
      </div>

      {/* ì¶œíŒì‚¬ (êµì¬ë§Œ) */}
      {activeTab === "books" && (
        <div className="flex flex-col gap-1">
          <label className="text-xs font-medium text-gray-700">ì¶œíŒì‚¬</label>
          <select
            name="publisher"
            defaultValue={publisherFilter ?? ""}
            className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
          >
            <option value="">ì „ì²´</option>
            {allPublishers.map((pub) => (
              <option key={pub} value={pub}>
                {pub}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* í”Œë«í¼ (ê°•ì˜ë§Œ) */}
      {activeTab === "lectures" && (
        <div className="flex flex-col gap-1">
          <label className="text-xs font-medium text-gray-700">í”Œë«í¼</label>
          <select
            name="platform"
            defaultValue={platformFilter ?? ""}
            className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
          >
            <option value="">ì „ì²´</option>
            {allPlatforms.map((plat) => (
              <option key={plat} value={plat}>
                {plat}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* ë‚œì´ë„ */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">ë‚œì´ë„</label>
        <select
          name="difficulty"
          defaultValue={difficultyFilter ?? ""}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="">ì „ì²´</option>
          {allDifficulties.map((diff) => (
            <option key={diff} value={diff}>
              {diff}
            </option>
          ))}
        </select>
      </div>

      {/* ì •ë ¬ */}
      <div className="flex flex-col gap-1">
        <label className="text-xs font-medium text-gray-700">ì •ë ¬</label>
        <select
          name="sort"
          defaultValue={sortBy}
          className="rounded-md border border-gray-300 px-3 py-1.5 text-sm focus:border-gray-900 focus:outline-none"
        >
          <option value="created_at_desc">ìµœì‹ ìˆœ</option>
          <option value="created_at_asc">ì˜¤ë˜ëœìˆœ</option>
          <option value="title_asc">ì œëª© ê°€ë‚˜ë‹¤ìˆœ</option>
          <option value="title_desc">ì œëª© ì—­ìˆœ</option>
          <option value="difficulty_level_asc">ë‚œì´ë„ ë‚®ì€ìˆœ</option>
          <option value="difficulty_level_desc">ë‚œì´ë„ ë†’ì€ìˆœ</option>
        </select>
      </div>

      {/* ê²€ìƒ‰ ë²„íŠ¼ */}
      <button
        type="submit"
        className="rounded-lg bg-indigo-600 px-4 py-1.5 text-sm font-semibold text-white transition hover:bg-indigo-700 whitespace-nowrap"
      >
        ê²€ìƒ‰
      </button>

      {/* í•„í„° ì´ˆê¸°í™” */}
      {hasAnyFilter && (
        <Link
          href={baseUrl}
          className="rounded-lg border border-gray-300 bg-white px-4 py-1.5 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          ì´ˆê¸°í™”
        </Link>
      )}
    </form>
  );
}
</file>

<file path="_components/FilterDrawer.tsx">
"use client";

import { useState } from "react";
import { FilterBar } from "./FilterBar";

type FilterDrawerProps = {
  activeTab: "books" | "lectures";
  searchQuery?: string;
  subjectFilter?: string;
  subjectCategoryFilter?: string;
  semesterFilter?: string;
  revisionFilter?: string;
  publisherFilter?: string;
  platformFilter?: string;
  difficultyFilter?: string;
  sortBy: string;
  allSubjects: string[];
  allSubjectCategories: string[];
  allSemesters: string[];
  allRevisions: string[];
  allPublishers: string[];
  allPlatforms: string[];
  allDifficulties: string[];
};

export function FilterDrawer({
  activeTab,
  searchQuery,
  subjectFilter,
  subjectCategoryFilter,
  semesterFilter,
  revisionFilter,
  publisherFilter,
  platformFilter,
  difficultyFilter,
  sortBy,
  allSubjects,
  allSubjectCategories,
  allSemesters,
  allRevisions,
  allPublishers,
  allPlatforms,
  allDifficulties,
}: FilterDrawerProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      {/* ëª¨ë°”ì¼: í•„í„° ë²„íŠ¼ */}
      <div className="sm:hidden">
        <button
          type="button"
          onClick={() => setIsOpen(true)}
          className="w-full rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          ğŸ” í•„í„° ë° ê²€ìƒ‰
        </button>
      </div>

      {/* ëª¨ë°”ì¼: ë“œë¡œì–´ ì˜¤ë²„ë ˆì´ */}
      {isOpen && (
        <div
          className="fixed inset-0 z-50 bg-black/50 sm:hidden"
          onClick={() => setIsOpen(false)}
        />
      )}

      {/* ëª¨ë°”ì¼: ë“œë¡œì–´ */}
      <div
        className={`fixed inset-y-0 right-0 z-50 w-full max-w-sm bg-white shadow-xl transition-transform duration-300 sm:hidden ${
          isOpen ? "translate-x-0" : "translate-x-full"
        }`}
      >
        <div className="flex h-full flex-col">
          {/* í—¤ë” */}
          <div className="flex items-center justify-between border-b border-gray-200 px-4 py-4">
            <h2 className="text-lg font-semibold text-gray-900">í•„í„° ë° ê²€ìƒ‰</h2>
            <button
              type="button"
              onClick={() => setIsOpen(false)}
              className="rounded-lg p-1 text-gray-400 hover:bg-gray-100 hover:text-gray-600"
            >
              âœ•
            </button>
          </div>

          {/* í•„í„° ë‚´ìš© */}
          <div className="flex-1 overflow-y-auto px-4 py-4">
            <div className="space-y-4">
              <FilterBar
                activeTab={activeTab}
                searchQuery={searchQuery}
                subjectFilter={subjectFilter}
                subjectCategoryFilter={subjectCategoryFilter}
                semesterFilter={semesterFilter}
                revisionFilter={revisionFilter}
                publisherFilter={publisherFilter}
                platformFilter={platformFilter}
                difficultyFilter={difficultyFilter}
                sortBy={sortBy}
                allSubjects={allSubjects}
                allSubjectCategories={allSubjectCategories}
                allSemesters={allSemesters}
                allRevisions={allRevisions}
                allPublishers={allPublishers}
                allPlatforms={allPlatforms}
                allDifficulties={allDifficulties}
              />
            </div>
          </div>
        </div>
      </div>

      {/* ë°ìŠ¤í¬í†±: ê¸°ë³¸ í•„í„° ë°” */}
      <div className="hidden sm:block">
        <FilterBar
          activeTab={activeTab}
          searchQuery={searchQuery}
          subjectFilter={subjectFilter}
          subjectCategoryFilter={subjectCategoryFilter}
          semesterFilter={semesterFilter}
          revisionFilter={revisionFilter}
          publisherFilter={publisherFilter}
          platformFilter={platformFilter}
          difficultyFilter={difficultyFilter}
          sortBy={sortBy}
          allSubjects={allSubjects}
          allSubjectCategories={allSubjectCategories}
          allSemesters={allSemesters}
          allRevisions={allRevisions}
          allPublishers={allPublishers}
          allPlatforms={allPlatforms}
          allDifficulties={allDifficulties}
        />
      </div>
    </>
  );
}
</file>

<file path="_components/FilterOptions.tsx">
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { unstable_cache } from "next/cache";
import { cookies } from "next/headers";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { FilterBar } from "./FilterBar";
import { FilterDrawer } from "./FilterDrawer";

type TabKey = "books" | "lectures";

type FilterOptionsProps = {
  activeTab: TabKey;
  studentId: string;
  filters: {
    search?: string;
    subject?: string;
    subject_category?: string;
    semester?: string;
    revision?: string;
    publisher?: string;
    platform?: string;
    difficulty?: string;
  };
  sortBy: string;
  searchQuery?: string;
};

async function FilterOptionsContent({
  activeTab,
  studentId,
  filters,
  sortBy,
  searchQuery,
}: FilterOptionsProps) {
  // cookies()ë¥¼ unstable_cache() ì™¸ë¶€ì—ì„œ í˜¸ì¶œ
  const cookieStore = await cookies();

  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ìºì‹± ì ìš©)
  const getCachedFilterOptions = unstable_cache(
    async (tab: TabKey, userId: string) => {
      // ìºì‹œ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì¿ í‚¤ ìŠ¤í† ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ Supabase í´ë¼ì´ì–¸íŠ¸ ìƒì„±
      const supabaseInstance = await createSupabaseServerClient(cookieStore);
      const [allSubjects, allSubjectCategories, allSemesters, allRevisions, allPublishers, allPlatforms, allDifficulties] = await Promise.all([
        fetchDistinctValues(supabaseInstance, tab, userId, "subject"),
        fetchDistinctValues(supabaseInstance, tab, userId, "subject_category"),
        fetchDistinctValues(supabaseInstance, tab, userId, "semester"),
        fetchDistinctValues(supabaseInstance, tab, userId, "revision"),
        tab === "books" ? fetchDistinctValues(supabaseInstance, tab, userId, "publisher") : Promise.resolve([]),
        tab === "lectures" ? fetchDistinctValues(supabaseInstance, tab, userId, "platform") : Promise.resolve([]),
        fetchDistinctValues(supabaseInstance, tab, userId, "difficulty_level"),
      ]);

      return {
        allSubjects,
        allSubjectCategories,
        allSemesters,
        allRevisions,
        allPublishers,
        allPlatforms,
        allDifficulties,
      };
    },
    [`filter-options-${studentId}-${activeTab}`],
    {
      revalidate: 300, // 5ë¶„ ìºì‹œ
      tags: [`filter-options-${studentId}-${activeTab}`],
    }
  );

  const filterOptions = await getCachedFilterOptions(activeTab, studentId);

  return (
    <FilterDrawer
      activeTab={activeTab}
      searchQuery={searchQuery}
      subjectFilter={filters.subject}
      subjectCategoryFilter={filters.subject_category}
      semesterFilter={filters.semester}
      revisionFilter={filters.revision}
      publisherFilter={filters.publisher}
      platformFilter={filters.platform}
      difficultyFilter={filters.difficulty}
      sortBy={sortBy}
      {...filterOptions}
    />
  );
}

export function FilterOptions(props: FilterOptionsProps) {
  return (
    <Suspense fallback={<SuspenseFallback />}>
      <FilterOptionsContent {...props} />
    </Suspense>
  );
}

async function fetchDistinctValues(
  supabase: any,
  tab: TabKey,
  studentId: string,
  fieldName: string
): Promise<string[]> {
  try {
    const tableName = tab === "books" ? "books" : "lectures";

    const selectQuery = () =>
      supabase
        .from(tableName)
        .select(fieldName)
        .not(fieldName, "is", null);

    let { data, error } = await selectQuery().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectQuery());
    }
    if (error) throw error;

    const values = new Set<string>();
    (data ?? []).forEach((item: Record<string, string | null>) => {
      const value = item[fieldName];
      if (value) values.add(value);
    });
    return Array.from(values).sort();
  } catch (err) {
    console.error(err);
    return [];
  }
}
</file>

<file path="_components/LectureEpisodesDisplay.tsx">
"use client";

import { useState, useMemo } from "react";
import { LectureEpisode } from "@/lib/types/plan";
import { secondsToMinutes } from "@/lib/utils/duration";

type LectureEpisodesDisplayProps = {
  episodes: LectureEpisode[];
};

export function LectureEpisodesDisplay({ episodes }: LectureEpisodesDisplayProps) {
  // episode ë²ˆí˜¸ë¡œ ì •ë ¬
  const sortedEpisodes = useMemo(() => {
    return [...episodes].sort((a, b) => {
      if (a.episode_number !== b.episode_number) {
        return a.episode_number - b.episode_number;
      }
      return a.display_order - b.display_order;
    });
  }, [episodes]);

  if (sortedEpisodes.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col gap-4 border-t pt-8">
      <h3 className="text-lg font-semibold text-gray-900">ê°•ì˜ íšŒì°¨ ì •ë³´</h3>
      <div className="overflow-x-auto">
        <table className="w-full border-collapse text-sm">
          <thead>
            <tr className="border-b bg-gray-50">
              <th className="px-4 py-2 text-left font-semibold text-gray-700">íšŒì°¨</th>
              <th className="px-4 py-2 text-left font-semibold text-gray-700">ì œëª©</th>
              <th className="px-4 py-2 text-left font-semibold text-gray-700">ì‹œê°„</th>
            </tr>
          </thead>
          <tbody>
            {sortedEpisodes.map((episode) => (
              <tr
                key={episode.id}
                className="border-b transition hover:bg-gray-50"
              >
                <td className="px-4 py-2 text-gray-900">
                  {episode.episode_number}íšŒ
                </td>
                <td className="px-4 py-2 text-gray-600">
                  {episode.episode_title || "â€”"}
                </td>
                <td className="px-4 py-2 text-gray-600">
                  {episode.duration ? `${secondsToMinutes(episode.duration)}ë¶„` : "â€”"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}
</file>

<file path="_components/LectureEpisodesManager.tsx">
"use client";

import { useState, useMemo } from "react";
import { LectureEpisode } from "@/lib/types/plan";
import { secondsToMinutes } from "@/lib/utils/duration";

type LectureEpisodesManagerProps = {
  initialEpisodes?: LectureEpisode[];
  onChange?: (episodes: Omit<LectureEpisode, "id" | "created_at">[]) => void;
};

type EpisodeItem = Omit<LectureEpisode, "id" | "created_at"> & { tempId?: string };

export function LectureEpisodesManager({
  initialEpisodes = [],
  onChange,
}: LectureEpisodesManagerProps) {
  const [episodes, setEpisodes] = useState<EpisodeItem[]>(
    initialEpisodes.map((e) => ({
      lecture_id: e.lecture_id,
      episode_number: e.episode_number,
      episode_title: e.episode_title || "",
      duration: e.duration ? secondsToMinutes(e.duration) || 0 : 0,  // ì´ˆ â†’ ë¶„ ë³€í™˜
      display_order: e.display_order || 0,
      tempId: e.id,
    }))
  );

  const updateEpisodes = (newEpisodes: EpisodeItem[]) => {
    // display_order ì¬ê³„ì‚°
    let order = 0;
    const updated = newEpisodes.map((e) => ({
      ...e,
      display_order: order++,
    }));

    setEpisodes(updated);
    onChange?.(
      updated.map((e) => ({
        lecture_id: e.lecture_id,
        episode_number: e.episode_number,
        episode_title: e.episode_title || null,
        duration: e.duration || null,
        display_order: e.display_order || 0,
      }))
    );
  };

  // Episode ì¶”ê°€
  const addEpisode = () => {
    const maxEpisodeNumber =
      episodes.length > 0
        ? Math.max(...episodes.map((e) => e.episode_number || 0))
        : 0;

    const newEpisode: EpisodeItem = {
      lecture_id: episodes[0]?.lecture_id || "",
      episode_number: maxEpisodeNumber + 1,
      episode_title: "",
      duration: 0,
      display_order: episodes.length,
      tempId: `temp-${Date.now()}`,
    };
    updateEpisodes([...episodes, newEpisode]);
  };

  // Episode ì‚­ì œ
  const removeEpisode = (tempId: string) => {
    updateEpisodes(episodes.filter((e) => e.tempId !== tempId));
  };

  // Episode ì—…ë°ì´íŠ¸
  const updateEpisode = (
    tempId: string,
    field: keyof EpisodeItem,
    value: string | number
  ) => {
    const newEpisodes = episodes.map((e) =>
      e.tempId === tempId ? { ...e, [field]: value } : e
    );
    updateEpisodes(newEpisodes);
  };

  // Episode ë²ˆí˜¸ë¡œ ì •ë ¬
  const sortedEpisodes = useMemo(() => {
    return [...episodes].sort((a, b) => {
      if (a.episode_number !== b.episode_number) {
        return a.episode_number - b.episode_number;
      }
      return a.display_order - b.display_order;
    });
  }, [episodes]);

  return (
    <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-gray-50 p-4">
      <div className="flex items-center justify-between">
        <h4 className="text-sm font-semibold text-gray-900">ê°•ì˜ íšŒì°¨ ì •ë³´</h4>
        <button
          type="button"
          onClick={addEpisode}
          className="rounded-md bg-indigo-600 px-3 py-1.5 text-xs font-semibold text-white transition hover:bg-indigo-700"
        >
          + íšŒì°¨ ì¶”ê°€
        </button>
      </div>

      {sortedEpisodes.length === 0 ? (
        <p className="py-4 text-center text-sm text-gray-500">
          íšŒì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. "+ íšŒì°¨ ì¶”ê°€" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”.
        </p>
      ) : (
        <div className="flex flex-col gap-3">
          {sortedEpisodes.map((episode, index) => (
            <div
              key={episode.tempId || index}
              className="flex flex-wrap gap-3 rounded-md border border-gray-200 bg-white p-3"
            >
              <div className="flex w-24 flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  íšŒì°¨
                </label>
                <input
                  type="number"
                  value={episode.episode_number || ""}
                  onChange={(e) =>
                    updateEpisode(
                      episode.tempId!,
                      "episode_number",
                      parseInt(e.target.value) || 0
                    )
                  }
                  min="1"
                  className="w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                />
              </div>

              <div className="flex min-w-[200px] flex-1 flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  íšŒì°¨ ì œëª©
                </label>
                <input
                  type="text"
                  value={episode.episode_title || ""}
                  onChange={(e) =>
                    updateEpisode(episode.tempId!, "episode_title", e.target.value)
                  }
                  placeholder="ì˜ˆ: 1ê°•. í•¨ìˆ˜ì˜ ê·¹í•œ"
                  className="w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                />
              </div>

              <div className="flex w-24 flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  ì‹œê°„(ë¶„)
                </label>
                <input
                  type="number"
                  value={episode.duration || ""}
                  onChange={(e) =>
                    updateEpisode(
                      episode.tempId!,
                      "duration",
                      parseInt(e.target.value) || 0
                    )
                  }
                  min="0"
                  placeholder="ë¶„"
                  className="w-full rounded-md border border-gray-300 px-2 py-1.5 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                />
              </div>

              <div className="flex items-end">
                <button
                  type="button"
                  onClick={() => {
                    if (confirm("ì´ íšŒì°¨ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                      removeEpisode(episode.tempId!);
                    }
                  }}
                  className="rounded-md border border-red-300 bg-white px-3 py-1.5 text-xs font-semibold text-red-600 transition hover:bg-red-50"
                >
                  ì‚­ì œ
                </button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Hidden input for form submission */}
      <input
        type="hidden"
        name="episodes"
        value={JSON.stringify(
          sortedEpisodes
            .filter((e) => e.episode_number > 0)
            .map((e) => ({
              episode_number: e.episode_number || 0,
              episode_title: e.episode_title || null,
              duration: e.duration || null,
              display_order: e.display_order || 0,
            }))
        )}
      />
    </div>
  );
}
</file>

<file path="_components/Pagination.tsx">
"use client";

import Link from "next/link";
import { useSearchParams } from "next/navigation";

type PaginationProps = {
  currentPage: number;
  totalPages: number;
  totalItems: number;
  activeTab: "books" | "lectures" | "custom";
  filters: {
    search?: string;
    curriculum_revision_id?: string;
    subject_group_id?: string;
    subject_id?: string;
    publisher_id?: string;
    platform_id?: string;
    difficulty?: string;
  };
  sortBy: string;
};

export function Pagination({
  currentPage,
  totalPages,
  totalItems,
  activeTab,
  filters,
  sortBy,
}: PaginationProps) {
  const searchParams = useSearchParams();

  const buildUrl = (page: number) => {
    const params = new URLSearchParams();
    
    if (activeTab === "lectures") {
      params.set("tab", "lectures");
    } else if (activeTab === "custom") {
      params.set("tab", "custom");
    }
    
    if (filters.search) params.set("search", filters.search);
    if (filters.curriculum_revision_id) params.set("curriculum_revision_id", filters.curriculum_revision_id);
    if (filters.subject_group_id) params.set("subject_group_id", filters.subject_group_id);
    if (filters.subject_id) params.set("subject_id", filters.subject_id);
    if (filters.publisher_id) params.set("publisher_id", filters.publisher_id);
    if (filters.platform_id) params.set("platform_id", filters.platform_id);
    if (filters.difficulty) params.set("difficulty", filters.difficulty);
    if (sortBy) params.set("sort", sortBy);
    if (page > 1) params.set("page", String(page));
    
    return `/contents${params.toString() ? `?${params.toString()}` : ""}`;
  };

  const getPageNumbers = () => {
    const pages: (number | string)[] = [];
    const maxVisible = 5;
    
    if (totalPages <= maxVisible) {
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      if (currentPage <= 3) {
        for (let i = 1; i <= 4; i++) {
          pages.push(i);
        }
        pages.push("...");
        pages.push(totalPages);
      } else if (currentPage >= totalPages - 2) {
        pages.push(1);
        pages.push("...");
        for (let i = totalPages - 3; i <= totalPages; i++) {
          pages.push(i);
        }
      } else {
        pages.push(1);
        pages.push("...");
        for (let i = currentPage - 1; i <= currentPage + 1; i++) {
          pages.push(i);
        }
        pages.push("...");
        pages.push(totalPages);
      }
    }
    
    return pages;
  };

  return (
    <div className="flex flex-col items-center gap-4 sm:flex-row sm:justify-between">
      <div className="text-sm text-gray-600">
        ì´ <span className="font-semibold text-gray-900">{totalItems}</span>ê°œ ì¤‘{" "}
        <span className="font-semibold text-gray-900">
          {(currentPage - 1) * 20 + 1}-{Math.min(currentPage * 20, totalItems)}
        </span>
        ê°œ í‘œì‹œ
      </div>
      
      <div className="flex items-center gap-2">
        {/* ì´ì „ ë²„íŠ¼ */}
        {currentPage > 1 ? (
          <Link
            href={buildUrl(currentPage - 1)}
            className="rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì´ì „
          </Link>
        ) : (
          <span className="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-sm font-semibold text-gray-400 cursor-not-allowed">
            ì´ì „
          </span>
        )}

        {/* í˜ì´ì§€ ë²ˆí˜¸ */}
        <div className="flex items-center gap-1">
          {getPageNumbers().map((page, index) => {
            if (page === "...") {
              return (
                <span key={`ellipsis-${index}`} className="px-2 text-gray-400">
                  ...
                </span>
              );
            }
            
            const pageNum = page as number;
            const isActive = pageNum === currentPage;
            
            return (
              <Link
                key={pageNum}
                href={buildUrl(pageNum)}
                className={`rounded-lg px-3 py-2 text-sm font-semibold transition ${
                  isActive
                    ? "bg-indigo-600 text-white"
                    : "border border-gray-300 bg-white text-gray-700 hover:bg-gray-50"
                }`}
              >
                {pageNum}
              </Link>
            );
          })}
        </div>

        {/* ë‹¤ìŒ ë²„íŠ¼ */}
        {currentPage < totalPages ? (
          <Link
            href={buildUrl(currentPage + 1)}
            className="rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ë‹¤ìŒ
          </Link>
        ) : (
          <span className="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-sm font-semibold text-gray-400 cursor-not-allowed">
            ë‹¤ìŒ
          </span>
        )}
      </div>
    </div>
  );
}
</file>

<file path="_components/SelectionContext.tsx">
"use client";

import { createContext, useContext, useState, useTransition, ReactNode, useMemo, useCallback } from "react";
import { useRouter } from "next/navigation";
import { deleteBooks, deleteLectures, deleteCustomContent } from "@/app/(student)/actions/contentActions";

type TabKey = "books" | "lectures" | "custom";

type SelectionContextType = {
  selectedIds: Set<string>;
  select: (id: string, checked: boolean) => void;
  selectAll: (checked: boolean, allIds: string[]) => void;
  cancel: () => void;
  deleteSelected: () => void;
  isPending: boolean;
  activeTab: TabKey;
};

const SelectionContext = createContext<SelectionContextType | null>(null);

export function useSelection() {
  const context = useContext(SelectionContext);
  if (!context) {
    throw new Error("useSelection must be used within SelectionProvider");
  }
  return context;
}

type SelectionProviderProps = {
  children: ReactNode;
  activeTab: TabKey;
};

export function SelectionProvider({ children, activeTab }: SelectionProviderProps) {
  const router = useRouter();
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [isPending, startTransition] = useTransition();

  const select = useCallback((id: string, checked: boolean) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (checked) {
        next.add(id);
      } else {
        next.delete(id);
      }
      return next;
    });
  }, []);

  const selectAll = useCallback((checked: boolean, allIds: string[]) => {
    if (checked) {
      setSelectedIds(new Set(allIds));
    } else {
      setSelectedIds(new Set());
    }
  }, []);

  const cancel = useCallback(() => {
    setSelectedIds(new Set());
  }, []);

  const deleteSelected = useCallback(() => {
    if (selectedIds.size === 0) {
      return;
    }

    const ids = Array.from(selectedIds);
    const count = ids.length;
    
    const contentTypeLabel = activeTab === "books" ? "ì±…" : activeTab === "lectures" ? "ê°•ì˜" : "ì»¤ìŠ¤í…€ ì½˜í…ì¸ ";
    if (!confirm(`ì„ íƒí•œ ${count}ê°œì˜ ${contentTypeLabel}ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      return;
    }

    startTransition(async () => {
      try {
        if (activeTab === "books") {
          await deleteBooks(ids);
        } else if (activeTab === "lectures") {
          await deleteLectures(ids);
        } else if (activeTab === "custom") {
          // ì»¤ìŠ¤í…€ ì½˜í…ì¸ ëŠ” í•˜ë‚˜ì”© ì‚­ì œ
          for (const id of ids) {
            await deleteCustomContent(id);
          }
        }
        setSelectedIds(new Set());
        router.refresh();
      } catch (err) {
        alert(
          err instanceof Error ? err.message : "ì½˜í…ì¸  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        );
      }
    });
  }, [selectedIds.size, activeTab, router]);

  // Context valueë¥¼ ë©”ëª¨ì´ì œì´ì…˜í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  const contextValue = useMemo(
    () => ({
      selectedIds,
      select,
      selectAll,
      cancel,
      deleteSelected,
      isPending,
      activeTab,
    }),
    [selectedIds, select, selectAll, cancel, deleteSelected, isPending, activeTab]
  );

  return (
    <SelectionContext.Provider value={contextValue}>
      {children}
    </SelectionContext.Provider>
  );
}
</file>

<file path="_components/SelectionToolbar.tsx">
"use client";

import { inlineButtonBase } from "@/lib/utils/darkMode";

type SelectionToolbarProps = {
  count: number;
  onCancel: () => void;
  onDelete: () => void;
  isPending: boolean;
};

export function SelectionToolbar({
  count,
  onCancel,
  onDelete,
  isPending,
}: SelectionToolbarProps) {
  return (
    <div className="flex items-center justify-between rounded-lg border border-indigo-200 dark:border-indigo-800 bg-indigo-50 dark:bg-indigo-900/30 px-4 py-3">
      <div className="flex items-center gap-2">
        <span className="text-sm font-semibold text-indigo-900 dark:text-indigo-200">
          {count}ê°œ ì„ íƒë¨
        </span>
      </div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onCancel}
          disabled={isPending}
          className={inlineButtonBase("px-4 py-2 text-sm font-semibold disabled:cursor-not-allowed disabled:opacity-50")}
        >
          ì·¨ì†Œ
        </button>
        <button
          type="button"
          onClick={onDelete}
          disabled={isPending}
          className="inline-flex items-center justify-center rounded-lg border border-red-300 dark:border-red-700 bg-red-600 dark:bg-red-700 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700 dark:hover:bg-red-600 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {isPending ? "ì‚­ì œ ì¤‘..." : `ì„ íƒí•œ í•­ëª© ì‚­ì œ (${count}ê°œ)`}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="books/[id]/_components/BookDetailsSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { BookDetailsDisplay } from "@/app/(student)/contents/_components/BookDetailsDisplay";
import { BookDetailsManager } from "@/app/(student)/contents/_components/BookDetailsManager";
import { saveBookDetailsAction } from "@/app/(student)/actions/contentDetailsActions";
import { BookDetail } from "@/lib/types/plan";

type BookDetailsSectionProps = {
  bookId: string;
  initialDetails: BookDetail[];
  isFromMaster: boolean;
};

export function BookDetailsSection({
  bookId,
  initialDetails,
  isFromMaster,
}: BookDetailsSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [details, setDetails] = useState(initialDetails);
  const [isSaving, setIsSaving] = useState(false);
  const [isCollapsed, setIsCollapsed] = useState(true);
  const [currentDetails, setCurrentDetails] = useState<Omit<BookDetail, "id" | "created_at">[]>(
    initialDetails.map((d) => ({
      book_id: d.book_id,
      major_unit: d.major_unit,
      minor_unit: d.minor_unit,
      page_number: d.page_number,
      display_order: d.display_order,
    }))
  );

  const handleSave = async (newDetails: Omit<BookDetail, "id" | "created_at">[]) => {
    setIsSaving(true);
    try {
      const result = await saveBookDetailsAction(bookId, newDetails);
      if (result.success) {
        // ì €ì¥ëœ ì„¸ë¶€ì •ë³´ë¡œ ì—…ë°ì´íŠ¸
        const updatedDetails: BookDetail[] = newDetails.map((d, index) => ({
          id: `temp-${index}`,
          book_id: bookId,
          major_unit: d.major_unit,
          minor_unit: d.minor_unit,
          page_number: d.page_number || 0,
          display_order: d.display_order || 0,
          created_at: "",
        }));
        setDetails(updatedDetails);
        setIsEditing(false);
        router.refresh();
      }
    } catch (error) {
      console.error("ì„¸ë¶€ì •ë³´ ì €ì¥ ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "ì„¸ë¶€ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  if (isEditing && !isFromMaster) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">êµì¬ ëª©ì°¨ ê´€ë¦¬</h3>
          <div className="flex gap-2">
            <button
              type="button"
              onClick={() => setIsEditing(false)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
          </div>
        </div>
        <BookDetailsManager
          initialDetails={details}
          onChange={(newDetails) => {
            setCurrentDetails(newDetails);
          }}
        />
        <div className="flex justify-end gap-2">
          <button
            type="button"
            onClick={() => setIsEditing(false)}
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </button>
          <button
            type="button"
            onClick={async () => {
              await handleSave(currentDetails);
            }}
            disabled={isSaving}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
          >
            {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold text-gray-900">êµì¬ ëª©ì°¨</h3>
        <div className="flex gap-2">
          {details.length > 0 && (
            <button
              type="button"
              onClick={() => setIsCollapsed(!isCollapsed)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              {isCollapsed ? "ì „ì²´ í¼ì¹˜ê¸°" : "ì „ì²´ ì ‘ê¸°"}
            </button>
          )}
          {!isFromMaster && (
            <button
              type="button"
              onClick={() => setIsEditing(true)}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              {details.length > 0 ? "ìˆ˜ì •" : "ëª©ì°¨ ì¶”ê°€"}
            </button>
          )}
          {isFromMaster && (
            <div className="inline-flex items-center gap-2 rounded-md bg-blue-50 px-3 py-1.5 text-sm font-medium text-blue-700">
              <span>ğŸ“¦</span>
              <span>ë§ˆìŠ¤í„°ì—ì„œ ê°€ì ¸ì˜¨ êµì¬ëŠ” ëª©ì°¨ ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤</span>
            </div>
          )}
        </div>
      </div>
      {details.length > 0 ? (
        isCollapsed ? (
          <div className="rounded-lg border border-gray-200 bg-gray-50 p-6 text-center">
            <p className="text-sm text-gray-600">
              {details.length}ê°œì˜ ëª©ì°¨ í•­ëª©ì´ ìˆìŠµë‹ˆë‹¤. "ì „ì²´ í¼ì¹˜ê¸°" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.
            </p>
          </div>
        ) : (
          <BookDetailsDisplay details={details} />
        )
      ) : (
        <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">
            ëª©ì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. "ëª©ì°¨ ì¶”ê°€" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”.
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="books/[id]/_components/BookDetailTabs.tsx">
"use client";

import { useSearchParams } from "next/navigation";
import { ContentTabs } from "@/app/(student)/contents/_components/ContentTabs";
import { BookInfoSection } from "./BookInfoSection";
import { BookDetailsSection } from "./BookDetailsSection";
import { Book } from "@/app/types/content";
import { BookDetail } from "@/lib/types/plan";

type BookDetailTabsProps = {
  book: Book;
  deleteAction: () => void;
  initialDetails: BookDetail[];
  isFromMaster: boolean;
};

export function BookDetailTabs({
  book,
  deleteAction,
  initialDetails,
  isFromMaster,
}: BookDetailTabsProps) {
  const searchParams = useSearchParams();
  const activeTab = searchParams.get("tab") || "info";

  const tabs = [
    { key: "info", label: "êµì¬ ì •ë³´" },
    { key: "details", label: "ëª©ì°¨ ì •ë³´" },
  ];

  return (
    <div className="flex flex-col gap-6">
      {/* ìƒë‹¨ ì•¡ì…˜ ë²„íŠ¼ */}
      <div className="flex items-center justify-between border-b pb-4">
        <a
          href="/contents?tab=books"
          className="inline-flex items-center gap-2 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          â† ëª©ë¡ìœ¼ë¡œ
        </a>
        <div className="flex gap-2">
          <form action={deleteAction}>
            <button
              type="submit"
              onClick={(e) => {
                if (!confirm("ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                  e.preventDefault();
                }
              }}
              className="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700"
            >
              ì‚­ì œí•˜ê¸°
            </button>
          </form>
        </div>
      </div>

      <ContentTabs tabs={tabs} defaultTab="info" />

      {activeTab === "info" && (
        <BookInfoSection book={book} deleteAction={deleteAction} isFromMaster={isFromMaster} />
      )}

      {activeTab === "details" && (
        <BookDetailsSection
          bookId={book.id}
          initialDetails={initialDetails}
          isFromMaster={isFromMaster}
        />
      )}
    </div>
  );
}
</file>

<file path="books/[id]/_components/BookInfoSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { updateBook } from "@/app/(student)/actions/contentActions";
import { Book } from "@/app/types/content";
import { ContentHeader } from "@/app/(student)/contents/_components/ContentHeader";
import { ContentDetailTable } from "@/app/(student)/contents/_components/ContentDetailTable";

type BookInfoSectionProps = {
  book: Book;
  deleteAction: () => void;
  isFromMaster?: boolean;
};

export function BookInfoSection({ book, deleteAction, isFromMaster = false }: BookInfoSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [formData, setFormData] = useState({
    title: book.title,
    revision: book.revision || "",
    semester: book.semester || "",
    subject_category: book.subject_category || "",
    subject: book.subject || "",
    publisher: book.publisher || "",
    difficulty_level: book.difficulty_level || "",
    total_pages: book.total_pages || "",
    notes: book.notes || "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSaving(true);

    try {
      const formDataObj = new FormData();
      Object.entries(formData).forEach(([key, value]) => {
        formDataObj.append(key, String(value));
      });

      await updateBook(book.id, formDataObj);
      setIsEditing(false);
      router.refresh();
    } catch (error) {
      console.error("êµì¬ ìˆ˜ì • ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "êµì¬ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  if (isEditing) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold text-gray-900">êµì¬ ì •ë³´ ìˆ˜ì •</h2>
        </div>
        
        <form onSubmit={handleSubmit} className="flex flex-col gap-4">
          <div className="grid gap-4 md:grid-cols-2">
            {/* êµì¬ëª… */}
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                êµì¬ëª… <span className="text-red-500">*</span>
              </label>
              <input
                name="title"
                required
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                placeholder="êµì¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ê°œì •êµìœ¡ê³¼ì • */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê°œì •êµìœ¡ê³¼ì •
              </label>
              <input
                name="revision"
                value={formData.revision}
                onChange={(e) => setFormData({ ...formData, revision: e.target.value })}
                placeholder="ì˜ˆ: 2015ê°œì •"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* í•™ë…„/í•™ê¸° */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                í•™ë…„/í•™ê¸°
              </label>
              <input
                name="semester"
                value={formData.semester}
                onChange={(e) => setFormData({ ...formData, semester: e.target.value })}
                placeholder="ì˜ˆ: ê³ 3-1"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* êµê³¼ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                êµê³¼
              </label>
              <select
                name="subject_category"
                value={formData.subject_category}
                onChange={(e) => setFormData({ ...formData, subject_category: e.target.value })}
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="êµ­ì–´">êµ­ì–´</option>
                <option value="ìˆ˜í•™">ìˆ˜í•™</option>
                <option value="ì˜ì–´">ì˜ì–´</option>
                <option value="ì‚¬íšŒ">ì‚¬íšŒ</option>
                <option value="ê³¼í•™">ê³¼í•™</option>
              </select>
            </div>

            {/* ê³¼ëª© */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê³¼ëª©
              </label>
              <input
                name="subject"
                value={formData.subject}
                onChange={(e) => setFormData({ ...formData, subject: e.target.value })}
                placeholder="ì˜ˆ: í™”ë²•ê³¼ ì‘ë¬¸"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ì¶œíŒì‚¬ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ì¶œíŒì‚¬
              </label>
              <input
                name="publisher"
                value={formData.publisher}
                onChange={(e) => setFormData({ ...formData, publisher: e.target.value })}
                placeholder="ì¶œíŒì‚¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ì´ í˜ì´ì§€ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ì´ í˜ì´ì§€
              </label>
              <input
                name="total_pages"
                type="number"
                min="1"
                value={formData.total_pages}
                onChange={(e) => setFormData({ ...formData, total_pages: e.target.value })}
                placeholder="ì˜ˆ: 255"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ë‚œì´ë„ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ë‚œì´ë„
              </label>
              <select
                name="difficulty"
                value={formData.difficulty_level}
                onChange={(e) => setFormData({ ...formData, difficulty_level: e.target.value })}
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="í•˜">í•˜</option>
                <option value="ì¤‘">ì¤‘</option>
                <option value="ì¤‘ìƒ">ì¤‘ìƒ</option>
                <option value="ìƒ">ìƒ</option>
                <option value="ìµœìƒ">ìµœìƒ</option>
              </select>
            </div>

            {/* ë©”ëª¨ */}
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                ë©”ëª¨
              </label>
              <textarea
                name="notes"
                rows={3}
                value={formData.notes}
                onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
                placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
          </div>

          {/* ë²„íŠ¼ */}
          <div className="flex justify-end gap-3 border-t pt-4">
            <button
              type="button"
              onClick={() => {
                setFormData({
                  title: book.title,
                  revision: book.revision || "",
                  semester: book.semester || "",
                  subject_category: book.subject_category || "",
                  subject: book.subject || "",
                  publisher: book.publisher || "",
                  difficulty_level: book.difficulty_level || "",
                  total_pages: book.total_pages || "",
                  notes: book.notes || "",
                });
                setIsEditing(false);
              }}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={isSaving}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
            >
              {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
            </button>
          </div>
        </form>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      {/* ì •ë³´ ìˆ˜ì • ë²„íŠ¼ */}
      {!isFromMaster && (
        <div className="flex items-center justify-end">
          <button
            type="button"
            onClick={() => setIsEditing(true)}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            ì •ë³´ ìˆ˜ì •
          </button>
        </div>
      )}
      {isFromMaster && (
        <div className="flex items-center justify-end">
          <div className="inline-flex items-center gap-2 rounded-md bg-blue-50 px-3 py-1.5 text-sm font-medium text-blue-700">
            <span>ğŸ“¦</span>
            <span>ë§ˆìŠ¤í„°ì—ì„œ ê°€ì ¸ì˜¨ êµì¬ëŠ” ì •ë³´ ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤</span>
          </div>
        </div>
      )}

      <ContentHeader
        title={book.title}
        subtitle={book.publisher || ""}
        icon="ğŸ“š ì±…"
        createdAt={book.created_at}
      />

      <ContentDetailTable
        rows={[
          { label: "ê°œì •êµìœ¡ê³¼ì •", value: book.revision },
          { label: "í•™ë…„/í•™ê¸°", value: book.semester },
          { label: "êµê³¼", value: book.subject_category },
          { label: "ê³¼ëª©", value: book.subject },
          { label: "ì¶œíŒì‚¬", value: book.publisher },
          { label: "ë‚œì´ë„", value: book.difficulty_level },
          {
            label: "ì´ í˜ì´ì§€",
            value: book.total_pages ? `${book.total_pages}p` : null,
          },
          { label: "ë©”ëª¨", value: book.notes },
        ]}
      />
    </div>
  );
}
</file>

<file path="books/[id]/edit/BookEditForm.tsx">
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { updateBook } from "@/app/(student)/actions/contentActions";
import { Book } from "@/app/types/content";

export function BookEditForm({ book }: { book: Book }) {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);

    startTransition(async () => {
      try {
        await updateBook(book.id, formData);
        router.push(`/contents/books/${book.id}`);
        router.refresh();
      } catch (error) {
        console.error("ì±… ìˆ˜ì • ì‹¤íŒ¨:", error);
        alert(error instanceof Error ? error.message : "ì±… ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-6 rounded-lg border bg-white p-6 shadow-sm">
      <div className="grid gap-4 md:grid-cols-2">
        {/* êµì¬ëª… */}
        <div className="flex flex-col gap-1 md:col-span-2">
          <label className="block text-sm font-medium text-gray-700">
            êµì¬ëª… <span className="text-red-500">*</span>
          </label>
          <input
            name="title"
            required
            defaultValue={book.title}
            placeholder="êµì¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ê°œì •êµìœ¡ê³¼ì • */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ê°œì •êµìœ¡ê³¼ì •
          </label>
          <input
            name="revision"
            defaultValue={book.revision ?? ""}
            placeholder="ì˜ˆ: 2015ê°œì •"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* í•™ë…„/í•™ê¸° */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            í•™ë…„/í•™ê¸°
          </label>
          <input
            name="semester"
            defaultValue={book.semester ?? ""}
            placeholder="ì˜ˆ: ê³ 3-1"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* êµê³¼ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            êµê³¼
          </label>
          <select
            name="subject_category"
            defaultValue={book.subject_category ?? ""}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          >
            <option value="">ì„ íƒí•˜ì„¸ìš”</option>
            <option value="êµ­ì–´">êµ­ì–´</option>
            <option value="ìˆ˜í•™">ìˆ˜í•™</option>
            <option value="ì˜ì–´">ì˜ì–´</option>
            <option value="ì‚¬íšŒ">ì‚¬íšŒ</option>
            <option value="ê³¼í•™">ê³¼í•™</option>
          </select>
        </div>

        {/* ê³¼ëª© */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ê³¼ëª©
          </label>
          <input
            name="subject"
            defaultValue={book.subject ?? ""}
            placeholder="ì˜ˆ: í™”ë²•ê³¼ ì‘ë¬¸"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ì¶œíŒì‚¬ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ì¶œíŒì‚¬
          </label>
          <input
            name="publisher"
            defaultValue={book.publisher ?? ""}
            placeholder="ì¶œíŒì‚¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ì´ í˜ì´ì§€ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ì´ í˜ì´ì§€
          </label>
          <input
            name="total_pages"
            type="number"
            min="1"
            defaultValue={book.total_pages ?? ""}
            placeholder="ì˜ˆ: 255"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ë‚œì´ë„ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ë‚œì´ë„
          </label>
          <select
            name="difficulty"
            defaultValue={book.difficulty_level ?? ""}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          >
            <option value="">ì„ íƒí•˜ì„¸ìš”</option>
            <option value="í•˜">í•˜</option>
            <option value="ì¤‘">ì¤‘</option>
            <option value="ì¤‘ìƒ">ì¤‘ìƒ</option>
            <option value="ìƒ">ìƒ</option>
            <option value="ìµœìƒ">ìµœìƒ</option>
          </select>
        </div>

        {/* ë©”ëª¨ */}
        <div className="flex flex-col gap-1 md:col-span-2">
          <label className="block text-sm font-medium text-gray-700">
            ë©”ëª¨
          </label>
          <textarea
            name="notes"
            rows={3}
            defaultValue={book.notes ?? ""}
            placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>
      </div>

      {/* ë²„íŠ¼ */}
      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isPending}
          className="flex-1 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
        >
          {isPending ? "ìˆ˜ì • ì¤‘..." : "ë³€ê²½ì‚¬í•­ ì €ì¥"}
        </button>
        <Link
          href={`/contents/books/${book.id}`}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          ì·¨ì†Œ
        </Link>
      </div>
    </form>
  );
}
</file>

<file path="books/[id]/edit/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { BookEditForm } from "./BookEditForm";
import { Book } from "@/app/types/content";
import { getContainerClass } from "@/lib/constants/layout";

export default async function EditBookPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const selectBook = () =>
    supabase
      .from("books")
      .select(
        "id,title,revision,semester,subject_category,subject,publisher,difficulty_level,total_pages,notes,created_at"
      )
      .eq("id", id);

  let { data: book, error } = await selectBook()
    .eq("student_id", user.id)
    .maybeSingle<Book>();

  if (error && error.code === "42703") {
    ({ data: book, error } = await selectBook().maybeSingle<Book>());
  }

  if (error) {
    console.error(error);
    notFound();
  }

  if (!book) notFound();

  return (
    <section className={`${getContainerClass("FORM", "lg")} flex flex-col gap-6`}>
      <Link
        href={`/contents/books/${book.id}`}
        className="text-sm text-gray-500 transition hover:text-gray-900"
      >
        â† ìƒì„¸ë¡œ ëŒì•„ê°€ê¸°
      </Link>

      <div className="flex flex-col gap-2">
        <h1 className="text-2xl font-semibold">ì±… ì •ë³´ ìˆ˜ì •</h1>
        <p className="text-sm text-gray-500">
          ë“±ë¡ëœ ë‚´ìš©ì„ ìˆ˜ì •í•œ ë’¤ ì €ì¥í•˜ë©´ ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.
        </p>
      </div>

      <div className="rounded-2xl border bg-white p-6 shadow-sm">
        <BookEditForm book={book} />
      </div>
    </section>
  );
}
</file>

<file path="books/[id]/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { Suspense } from "react";
import { deleteBook } from "@/app/(student)/actions/contentActions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { Book } from "@/app/types/content";
import { BookDetailTabs } from "./_components/BookDetailTabs";
import { getMasterBookById } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BookDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const selectBook = () =>
    supabase
      .from("books")
      .select(
        "id,title,revision,semester,subject_category,subject,publisher,difficulty_level,total_pages,notes,master_content_id,created_at"
      )
      .eq("id", id);

  let { data: book, error } = await selectBook()
    .eq("student_id", user.id)
    .maybeSingle<Book & { master_content_id?: string | null }>();

  if (error && error.code === "42703") {
    ({ data: book, error } = await selectBook().maybeSingle<Book & { master_content_id?: string | null }>());
  }

  if (error) {
    console.error(error);
    notFound();
  }

  if (!book) notFound();

  // êµì¬ ìƒì„¸ ì •ë³´ ì¡°íšŒ (í•™ìƒ êµì¬ ìƒì„¸ ì •ë³´ ìš°ì„ , ì—†ìœ¼ë©´ ë§ˆìŠ¤í„° ì°¸ì¡°)
  let bookDetails: Array<{ id: string; major_unit: string | null; minor_unit: string | null; page_number: number | null; display_order: number }> = [];
  
  // ë¨¼ì € í•™ìƒ êµì¬ ìƒì„¸ ì •ë³´ ì¡°íšŒ
  const { data: studentDetails } = await supabase
    .from("student_book_details")
    .select("id,major_unit,minor_unit,page_number,display_order")
    .eq("book_id", id)
    .order("display_order", { ascending: true })
    .order("page_number", { ascending: true });

  if (studentDetails && studentDetails.length > 0) {
    bookDetails = studentDetails.map(d => ({
      id: d.id,
      major_unit: d.major_unit,
      minor_unit: d.minor_unit,
      page_number: d.page_number,
      display_order: d.display_order,
    }));
  } else if (book.master_content_id) {
    // í•™ìƒ êµì¬ ìƒì„¸ ì •ë³´ê°€ ì—†ìœ¼ë©´ ë§ˆìŠ¤í„° ì°¸ì¡°
    try {
      const { details } = await getMasterBookById(book.master_content_id);
      bookDetails = details.map(d => ({
        id: d.id,
        major_unit: d.major_unit,
        minor_unit: d.minor_unit,
        page_number: d.page_number,
        display_order: d.display_order,
      }));
    } catch (err) {
      console.error("ë§ˆìŠ¤í„° êµì¬ ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", err);
    }
  }

  const deleteAction = deleteBook.bind(null, book.id);

  return (
    <section className={getContainerClass("CONTENT_DETAIL", "lg")}>
      <div className="rounded-2xl border bg-white p-8 shadow-sm">
        <Suspense fallback={<SuspenseFallback />}>
          <BookDetailTabs
            book={book}
            deleteAction={deleteAction}
            initialDetails={bookDetails.map((d) => ({
              id: d.id,
              book_id: book.id,
              major_unit: d.major_unit,
              minor_unit: d.minor_unit,
              page_number: d.page_number || 0,
              display_order: d.display_order || 0,
              created_at: "",
            }))}
            isFromMaster={!!book.master_content_id}
          />
        </Suspense>
      </div>
    </section>
  );
}
</file>

<file path="books/new/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useTransition } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { addBook } from "@/app/(student)/actions/contentActions";
import { BookDetailsManager } from "@/app/(student)/contents/_components/BookDetailsManager";
import {
  getCurriculumRevisionsAction,
  getPublishersAction,
} from "@/app/(student)/actions/contentMetadataActions";
import { getSubjectGroupsAction, getSubjectsByGroupAction } from "@/app/(student)/actions/contentMetadataActions";
import type { SubjectGroup, Subject } from "@/lib/data/subjects";

export default function NewBookPage() {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();

  const [revisions, setRevisions] = useState<Array<{ id: string; name: string }>>([]);
  const [subjectGroups, setSubjectGroups] = useState<SubjectGroup[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [publishers, setPublishers] = useState<Array<{ id: string; name: string }>>([]);

  const [selectedRevisionId, setSelectedRevisionId] = useState<string>("");
  const [selectedSubjectGroupId, setSelectedSubjectGroupId] = useState<string>("");
  const [selectedSubjectId, setSelectedSubjectId] = useState<string>("");
  const [selectedPublisherId, setSelectedPublisherId] = useState<string>("");

  useEffect(() => {
    loadMetadata();
  }, []);

  useEffect(() => {
    if (selectedRevisionId) {
      loadSubjectGroups(selectedRevisionId);
    } else {
      setSubjectGroups([]);
      setSubjects([]);
    }
  }, [selectedRevisionId]);

  useEffect(() => {
    if (selectedSubjectGroupId) {
      loadSubjects(selectedSubjectGroupId);
    } else {
      setSubjects([]);
    }
  }, [selectedSubjectGroupId]);

  async function loadMetadata() {
    try {
      const [revs, pubs] = await Promise.all([
        getCurriculumRevisionsAction(),
        getPublishersAction(),
      ]);
      setRevisions(revs.filter((r) => r.is_active));
      setPublishers(pubs.filter((p) => p.is_active));
    } catch (error) {
      console.error("ë©”íƒ€ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  async function loadSubjectGroups(revisionId: string) {
    try {
      const groups = await getSubjectGroupsAction(revisionId);
      setSubjectGroups(groups);
      setSelectedSubjectGroupId("");
      setSubjects([]);
    } catch (error) {
      console.error("êµê³¼ ê·¸ë£¹ ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  async function loadSubjects(subjectGroupId: string) {
    try {
      const subs = await getSubjectsByGroupAction(subjectGroupId);
      setSubjects(subs);
      setSelectedSubjectId("");
    } catch (error) {
      console.error("ê³¼ëª© ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);

    // ê°œì •êµìœ¡ê³¼ì • ì´ë¦„ ì¶”ê°€
    if (selectedRevisionId) {
      const revision = revisions.find((r) => r.id === selectedRevisionId);
      if (revision) {
        formData.set("revision", revision.name);
      }
    }

    // êµê³¼ ì´ë¦„ ì¶”ê°€
    if (selectedSubjectGroupId) {
      const group = subjectGroups.find((g) => g.id === selectedSubjectGroupId);
      if (group) {
        formData.set("subject_category", group.name);
      }
    }

    // ê³¼ëª© ì´ë¦„ ì¶”ê°€
    if (selectedSubjectId) {
      const subject = subjects.find((s) => s.id === selectedSubjectId);
      if (subject) {
        formData.set("subject", subject.name);
      }
    }

    // ì¶œíŒì‚¬ ì´ë¦„ ì¶”ê°€
    if (selectedPublisherId) {
      const publisher = publishers.find((p) => p.id === selectedPublisherId);
      if (publisher) {
        formData.set("publisher", publisher.name);
      }
    }

    startTransition(async () => {
      try {
        await addBook(formData);
        router.push("/contents");
        router.refresh();
      } catch (error) {
        console.error("ì±… ë“±ë¡ ì‹¤íŒ¨:", error);
        alert(error instanceof Error ? error.message : "ì±… ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  return (
    <section className="mx-auto w-full max-w-3xl px-4 py-10">
      <div className="flex flex-col gap-2">
        <h1 className="text-3xl font-semibold text-gray-900">ğŸ“š ì±… ë“±ë¡í•˜ê¸°</h1>
        <p className="text-sm text-gray-500">ìƒˆë¡œìš´ êµì¬ë¥¼ ë“±ë¡í•˜ì„¸ìš”.</p>
      </div>

      <form onSubmit={handleSubmit} className="flex flex-col gap-6 rounded-lg border bg-white p-6 shadow-sm">
        <div className="grid gap-4 md:grid-cols-2">
          {/* êµì¬ëª… */}
          <div className="flex flex-col gap-1 md:col-span-2">
            <label className="block text-sm font-medium text-gray-700">
              êµì¬ëª… <span className="text-red-500">*</span>
            </label>
            <input
              name="title"
              required
              placeholder="êµì¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>

          {/* ê°œì •êµìœ¡ê³¼ì • */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ê°œì •êµìœ¡ê³¼ì •
            </label>
            <select
              value={selectedRevisionId}
              onChange={(e) => {
                setSelectedRevisionId(e.target.value);
                setSelectedSubjectGroupId("");
                setSelectedSubjectId("");
              }}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              {revisions.map((rev) => (
                <option key={rev.id} value={rev.id}>
                  {rev.name}
                </option>
              ))}
            </select>
          </div>

          {/* êµê³¼ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">êµê³¼</label>
            <select
              value={selectedSubjectGroupId}
              onChange={(e) => {
                setSelectedSubjectGroupId(e.target.value);
                setSelectedSubjectId("");
              }}
              disabled={!selectedRevisionId}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
            >
              <option value="">
                {selectedRevisionId ? "ì„ íƒí•˜ì„¸ìš”" : "ê°œì •êµìœ¡ê³¼ì •ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”"}
              </option>
              {subjectGroups.map((group) => (
                <option key={group.id} value={group.id}>
                  {group.name}
                </option>
              ))}
            </select>
          </div>

          {/* ê³¼ëª© */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">ê³¼ëª©</label>
            <select
              value={selectedSubjectId}
              onChange={(e) => setSelectedSubjectId(e.target.value)}
              disabled={!selectedSubjectGroupId}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
            >
              <option value="">
                {selectedSubjectGroupId ? "ì„ íƒí•˜ì„¸ìš”" : "êµê³¼ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”"}
              </option>
              {subjects.map((subject) => (
                <option key={subject.id} value={subject.id}>
                  {subject.name}
                </option>
              ))}
            </select>
          </div>

          {/* ì¶œíŒì‚¬ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">ì¶œíŒì‚¬</label>
            <select
              value={selectedPublisherId}
              onChange={(e) => setSelectedPublisherId(e.target.value)}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              {publishers.map((publisher) => (
                <option key={publisher.id} value={publisher.id}>
                  {publisher.name}
                </option>
              ))}
            </select>
          </div>

          {/* ì´ í˜ì´ì§€ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ì´ í˜ì´ì§€ <span className="text-red-500">*</span>
            </label>
            <input
              name="total_pages"
              type="number"
              required
              min="1"
              placeholder="ì˜ˆ: 255"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>

          {/* ë‚œì´ë„ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ë‚œì´ë„
            </label>
            <select
              name="difficulty"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              <option value="ê°œë…">ê°œë…</option>
              <option value="ê¸°ë³¸">ê¸°ë³¸</option>
              <option value="ì‹¬í™”">ì‹¬í™”</option>
            </select>
          </div>

          {/* ë©”ëª¨ */}
          <div className="flex flex-col gap-1 md:col-span-2">
            <label className="block text-sm font-medium text-gray-700">
              ë©”ëª¨
            </label>
            <textarea
              name="notes"
              rows={3}
              placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>
        </div>

        {/* êµì¬ ìƒì„¸ ì •ë³´ */}
        <BookDetailsManager />

        {/* ë²„íŠ¼ */}
        <div className="flex gap-3">
          <button
            type="submit"
            disabled={isPending}
            className="flex-1 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
          >
            {isPending ? "ë“±ë¡ ì¤‘..." : "ë“±ë¡í•˜ê¸°"}
          </button>
          <Link
            href="/contents"
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </Link>
        </div>
      </form>
    </section>
  );
}
</file>

<file path="books/page.tsx">
// app/contents/books/page.tsx
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { addBook } from "@/app/(student)/actions/contentActions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BooksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const { data: books } = await supabase
    .from("books")
    .select("*")
    .eq("student_id", user.id)
    .order("created_at", { ascending: false });

  return (
    <section className={getContainerClass("FORM", "lg")}>
      <div className="flex flex-col gap-6">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold">êµì¬ ë“±ë¡</h1>
          <Link
            href="/contents?tab=books"
            className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
          >
            ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>

        {/* ë“±ë¡ í¼ */}
        <form action={addBook} className="space-y-4 border p-4 rounded">
        <input
          name="title"
          placeholder="êµì¬ëª…"
          required
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="publisher"
          placeholder="ì¶œíŒì‚¬"
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="subject"
          placeholder="ê³¼ëª©"
          className="w-full border rounded px-3 py-2"
        />
        <input
          type="number"
          name="total_pages"
          placeholder="ì´ í˜ì´ì§€ ìˆ˜"
          required
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="difficulty"
          placeholder="ë‚œì´ë„ (ì˜ˆ: ìƒ/ì¤‘/í•˜)"
          className="w-full border rounded px-3 py-2"
        />

        <button className="w-full bg-black text-white py-2 rounded">
          ë“±ë¡í•˜ê¸°
        </button>
        </form>

        {/* ë¦¬ìŠ¤íŠ¸ */}
        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-medium">ë“±ë¡ëœ êµì¬</h2>

          <ul className="flex flex-col gap-3">
            {books?.map((book) => (
              <li key={book.id} className="border p-3 rounded">
                <strong>{book.title}</strong> ({book.subject})
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="lectures/[id]/_components/LectureDetailTabs.tsx">
"use client";

import { useSearchParams } from "next/navigation";
import { ContentTabs } from "@/app/(student)/contents/_components/ContentTabs";
import { LectureInfoSection } from "./LectureInfoSection";
import { LectureEpisodesSection } from "./LectureEpisodesSection";
import { LectureLinkedBookSection } from "./LectureLinkedBookSection";
import { Lecture } from "@/app/types/content";
import { MasterLecture } from "@/lib/types/plan";

type LectureDetailTabsProps = {
  lecture: Lecture & { linked_book_id?: string | null; total_episodes?: number | null };
  deleteAction: () => void;
  linkedBook: { id: string; title: string } | null;
  studentBooks: Array<{ id: string; title: string }>;
  initialEpisodes: Array<{
    id: string;
    lecture_id: string;
    episode_number: number;
    episode_title: string | null;
    duration: number | null;
    display_order: number;
    created_at: string;
  }>;
  isFromMaster: boolean;
  masterLecture?: MasterLecture | null;
};

export function LectureDetailTabs({
  lecture,
  deleteAction,
  linkedBook,
  studentBooks,
  initialEpisodes,
  isFromMaster,
  masterLecture,
}: LectureDetailTabsProps) {
  const searchParams = useSearchParams();
  const activeTab = searchParams.get("tab") || "info";

  const tabs = [
    { key: "info", label: "ê°•ì˜ ì •ë³´" },
    { key: "episodes", label: "íšŒì°¨ ì •ë³´" },
    { key: "linked-book", label: "ê°•ì˜ êµì¬ ì •ë³´" },
  ];

  return (
    <div className="flex flex-col gap-6">
      {/* ìƒë‹¨ ì•¡ì…˜ ë²„íŠ¼ */}
      <div className="flex items-center justify-between border-b pb-4">
        <a
          href="/contents?tab=lectures"
          className="inline-flex items-center gap-2 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          â† ëª©ë¡ìœ¼ë¡œ
        </a>
        <div className="flex gap-2">
          <form action={deleteAction}>
            <button
              type="submit"
              onClick={(e) => {
                if (!confirm("ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                  e.preventDefault();
                }
              }}
              className="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700"
            >
              ì‚­ì œí•˜ê¸°
            </button>
          </form>
        </div>
      </div>

      <ContentTabs tabs={tabs} defaultTab="info" />

      {activeTab === "info" && (
        <LectureInfoSection
          lecture={lecture}
          deleteAction={deleteAction}
          linkedBook={linkedBook}
          studentBooks={studentBooks}
          isFromMaster={isFromMaster}
          masterLecture={masterLecture}
        />
      )}

      {activeTab === "episodes" && (
        <LectureEpisodesSection
          lectureId={lecture.id}
          initialEpisodes={initialEpisodes}
          isFromMaster={isFromMaster}
        />
      )}

      {activeTab === "linked-book" && (
        <LectureLinkedBookSection
          lectureId={lecture.id}
          linkedBook={linkedBook}
          studentBooks={studentBooks}
        />
      )}
    </div>
  );
}
</file>

<file path="lectures/[id]/_components/LectureEpisodesSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { LectureEpisodesDisplay } from "@/app/(student)/contents/_components/LectureEpisodesDisplay";
import { LectureEpisodesManager } from "@/app/(student)/contents/_components/LectureEpisodesManager";
import { saveLectureEpisodesAction } from "@/app/(student)/actions/contentDetailsActions";
import { LectureEpisode } from "@/lib/types/plan";

type LectureEpisodesSectionProps = {
  lectureId: string;
  initialEpisodes: LectureEpisode[];
  isFromMaster: boolean;
};

export function LectureEpisodesSection({
  lectureId,
  initialEpisodes,
  isFromMaster,
}: LectureEpisodesSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [episodes, setEpisodes] = useState(initialEpisodes);
  const [isSaving, setIsSaving] = useState(false);
  const [currentEpisodes, setCurrentEpisodes] = useState<Omit<LectureEpisode, "id" | "created_at">[]>(
    initialEpisodes.map((e) => ({
      lecture_id: e.lecture_id,
      episode_number: e.episode_number,
      episode_title: e.episode_title,
      duration: e.duration,
      display_order: e.display_order,
    }))
  );

  const handleSave = async (newEpisodes: Omit<LectureEpisode, "id" | "created_at">[]) => {
    setIsSaving(true);
    try {
      const result = await saveLectureEpisodesAction(lectureId, newEpisodes);
      if (result.success) {
        // ì €ì¥ëœ íšŒì°¨ ì •ë³´ë¡œ ì—…ë°ì´íŠ¸
        const updatedEpisodes: LectureEpisode[] = newEpisodes.map((e, index) => ({
          id: `temp-${index}`,
          lecture_id: lectureId,
          episode_number: e.episode_number || 0,
          episode_title: e.episode_title,
          duration: e.duration,
          display_order: e.display_order || 0,
          created_at: "",
        }));
        setEpisodes(updatedEpisodes);
        setIsEditing(false);
        router.refresh();
      }
    } catch (error) {
      console.error("íšŒì°¨ ì •ë³´ ì €ì¥ ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "íšŒì°¨ ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  if (isEditing && !isFromMaster) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">ê°•ì˜ íšŒì°¨ ì •ë³´ ê´€ë¦¬</h3>
          <div className="flex gap-2">
            <button
              type="button"
              onClick={() => setIsEditing(false)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
          </div>
        </div>
        <LectureEpisodesManager
          initialEpisodes={episodes}
          onChange={(newEpisodes) => {
            setCurrentEpisodes(newEpisodes);
          }}
        />
        <div className="flex justify-end gap-2">
          <button
            type="button"
            onClick={() => setIsEditing(false)}
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </button>
          <button
            type="button"
            onClick={async () => {
              await handleSave(currentEpisodes);
            }}
            disabled={isSaving}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
          >
            {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold text-gray-900">ê°•ì˜ íšŒì°¨ ì •ë³´</h3>
        {!isFromMaster && (
          <button
            type="button"
            onClick={() => setIsEditing(true)}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            {episodes.length > 0 ? "ìˆ˜ì •" : "íšŒì°¨ ì¶”ê°€"}
          </button>
        )}
        {isFromMaster && (
          <div className="inline-flex items-center gap-2 rounded-md bg-blue-50 px-3 py-1.5 text-sm font-medium text-blue-700">
            <span>ğŸ“¦</span>
            <span>ë§ˆìŠ¤í„°ì—ì„œ ê°€ì ¸ì˜¨ ê°•ì˜ëŠ” íšŒì°¨ ì •ë³´ ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤</span>
          </div>
        )}
      </div>
      {episodes.length > 0 ? (
        <LectureEpisodesDisplay episodes={episodes} />
      ) : (
        <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">
            íšŒì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. "íšŒì°¨ ì¶”ê°€" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”.
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="lectures/[id]/_components/LectureInfoSection.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { updateLecture } from "@/app/(student)/actions/contentActions";
import { Lecture } from "@/app/types/content";
import { MasterLecture } from "@/lib/types/plan";
import { ContentHeader } from "@/app/(student)/contents/_components/ContentHeader";
import { ContentDetailTable } from "@/app/(student)/contents/_components/ContentDetailTable";

type LectureInfoSectionProps = {
  lecture: Lecture & { linked_book_id?: string | null };
  deleteAction: () => void;
  linkedBook?: { id: string; title: string } | null;
  studentBooks?: Array<{ id: string; title: string }>;
  isFromMaster?: boolean;
  masterLecture?: MasterLecture | null;
};

export function LectureInfoSection({ lecture, deleteAction, linkedBook, studentBooks = [], isFromMaster = false, masterLecture }: LectureInfoSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [formData, setFormData] = useState({
    title: lecture.title,
    revision: lecture.revision || "",
    semester: lecture.semester || "",
    subject_category: lecture.subject_category || "",
    subject: lecture.subject || "",
    platform: lecture.platform || "",
    difficulty_level: lecture.difficulty_level || "",
    duration: lecture.duration || "",
    notes: lecture.notes || "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSaving(true);

    try {
      const formDataObj = new FormData();
      Object.entries(formData).forEach(([key, value]) => {
        formDataObj.append(key, String(value));
      });

      await updateLecture(lecture.id, formDataObj);
      setIsEditing(false);
      router.refresh();
    } catch (error) {
      console.error("ê°•ì˜ ìˆ˜ì • ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "ê°•ì˜ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  if (isEditing) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold text-gray-900">ê°•ì˜ ì •ë³´ ìˆ˜ì •</h2>
        </div>
        
        <form onSubmit={handleSubmit} className="flex flex-col gap-4">
          <div className="grid gap-4 md:grid-cols-2">
            {/* ê°•ì˜ëª… */}
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                ê°•ì˜ëª… <span className="text-red-500">*</span>
              </label>
              <input
                name="title"
                required
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                placeholder="ê°•ì˜ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ê°œì •êµìœ¡ê³¼ì • */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê°œì •êµìœ¡ê³¼ì •
              </label>
              <input
                name="revision"
                value={formData.revision}
                onChange={(e) => setFormData({ ...formData, revision: e.target.value })}
                placeholder="ì˜ˆ: 2015ê°œì •"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* í•™ë…„/í•™ê¸° */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                í•™ë…„/í•™ê¸°
              </label>
              <input
                name="semester"
                value={formData.semester}
                onChange={(e) => setFormData({ ...formData, semester: e.target.value })}
                placeholder="ì˜ˆ: ê³ 3-1"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* êµê³¼ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                êµê³¼
              </label>
              <select
                name="subject_category"
                value={formData.subject_category}
                onChange={(e) => setFormData({ ...formData, subject_category: e.target.value })}
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="êµ­ì–´">êµ­ì–´</option>
                <option value="ìˆ˜í•™">ìˆ˜í•™</option>
                <option value="ì˜ì–´">ì˜ì–´</option>
                <option value="ì‚¬íšŒ">ì‚¬íšŒ</option>
                <option value="ê³¼í•™">ê³¼í•™</option>
              </select>
            </div>

            {/* ê³¼ëª© */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê³¼ëª©
              </label>
              <input
                name="subject"
                value={formData.subject}
                onChange={(e) => setFormData({ ...formData, subject: e.target.value })}
                placeholder="ì˜ˆ: í™”ë²•ê³¼ ì‘ë¬¸"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* í”Œë«í¼ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                í”Œë«í¼
              </label>
              <input
                name="platform"
                value={formData.platform}
                onChange={(e) => setFormData({ ...formData, platform: e.target.value })}
                placeholder="ì˜ˆ: ë©”ê°€ìŠ¤í„°ë””, EBSi"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ì´ ê°•ì˜ì‹œê°„ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ì´ ê°•ì˜ì‹œê°„ (ë¶„)
              </label>
              <input
                name="duration"
                type="number"
                min="0"
                value={formData.duration}
                onChange={(e) => setFormData({ ...formData, duration: e.target.value })}
                placeholder="ì˜ˆ: 300"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>

            {/* ë‚œì´ë„ */}
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ë‚œì´ë„
              </label>
              <select
                name="difficulty"
                value={formData.difficulty_level}
                onChange={(e) => setFormData({ ...formData, difficulty_level: e.target.value })}
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="í•˜">í•˜</option>
                <option value="ì¤‘">ì¤‘</option>
                <option value="ì¤‘ìƒ">ì¤‘ìƒ</option>
                <option value="ìƒ">ìƒ</option>
                <option value="ìµœìƒ">ìµœìƒ</option>
              </select>
            </div>

            {/* ë©”ëª¨ */}
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                ë©”ëª¨
              </label>
              <textarea
                name="notes"
                rows={3}
                value={formData.notes}
                onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
                placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
          </div>

          {/* ë²„íŠ¼ */}
          <div className="flex justify-end gap-3 border-t pt-4">
            <button
              type="button"
              onClick={() => {
                    setFormData({
                      title: lecture.title,
                      revision: lecture.revision || "",
                      semester: lecture.semester || "",
                      subject_category: lecture.subject_category || "",
                      subject: lecture.subject || "",
                      platform: lecture.platform || "",
                      difficulty_level: lecture.difficulty_level || "",
                      duration: lecture.duration || "",
                      notes: lecture.notes || "",
                    });
                setIsEditing(false);
              }}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={isSaving}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
            >
              {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
            </button>
          </div>
        </form>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      {/* ì •ë³´ ìˆ˜ì • ë²„íŠ¼ */}
      {!isFromMaster && (
        <div className="flex items-center justify-end">
          <button
            type="button"
            onClick={() => setIsEditing(true)}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            ì •ë³´ ìˆ˜ì •
          </button>
        </div>
      )}
      {isFromMaster && (
        <div className="flex items-center justify-end">
          <div className="inline-flex items-center gap-2 rounded-md bg-blue-50 px-3 py-1.5 text-sm font-medium text-blue-700">
            <span>ğŸ“¦</span>
            <span>ë§ˆìŠ¤í„°ì—ì„œ ê°€ì ¸ì˜¨ ê°•ì˜ëŠ” ì •ë³´ ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤</span>
          </div>
        </div>
      )}

      <ContentHeader
        title={lecture.title}
        subtitle={lecture.platform || ""}
        icon="ğŸ§ ê°•ì˜"
        createdAt={lecture.created_at}
      />

      <ContentDetailTable
        rows={[
          { label: "ê°œì •êµìœ¡ê³¼ì •", value: lecture.revision ?? null },
          { label: "í•™ë…„/í•™ê¸°", value: lecture.semester ?? null },
          { label: "êµê³¼", value: lecture.subject_category ?? null },
          { label: "ê³¼ëª©", value: lecture.subject ?? null },
          { label: "í”Œë«í¼", value: lecture.platform ?? null },
          { label: "ê°•ì˜ ìœ í˜•", value: lecture.lecture_type ?? null },
          { label: "ì½˜í…ì¸  ì¹´í…Œê³ ë¦¬", value: lecture.content_category ?? null },
          { label: "ê°•ì‚¬ëª…", value: lecture.instructor_name ?? null },
          { label: "ëŒ€ìƒ í•™ë…„", value: lecture.grade_level ?? null },
          { label: "ë‚œì´ë„", value: lecture.difficulty_level ?? null },
          {
            label: "ì´ íšŒì°¨",
            value: lecture.total_episodes ? `${lecture.total_episodes}íšŒ` : null,
          },
          {
            label: "ì´ ê¸¸ì´",
            value: lecture.duration ? `${Math.round(lecture.duration / 60)}ë¶„` : null,
          },
          {
            label: "ì´ ê°•ì˜ì‹œê°„",
            value: lecture.total_duration ? `${Math.round(lecture.total_duration / 60)}ë¶„` : null,
          },
          {
            label: "ì¶œì²˜ URL",
            value: lecture.lecture_source_url ?? null,
            isUrl: !!lecture.lecture_source_url,
          },
          { label: "ë¶€ì œëª©", value: lecture.subtitle ?? null },
          { label: "ì‹œë¦¬ì¦ˆëª…", value: lecture.series_name ?? null },
          { label: "ì„¤ëª…", value: lecture.description ?? null },
          { label: "ë©”ëª¨", value: lecture.notes ?? null },
        ]}
      />
    </div>
  );
}
</file>

<file path="lectures/[id]/_components/LectureLinkedBookSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { updateLecture, createBookWithoutRedirect } from "@/app/(student)/actions/contentActions";
import { BookDetailsManager } from "@/app/(student)/contents/_components/BookDetailsManager";
import { BookDetail } from "@/lib/types/plan";

type LectureLinkedBookSectionProps = {
  lectureId: string;
  linkedBook: { id: string; title: string } | null;
  studentBooks: Array<{ id: string; title: string }>;
};

export function LectureLinkedBookSection({
  lectureId,
  linkedBook,
  studentBooks,
}: LectureLinkedBookSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedBookId, setSelectedBookId] = useState(linkedBook?.id || "");
  const [bookDetails, setBookDetails] = useState<Omit<BookDetail, "id" | "created_at">[]>([]);

  // ê²€ìƒ‰ëœ êµì¬ ëª©ë¡
  const filteredBooks = studentBooks.filter((book) =>
    book.title.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleLinkBook = async (bookId: string) => {
    try {
      const formData = new FormData();
      formData.append("linked_book_id", bookId);
      await updateLecture(lectureId, formData);
      setIsEditing(false);
      setIsSearching(false);
      router.refresh();
    } catch (error) {
      console.error("êµì¬ ì—°ê²° ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "êµì¬ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleUnlinkBook = async () => {
    if (!confirm("ì—°ê²°ëœ êµì¬ë¥¼ í•´ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const formData = new FormData();
      formData.append("linked_book_id", "");
      await updateLecture(lectureId, formData);
      router.refresh();
    } catch (error) {
      console.error("êµì¬ ì—°ê²° í•´ì œ ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "êµì¬ ì—°ê²° í•´ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleCreateAndLink = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsCreating(true);

    try {
      const formData = new FormData(e.currentTarget);
      
      // ëª©ì°¨ ì •ë³´ ì¶”ê°€
      if (bookDetails.length > 0) {
        const detailsWithOrder = bookDetails.map((detail, index) => ({
          major_unit: detail.major_unit || null,
          minor_unit: detail.minor_unit || null,
          page_number: detail.page_number || 0,
          display_order: detail.display_order || index,
        }));
        formData.append("details", JSON.stringify(detailsWithOrder));
      }
      
      const result = await createBookWithoutRedirect(formData);
      
      if (result.success && result.bookId) {
        // ìƒˆë¡œ ìƒì„±ëœ êµì¬ë¡œ ì—°ê²°
        await handleLinkBook(result.bookId);
        setIsCreating(false);
        setBookDetails([]); // ëª©ì°¨ ì •ë³´ ì´ˆê¸°í™”
      } else {
        throw new Error(result.error || "êµì¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      console.error("êµì¬ ìƒì„± ì‹¤íŒ¨:", error);
      alert(error instanceof Error ? error.message : "êµì¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      setIsCreating(false);
    }
  };

  if (isCreating) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">êµì¬ ë“±ë¡ ë° ì—°ê²°</h3>
          <button
            type="button"
            onClick={() => setIsCreating(false)}
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </button>
        </div>
        <form onSubmit={handleCreateAndLink} className="flex flex-col gap-4">
          <div className="grid gap-4 md:grid-cols-2">
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                êµì¬ëª… <span className="text-red-500">*</span>
              </label>
              <input
                name="title"
                required
                placeholder="êµì¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê°œì •êµìœ¡ê³¼ì •
              </label>
              <input
                name="revision"
                placeholder="ì˜ˆ: 2022ê°œì •"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                í•™ë…„/í•™ê¸°
              </label>
              <input
                name="semester"
                placeholder="ì˜ˆ: ê³ 1-1"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                êµê³¼
              </label>
              <select
                name="subject_category"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="êµ­ì–´">êµ­ì–´</option>
                <option value="ìˆ˜í•™">ìˆ˜í•™</option>
                <option value="ì˜ì–´">ì˜ì–´</option>
                <option value="ì‚¬íšŒ">ì‚¬íšŒ</option>
                <option value="ê³¼í•™">ê³¼í•™</option>
              </select>
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ê³¼ëª©
              </label>
              <input
                name="subject"
                placeholder="ì˜ˆ: í™”ë²•ê³¼ ì‘ë¬¸"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ì¶œíŒì‚¬
              </label>
              <input
                name="publisher"
                placeholder="ì¶œíŒì‚¬ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ì´ í˜ì´ì§€
              </label>
              <input
                name="total_pages"
                type="number"
                min="1"
                placeholder="ì˜ˆ: 255"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">
                ë‚œì´ë„
              </label>
              <select
                name="difficulty"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              >
                <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                <option value="í•˜">í•˜</option>
                <option value="ì¤‘">ì¤‘</option>
                <option value="ì¤‘ìƒ">ì¤‘ìƒ</option>
                <option value="ìƒ">ìƒ</option>
                <option value="ìµœìƒ">ìµœìƒ</option>
              </select>
            </div>
            <div className="flex flex-col gap-1 md:col-span-2">
              <label className="block text-sm font-medium text-gray-700">
                ë©”ëª¨
              </label>
              <textarea
                name="notes"
                rows={3}
                placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
            </div>
          </div>

          {/* êµì¬ ìƒì„¸ ì •ë³´ (ëª©ì°¨) */}
          <div className="flex flex-col gap-3 border-t pt-4">
            <h4 className="text-sm font-semibold text-gray-900">êµì¬ ëª©ì°¨ (ì„ íƒì‚¬í•­)</h4>
            <BookDetailsManager
              initialDetails={[]}
              onChange={(details) => {
                setBookDetails(details);
              }}
            />
          </div>

          <div className="flex justify-end gap-2">
            <button
              type="button"
              onClick={() => setIsCreating(false)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={isCreating}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
            >
              {isCreating ? "ë“±ë¡ ì¤‘..." : "ë“±ë¡ ë° ì—°ê²°"}
            </button>
          </div>
        </form>
      </div>
    );
  }

  if (isSearching) {
    return (
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">êµì¬ ê²€ìƒ‰ ë° ì—°ê²°</h3>
          <button
            type="button"
            onClick={() => {
              setIsSearching(false);
              setSearchQuery("");
            }}
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </button>
        </div>
        <div className="flex flex-col gap-4">
          <div>
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="êµì¬ëª…ìœ¼ë¡œ ê²€ìƒ‰..."
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>
          {filteredBooks.length > 0 ? (
            <div className="flex flex-col gap-2">
              {filteredBooks.map((book) => (
                <div
                  key={book.id}
                  className="flex items-center justify-between rounded-lg border border-gray-200 bg-white p-4"
                >
                  <div>
                    <p className="font-medium text-gray-900">{book.title}</p>
                  </div>
                  <button
                    type="button"
                    onClick={() => handleLinkBook(book.id)}
                    className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
                  >
                    ì—°ê²°í•˜ê¸°
                  </button>
                </div>
              ))}
            </div>
          ) : (
            <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
              <p className="text-sm text-gray-500">
                {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." : "ë“±ë¡ëœ êµì¬ê°€ ì—†ìŠµë‹ˆë‹¤."}
              </p>
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold text-gray-900">ì—°ê²°ëœ êµì¬</h3>
        <div className="flex gap-2">
          {studentBooks.length > 0 && (
            <button
              type="button"
              onClick={() => setIsSearching(true)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              êµì¬ ê²€ìƒ‰
            </button>
          )}
          <button
            type="button"
            onClick={() => setIsCreating(true)}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            êµì¬ ë“±ë¡
          </button>
        </div>
      </div>

      {linkedBook ? (
        <div className="rounded-lg border border-gray-200 bg-white p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-lg font-semibold text-gray-900">{linkedBook.title}</p>
              <Link
                href={`/contents/books/${linkedBook.id}`}
                className="text-sm text-indigo-600 hover:underline"
              >
                êµì¬ ìƒì„¸ë³´ê¸° â†’
              </Link>
            </div>
            <button
              type="button"
              onClick={handleUnlinkBook}
              className="rounded-lg border border-red-300 bg-white px-4 py-2 text-sm font-semibold text-red-700 transition hover:bg-red-50"
            >
              ì—°ê²° í•´ì œ
            </button>
          </div>
        </div>
      ) : (
        <div className="flex flex-col gap-4 rounded-lg border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">
            ì—°ê²°ëœ êµì¬ê°€ ì—†ìŠµë‹ˆë‹¤.
          </p>
          <div className="flex justify-center gap-2">
            {studentBooks.length > 0 && (
              <button
                type="button"
                onClick={() => setIsSearching(true)}
                className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
              >
                êµì¬ ê²€ìƒ‰í•˜ì—¬ ì—°ê²°
              </button>
            )}
            <button
              type="button"
              onClick={() => setIsCreating(true)}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ìƒˆ êµì¬ ë“±ë¡í•˜ì—¬ ì—°ê²°
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="lectures/[id]/edit/LectureEditForm.tsx">
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { updateLecture } from "@/app/(student)/actions/contentActions";
import { Lecture } from "@/app/types/content";

export function LectureEditForm({ lecture }: { lecture: Lecture }) {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);

    startTransition(async () => {
      try {
        await updateLecture(lecture.id, formData);
        router.push(`/contents/lectures/${lecture.id}`);
        router.refresh();
      } catch (error) {
        console.error("ê°•ì˜ ìˆ˜ì • ì‹¤íŒ¨:", error);
        alert(error instanceof Error ? error.message : "ê°•ì˜ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-6 rounded-lg border bg-white p-6 shadow-sm">
      <div className="grid gap-4 md:grid-cols-2">
        {/* ê°•ì˜ëª… */}
        <div className="flex flex-col gap-1 md:col-span-2">
          <label className="block text-sm font-medium text-gray-700">
            ê°•ì˜ëª… <span className="text-red-500">*</span>
          </label>
          <input
            name="title"
            required
            defaultValue={lecture.title}
            placeholder="ê°•ì˜ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ê°œì •êµìœ¡ê³¼ì • */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ê°œì •êµìœ¡ê³¼ì •
          </label>
          <input
            name="revision"
            defaultValue={lecture.revision ?? ""}
            placeholder="ì˜ˆ: 2015ê°œì •"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* í•™ë…„/í•™ê¸° */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            í•™ë…„/í•™ê¸°
          </label>
          <input
            name="semester"
            defaultValue={lecture.semester ?? ""}
            placeholder="ì˜ˆ: ê³ 3-1"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* êµê³¼ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            êµê³¼
          </label>
          <select
            name="subject_category"
            defaultValue={lecture.subject_category ?? ""}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          >
            <option value="">ì„ íƒí•˜ì„¸ìš”</option>
            <option value="êµ­ì–´">êµ­ì–´</option>
            <option value="ìˆ˜í•™">ìˆ˜í•™</option>
            <option value="ì˜ì–´">ì˜ì–´</option>
            <option value="ì‚¬íšŒ">ì‚¬íšŒ</option>
            <option value="ê³¼í•™">ê³¼í•™</option>
          </select>
        </div>

        {/* ê³¼ëª© */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ê³¼ëª©
          </label>
          <input
            name="subject"
            defaultValue={lecture.subject ?? ""}
            placeholder="ì˜ˆ: í™”ë²•ê³¼ ì‘ë¬¸"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* í”Œë«í¼ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            í”Œë«í¼
          </label>
          <input
            name="platform"
            defaultValue={lecture.platform ?? ""}
            placeholder="ì˜ˆ: ë©”ê°€ìŠ¤í„°ë””, EBSi"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ì´ ê°•ì˜ì‹œê°„ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ì´ ê°•ì˜ì‹œê°„ (ë¶„)
          </label>
          <input
            name="duration"
            type="number"
            min="0"
            defaultValue={lecture.duration ?? ""}
            placeholder="ì˜ˆ: 300"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>

        {/* ë‚œì´ë„ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ë‚œì´ë„
          </label>
          <select
            name="difficulty"
            defaultValue={lecture.difficulty_level ?? ""}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          >
            <option value="">ì„ íƒí•˜ì„¸ìš”</option>
            <option value="í•˜">í•˜</option>
            <option value="ì¤‘">ì¤‘</option>
            <option value="ì¤‘ìƒ">ì¤‘ìƒ</option>
            <option value="ìƒ">ìƒ</option>
            <option value="ìµœìƒ">ìµœìƒ</option>
          </select>
        </div>

        {/* ë©”ëª¨ */}
        <div className="flex flex-col gap-1 md:col-span-2">
          <label className="block text-sm font-medium text-gray-700">
            ë©”ëª¨
          </label>
          <textarea
            name="notes"
            rows={3}
            defaultValue={lecture.notes ?? ""}
            placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
        </div>
      </div>

      {/* ë²„íŠ¼ */}
      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isPending}
          className="flex-1 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
        >
          {isPending ? "ìˆ˜ì • ì¤‘..." : "ë³€ê²½ì‚¬í•­ ì €ì¥"}
        </button>
        <Link
          href={`/contents/lectures/${lecture.id}`}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
        >
          ì·¨ì†Œ
        </Link>
      </div>
    </form>
  );
}
</file>

<file path="lectures/[id]/edit/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { LectureEditForm } from "./LectureEditForm";
import { Lecture } from "@/app/types/content";
import { getContainerClass } from "@/lib/constants/layout";

export default async function EditLecturePage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const selectLecture = () =>
    supabase
      .from("lectures")
      .select(
        "id,title,revision,semester,subject_category,subject,platform,difficulty_level,duration,notes,created_at"
      )
      .eq("id", id);

  let { data: lecture, error } = await selectLecture()
    .eq("student_id", user.id)
    .maybeSingle<Lecture>();

  if (error && error.code === "42703") {
    ({ data: lecture, error } = await selectLecture().maybeSingle<Lecture>());
  }

  if (error) {
    console.error(error);
    notFound();
  }

  if (!lecture) notFound();

  return (
    <section className={`${getContainerClass("FORM", "lg")} flex flex-col gap-6`}>
      <Link
        href={`/contents/lectures/${lecture.id}`}
        className="text-sm text-gray-500 transition hover:text-gray-900"
      >
        â† ìƒì„¸ë¡œ ëŒì•„ê°€ê¸°
      </Link>

      <div className="flex flex-col gap-2">
        <h1 className="text-2xl font-semibold">ê°•ì˜ ì •ë³´ ìˆ˜ì •</h1>
        <p className="text-sm text-gray-500">
          ë“±ë¡ëœ ë‚´ìš©ì„ ìˆ˜ì •í•œ ë’¤ ì €ì¥í•˜ë©´ ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.
        </p>
      </div>

      <div className="rounded-2xl border bg-white p-6 shadow-sm">
        <LectureEditForm lecture={lecture} />
      </div>
    </section>
  );
}
</file>

<file path="lectures/[id]/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { Suspense } from "react";
import { deleteLecture } from "@/app/(student)/actions/contentActions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { Lecture } from "@/app/types/content";
import { LectureDetailTabs } from "./_components/LectureDetailTabs";
import { getMasterLectureById } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";

export default async function LectureDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const selectLecture = () =>
    supabase
      .from("lectures")
      .select(
        "id,title,revision,semester,subject_category,subject,platform,difficulty_level,duration,total_episodes,notes,master_lecture_id,linked_book_id,created_at,content_category,lecture_type,subtitle,series_name,instructor_name,description,toc,curriculum_revision_id,subject_id,subject_group_id,grade_level,platform_id,lecture_source_url,source,source_product_code,cover_image_url,total_duration,video_url,transcript,episode_analysis,overall_difficulty,target_exam_type,tags,is_active"
      )
      .eq("id", id);

  let { data: lecture, error } = await selectLecture()
    .eq("student_id", user.id)
    .maybeSingle<Lecture & { master_lecture_id?: string | null; linked_book_id?: string | null; total_episodes?: number | null }>();

  if (error && error.code === "42703") {
    ({ data: lecture, error } = await selectLecture().maybeSingle<Lecture & { master_lecture_id?: string | null; linked_book_id?: string | null }>());
  }

  if (error) {
    console.error(error);
    notFound();
  }

  if (!lecture) notFound();

  // ë§ˆìŠ¤í„° ê°•ì˜ ì •ë³´ ì¡°íšŒ ë° ë³‘í•© (master_lecture_idê°€ ìˆëŠ” ê²½ìš°)
  let masterLecture = null;
  if (lecture.master_lecture_id) {
    try {
      const { lecture: master } = await getMasterLectureById(lecture.master_lecture_id);
      if (master) {
        masterLecture = master;
        // ë§ˆìŠ¤í„° ê°•ì˜ ì •ë³´ë¥¼ lecture ê°ì²´ì— ë³‘í•© (í•™ìƒ ê°•ì˜ì— ê°’ì´ ì—†ìœ¼ë©´ ë§ˆìŠ¤í„° ê°’ ì‚¬ìš©)
        lecture = {
          ...lecture,
          content_category: lecture.content_category || master.content_category || null,
          lecture_type: lecture.lecture_type || master.lecture_type || null,
          subtitle: lecture.subtitle || null, // MasterLectureì—ëŠ” subtitle í•„ë“œê°€ ì—†ìŒ
          series_name: lecture.series_name || null, // MasterLectureì—ëŠ” series_name í•„ë“œê°€ ì—†ìŒ
          instructor_name: lecture.instructor_name || master.instructor_name || null,
          description: lecture.description || null, // MasterLectureì—ëŠ” description í•„ë“œê°€ ì—†ìŒ
          toc: lecture.toc || null, // MasterLectureì—ëŠ” toc í•„ë“œê°€ ì—†ìŒ
          curriculum_revision_id: lecture.curriculum_revision_id || null, // MasterLectureì—ëŠ” curriculum_revision_id í•„ë“œê°€ ì—†ìŒ
          subject_id: lecture.subject_id || null, // MasterLectureì—ëŠ” subject_id í•„ë“œê°€ ì—†ìŒ
          subject_group_id: lecture.subject_group_id || null, // MasterLectureì—ëŠ” subject_group_id í•„ë“œê°€ ì—†ìŒ
          grade_level: lecture.grade_level || master.grade_level || null,
          platform_id: lecture.platform_id || master.platform_id || null,
          lecture_source_url: lecture.lecture_source_url || master.lecture_source_url || null,
          source: lecture.source || null, // MasterLectureì—ëŠ” source í•„ë“œê°€ ì—†ìŒ
          source_product_code: lecture.source_product_code || null, // MasterLectureì—ëŠ” source_product_code í•„ë“œê°€ ì—†ìŒ
          cover_image_url: lecture.cover_image_url || null, // MasterLectureì—ëŠ” cover_image_url í•„ë“œê°€ ì—†ìŒ
          total_duration: lecture.total_duration || master.total_duration || null,
          video_url: lecture.video_url || master.video_url || null,
          transcript: lecture.transcript || master.transcript || null,
          episode_analysis: lecture.episode_analysis || master.episode_analysis || null,
          overall_difficulty: lecture.overall_difficulty || master.overall_difficulty || null,
          target_exam_type: lecture.target_exam_type || null, // MasterLectureì—ëŠ” target_exam_type í•„ë“œê°€ ì—†ìŒ
          tags: lecture.tags || null, // MasterLectureì—ëŠ” tags í•„ë“œê°€ ì—†ìŒ
          is_active: lecture.is_active ?? true, // MasterLectureì—ëŠ” is_active í•„ë“œê°€ ì—†ìŒ
          // í”Œë«í¼ëª…ë„ ë³‘í•© (platformì´ ì—†ìœ¼ë©´ platform_name ì‚¬ìš©)
          platform: lecture.platform || master.platform_name || master.platform || null,
        };
      }
    } catch (err) {
      console.error("ë§ˆìŠ¤í„° ê°•ì˜ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", err);
    }
  }

  // ì—°ê²°ëœ êµì¬ ì¡°íšŒ (ìˆëŠ” ê²½ìš°)
  let linkedBook = null;
  if (lecture.linked_book_id) {
    const { data: book } = await supabase
      .from("books")
      .select("id, title")
      .eq("id", lecture.linked_book_id)
      .eq("student_id", user.id)
      .maybeSingle();
    linkedBook = book;
  }

  // í•™ìƒì˜ êµì¬ ëª©ë¡ ì¡°íšŒ (ì—°ê²°ëœ êµì¬ ì„ íƒìš©)
  const { data: studentBooks } = await supabase
    .from("books")
    .select("id, title")
    .eq("student_id", user.id)
    .order("title", { ascending: true });

  // ê°•ì˜ episode ì •ë³´ ì¡°íšŒ (í•™ìƒ ê°•ì˜ episode ìš°ì„ , ì—†ìœ¼ë©´ ë§ˆìŠ¤í„° ì°¸ì¡°)
  let lectureEpisodes: Array<{ 
    id: string; 
    lecture_id: string; 
    episode_number: number; 
    episode_title: string | null;
    duration: number | null; 
    display_order: number;
    created_at: string;
  }> = [];
  
  // ë¨¼ì € í•™ìƒ ê°•ì˜ episode ì¡°íšŒ
  const { data: studentEpisodes } = await supabase
    .from("student_lecture_episodes")
    .select("id,episode_number,episode_title,duration,display_order,created_at")
    .eq("lecture_id", id)
    .order("display_order", { ascending: true })
    .order("episode_number", { ascending: true });

  if (studentEpisodes && studentEpisodes.length > 0) {
    lectureEpisodes = studentEpisodes.map(e => ({
      id: e.id,
      lecture_id: lecture.id,
      episode_number: e.episode_number,
      episode_title: e.episode_title,
      duration: e.duration,
      display_order: e.display_order,
      created_at: e.created_at || "",
    }));
  } else if (lecture.master_lecture_id) {
    // í•™ìƒ ê°•ì˜ episodeê°€ ì—†ìœ¼ë©´ ë§ˆìŠ¤í„° ì°¸ì¡°
    try {
      const { episodes } = await getMasterLectureById(lecture.master_lecture_id);
      lectureEpisodes = episodes.map(e => ({
        id: e.id,
        lecture_id: lecture.id,
        episode_number: e.episode_number,
        episode_title: e.episode_title,
        duration: e.duration,
        display_order: e.display_order,
        created_at: "",
      }));
    } catch (err) {
      console.error("ë§ˆìŠ¤í„° ê°•ì˜ episode ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", err);
    }
  }

  // ì´ íšŒì°¨ ìë™ ê³„ì‚° (íšŒì°¨ ì •ë³´ ê¸°ë°˜)
  const calculatedTotalEpisodes = lectureEpisodes.length > 0
    ? Math.max(...lectureEpisodes.map(e => e.episode_number || 0))
    : null;
  
  // DBì˜ total_episodesì™€ ê³„ì‚°ëœ ê°’ì´ ë‹¤ë¥´ë©´ ì—…ë°ì´íŠ¸
  if (calculatedTotalEpisodes !== null && calculatedTotalEpisodes !== lecture.total_episodes) {
    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì—…ë°ì´íŠ¸ (ì—ëŸ¬ëŠ” ë¬´ì‹œ)
    supabase
      .from("lectures")
      .update({ total_episodes: calculatedTotalEpisodes })
      .eq("id", id)
      .then(({ error }) => {
        if (error) {
          console.error("[lecture] ì´ íšŒì°¨ ìë™ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
        }
      });
    // í‘œì‹œìš©ìœ¼ë¡œ ê³„ì‚°ëœ ê°’ ì‚¬ìš©
    lecture.total_episodes = calculatedTotalEpisodes;
  }

  const deleteAction = deleteLecture.bind(null, lecture.id);

  return (
    <section className={getContainerClass("CONTENT_DETAIL", "lg")}>
      <div className="rounded-2xl border bg-white p-8 shadow-sm">
        <Suspense fallback={<SuspenseFallback />}>
          <LectureDetailTabs
            lecture={lecture}
            deleteAction={deleteAction}
            linkedBook={linkedBook}
            studentBooks={studentBooks || []}
            initialEpisodes={lectureEpisodes.map((e) => ({
              id: e.id,
              lecture_id: e.lecture_id,
              episode_number: e.episode_number,
              episode_title: e.episode_title,
              duration: e.duration,
              display_order: e.display_order,
              created_at: e.created_at,
            }))}
            isFromMaster={!!lecture.master_lecture_id}
            masterLecture={masterLecture}
          />
        </Suspense>
      </div>
    </section>
  );
}
</file>

<file path="lectures/new/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useTransition } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { addLecture } from "@/app/(student)/actions/contentActions";
import { LectureEpisodesManager } from "@/app/(student)/contents/_components/LectureEpisodesManager";
import {
  getCurriculumRevisionsAction,
  getPlatformsAction,
} from "@/app/(student)/actions/contentMetadataActions";
import { getSubjectGroupsAction, getSubjectsByGroupAction } from "@/app/(student)/actions/contentMetadataActions";
import type { SubjectGroup, Subject } from "@/lib/data/subjects";

export default function NewLecturePage() {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();

  const [revisions, setRevisions] = useState<Array<{ id: string; name: string }>>([]);
  const [subjectGroups, setSubjectGroups] = useState<SubjectGroup[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [platforms, setPlatforms] = useState<Array<{ id: string; name: string }>>([]);

  const [selectedRevisionId, setSelectedRevisionId] = useState<string>("");
  const [selectedSubjectGroupId, setSelectedSubjectGroupId] = useState<string>("");
  const [selectedSubjectId, setSelectedSubjectId] = useState<string>("");
  const [selectedPlatformId, setSelectedPlatformId] = useState<string>("");

  useEffect(() => {
    loadMetadata();
  }, []);

  useEffect(() => {
    if (selectedRevisionId) {
      loadSubjectGroups(selectedRevisionId);
    } else {
      setSubjectGroups([]);
      setSubjects([]);
    }
  }, [selectedRevisionId]);

  useEffect(() => {
    if (selectedSubjectGroupId) {
      loadSubjects(selectedSubjectGroupId);
    } else {
      setSubjects([]);
    }
  }, [selectedSubjectGroupId]);

  async function loadMetadata() {
    try {
      const [revs, plats] = await Promise.all([
        getCurriculumRevisionsAction(),
        getPlatformsAction(),
      ]);
      setRevisions(revs.filter((r) => r.is_active));
      setPlatforms(plats.filter((p) => p.is_active));
    } catch (error) {
      console.error("ë©”íƒ€ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  async function loadSubjectGroups(revisionId: string) {
    try {
      const groups = await getSubjectGroupsAction(revisionId);
      setSubjectGroups(groups);
      setSelectedSubjectGroupId("");
      setSubjects([]);
    } catch (error) {
      console.error("êµê³¼ ê·¸ë£¹ ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  async function loadSubjects(subjectGroupId: string) {
    try {
      const subs = await getSubjectsByGroupAction(subjectGroupId);
      setSubjects(subs);
      setSelectedSubjectId("");
    } catch (error) {
      console.error("ê³¼ëª© ë¡œë“œ ì‹¤íŒ¨:", error);
    }
  }

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);

    // ê°œì •êµìœ¡ê³¼ì • ì´ë¦„ ì¶”ê°€
    if (selectedRevisionId) {
      const revision = revisions.find((r) => r.id === selectedRevisionId);
      if (revision) {
        formData.set("revision", revision.name);
      }
    }

    // êµê³¼ ì´ë¦„ ì¶”ê°€
    if (selectedSubjectGroupId) {
      const group = subjectGroups.find((g) => g.id === selectedSubjectGroupId);
      if (group) {
        formData.set("subject_category", group.name);
      }
    }

    // ê³¼ëª© ì´ë¦„ ì¶”ê°€
    if (selectedSubjectId) {
      const subject = subjects.find((s) => s.id === selectedSubjectId);
      if (subject) {
        formData.set("subject", subject.name);
      }
    }

    // í”Œë«í¼ ì´ë¦„ ì¶”ê°€
    if (selectedPlatformId) {
      const platform = platforms.find((p) => p.id === selectedPlatformId);
      if (platform) {
        formData.set("platform", platform.name);
      }
    }

    startTransition(async () => {
      try {
        await addLecture(formData);
        router.push("/contents");
        router.refresh();
      } catch (error) {
        console.error("ê°•ì˜ ë“±ë¡ ì‹¤íŒ¨:", error);
        alert(error instanceof Error ? error.message : "ê°•ì˜ ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  return (
    <section className="mx-auto flex flex-col gap-6 w-full max-w-3xl px-4 py-10">
      <div className="flex flex-col gap-2">
        <h1 className="text-3xl font-semibold text-gray-900">ğŸ§ ê°•ì˜ ë“±ë¡í•˜ê¸°</h1>
        <p className="text-sm text-gray-500">ìƒˆë¡œìš´ ê°•ì˜ë¥¼ ë“±ë¡í•˜ì„¸ìš”.</p>
      </div>

      <form onSubmit={handleSubmit} className="flex flex-col gap-6 rounded-lg border bg-white p-6 shadow-sm">
        <div className="grid gap-4 md:grid-cols-2">
          {/* ê°•ì˜ëª… */}
          <div className="flex flex-col gap-1 md:col-span-2">
            <label className="block text-sm font-medium text-gray-700">
              ê°•ì˜ëª… <span className="text-red-500">*</span>
            </label>
            <input
              name="title"
              required
              placeholder="ê°•ì˜ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>

          {/* ê°œì •êµìœ¡ê³¼ì • */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ê°œì •êµìœ¡ê³¼ì •
            </label>
            <select
              value={selectedRevisionId}
              onChange={(e) => {
                setSelectedRevisionId(e.target.value);
                setSelectedSubjectGroupId("");
                setSelectedSubjectId("");
              }}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              {revisions.map((rev) => (
                <option key={rev.id} value={rev.id}>
                  {rev.name}
                </option>
              ))}
            </select>
          </div>

          {/* êµê³¼ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">êµê³¼</label>
            <select
              value={selectedSubjectGroupId}
              onChange={(e) => {
                setSelectedSubjectGroupId(e.target.value);
                setSelectedSubjectId("");
              }}
              disabled={!selectedRevisionId}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
            >
              <option value="">
                {selectedRevisionId ? "ì„ íƒí•˜ì„¸ìš”" : "ê°œì •êµìœ¡ê³¼ì •ì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”"}
              </option>
              {subjectGroups.map((group) => (
                <option key={group.id} value={group.id}>
                  {group.name}
                </option>
              ))}
            </select>
          </div>

          {/* ê³¼ëª© */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">ê³¼ëª©</label>
            <select
              value={selectedSubjectId}
              onChange={(e) => setSelectedSubjectId(e.target.value)}
              disabled={!selectedSubjectGroupId}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:bg-gray-100 disabled:cursor-not-allowed"
            >
              <option value="">
                {selectedSubjectGroupId ? "ì„ íƒí•˜ì„¸ìš”" : "êµê³¼ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”"}
              </option>
              {subjects.map((subject) => (
                <option key={subject.id} value={subject.id}>
                  {subject.name}
                </option>
              ))}
            </select>
          </div>

          {/* í”Œë«í¼ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">í”Œë«í¼</label>
            <select
              value={selectedPlatformId}
              onChange={(e) => setSelectedPlatformId(e.target.value)}
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              {platforms.map((platform) => (
                <option key={platform.id} value={platform.id}>
                  {platform.name}
                </option>
              ))}
            </select>
          </div>

          {/* ì´ íšŒì°¨ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ì´ íšŒì°¨ <span className="text-red-500">*</span>
            </label>
            <input
              name="total_episodes"
              type="number"
              required
              min="1"
              placeholder="ì˜ˆ: 30"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>

          {/* ì´ ê°•ì˜ì‹œê°„ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ì´ ê°•ì˜ì‹œê°„ (ë¶„)
            </label>
            <input
              name="duration"
              type="number"
              min="0"
              placeholder="ì˜ˆ: 300"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>

          {/* ë‚œì´ë„ */}
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium text-gray-700">
              ë‚œì´ë„
            </label>
            <select
              name="difficulty"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            >
              <option value="">ì„ íƒí•˜ì„¸ìš”</option>
              <option value="ê°œë…">ê°œë…</option>
              <option value="ê¸°ë³¸">ê¸°ë³¸</option>
              <option value="ì‹¬í™”">ì‹¬í™”</option>
            </select>
          </div>

          {/* ë©”ëª¨ */}
          <div className="flex flex-col gap-1 md:col-span-2">
            <label className="block text-sm font-medium text-gray-700">
              ë©”ëª¨
            </label>
            <textarea
              name="notes"
              rows={3}
              placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
              className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
            />
          </div>
        </div>

        {/* ê°•ì˜ íšŒì°¨ ì •ë³´ */}
        <LectureEpisodesManager />

        {/* ë²„íŠ¼ */}
        <div className="flex gap-3">
          <button
            type="submit"
            disabled={isPending}
            className="flex-1 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
          >
            {isPending ? "ë“±ë¡ ì¤‘..." : "ë“±ë¡í•˜ê¸°"}
          </button>
          <Link
            href="/contents"
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </Link>
        </div>
      </form>
    </section>
  );
}
</file>

<file path="lectures/page.tsx">
// app/contents/lectures/page.tsx
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { addLecture } from "@/app/(student)/actions/contentActions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { getContainerClass } from "@/lib/constants/layout";

export default async function LecturesPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const { data: lectures } = await supabase
    .from("lectures")
    .select("*")
    .eq("student_id", user.id)
    .order("created_at", { ascending: false });

  return (
    <section className={getContainerClass("FORM", "lg")}>
      <div className="flex flex-col gap-6">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold">ê°•ì˜ ë“±ë¡</h1>
          <Link
            href="/contents?tab=lectures"
            className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
          >
            ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>

        <form action={addLecture} className="space-y-4 border p-4 rounded">
        <input
          name="title"
          placeholder="ê°•ì˜ëª…"
          required
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="platform"
          placeholder="í”Œë«í¼ (ë©”ê°€ìŠ¤í„°ë”” ë“±)"
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="subject"
          placeholder="ê³¼ëª©"
          className="w-full border rounded px-3 py-2"
        />
        <input
          type="number"
          name="duration"
          placeholder="ì´ ì‹œê°„(ë¶„)"
          required
          className="w-full border rounded px-3 py-2"
        />
        <input
          name="difficulty"
          placeholder="ë‚œì´ë„"
          className="w-full border rounded px-3 py-2"
        />

        <button className="w-full bg-black text-white py-2 rounded">
          ë“±ë¡í•˜ê¸°
        </button>
        </form>

        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-medium">ë“±ë¡ëœ ê°•ì˜</h2>

          <ul className="flex flex-col gap-3">
            {lectures?.map((l) => (
              <li key={l.id} className="border p-3 rounded">
                <strong>{l.title}</strong> ({l.subject})
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-books/_components/HierarchicalFilter.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";

type CurriculumRevision = {
  id: string;
  name: string;
};

type SubjectGroup = {
  id: string;
  name: string;
};

type Subject = {
  id: string;
  name: string;
};

type Publisher = {
  id: string;
  name: string;
};

type Platform = {
  id: string;
  name: string;
};

type HierarchicalFilterProps = {
  curriculumRevisions: CurriculumRevision[];
  initialCurriculumRevisionId?: string;
  initialSubjectGroupId?: string;
  initialSubjectId?: string;
  publishers?: Publisher[]; // êµì¬ìš©
  platforms?: Platform[]; // ê°•ì˜ìš©
  initialPublisherId?: string; // êµì¬ìš©
  initialPlatformId?: string; // ê°•ì˜ìš©
  contentType?: "book" | "lecture"; // êµì¬/ê°•ì˜ êµ¬ë¶„
  searchQuery?: string;
  basePath?: string;
};

export function HierarchicalFilter({
  curriculumRevisions,
  initialCurriculumRevisionId,
  initialSubjectGroupId,
  initialSubjectId,
  publishers = [],
  platforms = [],
  initialPublisherId,
  initialPlatformId,
  contentType = "book",
  searchQuery = "",
  basePath = "/contents/master-books",
}: HierarchicalFilterProps) {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [selectedCurriculumRevisionId, setSelectedCurriculumRevisionId] = useState(
    initialCurriculumRevisionId || ""
  );
  const [selectedSubjectGroupId, setSelectedSubjectGroupId] = useState(
    initialSubjectGroupId || ""
  );
  const [selectedSubjectId, setSelectedSubjectId] = useState(initialSubjectId || "");
  const [selectedPublisherId, setSelectedPublisherId] = useState(initialPublisherId || "");
  const [selectedPlatformId, setSelectedPlatformId] = useState(initialPlatformId || "");
  const [search, setSearch] = useState(searchQuery);

  const [subjectGroups, setSubjectGroups] = useState<SubjectGroup[]>([]);
  // êµê³¼ë³„ ê³¼ëª©ì„ Mapìœ¼ë¡œ ê´€ë¦¬ (êµê³¼ ID â†’ ê³¼ëª© ëª©ë¡)
  const [subjectsMap, setSubjectsMap] = useState<Map<string, Subject[]>>(new Map());
  const [loadingGroups, setLoadingGroups] = useState(false);
  const [loadingSubjects, setLoadingSubjects] = useState(false);

  // í˜„ì¬ ì„ íƒëœ êµê³¼ì˜ ê³¼ëª© ëª©ë¡
  const currentSubjects = selectedSubjectGroupId 
    ? subjectsMap.get(selectedSubjectGroupId) || []
    : [];

  // ì´ˆê¸° ë§ˆìš´íŠ¸ ì‹œ ì´ˆê¸°ê°’ì´ ìˆì„ ê²½ìš° ë³‘ë ¬ë¡œ ë°ì´í„° ë¡œë“œ
  useEffect(() => {
    if (initialCurriculumRevisionId) {
      // ì´ˆê¸°ê°’ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ë¡œë“œ
      loadHierarchyData(initialCurriculumRevisionId, initialSubjectGroupId, initialSubjectId);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ê°œì •êµìœ¡ê³¼ì • ë³€ê²½ ì‹œ êµê³¼ì™€ ê³¼ëª© ëª©ë¡ ë³‘ë ¬ ë¡œë“œ (ì´ˆê¸° ë¡œë“œ ì œì™¸)
  useEffect(() => {
    // ì´ˆê¸°ê°’ê³¼ ë‹¤ë¥¸ ê²½ìš°ì—ë§Œ ë¡œë“œ (ì¤‘ë³µ ë¡œë”© ë°©ì§€)
    if (
      selectedCurriculumRevisionId &&
      selectedCurriculumRevisionId !== initialCurriculumRevisionId
    ) {
      loadHierarchyData(selectedCurriculumRevisionId);
    } else if (!selectedCurriculumRevisionId) {
      setSubjectGroups([]);
      setSubjectsMap(new Map());
      setSelectedSubjectGroupId("");
      setSelectedSubjectId("");
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedCurriculumRevisionId]);

  // êµê³¼ ë³€ê²½ ì‹œ ê³¼ëª© ì´ˆê¸°í™” (ì´ë¯¸ ë¡œë“œëœ ë°ì´í„° ì‚¬ìš©)
  useEffect(() => {
    // êµê³¼ê°€ ë³€ê²½ë˜ê³  ì´ˆê¸°ê°’ê³¼ ë‹¤ë¥´ë©´ ê³¼ëª© ì´ˆê¸°í™”
    if (
      selectedSubjectGroupId &&
      selectedSubjectGroupId !== initialSubjectGroupId &&
      !subjectsMap.has(selectedSubjectGroupId)
    ) {
      // ëª¨ë“  ê³¼ëª©ì´ ì´ë¯¸ ë¡œë“œë˜ì–´ì•¼ í•˜ëŠ”ë° ì—†ëŠ” ê²½ìš°ì—ë§Œ ê°œë³„ ë¡œë“œ
      setLoadingSubjects(true);
      fetch(`/api/subjects?subject_group_id=${selectedSubjectGroupId}`)
        .then((res) => res.json())
        .then((data) => {
          const newSubjects = data.data || [];
          setSubjectsMap((prev) => {
            const next = new Map(prev);
            next.set(selectedSubjectGroupId, newSubjects);
            return next;
          });
          setLoadingSubjects(false);
        })
        .catch((err) => {
          console.error("ê³¼ëª© ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:", err);
          setLoadingSubjects(false);
        });
    }

    // êµê³¼ ë³€ê²½ ì‹œ ê³¼ëª© ì´ˆê¸°í™” (ì´ˆê¸°ê°’ì´ ì•„ë‹Œ ê²½ìš°)
    if (selectedSubjectGroupId !== initialSubjectGroupId) {
      setSelectedSubjectId("");
    }
  }, [selectedSubjectGroupId, initialSubjectGroupId, subjectsMap]);

  // ê³„ì¸µ êµ¬ì¡° ë°ì´í„° ë¡œë“œ (ë³‘ë ¬ ì²˜ë¦¬)
  const loadHierarchyData = async (
    curriculumRevisionId: string,
    preserveSubjectGroupId?: string,
    preserveSubjectId?: string
  ) => {
    setLoadingGroups(true);
    setLoadingSubjects(true);

    try {
      // êµê³¼ì™€ ê³¼ëª©ì„ í•¨ê»˜ ì¡°íšŒ (ë³‘ë ¬ ì²˜ë¦¬)
      const response = await fetch(
        `/api/subject-groups?curriculum_revision_id=${curriculumRevisionId}&include_subjects=true`
      );
      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || "ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨");
      }

      const groupsWithSubjects = result.data || [];
      const groups: SubjectGroup[] = groupsWithSubjects.map(
        (group: SubjectGroup & { subjects?: Subject[] }) => ({
          id: group.id,
          name: group.name,
        })
      );

      // êµê³¼ë³„ ê³¼ëª©ì„ Mapìœ¼ë¡œ ë³€í™˜
      const newSubjectsMap = new Map<string, Subject[]>();
      groupsWithSubjects.forEach((group: SubjectGroup & { subjects?: Subject[] }) => {
        if (group.subjects && group.subjects.length > 0) {
          newSubjectsMap.set(group.id, group.subjects);
        }
      });

      setSubjectGroups(groups);
      setSubjectsMap(newSubjectsMap);

      // ì´ˆê¸°ê°’ ë³´ì¡´
      if (preserveSubjectGroupId && newSubjectsMap.has(preserveSubjectGroupId)) {
        setSelectedSubjectGroupId(preserveSubjectGroupId);
        // í•´ë‹¹ êµê³¼ì˜ ê³¼ëª© ëª©ë¡ì´ ìˆê³  preserveSubjectIdê°€ ìˆìœ¼ë©´ ì„¤ì •
        const subjects = newSubjectsMap.get(preserveSubjectGroupId) || [];
        if (preserveSubjectId && subjects.some((s) => s.id === preserveSubjectId)) {
          setSelectedSubjectId(preserveSubjectId);
        }
      } else if (!preserveSubjectGroupId) {
        // ì´ˆê¸°ê°’ì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
        setSelectedSubjectGroupId("");
        setSelectedSubjectId("");
      }

      setLoadingGroups(false);
      setLoadingSubjects(false);
    } catch (err) {
      console.error("ê³„ì¸µ êµ¬ì¡° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", err);
      setLoadingGroups(false);
      setLoadingSubjects(false);
      setSubjectGroups([]);
      setSubjectsMap(new Map());
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const params = new URLSearchParams();
    
    if (selectedCurriculumRevisionId) {
      params.set("curriculum_revision_id", selectedCurriculumRevisionId);
    }
    if (selectedSubjectGroupId) {
      params.set("subject_group_id", selectedSubjectGroupId);
    }
    if (selectedSubjectId) {
      params.set("subject_id", selectedSubjectId);
    }
    if (contentType === "book" && selectedPublisherId) {
      params.set("publisher_id", selectedPublisherId);
    }
    if (contentType === "lecture" && selectedPlatformId) {
      params.set("platform_id", selectedPlatformId);
    }
    if (search.trim()) {
      params.set("search", search.trim());
    }

    router.push(`${basePath}?${params.toString()}`);
  };

  const handleReset = () => {
    router.push(basePath);
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="flex flex-wrap items-end gap-4 sm:gap-4"
    >
      {/* ê°œì •êµìœ¡ê³¼ì • */}
      <div className="flex flex-col gap-1 min-w-[160px]">
        <label className="text-xs font-medium text-gray-700">
          ê°œì •êµìœ¡ê³¼ì •
        </label>
        <select
          value={selectedCurriculumRevisionId}
          onChange={(e) => setSelectedCurriculumRevisionId(e.target.value)}
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
        >
          <option value="">ì „ì²´</option>
          {curriculumRevisions.map((rev) => (
            <option key={rev.id} value={rev.id}>
              {rev.name}
            </option>
          ))}
        </select>
      </div>

      {/* êµê³¼ */}
      <div className="flex flex-col gap-1 min-w-[140px]">
        <label className="text-xs font-medium text-gray-700">êµê³¼</label>
        <select
          value={selectedSubjectGroupId}
          onChange={(e) => setSelectedSubjectGroupId(e.target.value)}
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm disabled:bg-gray-100 disabled:cursor-not-allowed"
          disabled={!selectedCurriculumRevisionId || loadingGroups}
        >
          <option value="">ì „ì²´</option>
          {loadingGroups ? (
            <option value="">ë¡œë”© ì¤‘...</option>
          ) : (
            subjectGroups.map((group) => (
              <option key={group.id} value={group.id}>
                {group.name}
              </option>
            ))
          )}
        </select>
      </div>

      {/* ê³¼ëª© */}
      <div className="flex flex-col gap-1 min-w-[140px]">
        <label className="text-xs font-medium text-gray-700">ê³¼ëª©</label>
        <select
          value={selectedSubjectId}
          onChange={(e) => setSelectedSubjectId(e.target.value)}
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm disabled:bg-gray-100 disabled:cursor-not-allowed"
          disabled={!selectedSubjectGroupId || loadingSubjects}
        >
          <option value="">ì „ì²´</option>
          {loadingSubjects ? (
            <option value="">ë¡œë”© ì¤‘...</option>
          ) : (
            currentSubjects.map((subject) => (
              <option key={subject.id} value={subject.id}>
                {subject.name}
              </option>
            ))
          )}
        </select>
      </div>

      {/* ì¶œíŒì‚¬ (êµì¬ìš©) */}
      {contentType === "book" && publishers.length > 0 && (
        <div className="flex flex-col gap-1 min-w-[140px]">
          <label className="text-xs font-medium text-gray-700">ì¶œíŒì‚¬</label>
          <select
            value={selectedPublisherId}
            onChange={(e) => setSelectedPublisherId(e.target.value)}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
          >
            <option value="">ì „ì²´</option>
            {publishers.map((publisher) => (
              <option key={publisher.id} value={publisher.id}>
                {publisher.name}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* í”Œë«í¼ (ê°•ì˜ìš©) */}
      {contentType === "lecture" && platforms.length > 0 && (
        <div className="flex flex-col gap-1 min-w-[140px]">
          <label className="text-xs font-medium text-gray-700">í”Œë«í¼</label>
          <select
            value={selectedPlatformId}
            onChange={(e) => setSelectedPlatformId(e.target.value)}
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
          >
            <option value="">ì „ì²´</option>
            {platforms.map((platform) => (
              <option key={platform.id} value={platform.id}>
                {platform.name}
              </option>
            ))}
          </select>
        </div>
      )}

      {/* ì œëª© ê²€ìƒ‰ */}
      <div className="flex flex-col gap-1 min-w-[200px] flex-1 max-w-[300px]">
        <label className="text-xs font-medium text-gray-700">
          ì œëª© ê²€ìƒ‰
        </label>
        <input
          type="text"
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          placeholder={contentType === "book" ? "êµì¬ëª… ì…ë ¥" : "ê°•ì˜ëª… ì…ë ¥"}
          className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm"
        />
      </div>

      {/* ê²€ìƒ‰ ë²„íŠ¼ */}
      <button
        type="submit"
        className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
      >
        ê²€ìƒ‰
      </button>

      {/* ì´ˆê¸°í™” ë²„íŠ¼ */}
      <button
        type="button"
        onClick={handleReset}
        className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
      >
        ì´ˆê¸°í™”
      </button>
    </form>
  );
}
</file>

<file path="master-books/[id]/_components/CopyMasterBookButton.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { copyMasterToStudentContentAction } from "@/app/(student)/actions/contentMasterActions";

type CopyMasterBookButtonProps = {
  masterBookId: string;
};

export function CopyMasterBookButton({
  masterBookId,
}: CopyMasterBookButtonProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const handleCopy = async () => {
    setError(null);
    setSuccess(null);
    setIsLoading(true);

    try {
      const result = await copyMasterToStudentContentAction(masterBookId);
      const bookId = result.bookId;
      
      if (bookId) {
        setSuccess("êµì¬ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!");
        
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ í›„ ê²€ìƒ‰ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        setTimeout(() => {
          router.push("/contents/master-books");
          router.refresh();
        }, 1500);
      } else {
        setError("êµì¬ ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        setIsLoading(false);
      }
    } catch (err) {
      const errorMessage = err instanceof Error 
        ? err.message 
        : "êµì¬ ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
      setError(errorMessage);
      setIsLoading(false);
    }
  };

  return (
    <div className="flex-1">
      <button
        type="button"
        onClick={handleCopy}
        disabled={isLoading}
        className="w-full rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:bg-indigo-400 disabled:hover:bg-indigo-400"
      >
        {isLoading ? "ê°€ì ¸ì˜¤ëŠ” ì¤‘..." : "ë‚´ êµì¬ë¡œ ê°€ì ¸ì˜¤ê¸°"}
      </button>
      
      <div className="flex flex-col gap-2">
        {success && (
          <div className="rounded-lg bg-green-50 px-3 py-2 text-sm text-green-700">
            âœ… {success}
          </div>
        )}
        
        {error && (
          <div className="rounded-lg bg-red-50 px-3 py-2 text-sm text-red-700">
            âŒ {error}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="master-books/[id]/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { getMasterBookById } from "@/lib/data/contentMasters";
import { ContentHeader } from "@/app/(student)/contents/_components/ContentHeader";
import { ContentDetailTable } from "@/app/(student)/contents/_components/ContentDetailTable";
import { BookDetailsDisplay } from "@/app/(student)/contents/_components/BookDetailsDisplay";
import { CopyMasterBookButton } from "./_components/CopyMasterBookButton";
import { getContainerClass } from "@/lib/constants/layout";

export default async function StudentMasterBookDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  // êµì¬ ì¡°íšŒ
  const { book, details } = await getMasterBookById(id);

  if (!book) notFound();

  return (
    <section className={`${getContainerClass("CONTENT_DETAIL", "lg")} flex flex-col gap-8`}>
      <div className="rounded-2xl border bg-white p-8 shadow-sm">
        <ContentHeader
          title={book.title}
          subtitle={book.publisher || ""}
          icon="ğŸ“š êµì¬"
          createdAt={book.created_at}
          coverImageUrl={book.cover_image_url}
        />

        <ContentDetailTable
          rows={[
            { label: "ê°œì •êµìœ¡ê³¼ì •", value: book.revision ?? null },
            { label: "êµê³¼", value: book.subject_category ?? null },
            { label: "ê³¼ëª©", value: book.subject ?? null },
            { label: "ì¶œíŒì‚¬", value: book.publisher ?? null },
            { label: "ì´ í˜ì´ì§€", value: book.total_pages ? `${book.total_pages}p` : null },
            { label: "ë‚œì´ë„", value: book.difficulty_level ?? null },
            { label: "ë©”ëª¨", value: book.notes ?? null },
            { label: "ì¶œì²˜ URL", value: book.source_url ?? null, isUrl: !!book.source_url },
          ]}
        />

        {/* êµì¬ ëª©ì°¨ (ê³„ì¸µì  í‘œì‹œ) */}
        {details.length > 0 && <BookDetailsDisplay details={details} />}

        {/* ì•¡ì…˜ ë²„íŠ¼ */}
        <div className="flex flex-col gap-4 border-t pt-8">
          <div className="flex flex-col gap-3 sm:flex-row">
            <Link
              href="/contents/master-books"
              className="inline-flex flex-1 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ëª©ë¡ìœ¼ë¡œ
            </Link>
            <CopyMasterBookButton masterBookId={id} />
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-books/page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import Image from "next/image";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { searchMasterBooks, getPublishersForFilter, getDifficultiesForMasterBooks } from "@/lib/data/contentMasters";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { MasterBookFilters } from "@/lib/data/contentMasters";
import { unstable_cache } from "next/cache";
import { createSupabasePublicClient } from "@/lib/supabase/server";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { inlineButtonBase } from "@/lib/utils/darkMode";

// ê²€ìƒ‰ ê²°ê³¼ ì¡°íšŒ í•¨ìˆ˜ (ìºì‹± ì ìš©)
async function getCachedSearchResults(filters: MasterBookFilters) {
  // ì•ˆì •ì ì¸ ìºì‹œ í‚¤ ìƒì„±
      const cacheKey = [
        "master-books-search",
        filters.curriculum_revision_id || "",
        filters.subject_group_id || "",
        filters.subject_id || "",
        filters.publisher_id || "",
        filters.search || "",
        filters.difficulty || "",
        filters.sort || "",
        filters.limit || 50,
      ].join("-");
  
  const getCached = unstable_cache(
    async (filters: MasterBookFilters) => {
      // ìºì‹œ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ê³µê°œ ë°ì´í„°ìš© Supabase í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì¿ í‚¤ ì—†ì´)
      // master_booksëŠ” ê³µê°œ ë°ì´í„°ì´ë¯€ë¡œ ì¸ì¦ì´ í•„ìš” ì—†ìŒ
      const supabase = createSupabasePublicClient();
      
      let query = supabase
        .from("master_books")
        .select("*", { count: "exact" });

      // í•„í„° ì ìš©
      if (filters.curriculum_revision_id) {
        query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
      }
      if (filters.subject_group_id) {
        query = query.eq("subject_group_id", filters.subject_group_id);
      }
      if (filters.subject_id) {
        query = query.eq("subject_id", filters.subject_id);
      }
      if (filters.publisher_id) {
        query = query.eq("publisher_id", filters.publisher_id);
      }
      if (filters.search) {
        query = query.ilike("title", `%${filters.search}%`);
      }
      if (filters.difficulty) {
        query = query.eq("difficulty_level", filters.difficulty);
      }
      if (filters.tenantId) {
        query = query.or(`tenant_id.is.null,tenant_id.eq.${filters.tenantId}`);
      } else {
        query = query.is("tenant_id", null);
      }

      // ì •ë ¬
      const sortBy = filters.sort || "updated_at_desc";
      if (sortBy === "title_asc") {
        query = query.order("title", { ascending: true });
      } else if (sortBy === "title_desc") {
        query = query.order("title", { ascending: false });
      } else if (sortBy === "difficulty_level_asc") {
        query = query.order("difficulty_level", { ascending: true });
      } else if (sortBy === "difficulty_level_desc") {
        query = query.order("difficulty_level", { ascending: false });
      } else if (sortBy === "created_at_asc") {
        query = query.order("created_at", { ascending: true });
      } else if (sortBy === "created_at_desc") {
        query = query.order("created_at", { ascending: false });
      } else {
        // ê¸°ë³¸ê°’: updated_at_desc
        query = query.order("updated_at", { ascending: false });
      }

      // í˜ì´ì§€ë„¤ì´ì…˜
      if (filters.limit) {
        query = query.limit(filters.limit);
      }
      if (filters.offset) {
        query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);
      }

      const { data, error, count } = await query;

      if (error) {
        console.error("[master-books] ê²€ìƒ‰ ì‹¤íŒ¨", error);
        throw new Error(error.message || "êµì¬ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }

      return {
        data: (data || []) as any[],
        total: count ?? 0,
      };
    },
    [cacheKey],
    {
      revalidate: 60, // 1ë¶„ ìºì‹œ
      tags: ["master-books-search"],
    }
  );

  return getCached(filters);
}


function FilterFormWrapper({
  params,
  filterOptions,
}: {
  params: Record<string, string | undefined>;
  filterOptions: { 
    curriculumRevisions: Array<{ id: string; name: string }>; 
    publishers: Array<{ id: string; name: string }>;
    difficulties: string[];
  };
}) {
  return (
    <div className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm">
      <UnifiedContentFilter
        context="master"
        contentType="book"
        basePath="/contents/master-books"
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="updated_at_desc"
      />
    </div>
  );
}

export default async function StudentMasterBooksPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const { userId, role } = await getCurrentUserRole();

  if (!userId) redirect("/login");

  // ê²€ìƒ‰ í•„í„° êµ¬ì„±
  const filters: MasterBookFilters = {
    curriculum_revision_id: params.curriculum_revision_id,
    subject_group_id: params.subject_group_id,
    subject_id: params.subject_id,
    publisher_id: params.publisher_id,
    search: params.search,
    difficulty: params.difficulty,
    sort: params.sort || "updated_at_desc",
    limit: 50,
  };

  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ë“œë¡­ë‹¤ìš´ìš©) - ìºì‹œ ì—†ì´ ì§ì ‘ ì¡°íšŒ
  const [curriculumRevisions, publishers, difficulties] = await Promise.all([
    getCurriculumRevisions(),
    getPublishersForFilter(),
    getDifficultiesForMasterBooks(),
  ]);

  // ê²€ìƒ‰ ê²°ê³¼ ì¡°íšŒ (ìºì‹± ì ìš©)
  const searchResult = await getCachedSearchResults(filters);
  const { data: books, total } = searchResult;

  const filterOptions = {
    curriculumRevisions: curriculumRevisions.map((rev) => ({
      id: rev.id,
      name: rev.name,
    })),
    publishers,
    difficulties,
  };

  console.log("[student/master-books] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ê²°ê³¼:", {
    count: curriculumRevisions.length,
    revisions: curriculumRevisions.map((r) => ({ id: r.id, name: r.name })),
  });

  console.log("[student/master-books] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ê²°ê³¼:", {
    count: curriculumRevisions.length,
    revisions: curriculumRevisions.map((r) => ({ id: r.id, name: r.name })),
  });

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-500 dark:text-gray-400">ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„°</p>
            <h1 className="text-3xl font-semibold text-gray-900 dark:text-gray-100">êµì¬ ê²€ìƒ‰</h1>
            <p className="text-sm text-gray-500 dark:text-gray-400">
              ì„œë¹„ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” êµì¬ë¥¼ ê²€ìƒ‰í•˜ê³  ë‚´ êµì¬ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/contents"
            className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
          >
            â† ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>

        {/* ê²€ìƒ‰ í•„í„° */}
        <Suspense fallback={<SuspenseFallback />}>
          <FilterFormWrapper params={params} filterOptions={filterOptions} />
        </Suspense>

        {/* ê²°ê³¼ ê°œìˆ˜ */}
        <div className="text-sm text-gray-600 dark:text-gray-400">
          ì´ <span className="font-semibold">{total}</span>ê°œì˜ êµì¬ê°€
          ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.
        </div>

        {/* êµì¬ ëª©ë¡ */}
        <div>
          {books.length === 0 ? (
            <div className="rounded-xl border border-dashed border-gray-300 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 p-12 text-center">
              <div className="mx-auto flex max-w-md flex-col gap-6">
                <div className="text-6xl">ğŸ“š</div>
                <div className="flex flex-col gap-2">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                    ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
                  </h3>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    ë‹¤ë¥¸ ê²€ìƒ‰ ì¡°ê±´ìœ¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš”.
                  </p>
                </div>
              </div>
            </div>
          ) : (
            <ul className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
              {books.map((book) => (
                <li
                  key={book.id}
                  className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm"
                >
                  <div className="flex flex-col gap-3">
                    {book.cover_image_url && (
                      <div className="relative h-40 w-full overflow-hidden rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-100 dark:bg-gray-700">
                        <Image
                          src={book.cover_image_url}
                          alt={`${book.title} í‘œì§€`}
                          fill
                          className="object-cover"
                          sizes="(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw"
                        />
                      </div>
                    )}
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                        {book.title}
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400">
                        {book.publisher || "ì¶œíŒì‚¬ ì •ë³´ ì—†ìŒ"}
                      </p>
                    </div>

                    <dl className="grid gap-y-1 text-sm text-gray-600 dark:text-gray-400">
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ê°œì •</dt>
                        <dd>{book.revision || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">êµê³¼</dt>
                        <dd>{book.subject_category || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ê³¼ëª©</dt>
                        <dd>{book.subject || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ì´ í˜ì´ì§€</dt>
                        <dd>{book.total_pages}p</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ë‚œì´ë„</dt>
                        <dd>{book.difficulty_level || "â€”"}</dd>
                      </div>
                    </dl>

                    <Link
                      href={`/contents/master-books/${book.id}`}
                      className="inline-flex items-center justify-center rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
                    >
                      ìƒì„¸ë³´ê¸°
                    </Link>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-custom-contents/[id]/_components/CopyMasterCustomContentButton.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { copyMasterToStudentContentAction } from "@/app/(student)/actions/contentMasterActions";

type CopyMasterCustomContentButtonProps = {
  masterContentId: string;
};

export function CopyMasterCustomContentButton({
  masterContentId,
}: CopyMasterCustomContentButtonProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const handleCopy = async () => {
    setError(null);
    setSuccess(null);
    setIsLoading(true);

    try {
      const result = await copyMasterToStudentContentAction(masterContentId);
      const contentId = result.contentId;
      
      if (contentId) {
        setSuccess("ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!");
        
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ í›„ ì½˜í…ì¸  í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        setTimeout(() => {
          router.push("/contents?tab=custom");
          router.refresh();
        }, 1500);
      } else {
        setError("ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        setIsLoading(false);
      }
    } catch (err) {
      const errorMessage = err instanceof Error 
        ? err.message 
        : "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
      setError(errorMessage);
      setIsLoading(false);
    }
  };

  return (
    <div className="flex-1">
      <button
        type="button"
        onClick={handleCopy}
        disabled={isLoading}
        className="w-full rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:bg-indigo-400 disabled:hover:bg-indigo-400"
      >
        {isLoading ? "ê°€ì ¸ì˜¤ëŠ” ì¤‘..." : "ë‚´ ì½˜í…ì¸ ë¡œ ê°€ì ¸ì˜¤ê¸°"}
      </button>
      
      <div className="flex flex-col gap-2">
        {success && (
          <div className="rounded-lg bg-green-50 px-3 py-2 text-sm text-green-700">
            âœ… {success}
          </div>
        )}
        
        {error && (
          <div className="rounded-lg bg-red-50 px-3 py-2 text-sm text-red-700">
            âŒ {error}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="master-custom-contents/[id]/page.tsx">
import Link from "next/link";
import { notFound, redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getMasterCustomContentById } from "@/lib/data/contentMasters";
import { ContentHeader } from "@/app/(student)/contents/_components/ContentHeader";
import { ContentDetailTable } from "@/app/(student)/contents/_components/ContentDetailTable";
import { CopyMasterCustomContentButton } from "./_components/CopyMasterCustomContentButton";
import { getContainerClass } from "@/lib/constants/layout";

export default async function StudentMasterCustomContentDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const { role } = await getCurrentUserRole();

  if (role !== "student") {
    redirect("/login");
  }

  // ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ
  const { content } = await getMasterCustomContentById(id);

  if (!content) notFound();

  return (
    <section className={`${getContainerClass("CONTENT_DETAIL", "lg")} flex flex-col gap-8`}>
      <div className="rounded-2xl border bg-white p-8 shadow-sm">
        <ContentHeader
          title={content.title}
          subtitle={content.content_type || ""}
          icon="ğŸ“ ì»¤ìŠ¤í…€ ì½˜í…ì¸ "
          createdAt={content.created_at}
        />

        <ContentDetailTable
          rows={[
            { label: "ê°œì •êµìœ¡ê³¼ì •", value: content.revision },
            { label: "êµê³¼", value: content.subject_category },
            { label: "ê³¼ëª©", value: content.subject },
            { label: "ì½˜í…ì¸  ìœ í˜•", value: content.content_type },
            {
              label: content.content_type === "book" ? "ì´ í˜ì´ì§€" : "ì´ ì‹œê°„",
              value: content.total_page_or_time
                ? content.content_type === "book"
                  ? `${content.total_page_or_time}p`
                  : `${content.total_page_or_time}ë¶„`
                : null,
            },
            { label: "ë‚œì´ë„", value: content.difficulty_level },
            { label: "ì½˜í…ì¸  ì¹´í…Œê³ ë¦¬", value: content.content_category },
            { label: "ë©”ëª¨", value: content.notes },
          ]}
        />

        {/* ì•¡ì…˜ ë²„íŠ¼ */}
        <div className="flex flex-col gap-4 border-t pt-8">
          <div className="flex flex-col gap-3 sm:flex-row">
            <Link
              href="/contents/master-custom-contents"
              className="inline-flex flex-1 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ëª©ë¡ìœ¼ë¡œ
            </Link>
            <CopyMasterCustomContentButton masterContentId={id} />
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-custom-contents/page.tsx">
import Link from "next/link";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { searchMasterCustomContents, getCurriculumRevisions } from "@/lib/data/contentMasters";
import { MasterCustomContentFilters } from "@/lib/data/contentMasters";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { getContainerClass } from "@/lib/constants/layout";
import { inlineButtonBase } from "@/lib/utils/darkMode";

export default async function StudentMasterCustomContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const { role } = await getCurrentUserRole();

  if (role !== "student") {
    redirect("/login");
  }

  const tenantContext = await getTenantContext();

  // í…Œë„ŒíŠ¸ ID ì „ë‹¬ (ê³µê°œ ì½˜í…ì¸  + ìì‹ ì˜ í…Œë„ŒíŠ¸ ì½˜í…ì¸ )
  const tenantId = tenantContext?.tenantId || undefined;

  // ê²€ìƒ‰ í•„í„° êµ¬ì„±
  const filters: MasterCustomContentFilters = {
    curriculum_revision_id: params.curriculum_revision_id,
    subject_group_id: params.subject_group_id,
    subject_id: params.subject_id,
    content_type: params.content_type,
    search: params.search,
    difficulty: params.difficulty,
    sort: params.sort || "updated_at_desc",
    tenantId, // í…Œë„ŒíŠ¸ ID ì¶”ê°€
    limit: 50,
  };

  const { data: contents, total } = await searchMasterCustomContents(filters);

  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ë“œë¡­ë‹¤ìš´ìš©)
  const curriculumRevisions = await getCurriculumRevisions().catch(() => []);

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-700 dark:text-gray-300">ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„°</p>
            <h1 className="text-3xl font-semibold text-gray-900 dark:text-gray-100">ì»¤ìŠ¤í…€ ì½˜í…ì¸  ëª©ë¡</h1>
            <p className="text-sm text-gray-700 dark:text-gray-300">
              ì„œë¹„ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ê²€ìƒ‰í•˜ê³  ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/contents"
            className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
          >
            ë‚´ ì½˜í…ì¸ ë¡œ
          </Link>
        </div>

        {/* ê²€ìƒ‰ í•„í„° */}
        <div className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm">
          <UnifiedContentFilter
            context="student"
            contentType="custom"
            basePath="/contents/master-custom-contents"
            initialValues={{
              curriculum_revision_id: params.curriculum_revision_id,
              subject_group_id: params.subject_group_id,
              subject_id: params.subject_id,
              content_type: params.content_type,
              search: params.search,
              difficulty: params.difficulty,
              sort: params.sort,
            }}
            filterOptions={{
              curriculumRevisions,
            }}
            showDifficulty={true}
            showSort={true}
            defaultSort="updated_at_desc"
          />
        </div>

        {/* ê²°ê³¼ ê°œìˆ˜ */}
        <div className="text-sm text-gray-600 dark:text-gray-400">
          ì´ <span className="font-semibold">{total}</span>ê°œì˜ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ê°€
          ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.
        </div>

        {/* ì»¤ìŠ¤í…€ ì½˜í…ì¸  ëª©ë¡ */}
        <div>
          {contents.length === 0 ? (
            <div className="rounded-xl border border-dashed border-gray-300 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 p-12 text-center">
              <div className="mx-auto flex max-w-md flex-col gap-6">
                <div className="text-6xl">ğŸ“</div>
                <div className="flex flex-col gap-2">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                    ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
                  </h3>
                  <p className="text-sm text-gray-700 dark:text-gray-300">
                    ë‹¤ë¥¸ ê²€ìƒ‰ ì¡°ê±´ìœ¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš”.
                  </p>
                </div>
              </div>
            </div>
          ) : (
            <ul className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
              {contents.map((content) => (
                <li
                  key={content.id}
                  className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm"
                >
                  <div className="flex flex-col gap-3">
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                        {content.title}
                      </h3>
                      <p className="text-sm text-gray-700 dark:text-gray-300">
                        {content.content_type || "ìœ í˜• ì •ë³´ ì—†ìŒ"}
                      </p>
                    </div>

                    <dl className="grid gap-y-1 text-sm text-gray-600 dark:text-gray-400">
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-700 dark:text-gray-300">ê°œì •</dt>
                        <dd>{content.revision || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-700 dark:text-gray-300">ê³¼ëª©</dt>
                        <dd>{content.subject || "â€”"}</dd>
                      </div>
                      {content.total_page_or_time && (
                        <div className="flex justify-between">
                          <dt className="font-medium text-gray-700 dark:text-gray-300">
                            {content.content_type === "book" ? "ì´ í˜ì´ì§€" : "ì´ ì‹œê°„"}
                          </dt>
                          <dd>
                            {content.content_type === "book"
                              ? `${content.total_page_or_time}p`
                              : `${content.total_page_or_time}ë¶„`}
                          </dd>
                        </div>
                      )}
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-700 dark:text-gray-300">ë‚œì´ë„</dt>
                        <dd>{content.difficulty_level || "â€”"}</dd>
                      </div>
                    </dl>

                    <Link
                      href={`/contents/master-custom-contents/${content.id}`}
                      className="inline-flex items-center justify-center rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
                    >
                      ìƒì„¸ë³´ê¸°
                    </Link>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-lectures/[id]/_components/CopyMasterLectureButton.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { copyMasterToStudentContentAction } from "@/app/(student)/actions/contentMasterActions";

type CopyMasterLectureButtonProps = {
  masterLectureId: string;
};

export function CopyMasterLectureButton({
  masterLectureId,
}: CopyMasterLectureButtonProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const handleCopy = async () => {
    setError(null);
    setSuccess(null);
    setIsLoading(true);

    try {
      const result = await copyMasterToStudentContentAction(masterLectureId);
      const lectureId = result.lectureId;
      
      if (lectureId) {
        setSuccess("ê°•ì˜ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!");
        
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ í›„ ê²€ìƒ‰ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        setTimeout(() => {
          router.push("/contents/master-lectures");
          router.refresh();
        }, 1500);
      } else {
        setError("ê°•ì˜ ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        setIsLoading(false);
      }
    } catch (err) {
      const errorMessage = err instanceof Error 
        ? err.message 
        : "ê°•ì˜ ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
      setError(errorMessage);
      setIsLoading(false);
    }
  };

  return (
    <div className="flex-1">
      <button
        type="button"
        onClick={handleCopy}
        disabled={isLoading}
        className="w-full rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:bg-indigo-400 disabled:hover:bg-indigo-400"
      >
        {isLoading ? "ê°€ì ¸ì˜¤ëŠ” ì¤‘..." : "ë‚´ ê°•ì˜ë¡œ ê°€ì ¸ì˜¤ê¸°"}
      </button>
      
      <div className="flex flex-col gap-2">
        {success && (
          <div className="rounded-lg bg-green-50 px-3 py-2 text-sm text-green-700">
            âœ… {success}
          </div>
        )}
        
        {error && (
          <div className="rounded-lg bg-red-50 px-3 py-2 text-sm text-red-700">
            âŒ {error}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="master-lectures/[id]/page.tsx">
import Link from "next/link";
import { notFound } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  getMasterLectureById,
} from "@/lib/data/contentMasters";
import { ContentHeader } from "@/app/(student)/contents/_components/ContentHeader";
import { ContentDetailTable } from "@/app/(student)/contents/_components/ContentDetailTable";
import { LectureEpisodesDisplay } from "@/app/(student)/contents/_components/LectureEpisodesDisplay";
import { CopyMasterLectureButton } from "./_components/CopyMasterLectureButton";
import { secondsToMinutes } from "@/lib/utils/duration";
import { formatGradeLevel } from "@/lib/utils/formatGradeLevel";
import { getContainerClass } from "@/lib/constants/layout";

export default async function StudentMasterLectureDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  const supabase = await createSupabaseServerClient();

  // ê°•ì˜ ì¡°íšŒ
  const { lecture, episodes } = await getMasterLectureById(id);

  if (!lecture) notFound();

  // ì—°ê²°ëœ êµì¬ ì¡°íšŒ (ìˆëŠ” ê²½ìš°)
  let linkedBook = null;
  if (lecture.linked_book_id) {
    const { data: book } = await supabase
      .from("master_books")
      .select("id, title")
      .eq("id", lecture.linked_book_id)
      .maybeSingle();
    linkedBook = book;
  }

  return (
    <section className={`${getContainerClass("CONTENT_DETAIL", "lg")} flex flex-col gap-8`}>
      <div className="rounded-2xl border bg-white p-8 shadow-sm">
        <ContentHeader
          title={lecture.title}
          subtitle={lecture.platform_name || lecture.platform || ""}
          icon="ğŸ§ ê°•ì˜"
          createdAt={lecture.created_at}
        />

        <ContentDetailTable
          rows={[
            { label: "ê°œì •êµìœ¡ê³¼ì •", value: lecture.revision },
            { label: "êµê³¼", value: lecture.subject_category },
            { label: "ê³¼ëª©", value: lecture.subject },
            { label: "í”Œë«í¼", value: lecture.platform_name || lecture.platform },
            { label: "ê°•ì‚¬", value: lecture.instructor_name },
            { label: "ê°•ì˜ ìœ í˜•", value: lecture.lecture_type },
            { label: "ì´ íšŒì°¨", value: lecture.total_episodes ? `${lecture.total_episodes}íšŒ` : null },
            {
              label: "ì´ ê°•ì˜ì‹œê°„",
              value: lecture.total_duration
                ? `${secondsToMinutes(lecture.total_duration)}ë¶„`
                : null,
            },
            { label: "ë‚œì´ë„", value: lecture.difficulty_level },
            {
              label: "ì—°ê²°ëœ êµì¬",
              value: linkedBook ? linkedBook.title : null,
            },
            { label: "ì¶œì²˜ URL", value: lecture.lecture_source_url, isUrl: true },
            { label: "ë©”ëª¨", value: lecture.notes },
          ]}
        />

        {/* ê°•ì˜ íšŒì°¨ ì •ë³´ */}
        {episodes.length > 0 && <LectureEpisodesDisplay episodes={episodes} />}

        {/* ì•¡ì…˜ ë²„íŠ¼ */}
        <div className="flex flex-col gap-4 border-t pt-8">
          <div className="flex flex-col gap-3 sm:flex-row">
            <Link
              href="/contents/master-lectures"
              className="inline-flex flex-1 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ëª©ë¡ìœ¼ë¡œ
            </Link>
            <CopyMasterLectureButton masterLectureId={id} />
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="master-lectures/page.tsx">
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { searchMasterLectures, getPlatformsForFilter, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { MasterLectureFilters } from "@/lib/data/contentMasters";
import { unstable_cache } from "next/cache";
import { createSupabasePublicClient } from "@/lib/supabase/server";
import { secondsToMinutes } from "@/lib/utils/duration";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { inlineButtonBase } from "@/lib/utils/darkMode";


// ê²€ìƒ‰ ê²°ê³¼ ì¡°íšŒ í•¨ìˆ˜ (ìºì‹± ì ìš©)
async function getCachedSearchResults(filters: MasterLectureFilters) {
  // ì•ˆì •ì ì¸ ìºì‹œ í‚¤ ìƒì„±
      const cacheKey = [
        "master-lectures-search",
        filters.curriculum_revision_id || "",
        filters.subject_group_id || "",
        filters.subject_id || "",
        filters.platform_id || "",
        filters.search || "",
        filters.difficulty || "",
        filters.sort || "",
        filters.limit || 50,
      ].join("-");
  
  const getCached = unstable_cache(
    async (filters: MasterLectureFilters) => {
      // ê³µê°œ ë°ì´í„°ìš© Supabase í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì¿ í‚¤ ì—†ì´)
      // í•™ìƒì€ ê³µê°œ ì½˜í…ì¸ (tenant_id IS NULL)ë§Œ ì¡°íšŒ ê°€ëŠ¥
      const supabase = createSupabasePublicClient();
      
      // tenantIdë¥¼ ëª…ì‹œì ìœ¼ë¡œ undefinedë¡œ ì„¤ì •í•˜ì—¬ ê³µê°œ ì½˜í…ì¸ ë§Œ ì¡°íšŒ
      const searchFilters: MasterLectureFilters = {
        ...filters,
        tenantId: undefined, // ê³µê°œ ì½˜í…ì¸ ë§Œ ì¡°íšŒ
      };

      // í‘œì¤€ í•¨ìˆ˜ ì‚¬ìš©
      return await searchMasterLectures(searchFilters, supabase);
    },
    [cacheKey],
    {
      revalidate: 60, // 1ë¶„ ìºì‹œ
      tags: ["master-lectures-search"],
    }
  );

  return getCached(filters);
}


function FilterFormWrapper({
  params,
  filterOptions,
}: {
  params: Record<string, string | undefined>;
  filterOptions: { 
    curriculumRevisions: Array<{ id: string; name: string }>; 
    platforms: Array<{ id: string; name: string }>;
    difficulties: string[];
  };
}) {
  return (
    <div className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm">
      <UnifiedContentFilter
        context="master"
        contentType="lecture"
        basePath="/contents/master-lectures"
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="updated_at_desc"
      />
    </div>
  );
}

export default async function StudentMasterLecturesPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const { userId, role } = await getCurrentUserRole();

  if (!userId) redirect("/login");

  // ê²€ìƒ‰ í•„í„° êµ¬ì„±
  const filters: MasterLectureFilters = {
    curriculum_revision_id: params.curriculum_revision_id,
    subject_group_id: params.subject_group_id,
    subject_id: params.subject_id,
    platform_id: params.platform_id,
    search: params.search,
    difficulty: params.difficulty,
    sort: params.sort || "updated_at_desc",
    limit: 50,
  };

  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ë“œë¡­ë‹¤ìš´ìš©) - ìºì‹œ ì—†ì´ ì§ì ‘ ì¡°íšŒ
  const [curriculumRevisions, platforms, difficulties] = await Promise.all([
    getCurriculumRevisions(),
    getPlatformsForFilter(),
    getDifficultiesForMasterLectures(),
  ]);

  // ê²€ìƒ‰ ê²°ê³¼ ì¡°íšŒ (ìºì‹± ì ìš©)
  const searchResult = await getCachedSearchResults(filters);
  const { data: lectures, total } = searchResult;

  const filterOptions = {
    curriculumRevisions: curriculumRevisions.map((rev) => ({
      id: rev.id,
      name: rev.name,
    })),
    platforms,
    difficulties,
  };

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-500 dark:text-gray-400">ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„°</p>
            <h1 className="text-3xl font-semibold text-gray-900 dark:text-gray-100">ê°•ì˜ ê²€ìƒ‰</h1>
            <p className="text-sm text-gray-500 dark:text-gray-400">
              ì„œë¹„ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ê°•ì˜ë¥¼ ê²€ìƒ‰í•˜ê³  ë‚´ ê°•ì˜ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/contents"
            className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
          >
            â† ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>

        {/* ê²€ìƒ‰ í•„í„° */}
        <Suspense fallback={<SuspenseFallback />}>
          <FilterFormWrapper params={params} filterOptions={filterOptions} />
        </Suspense>

        {/* ê²°ê³¼ ê°œìˆ˜ */}
        <div className="text-sm text-gray-600 dark:text-gray-400">
          ì´ <span className="font-semibold">{total}</span>ê°œì˜ ê°•ì˜ê°€
          ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.
        </div>

        {/* ê°•ì˜ ëª©ë¡ */}
        <div>
          {lectures.length === 0 ? (
            <div className="rounded-xl border border-dashed border-gray-300 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 p-12 text-center">
              <div className="mx-auto flex max-w-md flex-col gap-6">
                <div className="text-6xl">ğŸ§</div>
                <div className="flex flex-col gap-2">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                    ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
                  </h3>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    ë‹¤ë¥¸ ê²€ìƒ‰ ì¡°ê±´ìœ¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš”.
                  </p>
                </div>
              </div>
            </div>
          ) : (
            <ul className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
              {lectures.map((lecture) => (
                <li
                  key={lecture.id}
                  className="rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-4 shadow-sm"
                >
                  <div className="flex flex-col gap-3">
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                        {lecture.title}
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400">
                        {lecture.platform || "í”Œë«í¼ ì •ë³´ ì—†ìŒ"}
                      </p>
                    </div>

                    <dl className="grid gap-y-1 text-sm text-gray-600 dark:text-gray-400">
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ê°œì •</dt>
                        <dd>{lecture.revision || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">êµê³¼</dt>
                        <dd>{lecture.subject_category || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ê³¼ëª©</dt>
                        <dd>{lecture.subject || "â€”"}</dd>
                      </div>
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ì´ íšŒì°¨</dt>
                        <dd>{lecture.total_episodes}íšŒ</dd>
                      </div>
                      {lecture.total_duration && (
                        <div className="flex justify-between">
                          <dt className="font-medium text-gray-500 dark:text-gray-400">
                            ì´ ê°•ì˜ì‹œê°„
                          </dt>
                          <dd>{secondsToMinutes(lecture.total_duration)}ë¶„</dd>
                        </div>
                      )}
                      <div className="flex justify-between">
                        <dt className="font-medium text-gray-500 dark:text-gray-400">ë‚œì´ë„</dt>
                        <dd>{lecture.difficulty_level || "â€”"}</dd>
                      </div>
                    </dl>

                    <Link
                      href={`/contents/master-lectures/${lecture.id}`}
                      className="inline-flex items-center justify-center rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
                    >
                      ìƒì„¸ë³´ê¸°
                    </Link>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="page.tsx">
// app/contents/page.tsx
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ContentTabs } from "./_components/ContentTabs";
import { ContentsListWrapper } from "./_components/ContentsListWrapper";
import { ContentsList } from "./_components/ContentsList";
import { ContentStats } from "./_components/ContentStats";
import { UnifiedContentFilter } from "@/components/filters/UnifiedContentFilter";
import { Card } from "@/components/molecules/Card";
import { getCurriculumRevisions } from "@/lib/data/contentMetadata";
import { getPublishersForFilter, getPlatformsForFilter, getDifficultiesForMasterBooks, getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type TabKey = "books" | "lectures" | "custom";

export default async function ContentsPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const params = await searchParams;
  const tabParam = params.tab;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  const activeTab: TabKey =
    tabParam === "lectures" ? "lectures" : tabParam === "custom" ? "custom" : "books";

  const searchQuery = params.search;
  const curriculumRevisionId = params.curriculum_revision_id;
  const subjectGroupId = params.subject_group_id;
  const subjectId = params.subject_id;
  const publisherId = params.publisher_id;
  const platformId = params.platform_id;
  const difficultyFilter = params.difficulty;
  const sortBy = params.sort || "created_at_desc";
  const page = Number(params.page) || 1;

  const filters = {
    search: searchQuery,
    curriculum_revision_id: curriculumRevisionId,
    subject_group_id: subjectGroupId,
    subject_id: subjectId,
    publisher_id: publisherId,
    platform_id: platformId,
    difficulty: difficultyFilter,
  };

  return (
    <section className={getContainerClass("LIST", "md")}>
      <div className="flex flex-col gap-8">
        <PageHeader
          title="ë“±ë¡ëœ ì½˜í…ì¸ "
          description="ë“±ë¡í•œ ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”."
          action={
            <div className="flex gap-2 flex-wrap">
              <Link
                href="/contents/master-books"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“š ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬
              </Link>
              <Link
                href="/contents/master-lectures"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ§ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜
              </Link>
              <Link
                href="/contents/master-custom-contents"
                className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
              >
                ğŸ“ ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ 
              </Link>
              {activeTab !== "custom" && (
                <Link
                  href={`/contents/${activeTab}/new`}
                  className="inline-flex items-center justify-center gap-2 rounded-lg border border-transparent bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition-colors hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
                >
                  {activeTab === "books" ? "+ ì±… ë“±ë¡" : "+ ê°•ì˜ ë“±ë¡"}
                </Link>
              )}
            </div>
          }
        />

        {/* í†µê³„ */}
        <ContentStats studentId={user.id} />

        {/* Tabs */}
        <ContentTabs
          tabs={[
            { key: "books", label: "êµì¬" },
            { key: "lectures", label: "ê°•ì˜" },
            { key: "custom", label: "ì»¤ìŠ¤í…€" },
          ]}
          defaultTab={activeTab}
        />

        {/* Filters and Sort */}
        <Suspense fallback={<Card padding="sm"><SuspenseFallback /></Card>}>
          <StudentContentFilterWrapper
            activeTab={activeTab}
            params={params}
          />
        </Suspense>

        {/* List */}
        <ContentsListWrapper activeTab={activeTab}>
          <ContentsList
            activeTab={activeTab}
            studentId={user.id}
            filters={filters}
            sortBy={sortBy}
            page={page}
          />
        </ContentsListWrapper>
      </div>
    </section>
  );
}

async function StudentContentFilterWrapper({
  activeTab,
  params,
}: {
  activeTab: TabKey;
  params: Record<string, string | undefined>;
}) {
  // í•„í„° ì˜µì…˜ ì¡°íšŒ (ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ëŒ€ì²´)
  const [curriculumRevisions, publishers, platforms, difficulties] = await Promise.allSettled([
    getCurriculumRevisions(),
    activeTab === "books" ? getPublishersForFilter() : Promise.resolve([]),
    activeTab === "lectures" ? getPlatformsForFilter() : Promise.resolve([]),
    activeTab === "books" ? getDifficultiesForMasterBooks() : getDifficultiesForMasterLectures(),
  ]).then((results) =>
    results.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        console.error("[StudentContentFilterWrapper] í•„í„° ì˜µì…˜ ì¡°íšŒ ì‹¤íŒ¨", result.reason);
        return [];
      }
    })
  );

  const filterOptions = {
    curriculumRevisions: Array.isArray(curriculumRevisions)
      ? curriculumRevisions
          .filter((rev): rev is { id: string; name: string } => 
            typeof rev === "object" && rev !== null && "id" in rev && "name" in rev
          )
          .map((rev) => ({
            id: rev.id,
            name: rev.name,
          }))
      : [],
    publishers: activeTab === "books" && Array.isArray(publishers) 
      ? publishers.filter((pub): pub is { id: string; name: string } => 
          typeof pub === "object" && pub !== null && "id" in pub && "name" in pub
        )
      : undefined,
    platforms: activeTab === "lectures" && Array.isArray(platforms)
      ? platforms.filter((plat): plat is { id: string; name: string } => 
          typeof plat === "object" && plat !== null && "id" in plat && "name" in plat
        )
      : undefined,
    difficulties: Array.isArray(difficulties) 
      ? difficulties.filter((diff): diff is string => typeof diff === "string")
      : [],
  };

  const basePath = "/contents";

  return (
    <Card padding="sm">
      <UnifiedContentFilter
        context="student"
        contentType={activeTab === "books" ? "book" : activeTab === "lectures" ? "lecture" : "custom"}
        basePath={basePath}
        initialValues={{
          curriculum_revision_id: params.curriculum_revision_id,
          subject_group_id: params.subject_group_id,
          subject_id: params.subject_id,
          publisher_id: params.publisher_id,
          platform_id: params.platform_id,
          search: params.search,
          difficulty: params.difficulty,
          sort: params.sort,
        }}
        filterOptions={filterOptions}
        showDifficulty={true}
        showSort={true}
        defaultSort="created_at_desc"
      />
    </Card>
  );
}
</file>

<file path="_components/timer/StatusBadge.tsx">
"use client";

import type { TimerStatus } from "@/lib/store/planTimerStore";
import { cn } from "@/lib/cn";

type StatusBadgeProps = {
  status: TimerStatus;
  className?: string;
  size?: "sm" | "md" | "lg";
};

const statusConfig: Record<
  TimerStatus,
  { label: string; className: string }
> = {
  NOT_STARTED: {
    label: "ëŒ€ê¸°",
    className: "bg-gray-100 text-gray-800 border-gray-300",
  },
  RUNNING: {
    label: "ì§„í–‰ ì¤‘",
    className: "bg-blue-100 text-blue-800 border-blue-300",
  },
  PAUSED: {
    label: "ì¼ì‹œì •ì§€",
    className: "bg-yellow-100 text-yellow-800 border-yellow-300",
  },
  COMPLETED: {
    label: "ì™„ë£Œ",
    className: "bg-emerald-100 text-emerald-800 border-emerald-300",
  },
};

const sizeClasses = {
  sm: "px-2 py-0.5 text-xs",
  md: "px-2.5 py-1 text-sm",
  lg: "px-3 py-1.5 text-base",
};

export function StatusBadge({
  status,
  className,
  size = "md",
}: StatusBadgeProps) {
  const config = statusConfig[status];
  const sizeClass = sizeClasses[size];

  return (
    <span
      className={cn(
        "inline-flex items-center rounded-full border-2 font-bold shadow-sm",
        config.className,
        sizeClass,
        className
      )}
    >
      {config.label}
    </span>
  );
}
</file>

<file path="_components/timer/TimerControls.tsx">
"use client";

import { Play, Pause, Square, CheckCircle2, Loader2 } from "lucide-react";
import type { TimerStatus } from "@/lib/store/planTimerStore";
import { cn } from "@/lib/cn";

type PendingAction = "start" | "pause" | "resume" | "complete" | null;

type TimerControlsProps = {
  status: TimerStatus;
  isLoading: boolean;
  pendingAction?: PendingAction;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onComplete: () => void;
  onPostpone?: () => void;
  canPostpone?: boolean;
  compact?: boolean;
  className?: string;
};

const pendingMessages: Record<
  Exclude<PendingAction, null>,
  string
> = {
  start: "í•™ìŠµ ì¤‘...",
  resume: "í•™ìŠµ ì¤‘...",
  pause: "ì¼ì‹œì •ì§€ ì¤‘...",
  complete: "ì™„ë£Œ ì²˜ë¦¬ ì¤‘...",
};

export function TimerControls({
  status,
  isLoading,
  pendingAction = null,
  onStart,
  onPause,
  onResume,
  onComplete,
  onPostpone,
  canPostpone = false,
  compact = false,
  className,
}: TimerControlsProps) {
  const currentPendingMessage =
    isLoading && pendingAction
      ? pendingMessages[pendingAction as Exclude<PendingAction, null>]
      : null;

  // ëª¨ë°”ì¼ í„°ì¹˜ ì¹œí™”ì  ë²„íŠ¼ í¬ê¸° (ìµœì†Œ 44px ë†’ì´)
  const buttonSize = compact ? "text-sm px-3 py-2 min-h-[36px]" : "text-sm px-4 py-3 min-h-[44px]";
  const iconSize = compact ? "h-3.5 w-3.5" : "h-4 w-4";

  return (
    <div className={cn("flex flex-col gap-2", className)}>
      {currentPendingMessage && (
        <div
          className={cn(
            "text-center font-semibold text-indigo-600",
            compact ? "text-[11px]" : "text-sm"
          )}
        >
          {currentPendingMessage}
        </div>
      )}

      <div className="flex gap-2">
        {status === "NOT_STARTED" && (
          <button
            onClick={onStart}
            disabled={isLoading}
            className={cn(
              "flex flex-1 items-center justify-center gap-2 rounded-lg bg-indigo-600 font-bold text-white shadow-sm transition hover:bg-indigo-700 hover:shadow-md disabled:opacity-50 active:scale-[0.98]",
              buttonSize
            )}
          >
            {isLoading && pendingAction === "start" ? (
              <Loader2 className={cn("animate-spin", iconSize)} />
            ) : (
              <Play className={iconSize} />
            )}
            ì‹œì‘í•˜ê¸°
          </button>
        )}

        {status === "RUNNING" && (
          <>
            <button
              onClick={onPause}
              disabled={isLoading}
              className={cn(
                "flex flex-1 items-center justify-center gap-2 rounded-lg bg-yellow-600 font-bold text-white shadow-sm transition hover:bg-yellow-700 hover:shadow-md disabled:opacity-50 active:scale-[0.98]",
                buttonSize
              )}
            >
              {isLoading && pendingAction === "pause" ? (
                <Loader2 className={cn("animate-spin", iconSize)} />
              ) : (
                <Pause className={iconSize} />
              )}
              ì¼ì‹œì •ì§€
            </button>
            <button
              onClick={onComplete}
              disabled={isLoading}
              className={cn(
                "flex flex-1 items-center justify-center gap-2 rounded-lg bg-gradient-to-r from-green-600 to-green-700 font-bold text-white shadow-md transition hover:from-green-700 hover:to-green-800 hover:shadow-lg disabled:opacity-50 active:scale-[0.98]",
                buttonSize
              )}
            >
              {isLoading && pendingAction === "complete" ? (
                <Loader2 className={cn("animate-spin", iconSize)} />
              ) : (
                <Square className={iconSize} />
              )}
              í•™ìŠµ ê²°ê³¼ ì…ë ¥
            </button>
          </>
        )}

        {status === "PAUSED" && (
          <>
            <button
              onClick={onResume}
              disabled={isLoading}
              className={cn(
                "flex flex-1 items-center justify-center gap-2 rounded-lg bg-indigo-600 font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50",
                buttonSize
              )}
            >
              {isLoading && pendingAction === "resume" ? (
                <Loader2 className={cn("animate-spin", iconSize)} />
              ) : (
                <Play className={iconSize} />
              )}
              ì¬ì‹œì‘
            </button>
            <button
              onClick={onComplete}
              disabled={isLoading}
              className={cn(
                "flex flex-1 items-center justify-center gap-2 rounded-lg bg-gradient-to-r from-green-600 to-green-700 font-bold text-white shadow-md transition hover:from-green-700 hover:to-green-800 hover:shadow-lg disabled:opacity-50 active:scale-[0.98]",
                buttonSize
              )}
            >
              {isLoading && pendingAction === "complete" ? (
                <Loader2 className={cn("animate-spin", iconSize)} />
              ) : (
                <Square className={iconSize} />
              )}
              í•™ìŠµ ê²°ê³¼ ì…ë ¥
            </button>
          </>
        )}

        {status === "COMPLETED" && (
          <div
            className={cn(
              "flex flex-1 items-center justify-center gap-2 rounded-lg border border-emerald-100 bg-emerald-50 font-semibold text-emerald-700",
              buttonSize
            )}
          >
            <CheckCircle2 className={iconSize} />
            ì™„ë£Œë¨
          </div>
        )}
      </div>

      {canPostpone && onPostpone && status !== "COMPLETED" && (
        <button
          onClick={onPostpone}
          disabled={isLoading}
          className={cn(
            "w-full rounded-lg border border-orange-200 bg-orange-50 font-semibold text-orange-700 transition hover:bg-orange-100 disabled:opacity-50",
            compact ? "px-3 py-1.5 text-xs" : "px-3 py-2 text-sm"
          )}
        >
          ì˜¤ëŠ˜ ì¼ì • ë¯¸ë£¨ê¸°
        </button>
      )}
    </div>
  );
}
</file>

<file path="_components/timer/TimerDisplay.tsx">
"use client";

import { Clock } from "lucide-react";
import { formatTime } from "../../_utils/planGroupUtils";
import { StatusBadge } from "./StatusBadge";
import type { TimerStatus } from "@/lib/store/planTimerStore";
import { cn } from "@/lib/cn";

type TimerDisplayProps = {
  seconds: number;
  status: TimerStatus;
  subtitle?: string;
  showStatusBadge?: boolean;
  compact?: boolean;
  className?: string;
};

export function TimerDisplay({
  seconds,
  status,
  subtitle,
  showStatusBadge = true,
  compact = false,
  className,
}: TimerDisplayProps) {
  const formattedTime = formatTime(seconds);

  if (compact) {
    return (
      <div className={cn("flex flex-col gap-2", className)}>
        <div className="flex items-center justify-between rounded-lg bg-gray-50 p-2">
          <div className="flex items-center gap-2">
            <Clock className="h-4 w-4 text-gray-500" />
            <span className="text-sm font-medium text-gray-700">
              {subtitle || "í•™ìŠµ ì‹œê°„"}
            </span>
          </div>
          <div className="flex items-center gap-2">
            {showStatusBadge && <StatusBadge status={status} size="sm" />}
            <div className="text-lg font-bold text-indigo-600">
              {formattedTime}
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div
      className={cn(
        "rounded-lg border border-gray-200 bg-white p-4 shadow-sm",
        className
      )}
    >
      <div className="flex flex-col gap-3">
        <div className="flex flex-col gap-3 rounded-lg bg-gray-50 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Clock className="h-5 w-5 text-gray-500" />
              <span className="text-base font-medium text-gray-700">
                {subtitle || "í•™ìŠµ ì‹œê°„"}
              </span>
            </div>
            <div className="text-2xl font-bold text-indigo-600">
              {formattedTime}
            </div>
          </div>
          {showStatusBadge && (
            <div className="flex items-center justify-center">
              <StatusBadge status={status} size="md" />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/AttachGoalButton.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { recordGoalProgress, getAllGoalsAction } from "@/app/actions/goals";

type AttachGoalButtonProps = {
  goalId?: string;
  planId?: string;
};

export function AttachGoalButton({ goalId, planId }: AttachGoalButtonProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [showModal, setShowModal] = useState(false);
  const [goals, setGoals] = useState<Array<{ id: string; title: string }>>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleOpenModal = async () => {
    setShowModal(true);
    setError(null);
    setLoading(true);

    try {
      // ëª©í‘œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (ì„œë²„ ì•¡ì…˜ ì‚¬ìš©)
      const allGoals = await getAllGoalsAction();
      setGoals(allGoals.map((g) => ({ id: g.id, title: g.title })));
    } catch (err) {
      setError(err instanceof Error ? err.message : "ëª©í‘œ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  const handleSelectGoal = (selectedGoalId: string) => {
    if (!planId) {
      setError("í”Œëœ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.");
      return;
    }

    setError(null);
    startTransition(async () => {
      try {
        const result = await recordGoalProgress(selectedGoalId, planId);
        if (result.success) {
          setShowModal(false);
          router.refresh();
        } else {
          setError(result.error || "ëª©í‘œ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "ëª©í‘œ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  return (
    <>
      <button
        onClick={handleOpenModal}
        className="rounded-lg border border-indigo-300 bg-indigo-50 px-3 py-1.5 text-xs font-semibold text-indigo-700 transition hover:bg-indigo-100"
      >
        {goalId ? "ëª©í‘œ ì—°ê²°" : "+ ëª©í‘œ ì—°ê²°"}
      </button>

      {showModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="flex flex-col gap-4 rounded-lg bg-white p-6 shadow-xl max-w-md w-full px-4">
            <h3 className="text-lg font-semibold text-gray-900">ëª©í‘œ ì„ íƒ</h3>
            {loading ? (
              <p className="text-sm text-gray-500">ëª©í‘œ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
            ) : error ? (
              <div className="rounded-md bg-red-50 p-3 text-sm text-red-600">{error}</div>
            ) : goals.length === 0 ? (
              <p className="text-sm text-gray-500">ë“±ë¡ëœ ëª©í‘œê°€ ì—†ìŠµë‹ˆë‹¤.</p>
            ) : (
              <div className="flex flex-col gap-2 max-h-64 overflow-y-auto">
                {goals.map((goal) => (
                  <button
                    key={goal.id}
                    onClick={() => handleSelectGoal(goal.id)}
                    disabled={isPending}
                    className="w-full rounded-lg border border-gray-200 bg-white p-3 text-left transition hover:bg-gray-50 disabled:opacity-50"
                  >
                    <p className="text-sm font-semibold text-gray-900">{goal.title}</p>
                  </button>
                ))}
              </div>
            )}
            <div className="flex justify-end">
              <button
                onClick={() => setShowModal(false)}
                disabled={isPending}
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
              >
                ë‹«ê¸°
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
</file>

<file path="_components/CircularProgress.tsx">
"use client";

import { cn } from "@/lib/cn";

type CircularProgressProps = {
  percentage: number;
  size?: "sm" | "md" | "lg";
  strokeWidth?: number;
  className?: string;
  showPercentage?: boolean;
  children?: React.ReactNode;
};

const sizeMap = {
  sm: { dimension: 48, fontSize: "text-xs", sizeClass: "w-12 h-12" },
  md: { dimension: 80, fontSize: "text-sm", sizeClass: "w-20 h-20" },
  lg: { dimension: 120, fontSize: "text-lg", sizeClass: "w-[120px] h-[120px]" },
};

export function CircularProgress({
  percentage,
  size = "md",
  strokeWidth = 4,
  className,
  showPercentage = false,
  children,
}: CircularProgressProps) {
  const { dimension, fontSize, sizeClass } = sizeMap[size];
  const radius = (dimension - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference - (percentage / 100) * circumference;

  return (
    <div
      className={cn("relative inline-flex items-center justify-center", sizeClass, className)}
      role="progressbar"
      aria-valuenow={percentage}
      aria-valuemin={0}
      aria-valuemax={100}
      aria-label={`ì§„í–‰ë¥  ${percentage}%`}
    >
      <svg
        width={dimension}
        height={dimension}
        className="rotate-[-90deg]"
      >
        {/* ë°°ê²½ ì› */}
        <circle
          cx={dimension / 2}
          cy={dimension / 2}
          r={radius}
          fill="none"
          stroke="currentColor"
          strokeWidth={strokeWidth}
          className="text-gray-200"
        />
        {/* ì§„í–‰ë¥  ì› */}
        <circle
          cx={dimension / 2}
          cy={dimension / 2}
          r={radius}
          fill="none"
          stroke="currentColor"
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={offset}
          strokeLinecap="round"
          className="text-indigo-600 transition-all duration-300 ease-in-out"
        />
      </svg>
      <div className="absolute inset-0 flex flex-col items-center justify-center">
        {showPercentage && (
          <span className={cn("font-semibold text-gray-900", fontSize)}>
            {Math.round(percentage)}%
          </span>
        )}
        {children}
      </div>
    </div>
  );
}
</file>

<file path="_components/CompletionAnimation.tsx">
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { CheckCircle2, Sparkles } from "lucide-react";
import { useEffect, useState, useMemo } from "react";
import { cn } from "@/lib/cn";

const CONFETTI_COLORS = [
  "bg-pink-400",
  "bg-purple-400",
  "bg-blue-400",
  "bg-cyan-400",
  "bg-green-400",
  "bg-yellow-400",
  "bg-orange-400",
  "bg-red-400",
] as const;

type CompletionAnimationProps = {
  show: boolean;
  planTitle?: string;
  studyDuration?: string;
  onAnimationComplete?: () => void;
};

export function CompletionAnimation({
  show,
  planTitle = "í•™ìŠµ í”Œëœ",
  studyDuration,
  onAnimationComplete,
}: CompletionAnimationProps) {
  const [confetti, setConfetti] = useState<
    Array<{ id: number; x: number; delay: number; colorIndex: number }>
  >([]);

  useEffect(() => {
    if (show) {
      // ì»¨í˜í‹° ìƒì„±
      const items = Array.from({ length: 20 }, (_, i) => ({
        id: i,
        x: Math.random() * 100,
        delay: Math.random() * 0.3,
        colorIndex: i % CONFETTI_COLORS.length,
      }));
      setConfetti(items);

      // 3ì´ˆ í›„ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì½œë°±
      const timer = setTimeout(() => {
        onAnimationComplete?.();
      }, 3000);

      return () => clearTimeout(timer);
    }
  }, [show, onAnimationComplete]);

  return (
    <AnimatePresence>
      {show && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
          onClick={onAnimationComplete}
        >
          {/* ì»¨í˜í‹° íš¨ê³¼ */}
          {confetti.map((item) => (
            <motion.div
              key={item.id}
              initial={{ y: -100, x: `${item.x}vw`, opacity: 1, rotate: 0 }}
              animate={{
                y: "100vh",
                rotate: 360,
                opacity: 0,
              }}
              transition={{
                duration: 2,
                delay: item.delay,
                ease: "easeIn",
              }}
              className={cn(
                "absolute h-3 w-3 rounded-full",
                CONFETTI_COLORS[item.colorIndex]
              )}
            />
          ))}

          {/* ë©”ì¸ ì™„ë£Œ ì¹´ë“œ */}
          <motion.div
            initial={{ scale: 0, rotate: -180 }}
            animate={{ scale: 1, rotate: 0 }}
            exit={{ scale: 0, rotate: 180 }}
            transition={{
              type: "spring",
              stiffness: 200,
              damping: 20,
            }}
            className="relative flex max-w-md flex-col items-center gap-6 rounded-2xl bg-white p-8 shadow-2xl px-4"
          >
            {/* ì²´í¬ ì•„ì´ì½˜ */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{
                delay: 0.2,
                type: "spring",
                stiffness: 300,
                damping: 15,
              }}
              className="relative"
            >
              <div className="absolute inset-0 animate-ping rounded-full bg-green-400 opacity-75" />
              <div className="relative flex h-20 w-20 items-center justify-center rounded-full bg-gradient-to-br from-green-400 to-green-600 shadow-lg">
                <CheckCircle2 className="h-10 w-10 text-white" />
              </div>
            </motion.div>

            {/* í…ìŠ¤íŠ¸ */}
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4 }}
              className="flex flex-col items-center gap-2 text-center"
            >
              <h2 className="text-2xl font-bold text-gray-900">
                ğŸ‰ í•™ìŠµ ì™„ë£Œ!
              </h2>
              <p className="text-sm text-gray-600 line-clamp-2">{planTitle}</p>
              {studyDuration && (
                <div className="flex items-center gap-2 rounded-full bg-indigo-50 px-4 py-2">
                  <Sparkles className="h-4 w-4 text-indigo-600" />
                  <span className="text-sm font-semibold text-indigo-700">
                    {studyDuration} ë™ì•ˆ í•™ìŠµí•˜ì…¨ì–´ìš”!
                  </span>
                </div>
              )}
            </motion.div>

            {/* ë‹«ê¸° ì•ˆë‚´ */}
            <motion.p
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 1 }}
              className="text-xs text-gray-400"
            >
              ì•„ë¬´ ê³³ì´ë‚˜ í´ë¦­í•˜ì—¬ ë‹«ê¸°
            </motion.p>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="_components/CompletionToast.tsx">
"use client";

import { useEffect, useState } from "react";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { useToast } from "@/components/ui/ToastProvider";

type CompletionToastProps = {
  completedPlanId?: string | null;
  planTitle?: string | null;
};

export function CompletionToast({ completedPlanId, planTitle }: CompletionToastProps) {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();
  const { showSuccess } = useToast();
  const planId = completedPlanId || searchParams.get("completedPlanId");
  const [handled, setHandled] = useState(false);

  useEffect(() => {
    if (!planId) {
      return;
    }

    if (handled) {
      return;
    }

    setHandled(true);

    // í˜„ì¬ ê²½ë¡œ ê¸°ì¤€ìœ¼ë¡œ ìº í”„ ëª¨ë“œ ì—¬ë¶€ íŒë‹¨
    const isCampMode = pathname?.startsWith("/camp/today");
    const basePath = isCampMode ? "/camp/today" : "/today";

    // URLì—ì„œ completedPlanId ì œê±°
    const params = new URLSearchParams(searchParams.toString());
    params.delete("completedPlanId");
    const newSearch = params.toString();
    const newUrl = newSearch ? `${basePath}?${newSearch}` : basePath;
    router.replace(newUrl, { scroll: false });

    // í† ìŠ¤íŠ¸ í‘œì‹œ
    const title = planTitle || "í”Œëœ";
    showSuccess(`${title} í”Œëœì´ ì™„ë£Œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
  }, [planId, planTitle, handled, pathname, router, showSuccess]);

  return null;
}
</file>

<file path="_components/CurrentLearningSection.tsx">
import { fetchActivePlan } from "@/app/(student)/dashboard/_utils";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { ActiveLearningWidget } from "@/app/(student)/dashboard/_components/ActiveLearningWidget";
import { formatDateString } from "@/lib/date/calendarUtils";

type CurrentLearningSectionProps = {
  campMode?: boolean;
};

export async function CurrentLearningSection({ campMode = false }: CurrentLearningSectionProps) {
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      return null;
    }

    const supabase = await createSupabaseServerClient();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayDate = formatDateString(today);

    const activePlan = await fetchActivePlan(supabase, user.userId, todayDate);

    if (!activePlan) {
      return null;
    }

    return (
      <div>
        <ActiveLearningWidget activePlan={activePlan} campMode={campMode} />
      </div>
    );
  } catch (error) {
    console.error("[CurrentLearningSection] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    return null;
  }
}
</file>

<file path="_components/DailyPlanListView.tsx">
"use client";

import { useCallback } from "react";
import { PlanCard } from "./PlanCard";
import { PlanGroup } from "../_utils/planGroupUtils";
import { formatKoreanDateWithDay } from "../_utils/dateDisplay";

type DailyPlanListViewProps = {
  groups: PlanGroup[];
  sessions: Map<
    string,
    { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }
  >;
  planDate: string;
  onViewDetail: (planNumber: number | null) => void;
  serverNow?: number;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

export function DailyPlanListView({
  groups,
  sessions,
  planDate,
  onViewDetail,
  serverNow = Date.now(),
  campMode = false,
}: DailyPlanListViewProps) {
  if (groups.length === 0) {
    const formattedDate = planDate
      ? formatKoreanDateWithDay(planDate)
      : "ì„ íƒí•œ ë‚ ì§œ";
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
        <div className="mx-auto flex max-w-md flex-col gap-4">
          <div className="text-6xl">ğŸ“š</div>
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-gray-900">
              ì„ íƒí•œ ë‚ ì§œì˜ í•™ìŠµ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-gray-500">
              {formattedDate}ì— ë“±ë¡ëœ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ í”Œëœì„
              ë§Œë“¤ì–´ë³´ì„¸ìš”.
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      {groups.map((group) => (
        <PlanCard
          key={group.planNumber ?? `null-${group.plan.id}`}
          group={group}
          sessions={sessions}
          planDate={planDate}
          viewMode="daily"
          onViewDetail={onViewDetail}
          serverNow={serverNow}
          campMode={campMode}
        />
      ))}
    </div>
  );
}
</file>

<file path="_components/DailyPlanView.tsx">
"use client";

import { useMemo, useCallback } from "react";
import { PlanGroup } from "../_utils/planGroupUtils";
import { PlanGroupCard } from "./PlanGroupCard";
import { ViewMode } from "./ViewModeSelector";
import { VirtualizedList } from "@/lib/components/VirtualizedList";

type DailyPlanViewProps = {
  groups: PlanGroup[];
  sessions: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>;
  planDate: string;
  memos: Map<number | null, string | null>; // planNumber -> memo
  totalPagesMap: Map<string, number>; // contentKey -> totalPages
  onViewDetail: (planNumber: number | null) => void;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

export function DailyPlanView({
  groups,
  sessions,
  planDate,
  memos,
  totalPagesMap,
  onViewDetail,
  campMode = false,
}: DailyPlanViewProps) {
  if (groups.length === 0) {
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
        <div className="mx-auto flex max-w-md flex-col gap-4">
          <div className="text-6xl">ğŸ“š</div>
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-gray-900">
              ì˜¤ëŠ˜ ë°°ìš¸ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-gray-500">
              í•™ìŠµ í”Œëœì„ ìƒì„±í•´ë³´ì„¸ìš”.
            </p>
          </div>
        </div>
      </div>
    );
  }

  // ê·¸ë£¹ ë Œë”ë§ í•¨ìˆ˜
  const renderGroup = useCallback(
    (group: PlanGroup, index: number) => {
      const contentKey = group.plan
        ? `${group.plan.content_type}:${group.plan.content_id}`
        : "";
      const totalPages = totalPagesMap.get(contentKey);
      const memo = memos.get(group.planNumber);

      return (
        <div key={`group-${group.planNumber}-${index}`}>
          <PlanGroupCard
            group={group}
            viewMode="daily"
            sessions={sessions}
            planDate={planDate}
            memo={memo}
            totalPages={totalPages}
            onViewDetail={onViewDetail}
            campMode={campMode}
          />
        </div>
      );
    },
    [sessions, planDate, memos, totalPagesMap, onViewDetail, campMode]
  );

  // í”Œëœ ê·¸ë£¹ì´ 10ê°œ ì´ìƒì¼ ë•Œ ê°€ìƒí™” ì ìš©
  if (groups.length > 10) {
    return (
      <VirtualizedList
        items={groups}
        itemHeight={200} // PlanGroupCardì˜ ì˜ˆìƒ ë†’ì´
        containerHeight={600} // ì»¨í…Œì´ë„ˆ ë†’ì´
        renderItem={renderGroup}
        className="rounded-xl border border-gray-200 bg-white p-4"
        overscan={3}
      />
    );
  }

  // 10ê°œ ì´í•˜ì¼ ë•ŒëŠ” ì¼ë°˜ ë Œë”ë§
  return (
    <div className="flex flex-col gap-4">
      {groups.map((group, index) => renderGroup(group, index))}
    </div>
  );
}
</file>

<file path="_components/DraggablePlanList.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { GripVertical } from "lucide-react";
import { updatePlanOrder } from "../actions/planOrderActions";
import { PlanTimerCard } from "./PlanTimerCard";
import { TodayPlanItem } from "./TodayPlanItem";
import { cn } from "@/lib/cn";
import type { PlanWithContent } from "../_utils/planGroupUtils";

type DraggablePlanListProps = {
  plans: PlanWithContent[];
  planDate: string;
  serverNow?: number;
  campMode?: boolean;
};

export function DraggablePlanList({ plans: initialPlans, planDate, serverNow = Date.now(), campMode = false }: DraggablePlanListProps) {
  const router = useRouter();
  const [plans, setPlans] = useState(initialPlans);
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);
  const [isPending, startTransition] = useTransition();

  // block_index ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
  const sortedPlans = [...plans].sort((a, b) => {
    const aIndex = a.block_index ?? 0;
    const bIndex = b.block_index ?? 0;
    return aIndex - bIndex;
  });

  const handleDragStart = (index: number) => {
    setDraggedIndex(index);
  };

  const handleDragOver = (e: React.DragEvent, index: number) => {
    e.preventDefault();
    if (draggedIndex === null || draggedIndex === index) return;
    setDragOverIndex(index);
  };

  const handleDragLeave = () => {
    setDragOverIndex(null);
  };

  const handleDrop = async (e: React.DragEvent, dropIndex: number) => {
    e.preventDefault();
    setDragOverIndex(null);

    if (draggedIndex === null || draggedIndex === dropIndex) {
      setDraggedIndex(null);
      return;
    }

    const newPlans = [...sortedPlans];
    const [draggedPlan] = newPlans.splice(draggedIndex, 1);
    newPlans.splice(dropIndex, 0, draggedPlan);

    // ìƒˆë¡œìš´ block_index ê³„ì‚°
    const updates = newPlans.map((plan, index) => ({
      planId: plan.id,
      newBlockIndex: index + 1,
    }));

    // UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    setPlans(newPlans.map((plan, index) => ({
      ...plan,
      block_index: index + 1,
    })));

    // ì„œë²„ì— ì—…ë°ì´íŠ¸
    startTransition(async () => {
      const result = await updatePlanOrder(planDate, updates);
      if (result.success) {
        router.refresh();
      } else {
        // ì‹¤íŒ¨ ì‹œ ì›ë˜ ìƒíƒœë¡œ ë³µêµ¬
        setPlans(initialPlans);
        alert(result.error || "í”Œëœ ìˆœì„œ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
      setDraggedIndex(null);
    });
  };

  const handleDragEnd = () => {
    setDraggedIndex(null);
    setDragOverIndex(null);
  };

  if (sortedPlans.length === 0) {
    return (
      <div className="flex flex-col gap-4 rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
        <div className="mx-auto flex flex-col gap-2 max-w-md">
          <div className="text-6xl">ğŸ“š</div>
          <h3 className="text-lg font-semibold text-gray-900">
            ì˜¤ëŠ˜ ë°°ìš¸ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤
          </h3>
          <p className="text-sm text-gray-500">
            í•™ìŠµ í”Œëœì„ ìƒì„±í•´ë³´ì„¸ìš”.
          </p>
        </div>
      </div>
    );
  }

  const primaryPlanIds = (() => {
    const ids = new Set<string>();
    const seen = new Set<number>();
    sortedPlans.forEach((plan) => {
      if (plan.plan_number === null || plan.plan_number === undefined) {
        ids.add(plan.id);
        return;
      }
      if (!seen.has(plan.plan_number)) {
        ids.add(plan.id);
        seen.add(plan.plan_number);
      }
    });
    return ids;
  })();

  return (
    <div className="flex flex-col gap-4">
      <h2 className="text-lg font-semibold text-gray-900">ì„ íƒ ë‚ ì§œ í”Œëœ</h2>
      <div className="space-y-3">
        {sortedPlans.map((plan, index) => {
          const isActive = !!plan.actual_start_time && !plan.actual_end_time;
          const isCompleted = !!plan.actual_end_time;
          const isDragging = draggedIndex === index;
          const isDragOver = dragOverIndex === index;

          // í™œì„± í”Œëœì´ê±°ë‚˜ ì™„ë£Œëœ í”Œëœì€ PlanTimerCard ì‚¬ìš©
          if (isActive || isCompleted) {
            return (
              <div
                key={plan.id}
                draggable={!isActive && !isCompleted}
                onDragStart={(e) => {
                  if (!isActive && !isCompleted) {
                    handleDragStart(index);
                    e.dataTransfer.effectAllowed = "move";
                  } else {
                    e.preventDefault();
                  }
                }}
                onDragOver={(e) => {
                  if (!isActive && !isCompleted) {
                    handleDragOver(e, index);
                  }
                }}
                onDragLeave={handleDragLeave}
                onDrop={(e) => {
                  if (!isActive && !isCompleted) {
                    handleDrop(e, index);
                  }
                }}
                onDragEnd={handleDragEnd}
                className={cn(
                  "relative",
                  isDragging && "opacity-50",
                  isDragOver && "ring-2 ring-indigo-500 ring-offset-2"
                )}
              >
                <PlanTimerCard
                  planId={plan.id}
                  planTitle={plan.content?.title || "ì œëª© ì—†ìŒ"}
                  contentType={plan.content_type}
                  startTime={null}
                  endTime={null}
                  actualStartTime={plan.actual_start_time}
                  actualEndTime={plan.actual_end_time}
                  totalDurationSeconds={plan.total_duration_seconds}
                  pausedDurationSeconds={plan.paused_duration_seconds}
                  pauseCount={plan.pause_count}
                  activeSessionId={plan.session ? plan.id : null}
                  isPaused={plan.session?.isPaused || false}
                  currentPausedAt={plan.session?.pausedAt ?? null}
                  allowTimerControl={primaryPlanIds.has(plan.id)}
                  sessionStartedAt={plan.session?.startedAt ?? null}
                  sessionPausedDurationSeconds={plan.session?.pausedDurationSeconds ?? null}
                  serverNow={serverNow}
                  campMode={campMode}
                />
              </div>
            );
          }

          // ëŒ€ê¸° ì¤‘ì¸ í”Œëœì€ ë“œë˜ê·¸ ê°€ëŠ¥í•œ TodayPlanItem ì‚¬ìš©
          return (
            <div
              key={plan.id}
              draggable={!isPending}
              onDragStart={(e) => {
                if (!isPending) {
                  handleDragStart(index);
                  e.dataTransfer.effectAllowed = "move";
                } else {
                  e.preventDefault();
                }
              }}
              onDragOver={(e) => {
                if (!isPending) {
                  handleDragOver(e, index);
                }
              }}
              onDragLeave={handleDragLeave}
              onDrop={(e) => {
                if (!isPending) {
                  handleDrop(e, index);
                }
              }}
              onDragEnd={handleDragEnd}
              className={cn(
                "relative flex items-start gap-3 rounded-lg border border-gray-200 bg-white p-4 shadow-sm transition",
                isDragging && "opacity-50 cursor-grabbing",
                isDragOver && "ring-2 ring-indigo-500 ring-offset-2",
                !isPending && "hover:shadow-md cursor-grab"
              )}
            >
              <div
                className={cn(
                  "text-gray-400 transition self-start",
                  isDragging ? "cursor-grabbing" : "cursor-grab"
                )}
              >
                <GripVertical className="h-5 w-5" />
              </div>
              <div className="flex-1">
                <TodayPlanItem
                  plan={{
                    ...plan,
                    content: plan.content,
                    progress: plan.progress,
                  }}
                  campMode={campMode}
                />
              </div>
            </div>
          );
        })}
      </div>
      {isPending && (
        <div className="text-center text-sm text-gray-500">
          ìˆœì„œë¥¼ ì €ì¥í•˜ëŠ” ì¤‘...
        </div>
      )}
    </div>
  );
}
</file>

<file path="_components/MobileActionBar.tsx">
"use client";

import { Play, Pause, Square } from "lucide-react";
import { cn } from "@/lib/cn";

type MobileActionBarProps = {
  isVisible: boolean;
  isActive: boolean;
  isPaused: boolean;
  planTitle?: string;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onComplete: () => void;
  isLoading?: boolean;
};

export function MobileActionBar({
  isVisible,
  isActive,
  isPaused,
  planTitle = "í•™ìŠµ í”Œëœ",
  onStart,
  onPause,
  onResume,
  onComplete,
  isLoading = false,
}: MobileActionBarProps) {
  if (!isVisible) {
    return null;
  }

  const handleComplete = () => {
    if (!confirm("í”Œëœì„ ì™„ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      return;
    }
    onComplete();
  };

  return (
    <div className="fixed inset-x-0 bottom-0 z-50 border-t border-gray-200 bg-white p-4 shadow-lg md:hidden">
      <div className="flex flex-col gap-3">
        {(isActive || isPaused) && (
          <div className="flex items-center justify-between">
            <div className="flex flex-col">
              <span className="text-xs text-gray-500">ì§„í–‰ ì¤‘</span>
              <span className="text-sm font-semibold text-gray-900 line-clamp-1">
                {planTitle}
              </span>
            </div>
            <div
              className={cn(
                "h-2 w-2 rounded-full",
                isPaused ? "bg-yellow-500" : "bg-green-500 animate-pulse"
              )}
              aria-label={isPaused ? "ì¼ì‹œì •ì§€ ìƒíƒœ" : "í•™ìŠµ ì§„í–‰ ì¤‘"}
            />
          </div>
        )}

        <div className="flex gap-2">
          {!isActive && !isPaused && (
            <button
              onClick={onStart}
              disabled={isLoading}
              aria-label="í•™ìŠµ ì‹œì‘í•˜ê¸°"
              className="flex flex-1 min-h-[48px] items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-3 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
            >
              <Play className="h-5 w-5" aria-hidden="true" />
              ì‹œì‘í•˜ê¸°
            </button>
          )}

          {isActive && !isPaused && (
            <>
              <button
                onClick={onPause}
                disabled={isLoading}
                aria-label="í•™ìŠµ ì¼ì‹œì •ì§€"
                className="flex flex-1 min-h-[48px] items-center justify-center gap-2 rounded-lg bg-yellow-600 px-4 py-3 text-sm font-semibold text-white transition hover:bg-yellow-700 disabled:opacity-50"
              >
                <Pause className="h-5 w-5" aria-hidden="true" />
                ì¼ì‹œì •ì§€
              </button>
              <button
                onClick={handleComplete}
                disabled={isLoading}
                aria-label="í•™ìŠµ ì™„ë£Œí•˜ê¸°"
                className="flex flex-1 min-h-[48px] items-center justify-center gap-2 rounded-lg bg-green-600 px-4 py-3 text-sm font-semibold text-white transition hover:bg-green-700 disabled:opacity-50"
              >
                <Square className="h-5 w-5" aria-hidden="true" />
                ì™„ë£Œ
              </button>
            </>
          )}

          {isPaused && (
            <>
              <button
                onClick={onResume}
                disabled={isLoading}
                aria-label="í•™ìŠµ ì¬ê°œí•˜ê¸°"
                className="flex flex-1 min-h-[48px] items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-3 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
              >
                <Play className="h-5 w-5" aria-hidden="true" />
                ì¬ê°œ
              </button>
              <button
                onClick={handleComplete}
                disabled={isLoading}
                aria-label="í•™ìŠµ ì™„ë£Œí•˜ê¸°"
                className="flex flex-1 min-h-[48px] items-center justify-center gap-2 rounded-lg bg-green-600 px-4 py-3 text-sm font-semibold text-white transition hover:bg-green-700 disabled:opacity-50"
              >
                <Square className="h-5 w-5" aria-hidden="true" />
                ì™„ë£Œ
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/PlanCard.tsx">
"use client";

import { useState, useMemo, useEffect, memo } from "react";
import { useRouter } from "next/navigation";
import { PlanGroup } from "../_utils/planGroupUtils";
import { getActivePlan, getTimeStats } from "../_utils/planGroupUtils";
import { PlanTimer } from "./PlanTimer";
import {
  startPlan,
  pausePlan,
  resumePlan,
  preparePlanCompletion,
  postponePlan,
} from "../actions/todayActions";
import { Clock } from "lucide-react";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import { useToast } from "@/components/ui/ToastProvider";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";

type PlanRunState = "idle" | "running" | "paused" | "completed";
type PendingAction = "start" | "pause" | "resume" | "complete";

type PlanCardProps = {
  group: PlanGroup;
  sessions: Map<string, { 
    isPaused: boolean; 
    startedAt?: string | null;
    pausedAt?: string | null; 
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }>;
  planDate: string;
  viewMode: "single" | "daily";
  onViewDetail?: (planNumber: number | null) => void;
  serverNow?: number;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

function PlanCardComponent({
  group,
  sessions,
  planDate,
  viewMode,
  onViewDetail,
  serverNow = Date.now(),
  campMode = false,
}: PlanCardProps) {
  const router = useRouter();
  const { showError } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [pendingAction, setPendingAction] = useState<PendingAction | null>(null);
  const timerStore = usePlanTimerStore();

  // ì½˜í…ì¸  ì •ë³´
  const contentInfo = useMemo(
    () => ({
      title: group.content?.title || "ì œëª© ì—†ìŒ",
      icon:
        group.plan.content_type === "book"
          ? "ğŸ“š"
          : group.plan.content_type === "lecture"
          ? "ğŸ§"
          : "ğŸ“",
    }),
    [group.content?.title, group.plan.content_type]
  );

  const activePlan = useMemo(
    () => getActivePlan(group, sessions),
    [group, sessions]
  );

  const sessionForPlan = sessions.get(group.plan.id);

  const derivedStatus = useMemo<PlanRunState>(() => {
    if (group.plan.actual_end_time) {
      return "completed";
    }
    if (group.plan.actual_start_time) {
      return sessionForPlan?.isPaused ? "paused" : "running";
    }
    return "idle";
  }, [group.plan.actual_end_time, group.plan.actual_start_time, sessionForPlan?.isPaused]);

  const [optimisticStatus, setOptimisticStatus] = useState<PlanRunState | null>(null);

  useEffect(() => {
    setOptimisticStatus(null);
  }, [derivedStatus]);

  const resolvedStatus = optimisticStatus ?? derivedStatus;
  const isRunning = resolvedStatus === "running";
  const isPausedState = resolvedStatus === "paused";

  // ì‹œê°„ í†µê³„
  const timeStats = useMemo(
    () => getTimeStats([group.plan], activePlan, sessions),
    [group.plan, activePlan, sessions]
  );

  // ì„œë²„ì—ì„œ ê³„ì‚°ëœ ì´ˆê¸° íƒ€ì´ë¨¸ ìƒíƒœ ê³„ì‚° (ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©)
  const timerState = useMemo(() => {
    const plan = group.plan;
    const session = sessions.get(plan.id);

    // ì™„ë£Œëœ ê²½ìš°
    if (plan.actual_end_time && plan.total_duration_seconds !== null && plan.total_duration_seconds !== undefined) {
      return {
        status: "COMPLETED" as const,
        accumulatedSeconds: plan.total_duration_seconds,
        startedAt: null,
      };
    }

    // ì‹œì‘í•˜ì§€ ì•Šì€ ê²½ìš°
    if (!plan.actual_start_time) {
      return {
        status: "NOT_STARTED" as const,
        accumulatedSeconds: 0,
        startedAt: null,
      };
    }

    // ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš°
    if (session && session.isPaused && session.pausedAt) {
      const startMs = new Date(plan.actual_start_time).getTime();
      const pausedAtMs = new Date(session.pausedAt).getTime();
      if (Number.isFinite(startMs) && Number.isFinite(pausedAtMs)) {
        const elapsedUntilPause = Math.floor((pausedAtMs - startMs) / 1000);
        const sessionPausedDuration = session.pausedDurationSeconds || 0;
        const planPausedDuration = plan.paused_duration_seconds || 0;
        const accumulatedSeconds = Math.max(0, elapsedUntilPause - sessionPausedDuration - planPausedDuration);

        return {
          status: "PAUSED" as const,
          accumulatedSeconds,
          startedAt: null,
        };
      }
    }

    // ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° - ì„œë²„ì—ì„œ ê³„ì‚°ëœ ëˆ„ì  ì‹œê°„ ì‚¬ìš©
    if (session && session.startedAt) {
      const sessionStartMs = new Date(session.startedAt).getTime();
      const now = Date.now();
      if (Number.isFinite(sessionStartMs)) {
        const elapsed = Math.floor((now - sessionStartMs) / 1000);
        const sessionPausedDuration = session.pausedDurationSeconds || 0;
        const planPausedDuration = plan.paused_duration_seconds || 0;
        const accumulatedSeconds = Math.max(0, elapsed - sessionPausedDuration - planPausedDuration);

        return {
          status: "RUNNING" as const,
          accumulatedSeconds,
          startedAt: session.startedAt,
        };
      }
    }

    // í™œì„± ì„¸ì…˜ì´ ì—†ì§€ë§Œ í”Œëœì´ ì‹œì‘ëœ ê²½ìš°
    const startMs = new Date(plan.actual_start_time).getTime();
    if (Number.isFinite(startMs)) {
      const elapsed = Math.floor((Date.now() - startMs) / 1000);
      const pausedDuration = plan.paused_duration_seconds || 0;
      const accumulatedSeconds = Math.max(0, elapsed - pausedDuration);

      return {
        status: "RUNNING" as const,
        accumulatedSeconds,
        startedAt: plan.actual_start_time,
      };
    }

    // fallback: ì‹œì‘ ì‹œê°„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°
    return {
      status: "NOT_STARTED" as const,
      accumulatedSeconds: 0,
      startedAt: null,
    };
  }, [group.plan, sessions]);

  const handlePostponePlan = async (planId: string) => {
    if (isLoading) return;
    if (!group.plan.is_reschedulable) {
      alert("ì´ í”Œëœì€ ì¼ì • ë¯¸ë£¨ê¸°ê°€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      return;
    }
    if (!confirm("ì´ í”Œëœì„ ë‚´ì¼ ì¼ì •ìœ¼ë¡œ ë¯¸ë£¨ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      return;
    }

    setIsLoading(true);
    try {
      const result = await postponePlan(planId);
      if (!result.success) {
        alert(result.error || "ì¼ì •ì„ ë¯¸ë£¨ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
      // postponePlanì€ Server Actionì—ì„œ revalidatePathë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ router.refresh() ë¶ˆí•„ìš”
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  // íƒ€ì´ë¨¸ ì œì–´ í•¸ë“¤ëŸ¬
  const handleStart = async () => {
    const plan = group.plan;
    if (plan.actual_start_time || plan.actual_end_time || isLoading) return;
    const waitingPlan = plan;

    setIsLoading(true);
    setPendingAction("start");
    setOptimisticStatus("running");
    try {
      const timestamp = new Date().toISOString();
      const result = await startPlan(waitingPlan.id, timestamp);
      if (!result.success) {
        alert(result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        setOptimisticStatus(null);
      } else if (result.serverNow && result.status && result.startedAt) {
        // ìŠ¤í† ì–´ì— íƒ€ì´ë¨¸ ì‹œì‘
        timerStore.startTimer(waitingPlan.id, result.serverNow, result.startedAt);
      }
    } catch (error) {
      setOptimisticStatus(null);
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handlePause = async () => {
    if (isLoading) return;
    if (resolvedStatus !== "running") {
      alert("ì¼ì‹œì •ì§€í•  í™œì„± í”Œëœì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    const plan = group.plan;
    setOptimisticStatus("paused");
    setIsLoading(true);
    setPendingAction("pause");
    try {
      const timestamp = new Date().toISOString();
      const result = await pausePlan(plan.id, timestamp);
      if (!result.success) {
        setOptimisticStatus(null);
        alert(result.error || "í”Œëœ ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      } else if (result.serverNow && result.accumulatedSeconds !== undefined) {
        // ìŠ¤í† ì–´ì— íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€
        timerStore.pauseTimer(plan.id, result.accumulatedSeconds);
      }
    } catch (error) {
      setOptimisticStatus(null);
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handleResume = async () => {
    if (resolvedStatus !== "paused") {
      alert("ì¬ê°œí•  ì¼ì‹œì •ì§€ëœ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    const plan = group.plan;
    setOptimisticStatus("running");
    setIsLoading(true);
    setPendingAction("resume");
    try {
      const timestamp = new Date().toISOString();
      const result = await resumePlan(plan.id, timestamp);
      if (!result.success) {
        setOptimisticStatus(null);
        alert(result.error || "í”Œëœ ì¬ê°œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      } else if (result.serverNow && result.status && result.startedAt) {
        // ìŠ¤í† ì–´ì— íƒ€ì´ë¨¸ ì¬ê°œ
        timerStore.startTimer(plan.id, result.serverNow, result.startedAt);
      }
    } catch (error) {
      setOptimisticStatus(null);
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handleComplete = async () => {
    const targetPlanId = activePlan?.id || group.plan.id;
    
    // í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
    const confirmed = confirm(
      "ì§€ê¸ˆê¹Œì§€ì˜ í•™ìŠµì„ ê¸°ì¤€ìœ¼ë¡œ ì´ í”Œëœì„ ì™„ë£Œ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™í• ê¹Œìš”?"
    );
    
    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    setPendingAction("complete");
    try {
      const result = await preparePlanCompletion(targetPlanId);
      
      if (!result.success) {
        showError(result.error || "í”Œëœ ì™„ë£Œ ì¤€ë¹„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      // íƒ€ì´ë¨¸ ì •ì§€ (ìŠ¤í† ì–´ì—ì„œ ì œê±°)
      timerStore.removeTimer(targetPlanId);

      // ì™„ë£Œ ì…ë ¥ í˜ì´ì§€ë¡œ ì´ë™
      router.push(buildPlanExecutionUrl(targetPlanId, campMode));
    } catch (error) {
      console.error("[PlanCard] ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const planTimeRange =
    group.plan.start_time && group.plan.end_time
      ? `${group.plan.start_time} ~ ${group.plan.end_time}`
      : null;

  const getChapterIcon = (contentType: PlanGroup["plan"]["content_type"]) => {
    if (contentType === "book") return "ğŸ“–";
    if (contentType === "lecture") return "ğŸ§";
    return "ğŸ“";
  };

  const getRangeLabel = (planData: PlanGroup["plan"]) => {
    const { planned_start_page_or_time: start, planned_end_page_or_time: end, content_type } = planData;
    if (start === null || end === null) {
      return null;
    }
    if (content_type === "book") {
      return `ğŸ“„ í˜ì´ì§€: ${start} ~ ${end}`;
    }
    if (content_type === "lecture") {
      return `ğŸ§ ê°•ì˜: ${start} ~ ${end}`;
    }
    return `ğŸ“ ë²”ìœ„: ${start} ~ ${end}`;
  };

  const planChapterIcon = getChapterIcon(group.plan.content_type);
  const planRangeLabel = getRangeLabel(group.plan);

  // ë‹¨ì¼ ë·°
  if (viewMode === "single") {
    return (
      <div className="flex flex-col gap-6">
        {/* í—¤ë” */}
        <div className="flex flex-col items-center gap-3 text-center">
          {planTimeRange && (
            <div className="inline-flex items-center gap-2 rounded-md bg-white px-4 py-1 text-sm font-semibold text-indigo-900 shadow-sm">
              <Clock className="h-4 w-4 text-indigo-500" aria-hidden="true" />
              <span>{planTimeRange}</span>
            </div>
          )}
          <div className="text-4xl">{contentInfo.icon}</div>
          <h2 className="text-2xl font-bold text-gray-900">{contentInfo.title}</h2>
          <div className="flex items-center gap-3">
            <span className="text-4xl" aria-hidden="true">
              {planChapterIcon}
            </span>
            <div className="flex flex-col gap-1">
              <span className="text-sm font-semibold text-gray-900">
                {group.plan.chapter || "ì±•í„° ì •ë³´ ì—†ìŒ"}
              </span>
            </div>
          </div>
          {planRangeLabel && (
            <div className="text-sm text-gray-600">{planRangeLabel}</div>
          )}
        </div>

        {/* íƒ€ì´ë¨¸ */}
        <PlanTimer
          planId={group.plan.id}
          timeStats={timeStats}
          isPaused={isPausedState}
          isActive={isRunning}
          isLoading={isLoading}
          onStart={handleStart}
          onPause={handlePause}
          onResume={handleResume}
          onComplete={handleComplete}
          pendingAction={pendingAction}
          onPostpone={
            group.plan.is_reschedulable && !group.plan.actual_end_time
              ? () => handlePostponePlan(group.plan.id)
              : undefined
          }
          canPostpone={group.plan.is_reschedulable && !group.plan.actual_end_time}
          status={timerState.status}
          accumulatedSeconds={timerState.accumulatedSeconds}
          startedAt={timerState.startedAt}
          serverNow={serverNow}
        />


      </div>
    );
  }

  // ì¼ì¼ ë·° - ëª¨ë°”ì¼ ì¹œí™”ì  ì¹´ë“œ ë ˆì´ì•„ì›ƒ
  return (
    <div className="rounded-xl border border-gray-200 bg-white p-4 shadow-sm transition hover:shadow-md sm:p-5">
      <div className="flex flex-col gap-4 sm:gap-5">
        {/* ì¹´ë“œ í—¤ë” */}
        <div className="flex flex-col gap-3 text-center sm:text-left">
          {planTimeRange && (
            <div className="inline-flex items-center justify-center gap-2 self-center rounded-md bg-white px-3 py-1 text-xs font-semibold text-indigo-900 shadow-sm sm:self-start">
              <Clock className="h-4 w-4 text-indigo-500" aria-hidden="true" />
              <span>{planTimeRange}</span>
            </div>
          )}
          <div className="flex flex-col items-center gap-2 sm:flex-row sm:items-center sm:justify-between">
            <div className="flex items-center gap-2 text-lg">
              <span>{contentInfo.icon}</span>
              <h3 className="font-semibold text-gray-900">{contentInfo.title}</h3>
            </div>
            {onViewDetail && (
              <button
                onClick={() => onViewDetail(group.planNumber)}
                className="text-sm font-semibold text-indigo-600 hover:text-indigo-700"
              >
                ìƒì„¸ë³´ê¸° â†’
              </button>
            )}
          </div>
          <div className="flex flex-col items-center gap-2 sm:items-start">
            <div className="flex items-center gap-3">
              <span className="text-3xl" aria-hidden="true">
                {planChapterIcon}
              </span>
              <span className="text-sm font-semibold text-gray-900">
                {group.plan.chapter || "ì±•í„° ì •ë³´ ì—†ìŒ"}
              </span>
            </div>
            {planRangeLabel && (
              <div className="text-sm text-gray-600">{planRangeLabel}</div>
            )}
          </div>
        </div>

        {/* íƒ€ì´ë¨¸ */}
        <PlanTimer
          planId={group.plan.id}
          timeStats={timeStats}
          isPaused={isPausedState}
          isActive={isRunning}
          isLoading={isLoading}
          onStart={handleStart}
          onPause={handlePause}
          onResume={handleResume}
          onComplete={handleComplete}
          pendingAction={pendingAction}
          onPostpone={
            group.plan.is_reschedulable && !group.plan.actual_end_time
              ? () => handlePostponePlan(group.plan.id)
              : undefined
          }
          canPostpone={group.plan.is_reschedulable && !group.plan.actual_end_time}
          compact
          status={timerState.status}
          accumulatedSeconds={timerState.accumulatedSeconds}
          startedAt={timerState.startedAt}
          serverNow={serverNow}
        />

      </div>
    </div>
  );
}

export const PlanCard = memo(PlanCardComponent, (prevProps, nextProps) => {
  // groupì˜ ì£¼ìš” ì†ì„±ë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  const prevPlan = prevProps.group.plan;
  const nextPlan = nextProps.group.plan;
  
  return (
    prevProps.group.planNumber === nextProps.group.planNumber &&
    prevPlan.id === nextPlan.id &&
    prevPlan.progress === nextPlan.progress &&
    prevPlan.actual_start_time === nextPlan.actual_start_time &&
    prevPlan.actual_end_time === nextPlan.actual_end_time &&
    prevProps.planDate === nextProps.planDate &&
    prevProps.viewMode === nextProps.viewMode &&
    prevProps.campMode === nextProps.campMode &&
    prevProps.serverNow === nextProps.serverNow &&
    // sessions Map ë¹„êµ (í¬ê¸°ì™€ ì£¼ìš” í‚¤ë§Œ í™•ì¸)
    prevProps.sessions.size === nextProps.sessions.size &&
    prevProps.sessions.get(prevPlan.id)?.isPaused === nextProps.sessions.get(nextPlan.id)?.isPaused
  );
});
</file>

<file path="_components/PlanDateNavigator.tsx">
"use client";

import { Calendar, ChevronLeft, ChevronRight, RotateCcw } from "lucide-react";
import {
  formatKoreanDateWithDay,
  getRelativeDateLabel,
  getTodayISODate,
} from "../_utils/dateDisplay";
import { cn } from "@/lib/cn";

type PlanDateNavigatorProps = {
  planDate: string;
  isToday: boolean;
  isLoading: boolean;
  isNavigating: boolean;
  onMoveDay: (delta: number) => void;
  onResetToToday: () => void;
};

export function PlanDateNavigator({
  planDate,
  isToday,
  isLoading,
  isNavigating,
  onMoveDay,
  onResetToToday,
}: PlanDateNavigatorProps) {
  const hasDate = Boolean(planDate);
  const formattedDate = hasDate
    ? formatKoreanDateWithDay(planDate)
    : "ë‚ ì§œ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ê³  ìˆìŠµë‹ˆë‹¤";
  const relativeLabelRaw = hasDate
    ? getRelativeDateLabel(planDate, getTodayISODate())
    : "";
  const relativeLabel =
    relativeLabelRaw && relativeLabelRaw !== "-" ? relativeLabelRaw : "ì„ íƒí•œ ë‚ ì§œ";
  const disableNav = !hasDate || isLoading || isNavigating;

  return (
    <div className="flex flex-col gap-3 rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
      <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div className="flex items-center gap-3">
          <div className="flex h-10 w-10 items-center justify-center rounded-full bg-indigo-50 text-indigo-600">
            <Calendar className="h-5 w-5" />
          </div>
          <div className="flex flex-col">
            <span className="text-sm font-medium text-gray-500">
              {relativeLabel}
            </span>
            <span className="text-lg font-semibold text-gray-900">
              {formattedDate}
            </span>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button
            type="button"
            onClick={() => onMoveDay(-1)}
            disabled={disableNav}
            aria-label="ì´ì „ ë‚ ì§œë¡œ ì´ë™"
            className={cn(
              "flex items-center gap-1 rounded-full border border-gray-200 px-3 py-2 text-sm font-medium text-gray-600 transition",
              disableNav ? "opacity-60" : "hover:bg-gray-50"
            )}
          >
            <ChevronLeft className="h-4 w-4" aria-hidden="true" />
            ì´ì „
          </button>
          <button
            type="button"
            onClick={() => onMoveDay(1)}
            disabled={disableNav}
            aria-label="ë‹¤ìŒ ë‚ ì§œë¡œ ì´ë™"
            className={cn(
              "flex items-center gap-1 rounded-full border border-gray-200 px-3 py-2 text-sm font-medium text-gray-600 transition",
              disableNav ? "opacity-60" : "hover:bg-gray-50"
            )}
          >
            ë‹¤ìŒ
            <ChevronRight className="h-4 w-4" aria-hidden="true" />
          </button>
        </div>
      </div>
      {!isToday && hasDate && (
        <div className="flex items-center justify-end">
          <button
            type="button"
            onClick={onResetToToday}
            disabled={isLoading || isNavigating}
            aria-label="ì˜¤ëŠ˜ ë‚ ì§œë¡œ ëŒì•„ê°€ê¸°"
            className={cn(
              "flex items-center gap-1 rounded-full bg-indigo-50 px-3 py-1.5 text-xs font-semibold text-indigo-700 transition",
              isLoading || isNavigating
                ? "opacity-60"
                : "hover:bg-indigo-100"
            )}
          >
            <RotateCcw className="h-4 w-4" aria-hidden="true" />
            ì˜¤ëŠ˜ë¡œ ì´ë™
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="_components/PlanDetailInfo.tsx">
"use client";

import { memo } from "react";
import { BookOpen, Repeat, Layers } from "lucide-react";
import { PlanGroup } from "../_utils/planGroupUtils";
import { getLearningRange } from "../_utils/planGroupUtils";

type PlanDetailInfoProps = {
  group: PlanGroup;
};

function PlanDetailInfoComponent({ group }: PlanDetailInfoProps) {
  const plan = group.plan;
  const learningRange = getLearningRange([plan]);
  const sequenceText = group.sequence
    ? `${group.sequence}íšŒì°¨`
    : `${plan.sequence || 1}íšŒì°¨`;

  return (
    <div className="flex items-center justify-center gap-6 text-sm">
      <div className="flex items-center gap-2">
        <BookOpen className="h-4 w-4 text-gray-400" />
        <span className="text-gray-600">ë²”ìœ„</span>
        <span className="font-semibold text-gray-900">{learningRange}</span>
      </div>
      <div className="h-4 w-px bg-gray-300"></div>
      <div className="flex items-center gap-2">
        <Repeat className="h-4 w-4 text-gray-400" />
        <span className="text-gray-600">íšŒì°¨</span>
        <span className="font-semibold text-gray-900">{sequenceText}</span>
      </div>
    </div>
  );
}

export const PlanDetailInfo = memo(PlanDetailInfoComponent, (prevProps, nextProps) => {
  // groupì˜ ì£¼ìš” ì†ì„±ë§Œ ë¹„êµ
  const prevPlan = prevProps.group.plan;
  const nextPlan = nextProps.group.plan;
  
  return (
    prevProps.group.planNumber === nextProps.group.planNumber &&
    prevPlan.id === nextPlan.id &&
    prevPlan.content_type === nextPlan.content_type &&
    prevPlan.content_id === nextPlan.content_id &&
    prevPlan.planned_start_page_or_time === nextPlan.planned_start_page_or_time &&
    prevPlan.planned_end_page_or_time === nextPlan.planned_end_page_or_time &&
    prevProps.group.sequence === nextProps.group.sequence
  );
});
</file>

<file path="_components/PlanGroupActions.tsx">
"use client";

import { FileText, Settings } from "lucide-react";
import { PlanGroup } from "../_utils/planGroupUtils";
import { cn } from "@/lib/cn";

type PlanGroupActionsProps = {
  group: PlanGroup;
  memo?: string | null;
  hasMemo: boolean;
  onMemoClick: () => void;
  onRangeAdjustClick: () => void;
  onViewDetail?: () => void;
  viewMode: "daily" | "single";
};

export function PlanGroupActions({
  group,
  memo,
  hasMemo,
  onMemoClick,
  onRangeAdjustClick,
  onViewDetail,
  viewMode,
}: PlanGroupActionsProps) {
  const memoPreview = memo && memo.length > 0 ? memo.slice(0, 50) + (memo.length > 50 ? "..." : "") : null;

  return (
    <div className="flex items-center gap-2">
      {/* ë©”ëª¨ ì•„ì´ì½˜ ë²„íŠ¼ */}
      <button
        onClick={onMemoClick}
        className={cn(
          "group relative flex items-center justify-center rounded-lg p-2 transition hover:bg-gray-100",
          hasMemo ? "text-indigo-600" : "text-gray-400"
        )}
        title={memoPreview || "ë©”ëª¨ ì‘ì„±"}
      >
        <FileText className={cn("h-5 w-5", hasMemo && "fill-current")} />
        {hasMemo && memo && memo.length > 0 && (
          <span className="absolute -right-1 -top-1 flex h-3 w-3 items-center justify-center rounded-full bg-indigo-600 text-[8px] text-white">
            {memo.length > 9 ? "9+" : memo.length}
          </span>
        )}
        {/* íˆ´íŒ */}
        {/* ì˜ˆì™¸: íˆ´íŒ ìœ„ì¹˜ ì¡°ì •ì„ ìœ„í•œ ë™ì  margin ê³„ì‚° (Tailwind í´ë˜ìŠ¤ë¡œ ë³€í™˜ ë¶ˆê°€) */}
        {memoPreview && (
          <div className="pointer-events-none absolute bottom-full right-0 hidden w-48 rounded-lg bg-gray-900 px-3 py-2 text-xs text-white opacity-0 shadow-lg transition-opacity group-hover:block group-hover:opacity-100" style={{ marginBottom: '0.5rem' }}>
            <div className="whitespace-pre-wrap break-words">{memoPreview}</div>
            <div className="absolute bottom-0 right-4 translate-y-full">
              <div className="border-4 border-transparent border-t-gray-900"></div>
            </div>
          </div>
        )}
      </button>

      {/* ë²”ìœ„ ì¡°ì • ì•„ì´ì½˜ ë²„íŠ¼ */}
      <button
        onClick={onRangeAdjustClick}
        className="flex items-center justify-center rounded-lg p-2 text-gray-400 transition hover:bg-gray-100 hover:text-gray-600"
        title="ë²”ìœ„ ì¡°ì •"
      >
        <Settings className="h-5 w-5" />
      </button>

      {/* ìƒì„¸ë³´ê¸° ë²„íŠ¼ (ì¼ì¼ ë·°ì—ì„œë§Œ) */}
      {viewMode === "daily" && onViewDetail && (
        <button
          onClick={onViewDetail}
          className="flex items-center gap-1 rounded-lg bg-gray-100 px-3 py-1.5 text-xs font-medium text-gray-700 transition hover:bg-gray-200"
        >
          <FileText className="h-4 w-4" />
          ìƒì„¸ë³´ê¸°
        </button>
      )}
    </div>
  );
}
</file>

<file path="_components/PlanGroupCard.tsx">
"use client";

import { PlanGroup, PlanWithContent } from "../_utils/planGroupUtils";
import {
  calculateGroupProgress,
  calculateGroupTotalStudyTime,
  getActivePlansCount,
  getCompletedPlansCount,
  formatTime,
} from "../_utils/planGroupUtils";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";
import { PlanItem } from "./PlanItem";
import { TimestampDisplay } from "./TimestampDisplay";
import { TimerControlButtons } from "./TimerControlButtons";
import { PlanGroupActions } from "./PlanGroupActions";
import { PlanMemoModal } from "./PlanMemoModal";
import { PlanRangeAdjustModal } from "./PlanRangeAdjustModal";
import { PlanDetailInfo } from "./PlanDetailInfo";
import { TimeCheckSection } from "./TimeCheckSection";
import { startPlan, pausePlan, resumePlan, preparePlanCompletion } from "../actions/todayActions";
import { savePlanMemo } from "../actions/planMemoActions";
import { adjustPlanRanges } from "../actions/planRangeActions";
import { resetPlanTimer } from "../actions/timerResetActions";
import { useRouter } from "next/navigation";
import { useState, useEffect, useTransition, useMemo, memo } from "react";
import { getTimeStats, getActivePlan } from "../_utils/planGroupUtils";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import { useToast } from "@/components/ui/ToastProvider";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type PlanGroupCardProps = {
  group: PlanGroup;
  viewMode: "daily" | "single";
  sessions: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>;
  planDate: string; // í”Œëœ ë‚ ì§œ (ë©”ëª¨ ì¡°íšŒìš©)
  memo?: string | null; // ë©”ëª¨ ë‚´ìš©
  totalPages?: number; // ì½˜í…ì¸  ì´ëŸ‰ (ë²”ìœ„ ì¡°ì •ìš©)
  onViewDetail?: (planNumber: number | null) => void; // ì¼ì¼ ë·°ì—ì„œ ë‹¨ì¼ ë·°ë¡œ ì „í™˜í•  ë•Œ
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

function PlanGroupCardComponent({
  group,
  viewMode,
  sessions,
  planDate,
  memo,
  totalPages,
  onViewDetail,
  campMode = false,
}: PlanGroupCardProps) {
  const router = useRouter();
  const timerStore = usePlanTimerStore();
  const { showError } = useToast();

  const [isLoading, setIsLoading] = useState(false);
  const [isPending, startTransition] = useTransition();
  const [isMemoModalOpen, setIsMemoModalOpen] = useState(false);
  const [isRangeModalOpen, setIsRangeModalOpen] = useState(false);

  // ì½˜í…ì¸  ì •ë³´ (ë©”ëª¨ì´ì œì´ì…˜)
  const contentInfo = useMemo(() => ({
    title: group.content?.title || "ì œëª© ì—†ìŒ",
    icon: group.plan.content_type === "book"
      ? "ğŸ“š"
      : group.plan.content_type === "lecture"
      ? "ğŸ§"
      : "ğŸ“"
  }), [group.content?.title, group.plan.content_type]);

   // ì§‘ê³„ ì •ë³´ ê³„ì‚° (ë©”ëª¨ì´ì œì´ì…˜)
   const aggregatedInfo = useMemo(() => ({
     totalProgress: calculateGroupProgress(group),
     totalStudyTime: calculateGroupTotalStudyTime(group, sessions),
     activePlansCount: getActivePlansCount(group, sessions),
     completedPlansCount: getCompletedPlansCount(group),
     activePlan: getActivePlan(group, sessions)
   }), [group, sessions]);

  // ê·¸ë£¹ ìƒíƒœ ê³„ì‚° (ë©”ëª¨ì´ì œì´ì…˜)
  const groupStatus = useMemo(() => {
    const activePlan = aggregatedInfo.activePlan;
    const isGroupRunning = !!activePlan;

    // ì¼ì‹œì •ì§€ëœ í”Œëœì´ ìˆìœ¼ë©´ ì¼ì‹œì •ì§€ ìƒíƒœë¡œ ê°„ì£¼
    const plan = group.plan;
    const session = sessions.get(plan.id);
    const isGroupPaused = plan.actual_start_time &&
      !plan.actual_end_time &&
      session &&
      session.isPaused;

    // ë‹¤ë¥¸ í”Œëœì´ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (í˜„ì¬ ê·¸ë£¹ì˜ í”Œëœ ì œì™¸)
    const currentGroupPlanIds = new Set([plan.id]);
    const hasOtherActivePlan = Array.from(sessions.entries()).some(
      ([planId, session]) =>
        !currentGroupPlanIds.has(planId) &&
        session &&
        !session.isPaused
    );

    return {
      isGroupRunning,
      isGroupPaused,
      hasOtherActivePlan
    };
  }, [aggregatedInfo.activePlan, group.plan, sessions]);

  // ì‹œê°„ í†µê³„ ê³„ì‚° (ë©”ëª¨ì´ì œì´ì…˜)
  const timeStats = useMemo(() =>
    getTimeStats([group.plan], aggregatedInfo.activePlan, sessions),
    [group.plan, aggregatedInfo.activePlan, sessions]
  );

  // ê·¸ë£¹ íƒ€ì´ë¨¸ ì œì–´ í•¸ë“¤ëŸ¬ (optimistic update ì ìš©)
  const handleGroupStart = async (timestamp?: string) => {
    // ê·¸ë£¹ ë‚´ ì²« ë²ˆì§¸ ëŒ€ê¸° ì¤‘ì¸ í”Œëœ ì‹œì‘
    const plan = group.plan;
    if (plan.actual_start_time || plan.actual_end_time) return;
    const waitingPlan = plan;

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„± (ì—†ìœ¼ë©´ ì„œë²„ì—ì„œ ìƒì„±)
      const clientTimestamp = timestamp || new Date().toISOString();
      // ì„œë²„ ë™ê¸°í™”ëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬ (startTransition ì‚¬ìš©)
      startTransition(async () => {
        const result = await startPlan(waitingPlan.id, clientTimestamp);
        if (result.success) {
          // ì„œë²„ ì•¡ì…˜ì—ì„œ ì´ë¯¸ revalidatePathë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ router.refresh() ë¶ˆí•„ìš”
          // Optimistic Updateë¡œ ì¦‰ì‹œ UI ë°˜ì‘, ì„œë²„ ìƒíƒœëŠ” ìë™ ë™ê¸°í™”ë¨
          setIsLoading(false);
        } else {
          alert(result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
          setIsLoading(false);
        }
      });
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      setIsLoading(false);
    }
  };

  const handleGroupPause = async () => {
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if (isLoading) {
      return;
    }

    // ì‹¤ì œë¡œ ì„¸ì…˜ì´ ìˆëŠ” í™œì„± í”Œëœë§Œ ì¼ì‹œì •ì§€ (ì„¸ì…˜ ë°ì´í„° ê¸°ë°˜)
    const plan = group.plan;
    const session = sessions.get(plan.id);
    const isActive = plan.actual_start_time &&
      !plan.actual_end_time &&
      session &&
      !session.isPaused;

    if (!isActive) {
      alert("ì¼ì‹œì •ì§€í•  í™œì„± í”Œëœì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
      const clientTimestamp = new Date().toISOString();
      const result = await pausePlan(plan.id, clientTimestamp);

      if (!result.success) {
        // "ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤" ë˜ëŠ” "í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" ì—ëŸ¬ëŠ” ë¬´ì‹œ
        // (ì„¸ì…˜ ìƒíƒœ ë™ê¸°í™” ë¬¸ì œë¡œ ì¸í•œ ì—ëŸ¬ì¼ ìˆ˜ ìˆìŒ)
        const isIgnorableError = result.error &&
          (result.error.includes("ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤") ||
           result.error.includes("í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
        
        if (!isIgnorableError) {
          alert(`ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${result.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}`);
          setIsLoading(false);
          // ì—ëŸ¬ ë°œìƒ ì‹œì—ë§Œ ìƒíƒœ ë™ê¸°í™”ë¥¼ ìœ„í•´ refresh
          startTransition(() => {
            router.refresh();
          });
          return;
        }
      }
      
      // ì„œë²„ ì•¡ì…˜ì—ì„œ ì´ë¯¸ revalidatePathë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ router.refresh() ë¶ˆí•„ìš”
      // Optimistic Updateë¡œ ì¦‰ì‹œ UI ë°˜ì‘, ì„œë²„ ìƒíƒœëŠ” ìë™ ë™ê¸°í™”ë¨
      setIsLoading(false);
    } catch (error) {
      console.error("[PlanGroupCard] ì¼ì‹œì •ì§€ ì˜¤ë¥˜:", error);
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + (error instanceof Error ? error.message : String(error)));
      setIsLoading(false);
    }
  };

  const handleGroupResume = async (timestamp?: string) => {
    // ì‹¤ì œë¡œ ì„¸ì…˜ì´ ìˆê³  ì¼ì‹œì •ì§€ëœ í”Œëœë§Œ ì¬ê°œ (ì„¸ì…˜ ë°ì´í„° ê¸°ë°˜)
    const plan = group.plan;
    const session = sessions.get(plan.id);
    const isPaused = session && session.isPaused;

    if (!isPaused) {
      alert("ì¬ê°œí•  ì¼ì‹œì •ì§€ëœ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„± (ì „ë‹¬ë°›ì€ íƒ€ì„ìŠ¤íƒ¬í”„ê°€ ì—†ìœ¼ë©´ ìƒì„±)
      const clientTimestamp = timestamp || new Date().toISOString();
      const result = await resumePlan(plan.id, clientTimestamp);

      if (!result.success) {
        // "í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" ì—ëŸ¬ëŠ” ë¬´ì‹œ (ì„¸ì…˜ ìƒíƒœ ë™ê¸°í™” ë¬¸ì œ)
        const isIgnorableError = result.error && result.error.includes("í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        
        if (!isIgnorableError) {
          alert(`ì¬ê°œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${result.error || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}`);
          setIsLoading(false);
          // ì—ëŸ¬ ë°œìƒ ì‹œì—ë§Œ ìƒíƒœ ë™ê¸°í™”ë¥¼ ìœ„í•´ refresh
          startTransition(() => {
            router.refresh();
          });
          return;
        }
      }
      
      // ì„œë²„ ì•¡ì…˜ì—ì„œ ì´ë¯¸ revalidatePathë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ router.refresh() ë¶ˆí•„ìš”
      // Optimistic Updateë¡œ ì¦‰ì‹œ UI ë°˜ì‘, ì„œë²„ ìƒíƒœëŠ” ìë™ ë™ê¸°í™”ë¨
      setIsLoading(false);
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      setIsLoading(false);
    }
  };

  const handleGroupComplete = async () => {
    const targetPlanId = aggregatedInfo.activePlan?.id || group.plan.id;
    
    // í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
    const confirmed = confirm(
      "ì§€ê¸ˆê¹Œì§€ì˜ í•™ìŠµì„ ê¸°ì¤€ìœ¼ë¡œ ì´ í”Œëœì„ ì™„ë£Œ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™í• ê¹Œìš”?"
    );
    
    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    try {
      const result = await preparePlanCompletion(targetPlanId);
      
      if (!result.success) {
        showError(result.error || "í”Œëœ ì™„ë£Œ ì¤€ë¹„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      // íƒ€ì´ë¨¸ ì •ì§€ (ìŠ¤í† ì–´ì—ì„œ ì œê±°)
      timerStore.removeTimer(targetPlanId);

      // ì™„ë£Œ ì…ë ¥ í˜ì´ì§€ë¡œ ì´ë™
      router.push(buildPlanExecutionUrl(targetPlanId, campMode));
    } catch (error) {
      console.error("[PlanGroupCard] ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  // íšŒì°¨ í‘œì‹œ
  const sequenceText = group.sequence
    ? `${group.sequence}íšŒì°¨`
    : `${group.plan.sequence || 1}íšŒì°¨`;

  // ë©”ëª¨ ì €ì¥ í•¸ë“¤ëŸ¬
  const handleSaveMemo = async (newMemo: string) => {
    const result = await savePlanMemo(group.planNumber, planDate, newMemo);
    if (result.success) {
      router.refresh();
    } else {
      throw new Error(result.error || "ë©”ëª¨ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  // ë²”ìœ„ ì¡°ì • ì €ì¥ í•¸ë“¤ëŸ¬
  const handleSaveRanges = async (ranges: Array<{ planId: string; startPageOrTime: number; endPageOrTime: number }>) => {
    const planIds = ranges.map((r) => r.planId);
    const result = await adjustPlanRanges(planIds, ranges);
    if (result.success) {
      router.refresh();
    } else {
      throw new Error(result.error || "ë²”ìœ„ ì¡°ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  // íƒ€ì´ë¨¸ ì´ˆê¸°í™” í•¸ë“¤ëŸ¬
  const handleResetTimer = async () => {
    if (!confirm("íƒ€ì´ë¨¸ ê¸°ë¡ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ˆê¸°í™”í•˜ë©´ ë‹¤ìŒ ì •ë³´ê°€ ì‚­ì œë©ë‹ˆë‹¤:\n- ì‹œì‘/ì¢…ë£Œ ì‹œê°„\n- í•™ìŠµ ì‹œê°„ ê¸°ë¡\n- ì¼ì‹œì •ì§€ ê¸°ë¡\n- íƒ€ì´ë¨¸ í™œë™ ê¸°ë¡\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")) {
      return;
    }

    setIsLoading(true);
    try {
      const result = await resetPlanTimer(group.planNumber, planDate);
      if (result.success) {
        // ì„œë²„ ìƒíƒœ ë°˜ì˜ì„ ìœ„í•´ í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
        startTransition(() => {
          router.refresh();
        });
      } else {
        alert(result.error || "íƒ€ì´ë¨¸ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      console.error("[PlanGroupCard] íƒ€ì´ë¨¸ ì´ˆê¸°í™” ì˜¤ë¥˜:", error);
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  // ì½˜í…ì¸  ì´ëŸ‰ ê³„ì‚° (ë©”ëª¨ì´ì œì´ì…˜)
  const totalPagesCalculated = useMemo(() => {
    if (totalPages !== undefined && totalPages > 0) {
      return totalPages;
    }
    // ê¸°ë³¸ê°’: endPageOrTimeì„ ì´ëŸ‰ìœ¼ë¡œ ì¶”ì •
    return group.plan.planned_end_page_or_time ?? 100;
  }, [totalPages, group.plan.planned_end_page_or_time]);

  const isBook = useMemo(() =>
    group.plan.content_type === "book",
    [group.plan.content_type]
  );

  if (viewMode === "single") {
    // ë‹¨ì¼ ë·°: ì „ì²´ í™”ë©´ìœ¼ë¡œ í¬ê²Œ í‘œì‹œ
    return (
      <div className="flex flex-col gap-6">
        {/* í—¤ë” */}
        <div className="relative text-center">
          <div className="absolute right-0 top-0">
            <PlanGroupActions
              group={group}
              memo={memo ?? null}
              hasMemo={!!memo && memo.length > 0}
              onMemoClick={() => setIsMemoModalOpen(true)}
              onRangeAdjustClick={() => setIsRangeModalOpen(true)}
              viewMode="single"
            />
          </div>
          <div className="flex flex-col gap-2">
            <div className="text-4xl">{contentInfo.icon}</div>
            <h2 className="text-h2 text-gray-900">{contentInfo.title}</h2>
          </div>
        </div>

        {/* í”Œëœ ìƒì„¸ ì •ë³´ */}
        <PlanDetailInfo group={group} />

        {/* ì‹œê°„ ì²´í¬ ì„¹ì…˜ */}
        <TimeCheckSection
          timeStats={timeStats}
          isPaused={!!groupStatus.isGroupPaused}
          activePlanStartTime={aggregatedInfo.activePlan?.actual_start_time ?? null}
          planId={aggregatedInfo.activePlan?.id || group.plan.id || ""}
          isActive={groupStatus.isGroupRunning}
          isLoading={isLoading || isPending}
          planNumber={group.planNumber}
          planDate={planDate}
          hasOtherActivePlan={groupStatus.hasOtherActivePlan}
          onStart={handleGroupStart}
          onPause={handleGroupPause}
          onResume={handleGroupResume}
          onComplete={handleGroupComplete}
          onReset={handleResetTimer}
          campMode={campMode}
        />


        {/* ì „ì²´ ì§„í–‰ë¥  ë° ì‹œê°„ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2 text-center">
              <h3 className="text-lg font-semibold text-gray-900">
                ì „ì²´ ì§„í–‰ë¥ 
              </h3>
              <div className="text-3xl font-bold text-indigo-600">
                {aggregatedInfo.totalProgress}%
              </div>
              <ProgressBar
                value={aggregatedInfo.totalProgress}
                color="indigo"
                size="md"
              />
            </div>

            <div className="flex flex-col gap-1 text-center">
              <p className="text-sm text-gray-600">ì´ í•™ìŠµ ì‹œê°„</p>
              <p className="text-2xl font-bold text-indigo-600">
                {formatTime(aggregatedInfo.totalStudyTime)}
              </p>
            </div>
          </div>
        </div>

        {/* ë©”ëª¨ ëª¨ë‹¬ */}
        <PlanMemoModal
          group={group}
          memo={memo ?? null}
          isOpen={isMemoModalOpen}
          onClose={() => setIsMemoModalOpen(false)}
          onSave={handleSaveMemo}
        />

        {/* ë²”ìœ„ ì¡°ì • ëª¨ë‹¬ */}
        <PlanRangeAdjustModal
          group={group}
          isOpen={isRangeModalOpen}
          onClose={() => setIsRangeModalOpen(false)}
          onSave={handleSaveRanges}
          totalPages={totalPagesCalculated}
          isBook={isBook}
        />
      </div>
    );
  }

  // ì¼ì¼ ë·°: ì»´íŒ©íŠ¸í•œ ì¹´ë“œ í˜•íƒœ
  return (
    <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
      <div className="flex flex-col gap-4">
        {/* ì¹´ë“œ í—¤ë” */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-lg">{contentInfo.icon}</span>
            <h3 className="font-semibold text-gray-900">{contentInfo.title}</h3>
            {group.planNumber !== null && (
              <span className="text-xs text-gray-500">
                (plan_number: {group.planNumber})
              </span>
            )}
          </div>
          <PlanGroupActions
            group={group}
            memo={memo ?? null}
            hasMemo={!!memo && memo.length > 0}
            onMemoClick={() => setIsMemoModalOpen(true)}
            onRangeAdjustClick={() => setIsRangeModalOpen(true)}
            onViewDetail={onViewDetail ? () => onViewDetail(group.planNumber) : undefined}
            viewMode="daily"
          />
        </div>
        {group.sequence && (
          <p className="text-sm text-gray-600">({sequenceText})</p>
        )}

        {/* í”Œëœ ì •ë³´ (ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœì€ í•˜ë‚˜ë§Œ í‘œì‹œ) */}
        <div className="flex flex-col gap-3">
          {(() => {
            const plan = group.plan;
            const planWithSession = {
              ...plan,
              session: sessions.get(plan.id) || undefined,
            };

            return (
              <PlanItem
                key={plan.id}
                plan={planWithSession}
                isGrouped={true}
                showTimer={
                  !!plan.actual_start_time ||
                  !!plan.actual_end_time ||
                  sessions.has(plan.id)
                }
                viewMode="daily"
                campMode={campMode}
              />
            );
          })()}
        </div>

        {/* ì§‘ê³„ ì •ë³´ */}
        <div className="rounded-lg bg-gray-50 p-3">
          <div className="flex flex-col gap-2">
            <div className="flex items-center justify-between text-sm">
              <span className="text-gray-600">ì „ì²´ ì§„í–‰ë¥ </span>
              <span className="font-semibold text-gray-900">{aggregatedInfo.totalProgress}%</span>
            </div>
            <ProgressBar
              value={aggregatedInfo.totalProgress}
              color="indigo"
              size="sm"
            />
            <div className="flex items-center justify-between text-xs text-gray-500">
              <span>ì´ í•™ìŠµ ì‹œê°„: {formatTime(aggregatedInfo.totalStudyTime)}</span>
              <span>
                í™œì„±: {aggregatedInfo.activePlansCount} | ì™„ë£Œ: {aggregatedInfo.completedPlansCount}
              </span>
            </div>
          </div>
        </div>
      </div>

      {/* ê·¸ë£¹ ì œì–´ ë²„íŠ¼ */}
      <TimerControlButtons
        planId={aggregatedInfo.activePlan?.id || group.plan.id || ""}
        isActive={groupStatus.isGroupRunning}
        isPaused={!!groupStatus.isGroupPaused}
        isCompleted={aggregatedInfo.completedPlansCount === 1}
        isLoading={isLoading || isPending}
        onStart={handleGroupStart}
        onPause={handleGroupPause}
        onResume={handleGroupResume}
        onComplete={handleGroupComplete}
        campMode={campMode}
      />

      {/* ë©”ëª¨ ëª¨ë‹¬ */}
      <PlanMemoModal
        group={group}
        memo={memo ?? null}
        isOpen={isMemoModalOpen}
        onClose={() => setIsMemoModalOpen(false)}
        onSave={handleSaveMemo}
      />

      {/* ë²”ìœ„ ì¡°ì • ëª¨ë‹¬ */}
      <PlanRangeAdjustModal
        group={group}
        isOpen={isRangeModalOpen}
        onClose={() => setIsRangeModalOpen(false)}
        onSave={handleSaveRanges}
        totalPages={totalPagesCalculated}
        isBook={isBook}
      />
    </div>
  );
}

export const PlanGroupCard = memo(PlanGroupCardComponent);
</file>

<file path="_components/PlanItem.tsx">
"use client";

import { useState, useMemo, memo } from "react";
import { PlanWithContent, calculateStudyTimeFromTimestamps } from "../_utils/planGroupUtils";
import { TimestampDisplay } from "./TimestampDisplay";
import { TimerControlButtons } from "./TimerControlButtons";
import { formatTime, formatTimestamp } from "../_utils/planGroupUtils";
import { startPlan, pausePlan, resumePlan, preparePlanCompletion } from "../actions/todayActions";
import { useRouter } from "next/navigation";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import { useToast } from "@/components/ui/ToastProvider";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type PlanItemProps = {
  plan: PlanWithContent;
  isGrouped: boolean; // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ê·¸ë£¹ì˜ ì¼ë¶€ì¸ì§€
  showTimer?: boolean; // íƒ€ì´ë¨¸ í‘œì‹œ ì—¬ë¶€
  viewMode?: "daily" | "single"; // ë·° ëª¨ë“œì— ë”°ë¼ ë ˆì´ì•„ì›ƒ ë‹¤ë¦„
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

function PlanItemComponent({
  plan,
  isGrouped,
  showTimer = false,
  viewMode = "daily",
  campMode = false,
}: PlanItemProps) {
  const router = useRouter();
  const timerStore = usePlanTimerStore();
  const { showError } = useToast();

  const [isLoading, setIsLoading] = useState(false);
  
  // ì„œë²„ ìƒíƒœë§Œ ì‚¬ìš© (ë” ì˜ˆì¸¡ ê°€ëŠ¥í•œ UX)
  const isPaused = plan.session?.isPaused ?? false;
  const isActive = !!plan.actual_start_time && !plan.actual_end_time;
  const isRunning = isActive && !isPaused;
  const isCompleted = !!plan.actual_end_time;

  // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ì‹œê°„ ê³„ì‚° (ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ìµœì í™”)
  // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš° ì¼ì‹œì •ì§€ ì‹œì‘ ì‹œê°„ë„ ê³ ë ¤
  const elapsedSeconds = useMemo(() => {
    const sessionPausedAt = plan.session?.pausedAt ?? null;
    return calculateStudyTimeFromTimestamps(
      plan.actual_start_time,
      plan.actual_end_time,
      plan.paused_duration_seconds,
      isPaused,
      sessionPausedAt
    );
  }, [
    plan.actual_start_time,
    plan.actual_end_time,
    plan.paused_duration_seconds,
    isPaused,
    plan.session
  ]);

  const handleStart = async () => {
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if (isLoading) {
      return;
    }

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
      const timestamp = new Date().toISOString();
      const result = await startPlan(plan.id, timestamp);
      if (!result.success) {
        alert(result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePause = async () => {
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if (isLoading || isPaused) {
      return;
    }

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
      const timestamp = new Date().toISOString();
      const result = await pausePlan(plan.id, timestamp);
      if (!result.success) {
        // "ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤" ì—ëŸ¬ëŠ” ë¬´ì‹œ (ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€)
        if (result.error && !result.error.includes("ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤")) {
          alert(result.error || "í”Œëœ ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleResume = async () => {
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if (isLoading) {
      return;
    }

    setIsLoading(true);
    try {
      // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
      const timestamp = new Date().toISOString();
      const result = await resumePlan(plan.id, timestamp);
      if (!result.success) {
        alert(result.error || "í”Œëœ ì¬ê°œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleComplete = async () => {
    // í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
    const confirmed = confirm(
      "ì§€ê¸ˆê¹Œì§€ì˜ í•™ìŠµì„ ê¸°ì¤€ìœ¼ë¡œ ì´ í”Œëœì„ ì™„ë£Œ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™í• ê¹Œìš”?"
    );
    
    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    try {
      const result = await preparePlanCompletion(plan.id);
      
      if (!result.success) {
        showError(result.error || "í”Œëœ ì™„ë£Œ ì¤€ë¹„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      // íƒ€ì´ë¨¸ ì •ì§€ (ìŠ¤í† ì–´ì—ì„œ ì œê±°)
      timerStore.removeTimer(plan.id);

      // ì™„ë£Œ ì…ë ¥ í˜ì´ì§€ë¡œ ì´ë™
      router.push(buildPlanExecutionUrl(plan.id, campMode));
    } catch (error) {
      console.error("[PlanItem] ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  const contentTypeIcon =
    plan.content_type === "book"
      ? "ğŸ“š"
      : plan.content_type === "lecture"
      ? "ğŸ§"
      : "ğŸ“";

  const contentTitle = plan.content?.title || "ì œëª© ì—†ìŒ";

  // ë²”ìœ„ í‘œì‹œ
  const startPage = plan.planned_start_page_or_time;
  const endPage = plan.planned_end_page_or_time;
  const pageRange =
    startPage !== null &&
    endPage !== null &&
    `${startPage} ~ ${endPage}${plan.content_type === "book" ? "í˜ì´ì§€" : "ë¶„"}`;

  // ì§„í–‰ë¥  ê³„ì‚°
  const progress = plan.progress ?? 0;

  // ì‹œê°„ ë²”ìœ„ í‘œì‹œ
  const timeRange =
    plan.start_time && plan.end_time
      ? `${plan.start_time} ~ ${plan.end_time}`
      : null;

  if (viewMode === "single") {
    // ë‹¨ì¼ ë·°: í° í™”ë©´ìœ¼ë¡œ í‘œì‹œ
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <span className="text-lg">{contentTypeIcon}</span>
              <h3 className="text-lg font-semibold text-gray-900">
                ë¸”ë¡ {plan.block_index ?? "-"}: {timeRange || "ì‹œê°„ ë¯¸ì •"}
              </h3>
            </div>
            <div className="flex flex-col gap-1">
              {plan.sequence && (
                <p className="text-sm text-gray-600">íšŒì°¨: {plan.sequence}íšŒì°¨</p>
              )}
              {pageRange && (
                <p className="text-sm text-gray-600">ë²”ìœ„: {pageRange}</p>
              )}
            </div>
            {progress > 0 && (
              <div className="flex flex-col gap-1">
                <div className="flex items-center justify-between text-xs text-gray-600">
                  <span>ì§„í–‰ë¥ </span>
                  <span>{progress}%</span>
                </div>
                <ProgressBar
                  value={progress}
                  color="blue"
                  size="sm"
                />
              </div>
            )}
          </div>

          {(showTimer || isRunning || isPaused || isCompleted) && (
            <TimestampDisplay
              actualStartTime={plan.actual_start_time}
              actualEndTime={plan.actual_end_time}
              totalDurationSeconds={plan.total_duration_seconds}
              pausedDurationSeconds={plan.paused_duration_seconds}
              pauseCount={plan.pause_count}
              isRunning={isRunning}
              isPaused={isPaused}
              isCompleted={isCompleted}
              currentPausedAt={plan.session?.pausedAt ?? null}
            />
          )}

          <TimerControlButtons
            planId={plan.id}
            isActive={isRunning}
            isPaused={isPaused}
            isCompleted={isCompleted}
            isLoading={isLoading}
            onStart={handleStart}
            onPause={handlePause}
            onResume={handleResume}
            onComplete={handleComplete}
            campMode={campMode}
          />
        </div>
      </div>
    );
  }

  // ì¼ì¼ ë·°: ì»´íŒ©íŠ¸í•˜ê²Œ í‘œì‹œ
  return (
    <div className="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
      <div className="flex flex-col gap-3">
        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <span>{contentTypeIcon}</span>
            <span className="text-sm font-medium text-gray-900">
              ë¸”ë¡ {plan.block_index ?? "-"}: {timeRange || "ì‹œê°„ ë¯¸ì •"}
            </span>
          </div>
          <div className="flex items-center gap-1">
            {plan.sequence && (
              <span className="text-xs text-gray-600">íšŒì°¨: {plan.sequence}íšŒì°¨</span>
            )}
            {pageRange && <span className="text-xs text-gray-600"> | {pageRange}</span>}
          </div>
          {progress > 0 && (
            <div className="flex flex-col gap-1">
              <div className="flex items-center justify-between text-xs text-gray-600">
                <span>ì§„í–‰ë¥ </span>
                <span>{progress}%</span>
              </div>
              <ProgressBar
                value={progress}
                color="blue"
                size="xs"
              />
            </div>
          )}
        </div>

        {(showTimer || isRunning || isPaused || isCompleted) && (
          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between rounded-lg bg-gray-50 p-2">
              <span className="text-xs text-gray-600">í•™ìŠµ ì‹œê°„</span>
              <span className="text-sm font-bold text-indigo-600">
                {formatTime(elapsedSeconds)}
              </span>
            </div>
            <div className="flex flex-col gap-0.5">
              {plan.actual_start_time && (
                <div className="text-xs text-gray-500">
                  ì‹œì‘: {formatTimestamp(plan.actual_start_time)}
                </div>
              )}
              {plan.pause_count != null && plan.pause_count > 0 && (
                <div className="text-xs text-gray-500">
                  ì¼ì‹œì •ì§€: {plan.pause_count}íšŒ
                </div>
              )}
            </div>
          </div>
        )}

        <TimerControlButtons
          planId={plan.id}
          isActive={isRunning}
          isPaused={isPaused}
          isCompleted={isCompleted}
          isLoading={isLoading}
          onStart={handleStart}
          onPause={handlePause}
          onResume={handleResume}
          onComplete={handleComplete}
          campMode={campMode}
        />
      </div>
    </div>
  );
}

export const PlanItem = memo(PlanItemComponent, (prevProps, nextProps) => {
  // planì˜ ì£¼ìš” ì†ì„±ë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  return (
    prevProps.plan.id === nextProps.plan.id &&
    prevProps.plan.progress === nextProps.plan.progress &&
    prevProps.plan.actual_start_time === nextProps.plan.actual_start_time &&
    prevProps.plan.actual_end_time === nextProps.plan.actual_end_time &&
    prevProps.plan.paused_duration_seconds === nextProps.plan.paused_duration_seconds &&
    prevProps.plan.session?.isPaused === nextProps.plan.session?.isPaused &&
    prevProps.isGrouped === nextProps.isGrouped &&
    prevProps.showTimer === nextProps.showTimer &&
    prevProps.viewMode === nextProps.viewMode &&
    prevProps.campMode === nextProps.campMode
  );
});
</file>

<file path="_components/PlanMemoModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { Save } from "lucide-react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { PlanGroup } from "../_utils/planGroupUtils";

type PlanMemoModalProps = {
  group: PlanGroup;
  memo: string | null;
  isOpen: boolean;
  onClose: () => void;
  onSave: (memo: string) => Promise<void>;
};

const MEMO_TEMPLATES = [
  { icon: "ğŸ“Œ", label: "í•µì‹¬ ì •ë¦¬", template: "ğŸ“Œ í•µì‹¬ ì •ë¦¬:\n- \n- \n-" },
  { icon: "ğŸ“Œ", label: "ë³µìŠµ í•„ìš”", template: "ğŸ“Œ ë³µìŠµ í•„ìš”:\n- \n- \n-" },
  { icon: "ğŸ“Œ", label: "ì§ˆë¬¸ ì‚¬í•­", template: "ğŸ“Œ ì§ˆë¬¸ ì‚¬í•­:\n- \n- \n-" },
  { icon: "ğŸ“Œ", label: "ì¶”ê°€ ìë£Œ", template: "ğŸ“Œ ì¶”ê°€ ìë£Œ:\n- \n- \n-" },
];

const QUICK_INPUTS = [
  { icon: "ğŸš€", label: "ì˜¤ëŠ˜ ëª©í‘œ", template: "ğŸš€ ì˜¤ëŠ˜ ëª©í‘œ: " },
  { icon: "âš ï¸", label: "ì£¼ì˜ì‚¬í•­", template: "âš ï¸ ì£¼ì˜ì‚¬í•­: " },
  { icon: "âœ…", label: "ì™„ë£Œ ì²´í¬", template: "âœ… ì™„ë£Œ ì²´í¬:\n- [ ] \n- [ ] \n- [ ]" },
];

const MAX_MEMO_LENGTH = 500;

export function PlanMemoModal({
  group,
  memo: initialMemo,
  isOpen,
  onClose,
  onSave,
}: PlanMemoModalProps) {
  const [memo, setMemo] = useState(initialMemo ?? "");
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setMemo(initialMemo ?? "");
    }
  }, [isOpen, initialMemo]);

  const handleSave = async () => {
    setIsSaving(true);
    try {
      await onSave(memo.trim());
      onClose();
    } catch (error) {
      alert("ë©”ëª¨ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  const handleTemplateClick = (template: string) => {
    if (memo.trim().length > 0) {
      setMemo((prev) => prev + "\n\n" + template);
    } else {
      setMemo(template);
    }
  };

  const handleQuickInputClick = (template: string) => {
    setMemo((prev) => prev + (prev.trim().length > 0 ? "\n" : "") + template);
  };

  const contentTitle = group.content?.title || "ì œëª© ì—†ìŒ";
  const contentTypeIcon =
    group.plan.content_type === "book"
      ? "ğŸ“š"
      : group.plan.content_type === "lecture"
      ? "ğŸ§"
      : "ğŸ“";

  const descriptionText = `${contentTypeIcon} ${contentTitle}${group.sequence ? ` (${group.sequence}íšŒì°¨)` : ""}`;

  if (!isOpen) return null;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={onClose}
      title="í”Œëœ ë©”ëª¨"
      description={descriptionText}
      maxWidth="2xl"
    >
      <DialogContent>
        <div className="max-h-[calc(100vh-300px)] overflow-y-auto">
          <div className="flex flex-col gap-6">
            {/* ë©”ëª¨ ì…ë ¥ ì˜ì—­ */}
            <div className="flex flex-col gap-2">
              <label className="block text-sm font-medium text-gray-700">
                ë©”ëª¨ ì…ë ¥
              </label>
              <textarea
                value={memo}
                onChange={(e) => {
                  const value = e.target.value;
                  if (value.length <= MAX_MEMO_LENGTH) {
                    setMemo(value);
                  }
                }}
                placeholder="ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                rows={8}
                className="w-full rounded-lg border border-gray-300 px-4 py-3 text-sm text-gray-900 placeholder-gray-400 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
              />
              <div className="flex items-center justify-between text-xs text-gray-600">
                <span>ì¤„ë°”ê¿ˆ ë° íŠ¹ìˆ˜ ë¬¸ì í—ˆìš©</span>
                <span className={memo.length > MAX_MEMO_LENGTH * 0.9 ? "text-amber-600" : ""}>
                  {memo.length}/{MAX_MEMO_LENGTH}ì
                </span>
              </div>
            </div>

            {/* ì¶”ì²œ ë©”ëª¨ í…œí”Œë¦¿ */}
            <div className="flex flex-col gap-3">
              <div className="flex items-center gap-2">
                <span className="text-lg">ğŸ’¡</span>
                <h3 className="text-sm font-semibold text-gray-900">ì¶”ì²œ ë©”ëª¨</h3>
              </div>
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-2">
                  <p className="text-xs text-gray-700">í…œí”Œë¦¿:</p>
                  <div className="flex flex-wrap gap-2">
                    {MEMO_TEMPLATES.map((item, index) => (
                      <button
                        key={index}
                        onClick={() => handleTemplateClick(item.template)}
                        className="rounded-lg border border-gray-200 bg-white px-3 py-1.5 text-xs font-medium text-gray-700 transition hover:bg-gray-50 hover:border-indigo-300 hover:text-indigo-600"
                        aria-label={`${item.label} í…œí”Œë¦¿ ì¶”ê°€`}
                      >
                        <span>{item.icon}</span>
                        {item.label}
                      </button>
                    ))}
                  </div>
                </div>
                <div className="flex flex-col gap-2">
                  <p className="text-xs text-gray-700">ë¹ ë¥¸ ì…ë ¥:</p>
                  <div className="flex flex-wrap gap-2">
                    {QUICK_INPUTS.map((item, index) => (
                      <button
                        key={index}
                        onClick={() => handleQuickInputClick(item.template)}
                        className="flex items-center gap-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5 text-xs font-medium text-gray-700 transition hover:bg-gray-50 hover:border-indigo-300 hover:text-indigo-600"
                        aria-label={`${item.label} ë¹ ë¥¸ ì…ë ¥ ì¶”ê°€`}
                      >
                        <span>{item.icon}</span>
                        {item.label}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
      <DialogFooter>
        <button
          onClick={onClose}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
        >
          ì·¨ì†Œ
        </button>
        <button
          onClick={handleSave}
          disabled={isSaving || memo.length > MAX_MEMO_LENGTH}
          className="flex items-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-indigo-700 disabled:opacity-50"
          aria-label="ë©”ëª¨ ì €ì¥"
        >
          <Save className="h-4 w-4" />
          ì €ì¥
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="_components/PlanRangeAdjustModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { Save, RotateCcw, ChevronLeft, ChevronRight } from "lucide-react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { PlanGroup } from "../_utils/planGroupUtils";

type PlanRange = {
  planId: string;
  blockIndex: number;
  startPageOrTime: number;
  endPageOrTime: number;
};

type PlanRangeAdjustModalProps = {
  group: PlanGroup;
  isOpen: boolean;
  onClose: () => void;
  onSave: (ranges: PlanRange[]) => Promise<void>;
  totalPages: number; // ì½˜í…ì¸ ì˜ ì´ í˜ì´ì§€/ì‹œê°„ ìˆ˜
  isBook: boolean; // ì±…ì¸ì§€ ê°•ì˜ì¸ì§€ (í˜ì´ì§€ vs ë¶„)
};

type AdjustMode = "bulk" | "individual" | "smart";

export function PlanRangeAdjustModal({
  group,
  isOpen,
  onClose,
  onSave,
  totalPages,
  isBook,
}: PlanRangeAdjustModalProps) {
  const [adjustMode, setAdjustMode] = useState<AdjustMode>("bulk");
  const [ranges, setRanges] = useState<PlanRange[]>([]);
  const [originalRanges, setOriginalRanges] = useState<PlanRange[]>([]);
  const [bulkStart, setBulkStart] = useState<number>(0);
  const [bulkEnd, setBulkEnd] = useState<number>(0);
  const [isSaving, setIsSaving] = useState(false);

  // ì´ˆê¸°í™”
  useEffect(() => {
    if (isOpen) {
      const plan = group.plan;
      const initialRanges: PlanRange[] = [{
        planId: plan.id,
        blockIndex: plan.block_index ?? 0,
        startPageOrTime: plan.planned_start_page_or_time ?? 0,
        endPageOrTime: plan.planned_end_page_or_time ?? 0,
      }];

      setRanges(initialRanges);
      setOriginalRanges(JSON.parse(JSON.stringify(initialRanges)));

      // ì „ì²´ ë²”ìœ„ ê³„ì‚°
      setBulkStart(plan.planned_start_page_or_time ?? 0);
      setBulkEnd(plan.planned_end_page_or_time ?? 0);
    }
  }, [isOpen, group.plan]);

  const handleSave = async () => {
    // ê²€ì¦
    for (const range of ranges) {
      if (range.startPageOrTime < 0) {
        alert(`${range.blockIndex}ë²ˆ ë¸”ë¡: ì‹œì‘ ê°’ì€ 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
        return;
      }
      if (range.endPageOrTime > totalPages) {
        alert(`${range.blockIndex}ë²ˆ ë¸”ë¡: ì¢…ë£Œ ê°’ì€ ì´ëŸ‰(${totalPages})ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }
      if (range.startPageOrTime >= range.endPageOrTime) {
        alert(`${range.blockIndex}ë²ˆ ë¸”ë¡: ì‹œì‘ ê°’ì€ ì¢…ë£Œ ê°’ë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤.`);
        return;
      }
    }

    // ë¸”ë¡ ê°„ ê²¹ì¹¨ ê²€ì¦
    const sortedRanges = [...ranges].sort((a, b) => a.blockIndex - b.blockIndex);
    for (let i = 0; i < sortedRanges.length - 1; i++) {
      if (sortedRanges[i].endPageOrTime > sortedRanges[i + 1].startPageOrTime) {
        alert("ë¸”ë¡ ê°„ ë²”ìœ„ê°€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ í•´ì£¼ì„¸ìš”.");
        return;
      }
    }

    setIsSaving(true);
    try {
      await onSave(ranges);
      onClose();
    } catch (error) {
      alert("ë²”ìœ„ ì¡°ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsSaving(false);
    }
  };

  const handleBulkAdjust = () => {
    if (bulkStart < 0 || bulkEnd > totalPages || bulkStart >= bulkEnd) {
      alert("ì˜¬ë°”ë¥¸ ë²”ìœ„ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    // ê¸°ì¡´ ë¸”ë¡ ë¹„ìœ¨ ìœ ì§€í•˜ì—¬ ë¶„ë°°
    const totalOriginalRange = originalRanges.reduce(
      (sum, r) => sum + (r.endPageOrTime - r.startPageOrTime),
      0
    );
    const newTotalRange = bulkEnd - bulkStart;

    let currentStart = bulkStart;
    const newRanges: PlanRange[] = [];

    for (let i = 0; i < originalRanges.length; i++) {
      const originalRange =
        originalRanges[i].endPageOrTime - originalRanges[i].startPageOrTime;
      const ratio = totalOriginalRange > 0 ? originalRange / totalOriginalRange : 1 / originalRanges.length;
      const newRange = Math.round(newTotalRange * ratio);
      const newEnd = i === originalRanges.length - 1 ? bulkEnd : currentStart + newRange;

      newRanges.push({
        planId: originalRanges[i].planId,
        blockIndex: originalRanges[i].blockIndex,
        startPageOrTime: currentStart,
        endPageOrTime: newEnd,
      });

      currentStart = newEnd;
    }

    setRanges(newRanges);
  };

  const handleQuickAdjust = (offset: number) => {
    const newRanges = ranges.map((range) => ({
      ...range,
      startPageOrTime: Math.max(0, range.startPageOrTime + offset),
      endPageOrTime: Math.min(totalPages, range.endPageOrTime + offset),
    }));
    setRanges(newRanges);

    // Bulk ë²”ìœ„ë„ ì—…ë°ì´íŠ¸
    const minStart = Math.min(...newRanges.map((r) => r.startPageOrTime));
    const maxEnd = Math.max(...newRanges.map((r) => r.endPageOrTime));
    setBulkStart(minStart);
    setBulkEnd(maxEnd);
  };

  const handleRestore = () => {
    setRanges(JSON.parse(JSON.stringify(originalRanges)));
    const minStart = Math.min(...originalRanges.map((r) => r.startPageOrTime));
    const maxEnd = Math.max(...originalRanges.map((r) => r.endPageOrTime));
    setBulkStart(minStart);
    setBulkEnd(maxEnd);
  };

  const handleIndividualRangeChange = (
    index: number,
    field: "startPageOrTime" | "endPageOrTime",
    value: number
  ) => {
    const newRanges = [...ranges];
    newRanges[index] = {
      ...newRanges[index],
      [field]: value,
    };
    setRanges(newRanges);
  };

  const contentTitle = group.content?.title || "ì œëª© ì—†ìŒ";
  const unit = isBook ? "í˜ì´ì§€" : "ë¶„";

  if (!isOpen) return null;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={onClose}
      title="í”Œëœ ë²”ìœ„ ì¡°ì •"
      description={contentTitle}
      maxWidth="4xl"
    >
      <DialogContent>
        <div className="max-h-[calc(90vh-200px)] overflow-y-auto">
          <div className="flex flex-col gap-6">
            {/* í˜„ì¬ ë²”ìœ„ */}
            <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50 p-4">
              <h3 className="text-sm font-semibold text-gray-900">í˜„ì¬ ë²”ìœ„</h3>
              <div className="flex flex-col gap-2">
                {ranges.map((range, index) => (
                  <div key={range.planId} className="text-sm text-gray-700">
                    ë¸”ë¡ {range.blockIndex}: {range.startPageOrTime} ~ {range.endPageOrTime} {unit} (
                    {range.endPageOrTime - range.startPageOrTime} {unit})
                  </div>
                ))}
                <div className="pt-2 border-t border-gray-300 text-sm font-medium text-gray-900">
                  ì „ì²´ ë²”ìœ„: {bulkStart} ~ {bulkEnd} {unit} (ì´ {bulkEnd - bulkStart} {unit})
                </div>
              </div>
            </div>

            {/* ì¡°ì • ë°©ì‹ ì„ íƒ */}
            <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-white p-4">
              <h3 className="text-sm font-semibold text-gray-900">ë²”ìœ„ ì¡°ì • ë°©ë²•</h3>
              <div className="flex flex-col gap-2">
                <label className="flex items-start gap-3 cursor-pointer">
                  <input
                    type="radio"
                    name="adjustMode"
                    value="bulk"
                    checked={adjustMode === "bulk"}
                    onChange={(e) => setAdjustMode(e.target.value as AdjustMode)}
                    className="shrink-0"
                    aria-label="ì „ì²´ ë²”ìœ„ ì¼ê´„ ì¡°ì •"
                  />
                  <div className="flex flex-col gap-1">
                    <div className="font-medium text-gray-900">ì „ì²´ ë²”ìœ„ ì¼ê´„ ì¡°ì •</div>
                    <div className="text-xs text-gray-500">
                      ëª¨ë“  ë¸”ë¡ì— ë™ì¼í•œ ë¹„ìœ¨ë¡œ ë²”ìœ„ ë¶„ë°°
                    </div>
                  </div>
                </label>
                <label className="flex items-start gap-3 cursor-pointer">
                  <input
                    type="radio"
                    name="adjustMode"
                    value="individual"
                    checked={adjustMode === "individual"}
                    onChange={(e) => setAdjustMode(e.target.value as AdjustMode)}
                    className="shrink-0"
                    aria-label="ê°œë³„ ë¸”ë¡ ì¡°ì •"
                  />
                  <div className="flex flex-col gap-1">
                    <div className="font-medium text-gray-900">ê°œë³„ ë¸”ë¡ ì¡°ì •</div>
                    <div className="text-xs text-gray-500">
                      ê° ë¸”ë¡ì˜ ë²”ìœ„ë¥¼ ê°œë³„ì ìœ¼ë¡œ ì¡°ì •
                    </div>
                  </div>
                </label>
              </div>
            </div>

            {/* ìƒˆ ë²”ìœ„ ì…ë ¥ */}
            {adjustMode === "bulk" && (
              <div className="rounded-lg border border-gray-200 bg-white p-4 flex flex-col gap-4">
                <h3 className="text-sm font-semibold text-gray-900">ìƒˆ ë²”ìœ„ ì…ë ¥</h3>
                <div className="grid grid-cols-2 gap-4">
                  <div className="flex flex-col gap-1">
                    <label className="block text-xs font-medium text-gray-700">
                      ì „ì²´ ì‹œì‘ ({unit})
                    </label>
                  <input
                    type="number"
                    value={bulkStart}
                    onChange={(e) => setBulkStart(Number(e.target.value))}
                    min={0}
                    max={totalPages}
                    className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                  />
                  </div>
                  <div className="flex flex-col gap-1">
                    <label className="block text-xs font-medium text-gray-700">
                      ì „ì²´ ì¢…ë£Œ ({unit})
                    </label>
                  <input
                    type="number"
                    value={bulkEnd}
                    onChange={(e) => setBulkEnd(Number(e.target.value))}
                    min={bulkStart + 1}
                    max={totalPages}
                    className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm text-gray-900 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                  />
                  </div>
                </div>
                <button
                  onClick={handleBulkAdjust}
                  className="w-full rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-indigo-700"
                  aria-label="ë²”ìœ„ ì ìš©"
                >
                  ë²”ìœ„ ì ìš©
                </button>

                {/* ë¹ ë¥¸ ì¡°ì • */}
                <div className="pt-4 border-t border-gray-200 flex flex-col gap-2">
                  <p className="text-xs font-medium text-gray-700">ë¹ ë¥¸ ì¡°ì •</p>
                <div className="flex gap-2">
                  <button
                    onClick={() => handleQuickAdjust(-10)}
                    className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-xs font-medium text-gray-700 transition hover:bg-gray-50"
                    aria-label={`10${unit} ì•ìœ¼ë¡œ ì´ë™`}
                  >
                    <ChevronLeft className="h-4 w-4" />
                    10{unit} ì•ìœ¼ë¡œ
                  </button>
                  <button
                    onClick={() => handleQuickAdjust(-5)}
                    className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-xs font-medium text-gray-700 transition hover:bg-gray-50"
                    aria-label={`5${unit} ì•ìœ¼ë¡œ ì´ë™`}
                  >
                    <ChevronLeft className="h-4 w-4" />
                    5{unit} ì•ìœ¼ë¡œ
                  </button>
                  <button
                    onClick={() => handleQuickAdjust(5)}
                    className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-xs font-medium text-gray-700 transition hover:bg-gray-50"
                    aria-label={`5${unit} ë’¤ë¡œ ì´ë™`}
                  >
                    5{unit} ë’¤ë¡œ
                    <ChevronRight className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => handleQuickAdjust(10)}
                    className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-xs font-medium text-gray-700 transition hover:bg-gray-50"
                    aria-label={`10${unit} ë’¤ë¡œ ì´ë™`}
                  >
                    10{unit} ë’¤ë¡œ
                    <ChevronRight className="h-4 w-4" />
                  </button>
                </div>
              </div>
            </div>
          )}

          {adjustMode === "individual" && (
            <div className="rounded-lg border border-gray-200 bg-white p-4 flex flex-col gap-4">
              <h3 className="text-sm font-semibold text-gray-900">ê°œë³„ ë¸”ë¡ ë²”ìœ„</h3>
              <div className="flex flex-col gap-3">
                {ranges.map((range, index) => (
                  <div key={range.planId} className="rounded-lg border border-gray-200 bg-gray-50 p-3 flex flex-col gap-2">
                    <div className="text-sm font-medium text-gray-900">
                      ë¸”ë¡ {range.blockIndex}
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                      <div className="flex flex-col gap-1">
                        <label className="block text-xs font-medium text-gray-700">
                          ì‹œì‘ ({unit})
                        </label>
                        <input
                          type="number"
                          value={range.startPageOrTime}
                          onChange={(e) =>
                            handleIndividualRangeChange(
                              index,
                              "startPageOrTime",
                              Number(e.target.value)
                            )
                          }
                          min={0}
                          max={totalPages}
                          className="w-full rounded-lg border border-gray-300 px-3 py-1.5 text-sm text-gray-900 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                        />
                      </div>
                      <div className="flex flex-col gap-1">
                        <label className="block text-xs font-medium text-gray-700">
                          ì¢…ë£Œ ({unit})
                        </label>
                        <input
                          type="number"
                          value={range.endPageOrTime}
                          onChange={(e) =>
                            handleIndividualRangeChange(
                              index,
                              "endPageOrTime",
                              Number(e.target.value)
                            )
                          }
                          min={range.startPageOrTime + 1}
                          max={totalPages}
                          className="w-full rounded-lg border border-gray-300 px-3 py-1.5 text-sm text-gray-900 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
                        />
                      </div>
                    </div>
                    <div className="text-xs text-gray-600">
                      ë²”ìœ„: {range.endPageOrTime - range.startPageOrTime} {unit}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

            {/* ë¯¸ë¦¬ë³´ê¸° */}
            <div className="rounded-lg border border-gray-200 bg-blue-50 p-4 flex flex-col gap-3">
              <h3 className="text-sm font-semibold text-gray-900">ë¯¸ë¦¬ë³´ê¸°</h3>
              <div className="flex flex-col gap-2">
                {ranges.map((range, index) => (
                  <div key={range.planId} className="text-sm text-gray-700">
                    ë¸”ë¡ {range.blockIndex}: {range.startPageOrTime} ~ {range.endPageOrTime} {unit} (
                    {range.endPageOrTime - range.startPageOrTime} {unit})
                  </div>
                ))}
              </div>
              <button
                onClick={handleRestore}
                className="flex items-center gap-1 text-xs font-medium text-gray-600 transition hover:text-gray-900"
                aria-label="ì›ë˜ëŒ€ë¡œ ë˜ëŒë¦¬ê¸°"
              >
                <RotateCcw className="h-3 w-3" />
                ì›ë˜ëŒ€ë¡œ ë˜ëŒë¦¬ê¸°
              </button>
            </div>

            {/* ì£¼ì˜ì‚¬í•­ */}
            <div className="rounded-lg border border-amber-200 bg-amber-50 p-4 flex flex-col gap-2">
              <h3 className="flex items-center gap-2 text-sm font-semibold text-amber-900">
                âš ï¸ ì£¼ì˜ì‚¬í•­
              </h3>
              <ul className="flex flex-col gap-1 text-xs text-amber-800">
                <li>â€¢ ë²”ìœ„ ì¡°ì • ì‹œ ì§„í–‰ ì¤‘ì¸ í”Œëœì€ ì¼ì‹œì •ì§€ë©ë‹ˆë‹¤.</li>
                <li>â€¢ ê¸°ì¡´ ì§„í–‰ë¥ ì€ ìœ ì§€ë©ë‹ˆë‹¤.</li>
                <li>â€¢ ì¡°ì • í›„ í•™ìŠµ ì‹œê°„ì´ ì¬ê³„ì‚°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                <li>â€¢ ë¸”ë¡ ê°„ ë²”ìœ„ê°€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ í•´ì£¼ì„¸ìš”.</li>
              </ul>
            </div>
          </div>
        </div>
      </DialogContent>
      <DialogFooter>
        <button
          onClick={onClose}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
        >
          ì·¨ì†Œ
        </button>
        <button
          onClick={handleSave}
          disabled={isSaving}
          className="flex items-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-indigo-700 disabled:opacity-50"
          aria-label="ë²”ìœ„ ì¡°ì • ì ìš©"
        >
          <Save className="h-4 w-4" />
          ì ìš©
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="_components/PlanSelector.tsx">
"use client";

import { ChevronLeft, ChevronRight } from "lucide-react";
import { PlanGroup } from "../_utils/planGroupUtils";
import { formatTime, calculateGroupTotalStudyTime, getActivePlansCount, getCompletedPlansCount } from "../_utils/planGroupUtils";
import { cn } from "@/lib/cn";

type PlanSelectorProps = {
  groups: PlanGroup[];
  selectedPlanNumber: number | null;
  onSelect: (planNumber: number | null) => void;
  sessions: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>;
};

export function PlanSelector({
  groups,
  selectedPlanNumber,
  onSelect,
  sessions,
}: PlanSelectorProps) {
  const currentIndex = groups.findIndex(
    (g) => g.planNumber === selectedPlanNumber
  );
  const currentGroup = groups[currentIndex];

  const handlePrevious = () => {
    if (currentIndex > 0) {
      onSelect(groups[currentIndex - 1].planNumber);
    }
  };

  const handleNext = () => {
    if (currentIndex < groups.length - 1) {
      onSelect(groups[currentIndex + 1].planNumber);
    }
  };

  const getGroupStatus = (group: PlanGroup): string => {
    const activeCount = getActivePlansCount(group, sessions);
    const completedCount = getCompletedPlansCount(group);
    const totalStudyTime = calculateGroupTotalStudyTime(group, sessions);

    if (activeCount > 0) {
      return `ì§„í–‰ ì¤‘ | â± ${formatTime(totalStudyTime)}`;
    }
    if (completedCount === 1) {
      return `ì™„ë£Œ | â± ${formatTime(totalStudyTime)}`;
    }
    return `ëŒ€ê¸° ì¤‘`;
  };

  if (groups.length === 0) {
    return null;
  }

  return (
    <div className="flex items-center gap-4">
      <button
        onClick={handlePrevious}
        disabled={currentIndex === 0}
        className={cn(
          "flex items-center justify-center rounded-lg border border-gray-300 p-2 transition",
          currentIndex === 0
            ? "cursor-not-allowed bg-gray-100 text-gray-400"
            : "bg-white text-gray-700 hover:bg-gray-50"
        )}
      >
        <ChevronLeft className="h-5 w-5" />
      </button>

      <div className="flex-1">
        <select
          value={selectedPlanNumber ?? ""}
          onChange={(e) => {
            const value = e.target.value;
            onSelect(value === "" ? null : Number(value));
          }}
          className="w-full rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-900 shadow-sm transition focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
        >
          {groups.map((group) => {
            const contentTitle = group.content?.title || "ì œëª© ì—†ìŒ";
            const sequence = group.sequence
              ? `${group.sequence}íšŒì°¨`
              : `${group.plan.sequence || 1}íšŒì°¨`;
            const status = getGroupStatus(group);

            return (
              <option key={group.planNumber ?? "null"} value={group.planNumber ?? ""}>
                {contentTitle} ({sequence}) - {status}
              </option>
            );
          })}
        </select>
      </div>

      <button
        onClick={handleNext}
        disabled={currentIndex === groups.length - 1}
        className={cn(
          "flex items-center justify-center rounded-lg border border-gray-300 p-2 transition",
          currentIndex === groups.length - 1
            ? "cursor-not-allowed bg-gray-100 text-gray-400"
            : "bg-white text-gray-700 hover:bg-gray-50"
        )}
      >
        <ChevronRight className="h-5 w-5" />
      </button>

      {currentGroup && (
        <div className="text-xs text-gray-500">
          {currentIndex + 1} / {groups.length}
        </div>
      )}
    </div>
  );
}
</file>

<file path="_components/PlanTimeline.tsx">
"use client";

import { cn } from "@/lib/cn";
import { CheckCircle, Circle, Clock } from "lucide-react";
import { formatTime } from "../_utils/planGroupUtils";

type TimelineItem = {
  id: string;
  title: string;
  subtitle?: string;
  startTime?: string;
  endTime?: string;
  duration?: number;
  status: "completed" | "in_progress" | "pending";
};

type PlanTimelineProps = {
  items: TimelineItem[];
  className?: string;
};

export function PlanTimeline({ items, className }: PlanTimelineProps) {
  if (items.length === 0) {
    return null;
  }

  return (
    <div className={cn("relative flex flex-col gap-6", className)}>
      {/* ì„¸ë¡œ ì—°ê²°ì„  */}
      <div className="absolute left-[15px] top-8 bottom-8 w-0.5 bg-gradient-to-b from-indigo-200 via-gray-200 to-gray-100" aria-hidden="true" />

      {items.map((item, index) => {
        const isCompleted = item.status === "completed";
        const isInProgress = item.status === "in_progress";
        const isPending = item.status === "pending";

        return (
          <div key={item.id} className="relative flex gap-4">
            {/* íƒ€ì„ë¼ì¸ ë§ˆì»¤ */}
            <div
              className={cn(
                "relative z-10 flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-full border-2 bg-white transition-all",
                isCompleted && "border-green-500 bg-green-50",
                isInProgress && "border-indigo-600 bg-indigo-50 shadow-lg shadow-indigo-200",
                isPending && "border-gray-300 bg-gray-50"
              )}
              aria-label={
                isCompleted ? "ì™„ë£Œë¨" : isInProgress ? "ì§„í–‰ ì¤‘" : "ëŒ€ê¸° ì¤‘"
              }
            >
              {isCompleted && (
                <CheckCircle className="h-4 w-4 text-green-600" aria-hidden="true" />
              )}
              {isInProgress && (
                <Clock className="h-4 w-4 text-indigo-600 animate-pulse" aria-hidden="true" />
              )}
              {isPending && (
                <Circle className="h-3 w-3 text-gray-400" aria-hidden="true" />
              )}
            </div>

            {/* ì½˜í…ì¸  ì¹´ë“œ */}
            <div
              className={cn(
                "flex flex-1 flex-col gap-2 rounded-lg border p-4 transition-all",
                isCompleted && "border-green-200 bg-green-50/50",
                isInProgress && "border-indigo-300 bg-indigo-50 shadow-md",
                isPending && "border-gray-200 bg-white"
              )}
            >
              {/* ì œëª© ì˜ì—­ */}
              <div className="flex items-start justify-between">
                <div className="flex flex-col gap-1">
                  <h3
                    className={cn(
                      "text-sm font-semibold",
                      isCompleted && "text-green-900",
                      isInProgress && "text-indigo-900",
                      isPending && "text-gray-900"
                    )}
                  >
                    {item.title}
                  </h3>
                  {item.subtitle && (
                    <p
                      className={cn(
                        "text-xs",
                        isCompleted && "text-green-700",
                        isInProgress && "text-indigo-700",
                        isPending && "text-gray-600"
                      )}
                    >
                      {item.subtitle}
                    </p>
                  )}
                </div>

                {/* ìƒíƒœ ë±ƒì§€ */}
                <span
                  className={cn(
                    "rounded-full px-2 py-0.5 text-xs font-medium",
                    isCompleted && "bg-green-100 text-green-700",
                    isInProgress && "bg-indigo-100 text-indigo-700",
                    isPending && "bg-gray-100 text-gray-600"
                  )}
                >
                  {isCompleted && "ì™„ë£Œ"}
                  {isInProgress && "ì§„í–‰ ì¤‘"}
                  {isPending && "ëŒ€ê¸°"}
                </span>
              </div>

              {/* ì‹œê°„ ì •ë³´ */}
              {(item.startTime || item.endTime || item.duration !== undefined) && (
                <div className="flex flex-wrap items-center gap-3 text-xs">
                  {item.startTime && (
                    <div className="flex items-center gap-1 text-gray-600">
                      <span className="font-medium">ì‹œì‘:</span>
                      <span>{new Date(item.startTime).toLocaleTimeString('ko-KR', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                      })}</span>
                    </div>
                  )}
                  {item.endTime && (
                    <div className="flex items-center gap-1 text-gray-600">
                      <span className="font-medium">ì¢…ë£Œ:</span>
                      <span>{new Date(item.endTime).toLocaleTimeString('ko-KR', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                      })}</span>
                    </div>
                  )}
                  {item.duration !== undefined && (
                    <div
                      className={cn(
                        "ml-auto flex items-center gap-1 font-semibold",
                        isCompleted && "text-green-700",
                        isInProgress && "text-indigo-700",
                        isPending && "text-gray-600"
                      )}
                    >
                      <Clock className="h-3 w-3" aria-hidden="true" />
                      <span>{formatTime(item.duration)}</span>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="_components/PlanTimer.tsx">
"use client";

import { formatTime, TimeStats, formatTimestamp } from "../_utils/planGroupUtils";
import { usePlanTimer } from "@/lib/hooks/usePlanTimer";
import type { TimerStatus } from "@/lib/store/planTimerStore";
import { TimerDisplay } from "./timer/TimerDisplay";
import { TimerControls } from "./timer/TimerControls";

type PendingAction = "start" | "pause" | "resume" | "complete" | null;

type PlanTimerProps = {
  planId: string;
  timeStats: TimeStats;
  isPaused: boolean;
  isActive: boolean;
  isLoading: boolean;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onComplete: () => void;
  onPostpone?: () => void;
  canPostpone?: boolean;
  pendingAction?: PendingAction;
  compact?: boolean;
  status: TimerStatus;
  accumulatedSeconds: number;
  startedAt: string | null;
  serverNow: number;
};

export function PlanTimer({
  planId,
  timeStats,
  isLoading,
  onStart,
  onPause,
  onResume,
  onComplete,
  onPostpone,
  canPostpone = false,
  pendingAction = null,
  compact = false,
  status,
  accumulatedSeconds,
  startedAt,
  serverNow,
}: PlanTimerProps) {
  // ìƒˆë¡œìš´ ìŠ¤í† ì–´ ê¸°ë°˜ íƒ€ì´ë¨¸ í›… ì‚¬ìš©
  const { seconds, status: timerStatus } = usePlanTimer({
    planId,
    status,
    accumulatedSeconds,
    startedAt,
    serverNow,
    isCompleted: timeStats.isCompleted,
  });

  const formattedStartTime = timeStats.firstStartTime
    ? formatTimestamp(timeStats.firstStartTime)
    : "-";
  const formattedEndTime = timeStats.lastEndTime
    ? formatTimestamp(timeStats.lastEndTime)
    : "-";
  const formattedPureStudyTime = formatTime(Math.max(0, timeStats.pureStudyTime || 0));

  const isCompleted = timeStats.isCompleted;
  const showTimer = status === "RUNNING" || status === "PAUSED" || status === "COMPLETED";
  const showCompletionMeta = isCompleted && (timeStats.firstStartTime || timeStats.lastEndTime);

  if (compact) {
    return (
      <div className="flex flex-col gap-2">
        {showTimer && (
          <TimerDisplay
            seconds={seconds}
            status={timerStatus}
            subtitle="í•™ìŠµ ì‹œê°„"
            showStatusBadge={true}
            compact={true}
          />
        )}

        {showCompletionMeta && (
          <div className="flex flex-col gap-2 rounded-lg border border-indigo-100 bg-indigo-50 p-3 text-xs text-indigo-900">
            <div className="font-semibold text-indigo-950">í•™ìŠµ ì™„ë£Œ ê¸°ë¡</div>
            <dl className="grid grid-cols-[92px,1fr] gap-1">
              <dt className="text-indigo-700">ì‹œì‘ ì‹œê°„</dt>
              <dd className="text-right font-medium">{formattedStartTime}</dd>
              <dt className="text-indigo-700">ì¢…ë£Œ ì‹œê°„</dt>
              <dd className="text-right font-medium">{formattedEndTime}</dd>
              <dt className="text-indigo-700">ì´ í•™ìŠµ</dt>
              <dd className="text-right font-semibold text-indigo-950">{formattedPureStudyTime}</dd>
            </dl>
          </div>
        )}

        <TimerControls
          status={timerStatus}
          isLoading={isLoading}
          pendingAction={pendingAction}
          onStart={onStart}
          onPause={onPause}
          onResume={onResume}
          onComplete={onComplete}
          onPostpone={onPostpone}
          canPostpone={canPostpone}
          compact={true}
        />

        {timeStats.pauseCount > 0 && showTimer && (
          <div className="text-xs text-gray-500">
            ì¼ì‹œì •ì§€: {timeStats.pauseCount}íšŒ
            {timeStats.pausedDuration > 0 && <span> ({formatTime(timeStats.pausedDuration)})</span>}
          </div>
        )}
      </div>
    );
  }

  // ì „ì²´ ë·°
  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        {showTimer && (
          <TimerDisplay
            seconds={seconds}
            status={timerStatus}
            subtitle="í•™ìŠµ ì‹œê°„"
            showStatusBadge={true}
            compact={false}
          />
        )}

        {showCompletionMeta && (
          <div className="flex flex-col gap-3 rounded-lg border border-indigo-100 bg-indigo-50 p-4">
            <h4 className="text-sm font-semibold text-indigo-900">í•™ìŠµ ì™„ë£Œ ê¸°ë¡</h4>
            <div className="grid gap-3 text-sm text-indigo-950 md:grid-cols-3">
              <div className="flex flex-col gap-1 rounded-md bg-white/60 p-3">
                <span className="text-xs text-indigo-600">ì‹œì‘ ì‹œê°„</span>
                <span className="text-sm font-semibold">{formattedStartTime}</span>
              </div>
              <div className="flex flex-col gap-1 rounded-md bg-white/60 p-3">
                <span className="text-xs text-indigo-600">ì¢…ë£Œ ì‹œê°„</span>
                <span className="text-sm font-semibold">{formattedEndTime}</span>
              </div>
              <div className="flex flex-col gap-1 rounded-md bg-white/60 p-3">
                <span className="text-xs text-indigo-600">ì´ í•™ìŠµ ì‹œê°„ (ì¼ì‹œì •ì§€ ì œì™¸)</span>
                <span className="text-lg font-bold text-indigo-900">{formattedPureStudyTime}</span>
              </div>
            </div>
          </div>
        )}

        {timeStats.pauseCount > 0 && showTimer && (
          <div className="text-xs text-gray-500">
            ì¼ì‹œì •ì§€: {timeStats.pauseCount}íšŒ
            {timeStats.pausedDuration > 0 && <span> ({formatTime(timeStats.pausedDuration)})</span>}
          </div>
        )}

        <TimerControls
          status={timerStatus}
          isLoading={isLoading}
          pendingAction={pendingAction}
          onStart={onStart}
          onPause={onPause}
          onResume={onResume}
          onComplete={onComplete}
          onPostpone={onPostpone}
          canPostpone={canPostpone}
          compact={false}
        />
      </div>
    </div>
  );
}
</file>

<file path="_components/PlanTimerCard.tsx">
"use client";

import { useState, useMemo } from "react";
import { startPlan, pausePlan, resumePlan, preparePlanCompletion } from "../actions/todayActions";
import { useRouter } from "next/navigation";
import { formatTime, formatTimestamp } from "../_utils/planGroupUtils";
import { usePlanTimer } from "@/lib/hooks/usePlanTimer";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import type { TimerStatus } from "@/lib/store/planTimerStore";
import { TimerDisplay } from "./timer/TimerDisplay";
import { TimerControls } from "./timer/TimerControls";
import { useToast } from "@/components/ui/ToastProvider";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";

type PendingAction = "start" | "pause" | "resume" | "complete" | null;

type PlanTimerCardProps = {
  planId: string;
  planTitle: string;
  contentType: "book" | "lecture" | "custom";
  startTime?: string | null;
  endTime?: string | null;
  actualStartTime?: string | null;
  actualEndTime?: string | null;
  totalDurationSeconds?: number | null;
  pausedDurationSeconds?: number | null;
  pauseCount?: number | null;
  activeSessionId?: string | null;
  isPaused?: boolean;
  currentPausedAt?: string | null;
  allowTimerControl?: boolean;
  sessionStartedAt?: string | null;
  sessionPausedDurationSeconds?: number | null;
  serverNow?: number;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

export function PlanTimerCard({
  planId,
  planTitle,
  contentType,
  startTime,
  endTime,
  actualStartTime,
  actualEndTime,
  totalDurationSeconds,
  pausedDurationSeconds,
  pauseCount,
  activeSessionId,
  isPaused: initialIsPaused = false,
  currentPausedAt,
  allowTimerControl = true,
  sessionStartedAt,
  sessionPausedDurationSeconds,
  serverNow = Date.now(),
  campMode = false,
}: PlanTimerCardProps) {
  const router = useRouter();
  const { showError } = useToast();
  const timerStore = usePlanTimerStore();
  const [isLoading, setIsLoading] = useState(false);
  const [pendingAction, setPendingAction] = useState<PendingAction>(null);

  // ì„œë²„ì—ì„œ ê³„ì‚°ëœ ì´ˆê¸° íƒ€ì´ë¨¸ ìƒíƒœ ê³„ì‚°
  const timerState = useMemo(() => {
    // ì™„ë£Œëœ ê²½ìš°
    if (actualEndTime && totalDurationSeconds !== null && totalDurationSeconds !== undefined) {
      return {
        status: "COMPLETED" as TimerStatus,
        accumulatedSeconds: totalDurationSeconds,
        startedAt: null,
      };
    }

    // ì‹œì‘í•˜ì§€ ì•Šì€ ê²½ìš°
    if (!actualStartTime) {
      return {
        status: "NOT_STARTED" as TimerStatus,
        accumulatedSeconds: 0,
        startedAt: null,
      };
    }

    const startMs = new Date(actualStartTime).getTime();
    if (!Number.isFinite(startMs)) {
      return {
        status: "NOT_STARTED" as TimerStatus,
        accumulatedSeconds: 0,
        startedAt: null,
      };
    }

    const now = Date.now();

    // ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš°
    if (initialIsPaused && currentPausedAt) {
      const pausedAtMs = new Date(currentPausedAt).getTime();
      if (Number.isFinite(pausedAtMs)) {
        const elapsedUntilPause = Math.floor((pausedAtMs - startMs) / 1000);
        const sessionPausedDuration = sessionPausedDurationSeconds || 0;
        const planPausedDuration = pausedDurationSeconds || 0;
        const accumulatedSeconds = Math.max(0, elapsedUntilPause - sessionPausedDuration - planPausedDuration);

        return {
          status: "PAUSED" as TimerStatus,
          accumulatedSeconds,
          startedAt: null,
        };
      }
    }

    // ì‹¤í–‰ ì¤‘ì¸ ê²½ìš°
    if (sessionStartedAt) {
      const sessionStartMs = new Date(sessionStartedAt).getTime();
      if (Number.isFinite(sessionStartMs)) {
        const elapsed = Math.floor((now - sessionStartMs) / 1000);
        const sessionPausedDuration = sessionPausedDurationSeconds || 0;
        const planPausedDuration = pausedDurationSeconds || 0;
        const accumulatedSeconds = Math.max(0, elapsed - sessionPausedDuration - planPausedDuration);

        return {
          status: "RUNNING" as TimerStatus,
          accumulatedSeconds,
          startedAt: sessionStartedAt,
        };
      }
    }

    // í™œì„± ì„¸ì…˜ì´ ì—†ì§€ë§Œ í”Œëœì´ ì‹œì‘ëœ ê²½ìš°
    const elapsed = Math.floor((now - startMs) / 1000);
    const pausedDuration = pausedDurationSeconds || 0;
    const accumulatedSeconds = Math.max(0, elapsed - pausedDuration);

    return {
      status: "RUNNING" as TimerStatus,
      accumulatedSeconds,
      startedAt: actualStartTime,
    };
  }, [
    actualStartTime,
    actualEndTime,
    totalDurationSeconds,
    pausedDurationSeconds,
    initialIsPaused,
    currentPausedAt,
    sessionStartedAt,
    sessionPausedDurationSeconds,
  ]);

  // ìƒˆë¡œìš´ ìŠ¤í† ì–´ ê¸°ë°˜ íƒ€ì´ë¨¸ í›… ì‚¬ìš©
  const { seconds, status: timerStatus } = usePlanTimer({
    planId,
    status: timerState.status,
    accumulatedSeconds: timerState.accumulatedSeconds,
    startedAt: timerState.startedAt,
    serverNow,
    isCompleted: !!actualEndTime,
  });

  const formattedStartTime = actualStartTime ? formatTimestamp(actualStartTime) : "-";
  const formattedEndTime = actualEndTime ? formatTimestamp(actualEndTime) : "-";
  const formattedPureStudyTime = formatTime(Math.max(0, seconds));

  const handleStart = async () => {
    setIsLoading(true);
    setPendingAction("start");
    try {
      const timestamp = new Date().toISOString();
      const result = await startPlan(planId, timestamp);
      if (result.success) {
        if (result.serverNow && result.status && result.startedAt) {
          timerStore.startTimer(planId, result.serverNow, result.startedAt);
        }
      } else {
        showError(result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handlePause = async () => {
    if (isLoading || timerStatus === "PAUSED") {
      return;
    }

    setIsLoading(true);
    setPendingAction("pause");
    try {
      const timestamp = new Date().toISOString();
      const result = await pausePlan(planId, timestamp);
      if (result.success) {
        if (result.serverNow && result.accumulatedSeconds !== undefined) {
          timerStore.pauseTimer(planId, result.accumulatedSeconds);
        }
      } else {
        if (result.error && !result.error.includes("ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤")) {
          showError(result.error || "í”Œëœ ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handleResume = async () => {
    setIsLoading(true);
    setPendingAction("resume");
    try {
      const timestamp = new Date().toISOString();
      const result = await resumePlan(planId, timestamp);
      if (result.success) {
        if (result.serverNow && result.status && result.startedAt) {
          timerStore.startTimer(planId, result.serverNow, result.startedAt);
        }
      } else {
        showError(result.error || "í”Œëœ ì¬ê°œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const handleComplete = async () => {
    // í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
    const confirmed = confirm(
      "ì§€ê¸ˆê¹Œì§€ì˜ í•™ìŠµì„ ê¸°ì¤€ìœ¼ë¡œ ì´ í”Œëœì„ ì™„ë£Œ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™í• ê¹Œìš”?"
    );
    
    if (!confirmed) {
      return;
    }

    setIsLoading(true);
    setPendingAction("complete");
    try {
      const result = await preparePlanCompletion(planId);
      
      if (!result.success) {
        showError(result.error || "í”Œëœ ì™„ë£Œ ì¤€ë¹„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      // íƒ€ì´ë¨¸ ì •ì§€ (ìŠ¤í† ì–´ì—ì„œ ì œê±°)
      timerStore.removeTimer(planId);

      // ì™„ë£Œ ì…ë ¥ í˜ì´ì§€ë¡œ ì´ë™
      router.push(buildPlanExecutionUrl(planId, campMode));
    } catch (error) {
      console.error("[PlanTimerCard] ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setPendingAction(null);
      setIsLoading(false);
    }
  };

  const isCompleted = !!actualEndTime;
  const showCompletionMeta = isCompleted && actualStartTime && actualEndTime;
  const showTimer = timerStatus === "RUNNING" || timerStatus === "PAUSED" || timerStatus === "COMPLETED";

  if (!allowTimerControl && timerStatus === "NOT_STARTED") {
    return (
      <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
        <div className="flex flex-col gap-1">
          <h3 className="font-semibold text-gray-900">{planTitle}</h3>
          <p className="text-xs text-gray-500">
            ì´ ë¸”ë¡ì€ ê°™ì€ í”Œëœ ë²ˆí˜¸ì˜ ëŒ€í‘œ íƒ€ì´ë¨¸ ì¹´ë“œì—ì„œ ì œì–´ë©ë‹ˆë‹¤.
          </p>
        </div>
        <button
          onClick={() => router.push(buildPlanExecutionUrl(planId, campMode))}
          className="w-full rounded-lg bg-gray-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-gray-700"
        >
          ìƒì„¸ë³´ê¸°
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
      <div className="flex flex-col gap-1">
        <h3 className="font-semibold text-gray-900">{planTitle}</h3>
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <span className="text-xs">
            {contentType === "book" ? "ğŸ“š" : contentType === "lecture" ? "ğŸ§" : "ğŸ“"}
          </span>
          {startTime && endTime && (
            <span>
              {startTime} ~ {endTime}
            </span>
          )}
        </div>
      </div>

      {showTimer && (
        <div className="flex flex-col gap-2">
          <TimerDisplay
            seconds={seconds}
            status={timerStatus}
            subtitle="í•™ìŠµ ì‹œê°„"
            showStatusBadge={true}
            compact={true}
          />
          {pauseCount != null && pauseCount > 0 && (
            <div className="text-xs text-gray-500">
              ì¼ì‹œì •ì§€: {pauseCount}íšŒ
              {pausedDurationSeconds != null && pausedDurationSeconds > 0 && (
                <span> ({formatTime(pausedDurationSeconds)})</span>
              )}
            </div>
          )}
        </div>
      )}

      {showCompletionMeta && (
        <div className="flex flex-col gap-2 rounded-lg border border-indigo-100 bg-indigo-50 p-3 text-xs text-indigo-900">
          <div className="font-semibold text-indigo-950">í•™ìŠµ ì™„ë£Œ ê¸°ë¡</div>
          <dl className="grid grid-cols-[92px,1fr] gap-1">
            <dt className="text-indigo-700">ì‹œì‘ ì‹œê°„</dt>
            <dd className="text-right font-medium">{formattedStartTime}</dd>
            <dt className="text-indigo-700">ì¢…ë£Œ ì‹œê°„</dt>
            <dd className="text-right font-medium">{formattedEndTime}</dd>
            <dt className="text-indigo-700">ì´ í•™ìŠµ</dt>
            <dd className="text-right font-semibold text-indigo-950">{formattedPureStudyTime}</dd>
          </dl>
        </div>
      )}

      <TimerControls
        status={timerStatus}
        isLoading={isLoading}
        pendingAction={pendingAction}
        onStart={handleStart}
        onPause={handlePause}
        onResume={handleResume}
        onComplete={handleComplete}
        compact={true}
      />

      {isCompleted && (
        <button
          onClick={() => router.push(buildPlanExecutionUrl(planId, campMode))}
          className="w-full rounded-lg bg-gray-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-gray-700"
        >
          ìƒì„¸ë³´ê¸°
        </button>
      )}
    </div>
  );
}
</file>

<file path="_components/PlanViewContainer.tsx">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { SinglePlanView } from "./SinglePlanView";
import { DailyPlanListView } from "./DailyPlanListView";
import { ViewModeSelector } from "./ViewModeSelector";
import { PlanDateNavigator } from "./PlanDateNavigator";
import { usePlanRealtimeUpdates } from "@/lib/realtime/usePlanRealtimeUpdates";
import {
  groupPlansByPlanNumber,
  PlanGroup,
  PlanWithContent,
} from "../_utils/planGroupUtils";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";
import {
  formatKoreanDateWithDay,
  getRelativeDateLabel,
  getTodayISODate,
} from "../_utils/dateDisplay";

export type ViewMode = "single" | "daily";

type PlanViewContainerProps = {
  initialMode?: ViewMode;
  initialSelectedPlanNumber?: number | null;
  initialPlanDate?: string | null;
  onDateChange?: (date: string, options?: { isToday: boolean; todayProgress?: PlansResponse["todayProgress"] }) => void;
  userId?: string;
  campMode?: boolean;
  /**
   * If provided, initializes state from this data and skips the client-side fetch.
   * This is used to avoid double-fetch on pages like /camp/today where the data
   * is already fetched on the server side.
   */
  initialData?: PlansResponse;
};

type SessionState = {
  isPaused: boolean;
  startedAt?: string | null;
  pausedAt?: string | null;
  resumedAt?: string | null;
  pausedDurationSeconds?: number | null;
};

type PlansResponse = {
  plans: PlanWithContent[];
  sessions: Record<string, SessionState>;
  planDate: string;
  isToday?: boolean;
  serverNow?: number;
  /**
   * Today progress summary (from /api/today/plans).
   * If provided, TodayPageContent can skip calling /api/today/progress separately.
   */
  todayProgress?: import("@/lib/metrics/todayProgress").TodayProgress | null;
};

const SESSION_REFRESH_INTERVAL_MS = 30000;

function shiftIsoDate(baseDate: string, delta: number): string | null {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(baseDate)) {
    return null;
  }

  const [year, month, day] = baseDate.split("-").map(Number);
  if (
    [year, month, day].some(
      (value) => typeof value !== "number" || Number.isNaN(value)
    )
  ) {
    return null;
  }

  const date = new Date(year, (month ?? 1) - 1, day ?? 1);
  if (Number.isNaN(date.getTime())) {
    return null;
  }

  date.setDate(date.getDate() + delta);

  const formattedMonth = String(date.getMonth() + 1).padStart(2, "0");
  const formattedDay = String(date.getDate()).padStart(2, "0");

  return `${date.getFullYear()}-${formattedMonth}-${formattedDay}`;
}

export function PlanViewContainer({
  initialMode = "daily",
  initialSelectedPlanNumber = null,
  initialPlanDate = null,
  onDateChange,
  userId,
  campMode = false,
  initialData,
}: PlanViewContainerProps) {
  const [viewMode, setViewMode] = useState<ViewMode>(initialMode);
  const [selectedPlanNumber, setSelectedPlanNumber] = useState<number | null>(
    initialSelectedPlanNumber
  );

  // If initialData is provided, initialize state from it to avoid double-fetch
  const [groups, setGroups] = useState<PlanGroup[]>(() => {
    if (initialData) {
      return groupPlansByPlanNumber(initialData.plans);
    }
    return [];
  });
  const [sessions, setSessions] = useState<Map<string, SessionState>>(() => {
    if (initialData) {
      const sessionEntries = Object.entries(initialData.sessions || {}) as [
        string,
        SessionState,
      ][];
      return new Map(sessionEntries);
    }
    return new Map();
  });
  const [planDate, setPlanDate] = useState<string>(() => {
    if (initialData) {
      return initialData.planDate || "";
    }
    return "";
  });
  const [isToday, setIsToday] = useState(() => {
    if (initialData) {
      return Boolean(initialData.isToday);
    }
    return true;
  });
  const [loading, setLoading] = useState(!initialData);
  const [isNavigating, setIsNavigating] = useState(false);
  const [serverNow, setServerNow] = useState<number>(() => {
    if (initialData?.serverNow) {
      return initialData.serverNow;
    }
    return Date.now();
  });

  const queryDateRef = useRef<string | null>(null);

  // Realtime êµ¬ë… ì„¤ì • (30ì´ˆ í´ë§ ëŒ€ì²´)
  usePlanRealtimeUpdates({
    planDate: planDate || getTodayISODate(),
    userId: userId || "",
    enabled: Boolean(userId && planDate),
  });

  const loadData = useCallback(
    async (date?: string, options?: { silent?: boolean }) => {
      const targetDate = date ?? queryDateRef.current;
      queryDateRef.current = targetDate ?? null;

      if (!options?.silent) {
        setLoading(true);
      }

      try {
        const queryParams = new URLSearchParams();
        if (targetDate) {
          queryParams.set("date", targetDate);
        }
        if (campMode) {
          queryParams.set("camp", "true");
        }
        // Include progress data to avoid separate /api/today/progress call
        queryParams.set("includeProgress", "true");
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await fetch(`/api/today/plans${query}`, {
          cache: "no-store",
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          let errorMessage = "í”Œëœ ì¡°íšŒ ì‹¤íŒ¨";
          try {
            const errorJson = JSON.parse(errorText);
            errorMessage = errorJson.error?.message || errorMessage;
          } catch {
            // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì›ë³¸ í…ìŠ¤íŠ¸ ì‚¬ìš©
            if (errorText) {
              errorMessage = `${errorMessage}: ${errorText.substring(0, 100)}`;
            }
          }
          console.error("[PlanViewContainer] API ì—ëŸ¬:", {
            status: response.status,
            statusText: response.statusText,
            error: errorText,
          });
          throw new Error(errorMessage);
        }

        const responseData = await response.json();
        // API ì‘ë‹µì´ { success: true, data: { plans, sessions, ... } } í˜•ì‹ì¸ì§€ í™•ì¸
        const data = (responseData.success && responseData.data 
          ? responseData.data 
          : responseData) as PlansResponse;
        const grouped = groupPlansByPlanNumber(data?.plans);

        setGroups(grouped);
        const sessionEntries = Object.entries(data?.sessions || {}) as [
          string,
          SessionState,
        ][];
        setSessions(new Map(sessionEntries));
        const resolvedDate = data?.planDate || targetDate || "";
        setPlanDate(resolvedDate);
        queryDateRef.current = resolvedDate || null;
        const resolvedIsToday = Boolean(data?.isToday);
        setIsToday(resolvedIsToday);
        
        // serverNow ì €ì¥
        if (data?.serverNow) {
          setServerNow(data.serverNow);
        }
        
        if (resolvedDate) {
          // Pass todayProgress if available to avoid separate /api/today/progress call
          onDateChange?.(resolvedDate, { 
            isToday: resolvedIsToday,
            todayProgress: data?.todayProgress,
          });
        }
        setSelectedPlanNumber((prev) => {
          if (grouped.length === 0) {
            return null;
          }
          if (prev != null && grouped.some((g) => g.planNumber === prev)) {
            return prev;
          }
          return grouped[0]?.planNumber ?? null;
        });
      } catch (error) {
        console.error("[PlanViewContainer] ë°ì´í„° ë¡œë”© ì‹¤íŒ¨", error);
      } finally {
        if (!options?.silent) {
          setLoading(false);
        }
        setIsNavigating(false);
      }
    },
    [onDateChange]
  );

  useEffect(() => {
    // If initialData is provided, use it and skip client-side fetch
    // This avoids double-fetch on pages like /camp/today where data is already fetched on the server
    if (initialData) {
      const grouped = groupPlansByPlanNumber(initialData.plans);
      setGroups(grouped);
      setSessions(new Map(Object.entries(initialData.sessions || {})));
      setPlanDate(initialData.planDate || "");
      setIsToday(Boolean(initialData.isToday));
      setServerNow(initialData.serverNow || Date.now());
      setLoading(false); // Data is already loaded
      queryDateRef.current = initialData.planDate || null;
      if (initialData.planDate) {
        // Pass todayProgress from initialData to avoid separate /api/today/progress call
        onDateChange?.(initialData.planDate, { 
          isToday: Boolean(initialData.isToday),
          todayProgress: initialData.todayProgress,
        });
      }
      setSelectedPlanNumber((prev) => {
        if (grouped.length === 0) return null;
        if (prev != null && grouped.some((g) => g.planNumber === prev)) return prev;
        return grouped[0]?.planNumber ?? null;
      });
      return;
    }

    // Otherwise, fetch data as usual
    if (initialPlanDate) {
      queryDateRef.current = initialPlanDate;
      loadData(initialPlanDate);
    } else {
      loadData();
    }
    // Realtime êµ¬ë…ìœ¼ë¡œ ëŒ€ì²´í•˜ì—¬ í´ë§ ì œê±°
  }, [initialPlanDate, loadData, initialData, onDateChange]);

  const handleViewDetail = (planNumber: number | null) => {
    setSelectedPlanNumber(planNumber);
    setViewMode("single");
  };

  const handleModeChange = (mode: ViewMode) => {
    setViewMode(mode);
    if (mode === "single" && !selectedPlanNumber && groups.length > 0) {
      setSelectedPlanNumber(groups[0]?.planNumber ?? null);
    }
  };

  const handleMoveDay = (delta: number) => {
    const baseDate =
      planDate || queryDateRef.current || getTodayISODate();
    const nextDate = shiftIsoDate(baseDate, delta);
    if (!nextDate) return;

    setIsNavigating(true);
    loadData(nextDate);
  };

  const handleResetToToday = () => {
    const today = getTodayISODate();
    setIsNavigating(true);
    loadData(today);
  };

  if (loading && groups.length === 0) {
    return (
      <div className="flex items-center justify-center p-8">
        <SuspenseFallback />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <PlanDateNavigator
        planDate={planDate}
        isToday={isToday}
        isLoading={loading}
        isNavigating={isNavigating}
        onMoveDay={handleMoveDay}
        onResetToToday={handleResetToToday}
      />

      {!isToday && planDate && (
        <div className="rounded-xl border border-amber-200 bg-amber-50 p-4">
          <div className="flex flex-col gap-1">
            <p className="text-sm font-semibold text-amber-900">
              {getRelativeDateLabel(planDate)}ì˜ í”Œëœì„ ë³´ê³  ìˆìŠµë‹ˆë‹¤
            </p>
            <p className="text-xs text-amber-700">
              {formatKoreanDateWithDay(planDate)}
            </p>
          </div>
        </div>
      )}

      <div className="flex items-center justify-end">
        <ViewModeSelector mode={viewMode} onChange={handleModeChange} />
      </div>

      {viewMode === "daily" ? (
        <DailyPlanListView
          groups={groups}
          sessions={sessions}
          planDate={planDate}
          onViewDetail={handleViewDetail}
          serverNow={serverNow}
          campMode={campMode}
        />
      ) : (
        <SinglePlanView
          groups={groups}
          sessions={sessions}
          planDate={planDate}
          selectedPlanNumber={selectedPlanNumber}
          onSelectPlan={setSelectedPlanNumber}
          serverNow={serverNow}
          campMode={campMode}
        />
      )}
    </div>
  );
}
</file>

<file path="_components/SinglePlanView.tsx">
"use client";

import { PlanCard } from "./PlanCard";
import { PlanSelector } from "./PlanSelector";
import { PlanGroup } from "../_utils/planGroupUtils";
import { formatKoreanDateWithDay } from "../_utils/dateDisplay";

type SinglePlanViewProps = {
  groups: PlanGroup[];
  sessions: Map<
    string,
    { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }
  >;
  planDate: string;
  selectedPlanNumber: number | null;
  onSelectPlan: (planNumber: number | null) => void;
  serverNow?: number;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

export function SinglePlanView({
  groups,
  sessions,
  planDate,
  selectedPlanNumber,
  onSelectPlan,
  serverNow = Date.now(),
  campMode = false,
}: SinglePlanViewProps) {
  const selectedGroup =
    groups.find((g) => g.planNumber === selectedPlanNumber) || groups[0];

  if (!selectedGroup) {
    const formattedDate = planDate
      ? formatKoreanDateWithDay(planDate)
      : "ì„ íƒí•œ ë‚ ì§œ";
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
        <div className="mx-auto flex max-w-md flex-col gap-4">
          <div className="text-6xl">ğŸ“š</div>
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-gray-900">
              ì„ íƒí•œ ë‚ ì§œì˜ ë‹¨ì¼ í”Œëœì´ ì—†ìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-gray-500">
              {formattedDate}ì—ëŠ” í•™ìŠµ í”Œëœì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-4">
      <PlanSelector
        groups={groups}
        selectedPlanNumber={selectedPlanNumber ?? groups[0]?.planNumber ?? null}
        onSelect={onSelectPlan}
        sessions={sessions}
      />
      <PlanCard
        group={selectedGroup}
        sessions={sessions}
        planDate={planDate}
        viewMode="single"
        serverNow={serverNow}
        campMode={campMode}
      />
    </div>
  );
}
</file>

<file path="_components/TimeCheckSection.tsx">
"use client";

import { useState, useTransition, useMemo, memo } from "react";
import { Clock, CheckCircle, RotateCcw } from "lucide-react";
import { formatTimestamp, type TimeStats } from "../_utils/planGroupUtils";
import { TimerControlButtons } from "./TimerControlButtons";

type TimeCheckSectionProps = {
  timeStats: TimeStats;
  isPaused: boolean;
  activePlanStartTime?: string | null; // í™œì„± í”Œëœì˜ ì‹œì‘ ì‹œê°„ (ì‹¤ì‹œê°„ ê³„ì‚°ìš©)
  planId: string; // íƒ€ì´ë¨¸ ì»¨íŠ¸ë¡¤ìš© í”Œëœ ID
  isActive: boolean; // ì§„í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€
  isLoading?: boolean; // ë¡œë”© ìƒíƒœ
  hasOtherActivePlan?: boolean; // ë‹¤ë¥¸ í”Œëœì˜ íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€
  planNumber: number | null; // í”Œëœ ê·¸ë£¹ ë²ˆí˜¸ (ì´ˆê¸°í™”ìš©)
  planDate: string; // í”Œëœ ë‚ ì§œ (ì´ˆê¸°í™”ìš©)
  onStart: (timestamp?: string) => void; // ì‹œì‘ í•¸ë“¤ëŸ¬ (íƒ€ì„ìŠ¤íƒ¬í”„ ì „ë‹¬)
  onPause: (timestamp?: string) => void; // ì¼ì‹œì •ì§€ í•¸ë“¤ëŸ¬ (íƒ€ì„ìŠ¤íƒ¬í”„ ì „ë‹¬)
  onResume: (timestamp?: string) => void; // ì¬ê°œ í•¸ë“¤ëŸ¬ (íƒ€ì„ìŠ¤íƒ¬í”„ ì „ë‹¬)
  onComplete: () => void; // ì™„ë£Œ í•¸ë“¤ëŸ¬
  onReset?: () => void; // ì´ˆê¸°í™” í•¸ë“¤ëŸ¬
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

function TimeCheckSectionComponent({
  timeStats,
  isPaused,
  activePlanStartTime,
  planId,
  isActive,
  isLoading = false,
  planNumber,
  planDate,
  hasOtherActivePlan = false,
  onStart,
  onPause,
  onResume,
  onComplete,
  onReset,
  campMode = false,
}: TimeCheckSectionProps) {
  const [isPending, startTransition] = useTransition();
  
  // Optimistic ìƒíƒœ ì œê±° - ì„œë²„ ìƒíƒœë§Œ ì‚¬ìš© (ë” ì˜ˆì¸¡ ê°€ëŠ¥í•œ UX)
  // Optimistic íƒ€ì„ìŠ¤íƒ¬í”„ ê´€ë¦¬ (ë²„íŠ¼ í´ë¦­ ì‹œ ì¦‰ì‹œ í‘œì‹œ, ì—¬ëŸ¬ ë²ˆ ëˆ„ì )
  const [optimisticTimestamps, setOptimisticTimestamps] = useState<{
    start?: string;
    pauses?: string[]; // ì¼ì‹œì •ì§€ íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´
    resumes?: string[]; // ì¬ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´
  }>({});

  // activePlanStartTimeì„ ì •ê·œí™” (null ë˜ëŠ” ë¬¸ìì—´ë¡œ í†µì¼)
  const normalizedStartTime = activePlanStartTime ?? null;
  
  // ì„œë²„ ìƒíƒœë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ë³„ë„ ì´ˆê¸°í™” ë¡œì§ ë¶ˆí•„ìš”

  // ì‹œê°„ ì´ë²¤íŠ¸ ì¡°íšŒëŠ” ì œê±°
  // í´ë¼ì´ì–¸íŠ¸ì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ìƒì„±í•´ì„œ ì„œë²„ì— ì „ë‹¬í•˜ë¯€ë¡œ, ì„œë²„ì—ì„œ ë‹¤ì‹œ ì¡°íšŒí•  í•„ìš” ì—†ìŒ
  // Optimistic íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì‚¬ìš©í•˜ê³ , propsê°€ ì—…ë°ì´íŠ¸ë˜ë©´ ì œê±°
  // ê°œë³„ í”Œëœì˜ íƒ€ì´ë¨¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ë™ì‘í•˜ë¯€ë¡œ ë‹¤ë¥¸ í”Œëœ ìƒíƒœ ë™ê¸°í™” ë¶ˆí•„ìš”

  // ì„œë²„ ìƒíƒœë§Œ ì‚¬ìš©
  const isCompleted = Boolean(timeStats.isCompleted);
  const isActiveState = Boolean(isActive);
  const hasStartTime = normalizedStartTime !== null && normalizedStartTime !== undefined;
  const isPausedState = Boolean(isPaused);

  return (
    <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <h3 className="flex items-center gap-2 text-sm font-semibold text-gray-700">
        <Clock className="h-4 w-4" />
        ì‹œê°„ ì •ë³´
      </h3>

      {/* ì‹œì‘/ì¢…ë£Œ ì‹œê°„ ë° ì‹œê°„ ì´ë²¤íŠ¸ */}
      <div className="flex flex-col gap-2 space-y-2 border-b border-gray-100 pb-4">
        {/* Optimistic íƒ€ì„ìŠ¤íƒ¬í”„ ë˜ëŠ” ì‹¤ì œ íƒ€ì„ìŠ¤íƒ¬í”„ í‘œì‹œ */}
        {/* ì‹œì‘ ì‹œê°„ */}
        {(optimisticTimestamps.start || timeStats.firstStartTime) && (
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">ì‹œì‘ ì‹œê°„</span>
            <span className="text-sm font-medium text-gray-900">
              {formatTimestamp(
                optimisticTimestamps.start || timeStats.firstStartTime || ""
              )}
            </span>
          </div>
        )}
        
        {/* ëª¨ë“  ì¼ì‹œì •ì§€/ì¬ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ í‘œì‹œ */}
        {useMemo(() => {
          // íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ í‘œì¤€í™”í•˜ì—¬ ì¤‘ë³µ ì œê±° (Date ê°ì²´ë¥¼ ì´ìš©í•œ ë¹„êµ)
          const normalizeTimestamp = (ts: string): number => {
            return new Date(ts).getTime();
          };

          // Mapì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì„ìŠ¤íƒ¬í”„ì˜ ì¤‘ë³µì„ ì œê±° (í‚¤: íƒ€ì„ìŠ¤íƒ¬í”„ì˜ ë°€ë¦¬ì´ˆ ê°’, ê°’: ì›ë³¸ íƒ€ì„ìŠ¤íƒ¬í”„)
          const pauseMap = new Map<number, string>();
          const resumeMap = new Map<number, string>();

          // Optimistic ì¼ì‹œì •ì§€ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
          if (optimisticTimestamps.pauses) {
            optimisticTimestamps.pauses.forEach(ts => {
              const normalized = normalizeTimestamp(ts);
              if (!pauseMap.has(normalized)) {
                pauseMap.set(normalized, ts);
              }
            });
          }

          // ì„œë²„ ì¼ì‹œì •ì§€ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
          // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ currentPausedAtë§Œ ì‚¬ìš©, ì¬ì‹œì‘ í›„ë©´ lastPausedAtë§Œ ì‚¬ìš©
          if (timeStats.currentPausedAt) {
            const normalized = normalizeTimestamp(timeStats.currentPausedAt);
            if (!pauseMap.has(normalized)) {
              pauseMap.set(normalized, timeStats.currentPausedAt);
            }
          } else if (timeStats.lastPausedAt) {
            const normalized = normalizeTimestamp(timeStats.lastPausedAt);
            if (!pauseMap.has(normalized)) {
              pauseMap.set(normalized, timeStats.lastPausedAt);
            }
          }

          // Optimistic ì¬ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
          if (optimisticTimestamps.resumes) {
            optimisticTimestamps.resumes.forEach(ts => {
              const normalized = normalizeTimestamp(ts);
              if (!resumeMap.has(normalized)) {
                resumeMap.set(normalized, ts);
              }
            });
          }

          // ì„œë²„ ì¬ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
          if (timeStats.lastResumedAt) {
            const normalized = normalizeTimestamp(timeStats.lastResumedAt);
            if (!resumeMap.has(normalized)) {
              resumeMap.set(normalized, timeStats.lastResumedAt);
            }
          }

          // Mapì„ ë°°ì—´ë¡œ ë³€í™˜í•˜ê³  ëª¨ë“  ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬
          const allEvents: Array<{ type: "pause" | "resume"; timestamp: string }> = [
            ...Array.from(pauseMap.entries()).map(([_, ts]) => ({ type: "pause" as const, timestamp: ts })),
            ...Array.from(resumeMap.entries()).map(([_, ts]) => ({ type: "resume" as const, timestamp: ts })),
          ].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

          return allEvents.map((event, index) => (
            <div key={`${event.type}-${event.timestamp}-${index}`} className="flex items-center justify-between">
              <span className={`text-sm ${event.type === "pause" ? "text-amber-600" : "text-blue-600"}`}>
                {event.type === "pause" ? "ì¼ì‹œì •ì§€ ì‹œê°„" : "ì¬ì‹œì‘ ì‹œê°„"}
              </span>
              <span className={`text-sm font-medium ${event.type === "pause" ? "text-amber-900" : "text-blue-900"}`}>
                {formatTimestamp(event.timestamp)}
              </span>
            </div>
          ));
        }, [optimisticTimestamps.pauses, optimisticTimestamps.resumes, timeStats.currentPausedAt, timeStats.lastPausedAt, timeStats.lastResumedAt])}
        
        {/* ì¢…ë£Œ ì‹œê°„ */}
        {timeStats.lastEndTime && (
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">ì¢…ë£Œ ì‹œê°„</span>
            <span className="text-sm font-medium text-gray-900">
              {formatTimestamp(timeStats.lastEndTime)}
            </span>
          </div>
        )}
      </div>

      {/* ì™„ë£Œ ìƒíƒœ í‘œì‹œ */}
      {timeStats.isCompleted && (
        <div className="flex items-center justify-center gap-2 rounded-lg bg-green-50 p-3">
          <CheckCircle className="h-5 w-5 text-green-600" />
          <span className="text-sm font-semibold text-green-900">í•™ìŠµ ì™„ë£Œ</span>
        </div>
      )}

      {/* íƒ€ì´ë¨¸ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ - ì„œë²„ ìƒíƒœë§Œ ì‚¬ìš© */}
      <div>
        <TimerControlButtons
          planId={planId}
          isActive={isActive}
          isPaused={isPaused}
          isCompleted={!!timeStats.lastEndTime}
          isLoading={isLoading || isPending}
          hasOtherActivePlan={hasOtherActivePlan}
          onStart={onStart}
          onPause={onPause}
          onResume={onResume}
          onComplete={onComplete}
          campMode={campMode}
        />
      </div>

      {/* íƒ€ì´ë¨¸ ì´ˆê¸°í™” ë²„íŠ¼ */}
      {(timeStats.firstStartTime || timeStats.lastEndTime || timeStats.totalDuration > 0) && onReset && (
        <div className="flex flex-col gap-4 border-t border-gray-200 pt-4">
          <button
            onClick={async () => {
              if (onReset) {
                await onReset();
              }
            }}
            disabled={isLoading}
            className="flex w-full items-center justify-center gap-2 rounded-lg border border-red-200 bg-red-50 px-4 py-2 text-sm font-medium text-red-700 transition hover:bg-red-100 disabled:opacity-50"
          >
            <RotateCcw className="h-4 w-4" />
            íƒ€ì´ë¨¸ ê¸°ë¡ ì´ˆê¸°í™”
          </button>
        </div>
      )}
    </div>
  );
}

export const TimeCheckSection = memo(TimeCheckSectionComponent, (prevProps, nextProps) => {
  // í•µì‹¬ propsë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  return (
    prevProps.planId === nextProps.planId &&
    prevProps.isActive === nextProps.isActive &&
    prevProps.isPaused === nextProps.isPaused &&
    prevProps.isLoading === nextProps.isLoading &&
    prevProps.hasOtherActivePlan === nextProps.hasOtherActivePlan &&
    prevProps.campMode === nextProps.campMode &&
    prevProps.planNumber === nextProps.planNumber &&
    prevProps.planDate === nextProps.planDate &&
    // timeStats ê°ì²´ì˜ ì£¼ìš” ì†ì„± ë¹„êµ
    prevProps.timeStats.isCompleted === nextProps.timeStats.isCompleted &&
    prevProps.timeStats.firstStartTime === nextProps.timeStats.firstStartTime &&
    prevProps.timeStats.lastEndTime === nextProps.timeStats.lastEndTime &&
    prevProps.timeStats.currentPausedAt === nextProps.timeStats.currentPausedAt &&
    prevProps.timeStats.lastPausedAt === nextProps.timeStats.lastPausedAt &&
    prevProps.timeStats.lastResumedAt === nextProps.timeStats.lastResumedAt &&
    prevProps.activePlanStartTime === nextProps.activePlanStartTime
  );
});
</file>

<file path="_components/TimerControlButtons.tsx">
"use client";

import { memo } from "react";
import { Play, Pause, Square, FileText } from "lucide-react";
import { useRouter } from "next/navigation";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";

type TimerControlButtonsProps = {
  planId: string;
  isActive: boolean;
  isPaused: boolean;
  isCompleted: boolean;
  isLoading?: boolean;
  hasOtherActivePlan?: boolean;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onComplete: () => void;
  className?: string;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

function TimerControlButtonsComponent({
  planId,
  isActive,
  isPaused,
  isCompleted,
  isLoading = false,
  hasOtherActivePlan = false,
  onStart,
  onPause,
  onResume,
  onComplete,
  className,
  campMode = false,
}: TimerControlButtonsProps) {
  const router = useRouter();

  const handleComplete = () => {
    if (!confirm("ì§€ê¸ˆê¹Œì§€ì˜ í•™ìŠµì„ ê¸°ì¤€ìœ¼ë¡œ ì´ í”Œëœì„ ì™„ë£Œ ì…ë ¥ í™”ë©´ìœ¼ë¡œ ì´ë™í• ê¹Œìš”?")) {
      return;
    }
    onComplete();
  };

  if (isCompleted) {
    return (
      <button
        onClick={() => router.push(buildPlanExecutionUrl(planId, campMode))}
        aria-label="ì™„ë£Œí•œ í”Œëœ ìƒì„¸ë³´ê¸°"
        className={`flex flex-1 items-center justify-center gap-2 rounded-lg bg-gray-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-gray-700 ${
          className || ""
        }`}
      >
        <FileText className="h-4 w-4" aria-hidden="true" />
        ìƒì„¸ë³´ê¸°
      </button>
    );
  }

  if (!isActive && !isPaused) {
    return (
      <button
        onClick={onStart}
        disabled={isLoading || hasOtherActivePlan}
        aria-label="í•™ìŠµ ì‹œì‘í•˜ê¸°"
        aria-disabled={isLoading || hasOtherActivePlan}
        className={`flex flex-1 items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50 ${
          className || ""
        }`}
        title={hasOtherActivePlan ? "ë‹¤ë¥¸ í”Œëœì˜ íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ë¨¼ì € í•´ë‹¹ í”Œëœì˜ íƒ€ì´ë¨¸ë¥¼ ì¤‘ì§€í•´ì£¼ì„¸ìš”." : ""}
      >
        <Play className="h-4 w-4" aria-hidden="true" />
        ì‹œì‘í•˜ê¸°
      </button>
    );
  }

  if (isActive && !isPaused) {
    return (
      <div className={`flex gap-2 ${className || ""}`}>
        <button
          onClick={onPause}
          disabled={isLoading}
          aria-label="í•™ìŠµ ì¼ì‹œì •ì§€"
          aria-pressed={false}
          className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-yellow-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-yellow-700 disabled:opacity-50"
        >
          <Pause className="h-4 w-4" aria-hidden="true" />
          ì¼ì‹œì •ì§€
        </button>
        <button
          onClick={handleComplete}
          disabled={isLoading}
          aria-label="í•™ìŠµ ì™„ë£Œí•˜ê¸°"
          className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-green-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-green-700 disabled:opacity-50"
        >
          <Square className="h-4 w-4" aria-hidden="true" />
          ì™„ë£Œí•˜ê¸°
        </button>
      </div>
    );
  }

  if (isPaused) {
    return (
      <div className={`flex gap-2 ${className || ""}`}>
        <button
          onClick={onResume}
          disabled={isLoading}
          aria-label="í•™ìŠµ ì¬ê°œí•˜ê¸°"
          aria-pressed={true}
          className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
        >
          <Play className="h-4 w-4" aria-hidden="true" />
          ì¬ê°œ
        </button>
        <button
          onClick={handleComplete}
          disabled={isLoading}
          aria-label="í•™ìŠµ ì™„ë£Œí•˜ê¸°"
          className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-green-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-green-700 disabled:opacity-50"
        >
          <Square className="h-4 w-4" aria-hidden="true" />
          ì™„ë£Œí•˜ê¸°
        </button>
      </div>
    );
  }

  return null;
}

export const TimerControlButtons = memo(TimerControlButtonsComponent, (prevProps, nextProps) => {
  // í•µì‹¬ propsë§Œ ë¹„êµí•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
  // í•¨ìˆ˜ propsëŠ” ì°¸ì¡° ë™ì¼ì„±ìœ¼ë¡œ ë¹„êµ (useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜ í•„ìš”)
  return (
    prevProps.planId === nextProps.planId &&
    prevProps.isActive === nextProps.isActive &&
    prevProps.isPaused === nextProps.isPaused &&
    prevProps.isCompleted === nextProps.isCompleted &&
    prevProps.isLoading === nextProps.isLoading &&
    prevProps.hasOtherActivePlan === nextProps.hasOtherActivePlan &&
    prevProps.campMode === nextProps.campMode &&
    prevProps.className === nextProps.className &&
    // í•¨ìˆ˜ propsëŠ” ì°¸ì¡° ë™ì¼ì„±ìœ¼ë¡œ ë¹„êµ (ë¶€ëª¨ì—ì„œ useCallback ì‚¬ìš© í•„ìš”)
    prevProps.onStart === nextProps.onStart &&
    prevProps.onPause === nextProps.onPause &&
    prevProps.onResume === nextProps.onResume &&
    prevProps.onComplete === nextProps.onComplete
  );
});
</file>

<file path="_components/TimerLogSection.tsx">
"use client";

import { Play, Pause, CheckCircle } from "lucide-react";
import { formatTime, formatTimestamp } from "../_utils/planGroupUtils";
import type { TimeEvent } from "../actions/sessionTimeActions";

type TimerLogSectionProps = {
  events: TimeEvent[];
};

export function TimerLogSection({ events }: TimerLogSectionProps) {
  if (events.length === 0) {
    return null;
  }

  // ìµœì‹ ìˆœ ì •ë ¬ (ì´ë¯¸ ì„œë²„ì—ì„œ ì •ë ¬ë˜ì–´ ìˆì§€ë§Œ í™•ì‹¤íˆ í•˜ê¸° ìœ„í•´)
  const sortedEvents = [...events].sort((a, b) => 
    new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
  );

  const getEventIcon = (eventType: string) => {
    switch (eventType) {
      case "start":
        return <Play className="h-4 w-4 text-green-600" />;
      case "pause":
        return <Pause className="h-4 w-4 text-yellow-600" />;
      case "resume":
        return <Play className="h-4 w-4 text-blue-600" />;
      case "complete":
        return <CheckCircle className="h-4 w-4 text-green-600" />;
      default:
        return null;
    }
  };

  const getEventLabel = (eventType: string) => {
    switch (eventType) {
      case "start":
        return "ì‹œì‘";
      case "pause":
        return "ì¼ì‹œì •ì§€";
      case "resume":
        return "ì¬ê°œ";
      case "complete":
        return "ì™„ë£Œ";
      default:
        return eventType;
    }
  };

  const getEventColor = (eventType: string) => {
    switch (eventType) {
      case "start":
        return "bg-green-50 border-green-200";
      case "pause":
        return "bg-yellow-50 border-yellow-200";
      case "resume":
        return "bg-blue-50 border-blue-200";
      case "complete":
        return "bg-green-50 border-green-200";
      default:
        return "bg-gray-50 border-gray-200";
    }
  };

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        <h3 className="flex items-center gap-2 text-sm font-semibold text-gray-700">
          <span>ğŸ“‹</span>
          íƒ€ì´ë¨¸ í™œë™ ê¸°ë¡
        </h3>
        
        <div className="flex max-h-64 flex-col gap-2 overflow-y-auto">
        {sortedEvents.map((event, index) => {
          const timeStr = formatTimestamp(event.timestamp);
          const timeOnly = timeStr.split(" ")[1] || timeStr; // ì‹œê°„ ë¶€ë¶„ë§Œ ì¶”ì¶œ
          
          return (
            <div
              key={`${event.type}-${event.timestamp}-${index}`}
              className={`flex items-center justify-between rounded-lg border p-3 ${getEventColor(event.type)}`}
            >
              <div className="flex items-center gap-3">
                {getEventIcon(event.type)}
                <div>
                  <div className="text-sm font-semibold text-gray-900">
                    {getEventLabel(event.type)}
                  </div>
                  <div className="text-xs text-gray-600">{timeOnly}</div>
                </div>
              </div>
              {event.durationSeconds != null && event.durationSeconds > 0 && (
                <div className="text-xs font-medium text-gray-700">
                  {formatTime(event.durationSeconds)}
                </div>
              )}
            </div>
          );
        })}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/TimestampDisplay.tsx">
"use client";

import { Clock } from "lucide-react";
import { formatTime, formatTimestamp, calculateStudyTimeFromTimestamps } from "../_utils/planGroupUtils";

type TimestampDisplayProps = {
  actualStartTime?: string | null;
  actualEndTime?: string | null;
  totalDurationSeconds?: number | null;
  pausedDurationSeconds?: number | null;
  pauseCount?: number | null;
  isRunning: boolean;
  isPaused: boolean;
  isCompleted: boolean;
  currentPausedAt?: string | null; // í˜„ì¬ ì¼ì‹œì •ì§€ ì‹œì‘ ì‹œê°„
  className?: string;
};

export function TimestampDisplay({
  actualStartTime,
  actualEndTime,
  totalDurationSeconds,
  pausedDurationSeconds,
  pauseCount,
  isRunning,
  isPaused,
  isCompleted,
  currentPausedAt,
  className,
}: TimestampDisplayProps) {
  // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ì‹œê°„ ê³„ì‚° (í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš° ê³ ë ¤)
  const displaySeconds = calculateStudyTimeFromTimestamps(
    actualStartTime,
    actualEndTime,
    pausedDurationSeconds,
    isPaused,
    currentPausedAt
  );

  return (
    <div className={`rounded-lg bg-gray-50 p-3 ${className || ""}`}>
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Clock className="h-4 w-4 text-gray-500" />
          <span className="text-sm font-medium text-gray-700">
            {isCompleted ? "ì´ í•™ìŠµ ì‹œê°„" : "í•™ìŠµ ì‹œê°„"}
          </span>
        </div>
        <div className="flex items-center gap-2 text-lg font-bold text-indigo-600">
          {formatTime(displaySeconds)}
          {isPaused && (
            <span className="text-xs text-gray-500">(ì¼ì‹œì •ì§€ ì¤‘)</span>
          )}
        </div>

        <div className="flex flex-col gap-1">
          {actualStartTime && (
            <div className="text-xs text-gray-600">
              ì‹œì‘: {formatTimestamp(actualStartTime)}
            </div>
          )}

          {actualEndTime && isCompleted && (
            <div className="text-xs text-gray-600">
              ì¢…ë£Œ: {formatTimestamp(actualEndTime)}
            </div>
          )}

          {pauseCount != null && pauseCount > 0 && (
            <div className="text-xs text-gray-500">
              ì¼ì‹œì •ì§€: {pauseCount}íšŒ
              {pausedDurationSeconds != null &&
                pausedDurationSeconds > 0 &&
                ` (${formatTime(pausedDurationSeconds)})`}
            </div>
          )}

          {isCompleted && pausedDurationSeconds && totalDurationSeconds && (
            <div className="text-xs text-gray-500">
              ì‹¤ì œ í•™ìŠµ: {formatTime(totalDurationSeconds - pausedDurationSeconds)}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/TodayAchievements.tsx">
"use client";

import type { TodayProgress } from "@/lib/metrics/todayProgress";
import { ProgressBar } from "@/components/atoms/ProgressBar";
import {
  formatKoreanDateWithDay,
  getRelativeDateLabel,
} from "../_utils/dateDisplay";

type TodayAchievementsProps = {
  todayProgress: TodayProgress;
  selectedDate?: string | null;
  isLoading?: boolean;
  errorMessage?: string | null;
};

export function TodayAchievements({
  todayProgress,
  selectedDate,
  isLoading = false,
  errorMessage,
}: TodayAchievementsProps) {
  const completionRate =
    todayProgress.planTotalCount > 0
      ? Math.round(
          (todayProgress.planCompletedCount / todayProgress.planTotalCount) * 100
        )
      : 0;

  const hasPlans = todayProgress.planTotalCount > 0;
  const formattedDate = selectedDate
    ? formatKoreanDateWithDay(selectedDate)
    : "-";
  const relativeLabel = selectedDate
    ? getRelativeDateLabel(selectedDate)
    : "ì„ íƒí•œ ë‚ ì§œ";

  if (isLoading) {
    return (
      <div className="rounded-xl border border-gray-200 bg-white p-4">
        <div className="flex flex-col gap-4 animate-pulse">
          <div className="h-5 w-28 rounded bg-gray-200" />
          <div className="h-4 w-40 rounded bg-gray-100" />
          <div className="h-4 w-full rounded bg-gray-100" />
          <div className="h-4 w-3/4 rounded bg-gray-100" />
          <div className="h-4 w-2/3 rounded bg-gray-100" />
        </div>
      </div>
    );
  }

  if (errorMessage) {
    return (
      <div className="rounded-xl border border-dashed border-red-200 bg-red-50 p-4">
        <div className="flex flex-col gap-2">
          <h2 className="text-lg font-semibold text-gray-900">í•™ìŠµ ì„±ì·¨ë„ ìš”ì•½</h2>
          <p className="text-sm text-red-700">{errorMessage}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="rounded-xl border border-gray-200 bg-white p-4">
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-lg font-semibold text-gray-900">í•™ìŠµ ì„±ì·¨ë„ ìš”ì•½</h2>
            <p className="text-xs text-gray-500">
              {relativeLabel} Â· {formattedDate}
            </p>
          </div>
          <div className="rounded-full bg-indigo-50 px-3 py-1 text-xs font-semibold text-indigo-700">
            {selectedDate || "-"}
          </div>
        </div>

        <div className="flex flex-col gap-4">
          <div className="flex items-center justify-between text-sm">
            <span className="text-gray-600">í•™ìŠµ ì‹œê°„</span>
            <span className="font-semibold text-gray-900">
              {Math.floor(todayProgress.todayStudyMinutes / 60)}ì‹œê°„{" "}
              {todayProgress.todayStudyMinutes % 60}ë¶„
            </span>
          </div>

          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between text-sm">
              <span className="text-gray-600">ì™„ë£Œí•œ í”Œëœ</span>
              {hasPlans ? (
                <span className="font-semibold text-gray-900">
                  {todayProgress.planCompletedCount} /{" "}
                  {todayProgress.planTotalCount}
                </span>
              ) : (
                <span className="text-gray-400">í”Œëœ ì—†ìŒ</span>
              )}
            </div>
            <ProgressBar
              value={hasPlans ? completionRate : 0}
              height="md"
              color={hasPlans ? "green" : undefined}
            />
          </div>

          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between text-sm">
              <span className="text-gray-600">í•™ìŠµ íš¨ìœ¨ ì ìˆ˜</span>
              <span className="font-semibold text-blue-600">
                {todayProgress.achievementScore}ì 
              </span>
            </div>
            <ProgressBar
              value={todayProgress.achievementScore}
              height="md"
              color="blue"
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/TodayAchievementsSection.tsx">
"use client";

import { useMemo } from "react";
import { TodayAchievements } from "./TodayAchievements";
import { useTodayPageContext } from "./TodayPageContext";

export function TodayAchievementsSection() {
  const { progress, selectedDate, isProgressLoading, progressError } = useTodayPageContext();

  const achievementsProps = useMemo(
    () => ({
      todayProgress: progress,
      selectedDate,
      isLoading: isProgressLoading,
      errorMessage: progressError,
    }),
    [progress, selectedDate, isProgressLoading, progressError]
  );

  return <TodayAchievements {...achievementsProps} />;
}
</file>

<file path="_components/TodayFocusPreview.tsx">
import type { TodayProgress } from "@/lib/metrics/todayProgress";

type TodayFocusPreviewProps = {
  todayProgress: TodayProgress;
};

export async function TodayFocusPreview({ todayProgress }: TodayFocusPreviewProps) {
  try {
    const hours = Math.floor(todayProgress.todayStudyMinutes / 60);
    const minutes = todayProgress.todayStudyMinutes % 60;

  return (
    <div className="rounded-xl border border-purple-200 bg-gradient-to-br from-purple-50 to-pink-50 p-4">
      <div className="flex flex-col gap-3">
        <h2 className="text-lg font-semibold text-gray-900">ì§‘ì¤‘ íƒ€ì´ë¨¸</h2>
        <div className="flex flex-col gap-1">
          <div className="text-2xl font-bold text-purple-700">
            {hours > 0 ? `${hours}ì‹œê°„ ` : ""}
            {minutes}ë¶„
          </div>
          <p className="text-sm text-gray-600">ì˜¤ëŠ˜ ì§‘ì¤‘í•œ ì‹œê°„</p>
        </div>
      </div>
    </div>
  );
  } catch (error) {
    console.error("[TodayFocusPreview] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-4">
        <div className="flex flex-col gap-3">
          <h2 className="text-lg font-semibold text-gray-900">ì§‘ì¤‘ íƒ€ì´ë¨¸</h2>
          <p className="text-sm text-gray-500">íƒ€ì´ë¨¸ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>
        </div>
      </div>
    );
  }
}
</file>

<file path="_components/TodayGoals.tsx">
import type { TodayProgress } from "@/lib/metrics/todayProgress";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type TodayGoalsProps = {
  todayProgress: TodayProgress;
};

export async function TodayGoals({ todayProgress }: TodayGoalsProps) {
  try {
    // goalProgressSummary ì†ì„±ì´ ì—†ìœ¼ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ì²˜ë¦¬
    // TODO: ëª©í‘œ ì§„í–‰ë¥  ë°ì´í„°ë¥¼ ë³„ë„ë¡œ ì¡°íšŒí•˜ê±°ë‚˜ TodayProgress íƒ€ì…ì— ì¶”ê°€ í•„ìš”
    const topGoals: Array<{ goalId: string; title: string; progress: number }> = [];

    if (topGoals.length === 0) {
      return (
        <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-4">
          <div className="flex flex-col gap-2">
            <h2 className="text-lg font-semibold text-gray-900">ì˜¤ëŠ˜ ëª©í‘œ</h2>
            <p className="text-sm text-gray-500">ì˜¤ëŠ˜ ì™„ë£Œí•´ì•¼ í•  ëª©í‘œê°€ ì—†ìŠµë‹ˆë‹¤.</p>
          </div>
        </div>
      );
    }

  return (
    <div className="rounded-xl border border-gray-200 bg-white p-4">
      <div className="flex flex-col gap-4">
        <h2 className="text-lg font-semibold text-gray-900">ì˜¤ëŠ˜ ëª©í‘œ</h2>
        <div className="flex flex-col gap-3">
          {topGoals.map((goal) => (
            <div key={goal.goalId} className="flex flex-col gap-1">
              <div className="flex items-center justify-between text-sm">
                <span className="font-medium text-gray-700">{goal.title}</span>
                <span className="text-gray-600">{goal.progress}%</span>
              </div>
              <ProgressBar value={goal.progress} height="md" color="blue" />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
  } catch (error) {
    console.error("[TodayGoals] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-4">
        <div className="flex flex-col gap-2">
          <h2 className="text-lg font-semibold text-gray-900">ì˜¤ëŠ˜ ëª©í‘œ</h2>
          <p className="text-sm text-gray-500">ëª©í‘œ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>
        </div>
      </div>
    );
  }
}
</file>

<file path="_components/TodayHeader.tsx">
import { getStudentById } from "@/lib/data/students";
import { calculateStreak } from "@/lib/metrics/streak";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";

const dayNames = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

export async function TodayHeader() {
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      return null;
    }

    const tenantContext = await getTenantContext();
    const [studentResult, streakResult] = await Promise.allSettled([
      getStudentById(user.userId, tenantContext?.tenantId || null),
      calculateStreak(user.userId, tenantContext?.tenantId || null),
    ]);

    const student =
      studentResult.status === "fulfilled" ? studentResult.value : null;
    const streak =
      streakResult.status === "fulfilled" ? streakResult.value : 0;

  const today = new Date();
  const dayOfWeek = dayNames[today.getDay()];
  const dateStr = `${today.getFullYear()}ë…„ ${today.getMonth() + 1}ì›” ${today.getDate()}ì¼`;

  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold text-gray-900">
          {student?.name || "í•™ìƒ"}ë‹˜, ì˜¤ëŠ˜ ì‹œì‘í•´ë³¼ê¹Œìš”?
        </h1>
        {streak > 0 && (
          <div className="flex items-center gap-1.5 rounded-full bg-orange-100 px-3 py-1.5">
            <span className="text-lg">ğŸ”¥</span>
            <span className="text-sm font-semibold text-orange-700">
              {streak}ì¼ ì—°ì†
            </span>
          </div>
        )}
      </div>
      <p className="text-sm text-gray-600">
        {dateStr} ({dayOfWeek})
      </p>
    </div>
  );
  } catch (error) {
    console.error("[TodayHeader] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    const today = new Date();
    const dayNames = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
    const dayOfWeek = dayNames[today.getDay()];
    const dateStr = `${today.getFullYear()}ë…„ ${today.getMonth() + 1}ì›” ${today.getDate()}ì¼`;

    return (
      <div className="flex flex-col gap-2">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold text-gray-900">
            í•™ìƒë‹˜, ì˜¤ëŠ˜ ì‹œì‘í•´ë³¼ê¹Œìš”?
          </h1>
        </div>
        <p className="text-sm text-gray-600">
          {dateStr} ({dayOfWeek})
        </p>
      </div>
    );
  }
}
</file>

<file path="_components/TodayPageContent.tsx">
"use client";

import { useCallback, useMemo, useRef, useState } from "react";
import type { TodayProgress } from "@/lib/metrics/todayProgress";
import { PlanViewContainer, type ViewMode } from "./PlanViewContainer";
import { TodayAchievements } from "./TodayAchievements";
import type { PlanWithContent } from "../_utils/planGroupUtils";

type PlansResponse = {
  plans: PlanWithContent[];
  sessions: Record<string, {
    isPaused: boolean;
    startedAt?: string | null;
    pausedAt?: string | null;
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }>;
  planDate: string;
  isToday?: boolean;
  serverNow?: number;
  /**
   * Today progress summary (from /api/today/plans).
   * If provided, we skip calling /api/today/progress separately.
   */
  todayProgress?: TodayProgress | null;
};

type TodayPageContentProps = {
  initialMode: ViewMode;
  initialPlanDate?: string | null;
  initialProgressDate: string;
  initialProgress: TodayProgress;
  showPlans?: boolean;
  showAchievements?: boolean;
  userId?: string;
  campMode?: boolean;
  /**
   * If provided, passes this data to PlanViewContainer to avoid client-side fetch.
   * Used on pages like /camp/today where data is already fetched on the server.
   */
  initialPlansData?: PlansResponse;
};

type ProgressResponse = {
  planDate: string;
  progress: TodayProgress;
};

export function TodayPageContent({
  initialMode,
  initialPlanDate = null,
  initialProgressDate,
  initialProgress,
  showPlans = true,
  showAchievements = true,
  userId,
  campMode = false,
  initialPlansData,
}: TodayPageContentProps) {
  const fallbackDate = initialPlanDate ?? initialProgressDate;
  const [selectedDate, setSelectedDate] = useState<string>(fallbackDate);
  
  // If initialPlansData includes todayProgress, use it instead of initialProgress
  // This avoids the need for a separate /api/today/progress call
  const effectiveInitialProgress = initialPlansData?.todayProgress ?? initialProgress;
  const [progress, setProgress] = useState<TodayProgress>(effectiveInitialProgress);
  const [isProgressLoading, setIsProgressLoading] = useState(false);
  const [progressError, setProgressError] = useState<string | null>(null);
  const lastFetchedDateRef = useRef<string>(fallbackDate);
  
  // Track if we should skip progress fetch (when data comes from /api/today/plans)
  const shouldSkipProgressFetch = Boolean(initialPlansData?.todayProgress);

  const fetchProgress = useCallback(async (date: string) => {
    if (!date) {
      return;
    }

    try {
      setIsProgressLoading(true);
      setProgressError(null);
      const query = date ? `?date=${encodeURIComponent(date)}` : "";
      const response = await fetch(`/api/today/progress${query}`, {
        cache: "no-store",
      });
      if (!response.ok) {
        throw new Error("ì„±ì·¨ë„ ì¡°íšŒ ì‹¤íŒ¨");
      }

      const data = (await response.json()) as ProgressResponse;
      setProgress(data.progress);
      lastFetchedDateRef.current = data.planDate ?? date;
    } catch (error) {
      console.error("[TodayPageContent] ì„±ì·¨ë„ ë¡œë”© ì‹¤íŒ¨", error);
      setProgressError("ì„±ì·¨ë„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsProgressLoading(false);
    }
  }, []);

  const handleDateChange = useCallback(
    (date: string, options?: { isToday: boolean; todayProgress?: TodayProgress | null }) => {
      if (!date) {
        return;
      }
      setSelectedDate(date);
      
      // If todayProgress is provided from /api/today/plans response, use it
      if (options?.todayProgress) {
        setProgress(options.todayProgress);
        lastFetchedDateRef.current = date;
        return;
      }
      
      // Otherwise, fetch progress separately (only if date changed)
      if (lastFetchedDateRef.current !== date) {
        fetchProgress(date);
      }
    },
    [fetchProgress]
  );

  const achievementsProps = useMemo(
    () => ({
      todayProgress: progress,
      selectedDate,
      isLoading: isProgressLoading,
      errorMessage: progressError,
    }),
    [progress, selectedDate, isProgressLoading, progressError]
  );

  return (
    <div className="flex flex-col gap-6">
      {showPlans && (
        <PlanViewContainer
          initialMode={initialMode}
          initialPlanDate={initialPlanDate}
          onDateChange={handleDateChange}
          userId={userId}
          campMode={campMode}
          initialData={initialPlansData}
        />
      )}
      {showAchievements && <TodayAchievements {...achievementsProps} />}
    </div>
  );
}
</file>

<file path="_components/TodayPageContext.tsx">
"use client";

import { createContext, useContext, useCallback, useState, useRef, type ReactNode } from "react";
import type { TodayProgress } from "@/lib/metrics/todayProgress";

type ProgressResponse = {
  planDate: string;
  progress: TodayProgress;
};

type TodayPageContextValue = {
  selectedDate: string;
  progress: TodayProgress;
  isProgressLoading: boolean;
  progressError: string | null;
  handleDateChange: (date: string, options?: { isToday: boolean; todayProgress?: TodayProgress | null }) => void;
  shouldSkipProgressFetch: boolean;
};

const TodayPageContext = createContext<TodayPageContextValue | null>(null);

type TodayPageContextProviderProps = {
  children: ReactNode;
  initialProgressDate: string;
  initialProgress: TodayProgress;
  initialPlansData?: {
    todayProgress?: TodayProgress | null;
  };
};

export function TodayPageContextProvider({
  children,
  initialProgressDate,
  initialProgress,
  initialPlansData,
}: TodayPageContextProviderProps) {
  const fallbackDate = initialProgressDate;
  const [selectedDate, setSelectedDate] = useState<string>(fallbackDate);
  
  // If initialPlansData includes todayProgress, use it instead of initialProgress
  const effectiveInitialProgress = initialPlansData?.todayProgress ?? initialProgress;
  const [progress, setProgress] = useState<TodayProgress>(effectiveInitialProgress);
  const [isProgressLoading, setIsProgressLoading] = useState(false);
  const [progressError, setProgressError] = useState<string | null>(null);
  const lastFetchedDateRef = useRef<string>(fallbackDate);
  
  // Track if we should skip progress fetch (when data comes from /api/today/plans)
  const shouldSkipProgressFetch = Boolean(initialPlansData?.todayProgress);

  const fetchProgress = useCallback(async (date: string) => {
    if (!date) {
      return;
    }

    try {
      setIsProgressLoading(true);
      setProgressError(null);
      const query = date ? `?date=${encodeURIComponent(date)}` : "";
      const response = await fetch(`/api/today/progress${query}`, {
        cache: "no-store",
      });
      if (!response.ok) {
        throw new Error("ì„±ì·¨ë„ ì¡°íšŒ ì‹¤íŒ¨");
      }

      const data = (await response.json()) as ProgressResponse;
      setProgress(data.progress);
      lastFetchedDateRef.current = data.planDate ?? date;
    } catch (error) {
      console.error("[TodayPageContext] ì„±ì·¨ë„ ë¡œë”© ì‹¤íŒ¨", error);
      setProgressError("ì„±ì·¨ë„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsProgressLoading(false);
    }
  }, []);

  const handleDateChange = useCallback(
    (date: string, options?: { isToday: boolean; todayProgress?: TodayProgress | null }) => {
      if (!date) {
        return;
      }
      setSelectedDate(date);
      
      // If todayProgress is provided from /api/today/plans response, use it
      if (options?.todayProgress) {
        setProgress(options.todayProgress);
        lastFetchedDateRef.current = date;
        return;
      }
      
      // Otherwise, fetch progress separately (only if date changed)
      if (lastFetchedDateRef.current !== date) {
        fetchProgress(date);
      }
    },
    [fetchProgress]
  );

  return (
    <TodayPageContext.Provider
      value={{
        selectedDate,
        progress,
        isProgressLoading,
        progressError,
        handleDateChange,
        shouldSkipProgressFetch,
      }}
    >
      {children}
    </TodayPageContext.Provider>
  );
}

export function useTodayPageContext() {
  const context = useContext(TodayPageContext);
  if (!context) {
    throw new Error("useTodayPageContext must be used within TodayPageContextProvider");
  }
  return context;
}
</file>

<file path="_components/TodayPlanItem.tsx">
"use client";

import Link from "next/link";
import { Plan } from "@/lib/data/studentPlans";
import { Book, Lecture, CustomContent } from "@/lib/data/studentContents";
import { Badge } from "@/components/atoms/Badge";
import { ProgressBar } from "@/components/atoms/ProgressBar";
import { buildPlanExecutionUrl } from "../_utils/navigationUtils";

type TodayPlanItemProps = {
  plan: Plan & {
    content?: Book | Lecture | CustomContent;
    progress?: number | null;
  };
  campMode?: boolean;
};

const contentTypeLabels: Record<string, string> = {
  book: "ì±…",
  lecture: "ê°•ì˜",
  custom: "ì»¤ìŠ¤í…€",
};

const statusLabels = {
  scheduled: "ì˜ˆì •",
  in_progress: "ì§„í–‰ ì¤‘",
  completed: "ì™„ë£Œ",
  incomplete: "ë¯¸ì™„ë£Œ",
};

function getPlanStatus(plan: Plan & { progress?: number | null }): keyof typeof statusLabels {
  if (plan.progress !== null && plan.progress !== undefined && plan.progress >= 100) {
    return "completed";
  }
  if (plan.progress !== null && plan.progress !== undefined && plan.progress > 0) {
    return "in_progress";
  }
  return "scheduled";
}

function getStatusVariant(status: keyof typeof statusLabels): "success" | "info" | "default" | "error" {
  switch (status) {
    case "completed":
      return "success";
    case "in_progress":
      return "info";
    case "scheduled":
      return "default";
    case "incomplete":
      return "error";
    default:
      return "default";
  }
}

export function TodayPlanItem({ plan, campMode = false }: TodayPlanItemProps) {
  const status = getPlanStatus(plan);
  const statusLabel = statusLabels[status];
  const statusVariant = getStatusVariant(status);

  const contentTitle = plan.content?.title || "ì œëª© ì—†ìŒ";
  const contentType = contentTypeLabels[plan.content_type] || plan.content_type;

  return (
    <div className="transition">
      <div className="flex flex-col gap-3">
        <div className="flex items-start justify-between">
          <div className="flex-1 flex flex-col gap-1">
            <div className="flex items-center gap-2">
              <Badge variant={statusVariant} size="sm">
                {statusLabel}
              </Badge>
              <span className="text-xs text-gray-500">{contentType}</span>
            </div>
            <h3 className="font-semibold text-gray-900">{contentTitle}</h3>
            {plan.chapter && (
              <p className="text-sm text-gray-600">ì±•í„°: {plan.chapter}</p>
            )}
          </div>
        </div>

        {plan.progress !== null && plan.progress !== undefined && plan.progress > 0 && (
          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between text-xs text-gray-600">
              <span>ì§„í–‰ë¥ </span>
              <span>{plan.progress}%</span>
            </div>
            <ProgressBar value={plan.progress} height="sm" color="blue" />
          </div>
        )}

        <div className="flex items-center justify-between">
          <div className="text-xs text-gray-500">
            {plan.planned_start_page_or_time !== null &&
              plan.planned_end_page_or_time !== null && (
                <span>
                  {plan.planned_start_page_or_time} ~ {plan.planned_end_page_or_time}
                  {plan.content_type === "book" ? "í˜ì´ì§€" : "ë¶„"}
                </span>
              )}
          </div>
          <Link
            href={buildPlanExecutionUrl(plan.id, campMode)}
            className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-blue-700"
          >
            {status === "completed" ? "ë³´ê¸°" : "ì‹œì‘í•˜ê¸°"}
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/TodayPlanList.tsx">
import { getPlansForStudent } from "@/lib/data/studentPlans";
import { getBooks, getLectures, getCustomContents } from "@/lib/data/studentContents";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { TodayPlanListView } from "./TodayPlanListView";
import { groupPlansByPlanNumber, PlanWithContent } from "../_utils/planGroupUtils";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { formatDateString } from "@/lib/date/calendarUtils";

type ProgressRow = {
  content_type?: string | null;
  content_id?: string | null;
  progress?: number | null;
};

async function fetchProgressMap(
  studentId: string
): Promise<Record<string, number | null>> {
  const supabase = await createSupabaseServerClient();
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const rows = (data as ProgressRow[] | null) ?? [];
    const map: Record<string, number | null> = {};

    rows.forEach((row) => {
      if (row.content_type && row.content_id) {
        const key = `${row.content_type}:${row.content_id}`;
        map[key] = row.progress ?? null;
      }
    });

    return map;
  } catch (error) {
    console.error("[today] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {};
  }
}

/**
 * ë‚ ì§œë¥¼ í•œêµ­ì–´ í˜•ì‹ìœ¼ë¡œ í¬ë§·íŒ… (ì˜ˆ: 2024ë…„ 1ì›” 15ì¼)
 */
function formatDateKorean(dateStr: string): string {
  const date = new Date(dateStr + "T00:00:00");
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return `${year}ë…„ ${month}ì›” ${day}ì¼`;
}

/**
 * ë‚ ì§œ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ ìƒëŒ€ì  í‘œí˜„ ë°˜í™˜ (ì˜ˆ: "ë‚´ì¼", "3ì¼ í›„")
 */
function getRelativeDateLabel(targetDateStr: string, todayDateStr: string): string {
  const target = new Date(targetDateStr + "T00:00:00");
  const today = new Date(todayDateStr + "T00:00:00");
  const diffTime = target.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays === 0) return "ì˜¤ëŠ˜";
  if (diffDays === 1) return "ë‚´ì¼";
  if (diffDays === 2) return "ëª¨ë ˆ";
  if (diffDays <= 7) return `${diffDays}ì¼ í›„`;
  return formatDateKorean(targetDateStr);
}

export async function TodayPlanList() {
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      return null;
    }

    const tenantContext = await getTenantContext();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayDate = formatDateString(today);

    // 1. ì˜¤ëŠ˜ í”Œëœ ì¡°íšŒ
    const [todayPlansResult, progressMapResult] = await Promise.allSettled([
      getPlansForStudent({
        studentId: user.userId,
        tenantId: tenantContext?.tenantId || null,
        planDate: todayDate,
      }),
      fetchProgressMap(user.userId),
    ]);

    const todayPlans =
      todayPlansResult.status === "fulfilled" ? todayPlansResult.value : [];
    const progressMap =
      progressMapResult.status === "fulfilled"
        ? progressMapResult.value
        : {};

    let plans = todayPlans;
    let displayDate = todayDate;
    let isToday = true;

    // 2. ì˜¤ëŠ˜ í”Œëœì´ ì—†ìœ¼ë©´ ê°€ì¥ ê°€ê¹Œìš´ ë¯¸ë˜ ë‚ ì§œì˜ í”Œëœ ì°¾ê¸°
    if (plans.length === 0) {
      // ë¨¼ì € 30ì¼ ë²”ìœ„ë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
      const shortRangeEndDate = new Date(today);
      shortRangeEndDate.setDate(shortRangeEndDate.getDate() + 30);
      const shortRangeEndDateStr = formatDateString(shortRangeEndDate);

      let futurePlansResult = await getPlansForStudent({
        studentId: user.userId,
        tenantId: tenantContext?.tenantId || null,
        dateRange: {
          start: todayDate,
          end: shortRangeEndDateStr,
        },
      });

      // 30ì¼ ë²”ìœ„ì— í”Œëœì´ ì—†ìœ¼ë©´ ë” ë„“ì€ ë²”ìœ„(180ì¼)ë¡œ í™•ì¥ ì¡°íšŒ
      if (futurePlansResult.length === 0) {
        const longRangeEndDate = new Date(today);
        longRangeEndDate.setDate(longRangeEndDate.getDate() + 180); // 180ì¼ í›„ê¹Œì§€ ì¡°íšŒ
        const longRangeEndDateStr = formatDateString(longRangeEndDate);

        futurePlansResult = await getPlansForStudent({
          studentId: user.userId,
          tenantId: tenantContext?.tenantId || null,
          dateRange: {
            start: todayDate,
            end: longRangeEndDateStr,
          },
        });
      }

      if (futurePlansResult.length > 0) {
        // ê°€ì¥ ê°€ê¹Œìš´ ë‚ ì§œ ì°¾ê¸° (plan_date ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬)
        const sortedPlans = futurePlansResult.sort((a, b) => {
          if (!a.plan_date || !b.plan_date) return 0;
          return a.plan_date.localeCompare(b.plan_date);
        });

        // ì²« ë²ˆì§¸ í”Œëœì˜ ë‚ ì§œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•´ë‹¹ ë‚ ì§œì˜ ëª¨ë“  í”Œëœ ê°€ì ¸ì˜¤ê¸°
        const nearestDate = sortedPlans[0].plan_date;
        if (nearestDate) {
          displayDate = nearestDate;
          isToday = false;
          plans = sortedPlans.filter((p) => p.plan_date === nearestDate);
        }
      }
    }

    // 3. ì—¬ì „íˆ í”Œëœì´ ì—†ìœ¼ë©´ ë¹ˆ ìƒíƒœ í‘œì‹œ
    if (plans.length === 0) {
      return (
        <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
          <div className="mx-auto flex max-w-md flex-col gap-4">
            <div className="text-6xl">ğŸ“š</div>
            <div className="flex flex-col gap-2">
              <h3 className="text-lg font-semibold text-gray-900">
                ì˜¤ëŠ˜ ë°°ìš¸ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤
              </h3>
              <p className="text-sm text-gray-500">
                í•™ìŠµ í”Œëœì„ ìƒì„±í•´ë³´ì„¸ìš”.
              </p>
            </div>
          </div>
        </div>
      );
    }

  // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ
  const bookIds = plans
    .filter((p) => p.content_type === "book" && p.content_id)
    .map((p) => p.content_id);
  const lectureIds = plans
    .filter((p) => p.content_type === "lecture" && p.content_id)
    .map((p) => p.content_id);
  const customIds = plans
    .filter((p) => p.content_type === "custom" && p.content_id)
    .map((p) => p.content_id);

  const [books, lectures, customContents] = await Promise.all([
    bookIds.length > 0
      ? getBooks(user.userId, tenantContext?.tenantId || null)
      : Promise.resolve([]),
    lectureIds.length > 0
      ? getLectures(user.userId, tenantContext?.tenantId || null)
      : Promise.resolve([]),
    customIds.length > 0
      ? getCustomContents(user.userId, tenantContext?.tenantId || null)
      : Promise.resolve([]),
  ]);

  const contentMap = new Map<string, any>();
  books.forEach((book) => contentMap.set(`book:${book.id}`, book));
  lectures.forEach((lecture) => contentMap.set(`lecture:${lecture.id}`, lecture));
  customContents.forEach((custom) => contentMap.set(`custom:${custom.id}`, custom));

  // í™œì„± ì„¸ì…˜ ì¡°íšŒ (ì¼ì‹œì •ì§€ ìƒíƒœ í™•ì¸ìš©)
  const supabase = await createSupabaseServerClient();
  const { data: activeSessions } = await supabase
    .from("student_study_sessions")
    .select("plan_id,paused_at,resumed_at")
    .eq("student_id", user.userId)
    .is("ended_at", null);

  const sessionMap = new Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>();
  activeSessions?.forEach((session) => {
    if (session.plan_id) {
      const isPaused = !!session.paused_at && !session.resumed_at;
      sessionMap.set(session.plan_id, {
        isPaused,
        pausedAt: session.paused_at,
        resumedAt: session.resumed_at,
      });
    }
  });

  // í”Œëœ ë°ì´í„°ë¥¼ PlanWithContent í˜•ì‹ìœ¼ë¡œ ë³€í™˜
  const plansWithContent: PlanWithContent[] = plans.map((plan) => {
    const contentKey = `${plan.content_type}:${plan.content_id}`;
    const content = contentMap.get(contentKey);
    const progress = progressMap[contentKey] ?? null;
    const session = sessionMap.get(plan.id);

    return {
      ...plan,
      content,
      progress,
      session: session ? { 
        isPaused: session.isPaused,
        pausedAt: session.pausedAt,
        resumedAt: session.resumedAt
      } : undefined,
    };
  });

  // ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì„ ê·¸ë£¹í™”
  const groups = groupPlansByPlanNumber(plansWithContent);


  // ì„¸ì…˜ ë§µ ìƒì„± (ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬í•˜ê¸° ìœ„í•´ Mapìœ¼ë¡œ ë³€í™˜)
  const sessionsMap = new Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>();
  sessionMap.forEach((value, key) => {
    sessionsMap.set(key, value);
  });

  // ë©”ëª¨ ì¡°íšŒ (ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì˜ ë©”ëª¨)
  // ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì€ ê°™ì€ memoë¥¼ ê³µìœ í•œë‹¤ê³  ê°€ì •
  const memosMap = new Map<number | null, string | null>();
  const uniquePlanNumbers = new Set<number | null>(
    groups.map((g) => g.planNumber)
  );

  // ê° plan_numberë³„ë¡œ í”Œëœì„ ì°¾ì•„ì„œ memo ì¡°íšŒ
  for (const planNumber of uniquePlanNumbers) {
    const plan = plans.find(
      (p) => (p.plan_number ?? null) === planNumber
    );
    if (plan) {
      // í”Œëœì—ì„œ memo í•„ë“œ ì¡°íšŒ
      const memo = plan.memo ?? null;
      memosMap.set(planNumber, memo);
    }
  }

  // plan_numberê°€ nullì¸ ê²½ìš°ë„ ì²˜ë¦¬
  const nullPlanNumberPlans = plans.filter((p) => (p.plan_number ?? null) === null);
  if (nullPlanNumberPlans.length > 0) {
    const firstNullPlan = nullPlanNumberPlans[0];
    const memo = firstNullPlan.memo ?? null;
    memosMap.set(null, memo);
  }

  // ì½˜í…ì¸  ì´ëŸ‰ ë§µ ìƒì„±
  const totalPagesMap = new Map<string, number>();
  books.forEach((book) => {
    const key = `book:${book.id}`;
    if (book.total_pages && book.total_pages > 0) {
      totalPagesMap.set(key, book.total_pages);
    }
  });
  lectures.forEach((lecture) => {
    const key = `lecture:${lecture.id}`;
    if (lecture.duration && lecture.duration > 0) {
      totalPagesMap.set(key, lecture.duration);
    }
  });
  customContents.forEach((custom) => {
    const key = `custom:${custom.id}`;
    if (custom.total_page_or_time && custom.total_page_or_time > 0) {
      totalPagesMap.set(key, custom.total_page_or_time);
    }
  });

  // ë‚ ì§œ í‘œì‹œ ë ˆì´ë¸” ìƒì„±
  const dateLabel = isToday 
    ? "ì˜¤ëŠ˜" 
    : getRelativeDateLabel(displayDate, todayDate);

  return (
    <div className="flex flex-col gap-4">
      {!isToday && (
        <div className="rounded-lg border border-amber-200 bg-amber-50 px-4 py-3">
          <div className="flex items-center gap-2">
            <span className="text-lg">ğŸ“…</span>
            <div className="flex-1">
              <p className="text-sm font-semibold text-amber-900">
                {dateLabel}ì˜ í”Œëœì„ í‘œì‹œí•˜ê³  ìˆìŠµë‹ˆë‹¤
              </p>
              <p className="text-xs text-amber-700">
                {formatDateKorean(displayDate)} ({dateLabel})
              </p>
            </div>
          </div>
        </div>
      )}
      <TodayPlanListView
        groups={groups}
        sessions={sessionsMap}
        planDate={displayDate}
        memos={memosMap}
        totalPagesMap={totalPagesMap}
        initialMode="daily"
        initialSelectedPlanNumber={groups[0]?.planNumber ?? null}
        serverNow={Date.now()}
      />
    </div>
  );
  } catch (error) {
    console.error("[TodayPlanList] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-8 text-center">
        <div className="mx-auto flex max-w-md flex-col gap-4">
          <div className="text-6xl">âš ï¸</div>
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-gray-900">
              í”Œëœì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-gray-500">
              ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
            </p>
          </div>
        </div>
      </div>
    );
  }
}
</file>

<file path="_components/TodayPlanListView.tsx">
"use client";

import { useState } from "react";
import { ViewModeSelector, ViewMode } from "./ViewModeSelector";
import { DailyPlanView } from "./DailyPlanView";
import { SinglePlanView } from "./SinglePlanView";
import { PlanGroup } from "../_utils/planGroupUtils";

type TodayPlanListViewProps = {
  groups: PlanGroup[];
  sessions: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>;
  planDate: string;
  memos: Map<number | null, string | null>; // planNumber -> memo
  totalPagesMap: Map<string, number>; // contentKey -> totalPages
  initialMode?: ViewMode;
  initialSelectedPlanNumber?: number | null;
  serverNow?: number;
  campMode?: boolean; // ìº í”„ ëª¨ë“œ ì—¬ë¶€
};

export function TodayPlanListView({
  groups,
  sessions,
  planDate,
  memos,
  totalPagesMap,
  initialMode = "single",
  initialSelectedPlanNumber = null,
  serverNow = Date.now(),
  campMode = false,
}: TodayPlanListViewProps) {
  const [viewMode, setViewMode] = useState<ViewMode>(initialMode);
  const [selectedPlanNumber, setSelectedPlanNumber] = useState<number | null>(
    initialSelectedPlanNumber ?? groups[0]?.planNumber ?? null
  );

  const handleViewDetail = (planNumber: number | null) => {
    setSelectedPlanNumber(planNumber);
    setViewMode("single");
  };

  const handleModeChange = (mode: ViewMode) => {
    setViewMode(mode);
    if (mode === "single" && !selectedPlanNumber) {
      // ë‹¨ì¼ ë·°ë¡œ ì „í™˜í•  ë•Œ ì„ íƒëœ í”Œëœì´ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í”Œëœ ì„ íƒ
      setSelectedPlanNumber(groups[0]?.planNumber ?? null);
    }
  };

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-end">
        <ViewModeSelector mode={viewMode} onChange={handleModeChange} />
      </div>

      {viewMode === "daily" ? (
        <DailyPlanView
          groups={groups}
          sessions={sessions}
          planDate={planDate}
          memos={memos}
          totalPagesMap={totalPagesMap}
          onViewDetail={handleViewDetail}
          campMode={campMode}
        />
      ) : (
        <SinglePlanView
          groups={groups}
          selectedPlanNumber={selectedPlanNumber}
          onSelectPlan={setSelectedPlanNumber}
          sessions={sessions}
          planDate={planDate}
          serverNow={serverNow}
          campMode={campMode}
        />
      )}
    </div>
  );
}
</file>

<file path="_components/TodayPlansSection.tsx">
"use client";

import { PlanViewContainer, type ViewMode } from "./PlanViewContainer";
import { useTodayPageContext } from "./TodayPageContext";
import type { PlanWithContent } from "../_utils/planGroupUtils";

type PlansResponse = {
  plans: PlanWithContent[];
  sessions: Record<string, {
    isPaused: boolean;
    startedAt?: string | null;
    pausedAt?: string | null;
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }>;
  planDate: string;
  isToday?: boolean;
  serverNow?: number;
  todayProgress?: import("@/lib/metrics/todayProgress").TodayProgress | null;
};

type TodayPlansSectionProps = {
  initialMode: ViewMode;
  initialPlanDate?: string | null;
  userId?: string;
  campMode?: boolean;
  initialPlansData?: PlansResponse;
};

export function TodayPlansSection({
  initialMode,
  initialPlanDate = null,
  userId,
  campMode = false,
  initialPlansData,
}: TodayPlansSectionProps) {
  const { handleDateChange } = useTodayPageContext();

  return (
    <PlanViewContainer
      initialMode={initialMode}
      initialPlanDate={initialPlanDate}
      onDateChange={handleDateChange}
      userId={userId}
      campMode={campMode}
      initialData={initialPlansData}
    />
  );
}
</file>

<file path="_components/TodayRecommendations.tsx">
import { getRecommendations, getTopRecommendations } from "@/lib/recommendations/engine";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";

export async function TodayRecommendations() {
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      return null;
    }

    const supabase = await createSupabaseServerClient();
    const recommendations = await getRecommendations(supabase, user.userId).catch(
      (error) => {
        console.error("[TodayRecommendations] ì¶”ì²œ ì¡°íšŒ ì‹¤íŒ¨", error);
        return { subjects: [], goals: [], studyPlan: [], contents: [] };
      }
    );
    const topRecommendations = getTopRecommendations(recommendations, 3);

    if (topRecommendations.length === 0) {
      return null;
    }

  return (
    <div className="rounded-xl border border-blue-200 bg-gradient-to-br from-blue-50 to-indigo-50 p-4">
      <div className="flex flex-col gap-4">
        <h2 className="text-lg font-semibold text-gray-900">ì˜¤ëŠ˜ ì¶”ì²œ</h2>
        <ul className="flex flex-col gap-2">
          {topRecommendations.map((rec, index) => (
            <li key={index} className="flex items-start gap-2">
              <span className="flex h-5 w-5 shrink-0 items-center justify-center rounded-full bg-blue-100 text-xs font-semibold text-blue-700">
                {index + 1}
              </span>
              <p className="flex-1 text-sm leading-relaxed text-gray-700">{rec}</p>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
  } catch (error) {
    console.error("[TodayRecommendations] ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì‹¤íŒ¨", error);
    return null;
  }
}
</file>

<file path="_components/ViewModeSelector.tsx">
"use client";

import { cn } from "@/lib/cn";

export type ViewMode = "daily" | "single";

type ViewModeSelectorProps = {
  mode: ViewMode;
  onChange: (mode: ViewMode) => void;
  className?: string;
};

export function ViewModeSelector({
  mode,
  onChange,
  className,
}: ViewModeSelectorProps) {
  return (
    <div
      role="group"
      aria-label="í”Œëœ ë³´ê¸° ëª¨ë“œ ì„ íƒ"
      className={cn(
        "flex gap-2 rounded-lg border border-gray-200 bg-white p-1",
        className
      )}
    >
      <button
        onClick={() => onChange("single")}
        aria-label="ë‹¨ì¼ í”Œëœ ë³´ê¸°"
        aria-pressed={mode === "single"}
        className={cn(
          "flex flex-1 items-center justify-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition",
          mode === "single"
            ? "bg-indigo-600 text-white"
            : "text-gray-600 hover:bg-gray-50"
        )}
      >
        <span aria-hidden="true">ğŸ“Œ</span>
        <span>ë‹¨ì¼ ë·°</span>
      </button>
      <button
        onClick={() => onChange("daily")}
        aria-label="ì¼ì¼ í”Œëœ ëª©ë¡ ë³´ê¸°"
        aria-pressed={mode === "daily"}
        className={cn(
          "flex flex-1 items-center justify-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition",
          mode === "daily"
            ? "bg-indigo-600 text-white"
            : "text-gray-600 hover:bg-gray-50"
        )}
      >
        <span aria-hidden="true">ğŸ“‹</span>
        <span>ì¼ì¼ ë·°</span>
      </button>
    </div>
  );
}
</file>

<file path="_utils/dateDisplay.ts">
const DAY_NAMES = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "] as const;

function isIsoDate(value: string | null | undefined): value is string {
  return typeof value === "string" && /^\d{4}-\d{2}-\d{2}$/.test(value);
}

function parseIsoDate(value: string): Date | null {
  if (!isIsoDate(value)) {
    return null;
  }

  const [year, month, day] = value.split("-").map(Number);
  const date = new Date(year, (month ?? 1) - 1, day ?? 1);

  return Number.isNaN(date.getTime()) ? null : date;
}

export function formatKoreanDate(dateStr: string): string {
  const date = parseIsoDate(dateStr);
  if (!date) {
    return "-";
  }

  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  return `${year}ë…„ ${month}ì›” ${day}ì¼`;
}

export function formatKoreanDateWithDay(dateStr: string): string {
  const date = parseIsoDate(dateStr);
  if (!date) {
    return "-";
  }

  const base = formatKoreanDate(dateStr);
  const dayName = DAY_NAMES[date.getDay()] ?? "";

  return `${base} (${dayName})`;
}

export function getRelativeDateLabel(
  targetDateStr: string,
  baseDateStr?: string
): string {
  const target = parseIsoDate(targetDateStr);
  const resolvedBase =
    (baseDateStr && parseIsoDate(baseDateStr)) ||
    (() => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return today;
    })();

  if (!target || !resolvedBase) {
    return "-";
  }

  // ë™ì¼ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê¸°
  target.setHours(0, 0, 0, 0);
  resolvedBase.setHours(0, 0, 0, 0);

  const diffMs = target.getTime() - resolvedBase.getTime();
  const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

  if (diffDays === 0) return "ì˜¤ëŠ˜";
  if (diffDays === 1) return "ë‚´ì¼";
  if (diffDays === 2) return "ëª¨ë ˆ";
  if (diffDays === -1) return "ì–´ì œ";
  if (diffDays === -2) return "ê·¸ì œ";
  if (diffDays > 2 && diffDays <= 7) return `${diffDays}ì¼ í›„`;
  if (diffDays < -2 && diffDays >= -7) return `${Math.abs(diffDays)}ì¼ ì „`;

  return formatKoreanDate(targetDateStr);
}

import { formatDateString } from "@/lib/date/calendarUtils";

export function getTodayISODate(): string {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  return formatDateString(today);
}
</file>

<file path="_utils/navigationUtils.ts">
/**
 * ë„¤ë¹„ê²Œì´ì…˜ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
 * í”Œëœ ì‹¤í–‰ í˜ì´ì§€ë¡œ ì´ë™í•˜ëŠ” URLì„ ìƒì„±í•©ë‹ˆë‹¤.
 */

/**
 * í”Œëœ ì‹¤í–‰ í˜ì´ì§€ URLì„ ìƒì„±í•©ë‹ˆë‹¤.
 * @param planId - í”Œëœ ID
 * @param campMode - ìº í”„ ëª¨ë“œ ì—¬ë¶€ (ê¸°ë³¸ê°’: false)
 * @returns í”Œëœ ì‹¤í–‰ í˜ì´ì§€ URL
 */
export function buildPlanExecutionUrl(
  planId: string,
  campMode: boolean = false
): string {
  const query = campMode ? "?mode=camp" : "";
  return `/today/plan/${planId}${query}`;
}
</file>

<file path="_utils/planGroupUtils.ts">
import type { Plan } from "@/lib/data/studentPlans";
import type { Book, Lecture, CustomContent } from "@/lib/data/studentContents";

export type PlanWithContent = Plan & {
  content?: Book | Lecture | CustomContent;
  progress?: number | null;
  session?: { 
    isPaused: boolean;
    startedAt?: string | null;
    pausedAt?: string | null;
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  };
};

export type PlanGroup = {
  planNumber: number | null;
  plan: PlanWithContent; // ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœ ì¤‘ ê°€ì¥ ë¹ ë¥¸ ì‹œì‘ ì‹œê°„ì„ ê°€ì§„ í”Œëœ
  content: Book | Lecture | CustomContent | undefined;
  sequence: number | null; // íšŒì°¨
};

/**
 * ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì„ ê·¸ë£¹í™”
 * ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì€ ê°™ì€ ì •ë³´ë¥¼ ê°€ì§€ë¯€ë¡œ, ê°€ì¥ ë¹ ë¥¸ ì‹œì‘ ì‹œê°„ì„ ê°€ì§„ í”Œëœ í•˜ë‚˜ë§Œ ì„ íƒ
 */
export function groupPlansByPlanNumber(plans: PlanWithContent[] | null | undefined): PlanGroup[] {
  if (!plans || !Array.isArray(plans)) {
    return [];
  }

  const groups = new Map<number | null, PlanWithContent[]>();

  plans.forEach((plan) => {
    const planNumber = plan.plan_number ?? null;
    if (!groups.has(planNumber)) {
      groups.set(planNumber, []);
    }
    groups.get(planNumber)!.push(plan);
  });

  return Array.from(groups.entries()).map(([planNumber, plans]) => {
    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœ ì¤‘ ê°€ì¥ ë¹ ë¥¸ ì‹œì‘ ì‹œê°„ì„ ê°€ì§„ í”Œëœ ì„ íƒ
    const selectedPlan = plans.reduce((earliest, current) => {
      const earliestTime = earliest.start_time || "";
      const currentTime = current.start_time || "";
      
      // start_timeì´ ì—†ìœ¼ë©´ block_indexë¡œ ë¹„êµ
      if (!earliestTime && !currentTime) {
        return (earliest.block_index ?? 0) < (current.block_index ?? 0) ? earliest : current;
      }
      
      // start_timeì´ ìˆëŠ” ê²ƒ ìš°ì„ 
      if (earliestTime && !currentTime) return earliest;
      if (!earliestTime && currentTime) return current;
      
      // ë‘˜ ë‹¤ ìˆìœ¼ë©´ ì‹œê°„ ë¹„êµ
      return earliestTime < currentTime ? earliest : current;
    });

    return {
      planNumber,
      plan: selectedPlan, // ê°€ì¥ ë¹ ë¥¸ ì‹œì‘ ì‹œê°„ì„ ê°€ì§„ í”Œëœ í•˜ë‚˜ë§Œ
      content: selectedPlan?.content,
      sequence: selectedPlan?.sequence ?? null,
    };
  });
}

/**
 * í™œì„± í”Œëœ í™•ì¸
 */
export function getActivePlan(
  planGroup: PlanGroup,
  sessions: Map<string, { isPaused: boolean }>
): Plan | null {
  const plan = planGroup.plan;
  const session = sessions.get(plan.id);
  return (
    plan.actual_start_time &&
    !plan.actual_end_time &&
    (!session || !session.isPaused)
  ) ? plan : null;
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ì „ì²´ ì§„í–‰ë¥  ê³„ì‚°
 */
export function getPlanProgressPercent(plan: PlanWithContent): number {
  if (plan.actual_end_time) {
    return 100;
  }

  if (typeof plan.progress === "number" && !Number.isNaN(plan.progress)) {
    return Math.min(100, Math.max(0, Math.round(plan.progress)));
  }

  const totalRange =
    (plan.planned_end_page_or_time ?? 0) -
    (plan.planned_start_page_or_time ?? 0);
  const completedAmount = plan.completed_amount ?? null;

  if (completedAmount !== null && totalRange > 0) {
    return Math.min(
      100,
      Math.max(0, Math.round((completedAmount / totalRange) * 100))
    );
  }

  return 0;
}

export function calculateGroupProgress(planGroup: PlanGroup): number {
  return getPlanProgressPercent(planGroup.plan);
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ì´ í•™ìŠµ ì‹œê°„ ê³„ì‚° (ì´ˆ ë‹¨ìœ„)
 */
export function calculateGroupTotalStudyTime(
  planGroup: PlanGroup,
  sessions?: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>
): number {
  const plan = planGroup.plan;
  // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•œ í•™ìŠµ ì‹œê°„ ê³„ì‚°
  const session = sessions?.get(plan.id);
  const isCurrentlyPaused = session?.isPaused ?? false;
  const currentPausedAt = session?.pausedAt ?? null;
  
  return calculateStudyTimeFromTimestamps(
    plan.actual_start_time,
    plan.actual_end_time,
    plan.paused_duration_seconds,
    isCurrentlyPaused,
    currentPausedAt
  );
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ í™œì„± í”Œëœ ìˆ˜
 */
export function getActivePlansCount(
  planGroup: PlanGroup,
  sessions: Map<string, { isPaused: boolean }>
): number {
  const plan = planGroup.plan;
  const session = sessions.get(plan.id);
  return (
    plan.actual_start_time &&
    !plan.actual_end_time &&
    (!session || !session.isPaused)
  ) ? 1 : 0;
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ì™„ë£Œ í”Œëœ ìˆ˜
 */
export function getCompletedPlansCount(planGroup: PlanGroup): number {
  return planGroup.plan.actual_end_time ? 1 : 0;
}

/**
 * ì‹œê°„ í¬ë§·íŒ… (ì´ˆë¥¼ HH:MM:SS ë˜ëŠ” MM:SS í˜•ì‹ìœ¼ë¡œ)
 */
export function formatTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  if (hours > 0) {
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
      2,
      "0"
    )}:${String(secs).padStart(2, "0")}`;
  }
  return `${String(minutes).padStart(2, "0")}:${String(secs).padStart(
    2,
    "0"
  )}`;
}

/**
 * íƒ€ì„ìŠ¤í…œí”„ í¬ë§·íŒ… (YYYY-MM-DD HH:mm:ss)
 */
export function formatTimestamp(timestamp: string | null | undefined): string {
  if (!timestamp) return "-";
  try {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const seconds = String(date.getSeconds()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  } catch {
    return "-";
  }
}

/**
 * í•™ìŠµ ë²”ìœ„ ê³„ì‚° (ì‹œì‘ ~ ì¢…ë£Œ)
 */
export function getLearningRange(plans: PlanWithContent[]): string {
  if (plans.length === 0) return "-";
  
  const sortedPlans = plans.sort((a, b) => (a.block_index ?? 0) - (b.block_index ?? 0));
  const firstPlan = sortedPlans[0];
  const lastPlan = sortedPlans[sortedPlans.length - 1];
  
  const start = firstPlan.planned_start_page_or_time ?? 0;
  const end = lastPlan.planned_end_page_or_time ?? 0;
  
  if (firstPlan.content_type === "book") {
    return `p.${start} ~ p.${end}`;
  } else {
    // ê°•ì˜ë‚˜ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ëŠ” ì‹œê°„ í˜•ì‹
    return `${formatTime(start)} ~ ${formatTime(end)}`;
  }
}

/**
 * ì´ í•™ìŠµ ë²”ìœ„ ê³„ì‚° (ëª¨ë“  ë¸”ë¡ì˜ í•©ì‚°)
 */
export function getTotalRange(plans: PlanWithContent[]): number {
  return plans.reduce((sum, plan) => {
    const range =
      (plan.planned_end_page_or_time ?? 0) -
      (plan.planned_start_page_or_time ?? 0);
    return sum + range;
  }, 0);
}

/**
 * íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ì´ í•™ìŠµ ì‹œê°„ ê³„ì‚°
 * @param startTime ì‹œì‘ íƒ€ì„ìŠ¤íƒ¬í”„
 * @param endTime ì¢…ë£Œ íƒ€ì„ìŠ¤íƒ¬í”„ (ì—†ìœ¼ë©´ í˜„ì¬ ì‹œê°„ ì‚¬ìš©)
 * @param pausedDurationSeconds ì¼ì‹œì •ì§€ëœ ì´ ì‹œê°„ (ì´ˆ) - ì´ë¯¸ ì™„ë£Œëœ ì¼ì‹œì •ì§€ ì‹œê°„
 * @param isCurrentlyPaused í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ì§€ ì—¬ë¶€
 * @param currentPausedAt í˜„ì¬ ì¼ì‹œì •ì§€ ì‹œì‘ ì‹œê°„ (isCurrentlyPausedê°€ trueì¼ ë•Œë§Œ ì‚¬ìš©)
 * @returns ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ (ì´ˆ)
 */
export function calculateStudyTimeFromTimestamps(
  startTime: string | null | undefined,
  endTime: string | null | undefined,
  pausedDurationSeconds: number | null | undefined,
  isCurrentlyPaused?: boolean,
  currentPausedAt?: string | null
): number {
  if (!startTime) return 0;

  const start = new Date(startTime).getTime();
  const end = endTime ? new Date(endTime).getTime() : Date.now();
  const totalSeconds = Math.floor((end - start) / 1000);
  
  // ì´ë¯¸ ì™„ë£Œëœ ì¼ì‹œì •ì§€ ì‹œê°„
  let pausedSeconds = pausedDurationSeconds || 0;
  
  // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš° ì¶”ê°€ ê³„ì‚°
  if (isCurrentlyPaused && currentPausedAt && !endTime) {
    const pausedAt = new Date(currentPausedAt).getTime();
    const now = Date.now();
    pausedSeconds += Math.floor((now - pausedAt) / 1000);
  }

  return Math.max(0, totalSeconds - pausedSeconds);
}

/**
 * ì„¸ì…˜ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ì´ í•™ìŠµ ì‹œê°„ ê³„ì‚°
 * @param session ì„¸ì…˜ ì •ë³´ (started_at, ended_at, paused_at, resumed_at, paused_duration_seconds)
 * @returns ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ (ì´ˆ)
 */
export function calculateStudyTimeFromSession(session: {
  started_at: string;
  ended_at?: string | null;
  paused_at?: string | null;
  resumed_at?: string | null;
  paused_duration_seconds?: number | null;
}): number {
  const start = new Date(session.started_at).getTime();
  const end = session.ended_at ? new Date(session.ended_at).getTime() : Date.now();
  const totalSeconds = Math.floor((end - start) / 1000);
  
  // ì¼ì‹œì •ì§€ ì‹œê°„ ê³„ì‚°
  let pausedSeconds = session.paused_duration_seconds || 0;
  
  // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš° ì¶”ê°€ ê³„ì‚°
  if (session.paused_at && !session.resumed_at && !session.ended_at) {
    const pausedAt = new Date(session.paused_at).getTime();
    const now = Date.now();
    pausedSeconds += Math.floor((now - pausedAt) / 1000);
  }

  return Math.max(0, totalSeconds - pausedSeconds);
}

/**
 * ì‹œê°„ í†µê³„ ê³„ì‚°
 */
export type TimeStats = {
  totalDuration: number; // ì´ í•™ìŠµ ì‹œê°„ (ì´ˆ)
  pureStudyTime: number; // ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ (ì¼ì‹œì •ì§€ ì œì™¸, ì´ˆ)
  pausedDuration: number; // ì¼ì‹œì •ì§€ ì‹œê°„ (ì´ˆ)
  pauseCount: number; // ì¼ì‹œì •ì§€ íšŸìˆ˜
  firstStartTime: string | null; // ì²« ì‹œì‘ ì‹œê°„
  lastEndTime: string | null; // ë§ˆì§€ë§‰ ì¢…ë£Œ ì‹œê°„
  isActive: boolean; // ì§„í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€
  isCompleted: boolean; // ëª¨ë“  í”Œëœì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
  currentPausedAt: string | null; // í˜„ì¬ ì¼ì‹œì •ì§€ ì‹œê°„ (ì§„í–‰ ì¤‘ì´ê³  ì¼ì‹œì •ì§€ëœ ê²½ìš°)
  lastPausedAt: string | null; // ë§ˆì§€ë§‰ ì¼ì‹œì •ì§€ ì‹œê°„ (ì¬ì‹œì‘ í›„ì—ë„ í‘œì‹œ)
  lastResumedAt: string | null; // ë§ˆì§€ë§‰ ì¬ì‹œì‘ ì‹œê°„
};

export function getTimeStats(
  plans: PlanWithContent[],
  activePlan: Plan | null,
  sessions?: Map<string, { isPaused: boolean; pausedAt?: string | null; resumedAt?: string | null }>
): TimeStats {
  const totalDuration = plans.reduce(
    (sum, plan) => sum + (plan.total_duration_seconds ?? 0),
    0
  );

  const pausedDuration = plans.reduce(
    (sum, plan) => sum + (plan.paused_duration_seconds ?? 0),
    0
  );

  const pureStudyTime = totalDuration - pausedDuration;

  const pauseCount = plans.reduce(
    (sum, plan) => sum + (plan.pause_count ?? 0),
    0
  );

  const plansWithStartTime = plans
    .filter((p) => p.actual_start_time)
    .sort(
      (a, b) =>
        new Date(a.actual_start_time!).getTime() -
        new Date(b.actual_start_time!).getTime()
    );

  const firstStartTime =
    plansWithStartTime.length > 0
      ? plansWithStartTime[0].actual_start_time!
      : null;

  const plansWithEndTime = plans
    .filter((p) => p.actual_end_time)
    .sort(
      (a, b) =>
        new Date(b.actual_end_time!).getTime() -
        new Date(a.actual_end_time!).getTime()
    );

  const lastEndTime =
    plansWithEndTime.length > 0 ? plansWithEndTime[0].actual_end_time! : null;

  // ëª¨ë“  í”Œëœì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
  const isCompleted = plans.length > 0 && plans.every((p) => !!p.actual_end_time);

  // í˜„ì¬ ì¼ì‹œì •ì§€ ì‹œê°„ ë° ë§ˆì§€ë§‰ ì¬ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  // ì¼ì‹œì •ì§€ëœ í”Œëœë„ ì°¾ì•„ì„œ currentPausedAt ê³„ì‚° (activePlanì´ nullì¼ ìˆ˜ ìˆìŒ)
  let currentPausedAt: string | null = null;
  let lastPausedAt: string | null = null;
  let lastResumedAt: string | null = null;

  if (sessions) {
    // ì¼ì‹œì •ì§€ëœ í”Œëœ ì°¾ê¸° (activePlanì´ ì—†ì–´ë„ ì¼ì‹œì •ì§€ëœ í”Œëœì€ ì°¾ì„ ìˆ˜ ìˆìŒ)
    const pausedPlan = plans.find((plan) => {
      const session = sessions.get(plan.id);
      return (
        plan.actual_start_time &&
        !plan.actual_end_time &&
        session &&
        session.isPaused
      );
    });

    if (pausedPlan) {
      // ì¼ì‹œì •ì§€ëœ í”Œëœ: í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì´ë¯€ë¡œ currentPausedAtë§Œ ì„¤ì •
      const session = sessions.get(pausedPlan.id);
      if (session) {
        currentPausedAt = session.pausedAt || null;
        // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ lastPausedAtì€ null (ì¬ì‹œì‘ í›„ì—ë§Œ ì„¤ì •)
        lastPausedAt = null;
        lastResumedAt = session.resumedAt || null;
      }
    } else if (activePlan) {
      // ì¼ì‹œì •ì§€ëœ í”Œëœì´ ì—†ìœ¼ë©´ í™œì„± í”Œëœì˜ ì„¸ì…˜ ì •ë³´ ì‚¬ìš©
      const session = sessions.get(activePlan.id);
      if (session) {
        if (session.isPaused) {
          // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘
          currentPausedAt = session.pausedAt || null;
          lastPausedAt = null;
        } else {
          // ì¬ì‹œì‘ëœ í”Œëœì˜ ê²½ìš° ë§ˆì§€ë§‰ ì¼ì‹œì •ì§€ ì‹œê°„ í‘œì‹œ
          currentPausedAt = null;
          if (session.pausedAt && session.resumedAt) {
            lastPausedAt = session.pausedAt;
          }
        }
        lastResumedAt = session.resumedAt || null;
      }
    } else {
      // í™œì„± í”Œëœë„ ì—†ìœ¼ë©´ ì¬ì‹œì‘ëœ í”Œëœ ì°¾ê¸° (pausedAtê³¼ resumedAtì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°)
      const resumedPlan = plans.find((plan) => {
        const session = sessions.get(plan.id);
        return (
          plan.actual_start_time &&
          !plan.actual_end_time &&
          session &&
          session.pausedAt &&
          session.resumedAt &&
          !session.isPaused
        );
      });

      if (resumedPlan) {
        const session = sessions.get(resumedPlan.id);
        if (session) {
          lastPausedAt = session.pausedAt || null;
          lastResumedAt = session.resumedAt || null;
        }
      }
    }
  }

  return {
    totalDuration,
    pureStudyTime,
    pausedDuration,
    pauseCount,
    firstStartTime,
    lastEndTime,
    isActive: !!activePlan && !isCompleted,
    isCompleted,
    currentPausedAt,
    lastPausedAt,
    lastResumedAt,
  };
}
</file>

<file path="actions/planMemoActions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseServerClient } from "@/lib/supabase/server";

/**
 * í”Œëœ ê·¸ë£¹ì˜ ë©”ëª¨ ì¡°íšŒ
 */
export async function getPlanMemo(
  planNumber: number | null,
  planDate: string
): Promise<{ success: boolean; memo?: string | null; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const tenantContext = await getTenantContext();

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœ ì¤‘ í•˜ë‚˜ë¥¼ ì°¾ì•„ì„œ ë©”ëª¨ ì¡°íšŒ
    // ë©”ëª¨ëŠ” ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ ê°„ì— ê³µìœ ëœë‹¤ê³  ê°€ì •
    const { data: plan } = await supabase
      .from("student_plan")
      .select("memo")
      .eq("student_id", user.userId)
      .eq("plan_date", planDate)
      .eq("plan_number", planNumber ?? null)
      .limit(1)
      .maybeSingle();

    if (!plan) {
      // plan_numberê°€ nullì¸ ê²½ìš°ë„ ì²˜ë¦¬
      if (planNumber === null) {
        // plan_numberê°€ nullì¸ í”Œëœ ì¡°íšŒ
        const { data: planNull } = await supabase
          .from("student_plan")
          .select("memo")
          .eq("student_id", user.userId)
          .eq("plan_date", planDate)
          .is("plan_number", null)
          .limit(1)
          .maybeSingle();

        return { success: true, memo: planNull?.memo ?? null };
      }
      return { success: true, memo: null };
    }

    return { success: true, memo: plan.memo ?? null };
  } catch (error) {
    console.error("[planMemoActions] ë©”ëª¨ ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ëª¨ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ë©”ëª¨ ì €ì¥
 */
export async function savePlanMemo(
  planNumber: number | null,
  planDate: string,
  memo: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const tenantContext = await getTenantContext();

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœì˜ ë©”ëª¨ ì—…ë°ì´íŠ¸
    const trimmedMemo = memo.trim();
    const updateData: { memo: string | null; updated_at: string } = {
      memo: trimmedMemo.length > 0 ? trimmedMemo : null,
      updated_at: new Date().toISOString(),
    };

    let query = supabase
      .from("student_plan")
      .update(updateData)
      .eq("student_id", user.userId)
      .eq("plan_date", planDate);

    if (planNumber === null) {
      query = query.is("plan_number", null);
    } else {
      query = query.eq("plan_number", planNumber);
    }

    const { error } = await query;

    if (error) {
      // memo ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ í´ë°±
      if (error.code === "42703") {
        console.warn("[planMemoActions] memo ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. í…Œì´ë¸” ìŠ¤í‚¤ë§ˆë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
        return {
          success: false,
          error: "ë©”ëª¨ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.",
        };
      }
      throw error;
    }

    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { success: true };
  } catch (error) {
    console.error("[planMemoActions] ë©”ëª¨ ì €ì¥ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë©”ëª¨ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/planOrderActions.ts">
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";

type PlanOrderUpdate = {
  planId: string;
  newBlockIndex: number;
};

export async function updatePlanOrder(
  planDate: string,
  updates: PlanOrderUpdate[]
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // íŠ¸ëœì­ì…˜ì²˜ëŸ¼ ëª¨ë“  ì—…ë°ì´íŠ¸ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬
    const updatePromises = updates.map((update) =>
      supabase
        .from("student_plan")
        .update({ block_index: update.newBlockIndex })
        .eq("id", update.planId)
        .eq("student_id", user.id)
        .eq("plan_date", planDate)
    );

    const results = await Promise.all(updatePromises);

    // ì—ëŸ¬ í™•ì¸
    for (const result of results) {
      if (result.error) {
        console.error("[planOrder] ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", result.error);
        return {
          success: false,
          error: "í”Œëœ ìˆœì„œ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }
    }

    return { success: true };
  } catch (error: any) {
    console.error("[planOrder] ì˜¤ë¥˜:", error);
    return {
      success: false,
      error: error.message || "í”Œëœ ìˆœì„œ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/planRangeActions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { pausePlan } from "./todayActions";

type PlanRange = {
  planId: string;
  startPageOrTime: number;
  endPageOrTime: number;
};

/**
 * í”Œëœ ê·¸ë£¹ì˜ ë²”ìœ„ ì¼ê´„ ì¡°ì •
 */
export async function adjustPlanRanges(
  planIds: string[],
  ranges: PlanRange[]
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // 1. ì§„í–‰ ì¤‘ì¸ í”Œëœ ì¼ì‹œì •ì§€
    for (const planId of planIds) {
      // í™œì„± ì„¸ì…˜ í™•ì¸
      const { data: activeSession } = await supabase
        .from("student_study_sessions")
        .select("id, paused_at")
        .eq("plan_id", planId)
        .eq("student_id", user.userId)
        .is("ended_at", null)
        .maybeSingle();

      // ì§„í–‰ ì¤‘ì´ê³  ì¼ì‹œì •ì§€ë˜ì§€ ì•Šì€ ê²½ìš° ì¼ì‹œì •ì§€
      if (activeSession && !activeSession.paused_at) {
        await pausePlan(planId);
      }
    }

    // 2. ë²”ìœ„ ì—…ë°ì´íŠ¸
    const updates = ranges.map((range) => ({
      id: range.planId,
      planned_start_page_or_time: range.startPageOrTime,
      planned_end_page_or_time: range.endPageOrTime,
      updated_at: new Date().toISOString(),
    }));

    // ë°°ì¹˜ ì—…ë°ì´íŠ¸ (SupabaseëŠ” í•œ ë²ˆì— ìµœëŒ€ 100ê°œê¹Œì§€)
    const batchSize = 100;
    for (let i = 0; i < updates.length; i += batchSize) {
      const batch = updates.slice(i, i + batchSize);

      // ê° í”Œëœì„ ê°œë³„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
      await Promise.all(
        batch.map(async (update) => {
          const { error } = await supabase
            .from("student_plan")
            .update({
              planned_start_page_or_time: update.planned_start_page_or_time,
              planned_end_page_or_time: update.planned_end_page_or_time,
              updated_at: update.updated_at,
            })
            .eq("id", update.id)
            .eq("student_id", user.userId);

          if (error) throw error;
        })
      );
    }

    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { success: true };
  } catch (error) {
    console.error("[planRangeActions] ë²”ìœ„ ì¡°ì • ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ë²”ìœ„ ì¡°ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/sessionTimeActions.ts">
"use server";

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseServerClient } from "@/lib/supabase/server";

export type TimeEvent = {
  type: "start" | "pause" | "resume" | "complete";
  timestamp: string;
  durationSeconds?: number | null;
};

/**
 * í”Œëœ ê·¸ë£¹ì˜ ì‹œê°„ ì´ë²¤íŠ¸ ì¡°íšŒ (ì„¸ì…˜ ë°ì´í„°ë¡œ ê³„ì‚°)
 */
export async function getTimeEventsByPlanNumber(
  planNumber: number | null,
  planDate: string
): Promise<{ success: boolean; events?: TimeEvent[]; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const tenantContext = await getTenantContext();

    // 1. í•´ë‹¹ plan_numberì™€ plan_dateë¥¼ ê°€ì§„ í”Œëœë“¤ ì¡°íšŒ
    const { data: plans, error: plansError } = await supabase
      .from("student_plan")
      .select("id, actual_start_time, actual_end_time")
      .eq("plan_number", planNumber)
      .eq("plan_date", planDate)
      .eq("student_id", user.userId);

    if (plansError) {
      console.error("[sessionTimeActions] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:", plansError);
      return { success: false, error: plansError.message };
    }

    if (!plans || plans.length === 0) {
      return { success: true, events: [] };
    }

    const planIds = plans.map((p) => p.id);

    // 2. í•´ë‹¹ í”Œëœë“¤ì˜ ì„¸ì…˜ ì¡°íšŒ (í•œ ë²ˆì— ëª¨ë“  í”Œëœ ID ì¡°íšŒ)
    const { data: sessionsData, error: sessionsError } = await supabase
      .from("student_study_sessions")
      .select("id, plan_id, started_at, ended_at, paused_at, resumed_at, paused_duration_seconds")
      .eq("student_id", user.userId)
      .in("plan_id", planIds)
      .order("started_at", { ascending: false });

    if (sessionsError) {
      console.error("[sessionTimeActions] ì„¸ì…˜ ì¡°íšŒ ì‹¤íŒ¨:", sessionsError);
      // ì„¸ì…˜ ì¡°íšŒ ì‹¤íŒ¨í•´ë„ í”Œëœ ë°ì´í„°ë¡œ ì‹œê°„ ì •ë³´ëŠ” í‘œì‹œ ê°€ëŠ¥
    }

    const relevantSessions = (sessionsData || []).filter(
      (session): session is typeof session & { plan_id: string } =>
        session.plan_id !== null && planIds.includes(session.plan_id)
    );

    // 3. ì‹œê°„ ì´ë²¤íŠ¸ ê³„ì‚°
    const events: TimeEvent[] = [];

    // ì‹œì‘ ì‹œê°„: í”Œëœì˜ actual_start_time
    const startTime = plans
      .map((p) => p.actual_start_time)
      .filter((t): t is string => t !== null)
      .sort()[0]; // ê°€ì¥ ë¹ ë¥¸ ì‹œì‘ ì‹œê°„

    if (startTime) {
      events.push({
        type: "start",
        timestamp: startTime,
        durationSeconds: 0,
      });
    }

    // ì¼ì‹œì •ì§€/ì¬ê°œ ì´ë²¤íŠ¸: ì„¸ì…˜ì˜ paused_at, resumed_at
    const pauseResumeEvents: Array<{ type: "pause" | "resume"; timestamp: string }> = [];

    relevantSessions.forEach((session) => {
      if (session.paused_at) {
        pauseResumeEvents.push({
          type: "pause",
          timestamp: session.paused_at,
        });
      }
      if (session.resumed_at) {
        pauseResumeEvents.push({
          type: "resume",
          timestamp: session.resumed_at,
        });
      }
    });

    // ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬
    pauseResumeEvents.sort(
      (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
    );

    // ì¼ì‹œì •ì§€/ì¬ê°œ ì´ë²¤íŠ¸ ì¶”ê°€ (duration ê³„ì‚°ì€ ë³µì¡í•˜ë¯€ë¡œ nullë¡œ ì„¤ì •)
    pauseResumeEvents.forEach((event) => {
      events.push({
        type: event.type,
        timestamp: event.timestamp,
        durationSeconds: null,
      });
    });

    // ì™„ë£Œ ì‹œê°„: í”Œëœì˜ actual_end_time
    const endTime = plans
      .map((p) => p.actual_end_time)
      .filter((t): t is string => t !== null)
      .sort()
      .reverse()[0]; // ê°€ì¥ ëŠ¦ì€ ì¢…ë£Œ ì‹œê°„

    if (endTime) {
      // ì™„ë£Œ ì‹œì ì˜ ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ ê³„ì‚°
      const plan = plans.find((p) => p.actual_end_time === endTime);
      let finalDuration: number | null = null;

      if (plan?.actual_start_time) {
        const start = new Date(plan.actual_start_time).getTime();
        const end = new Date(endTime).getTime();
        const totalSeconds = Math.floor((end - start) / 1000);

        // ì„¸ì…˜ì˜ ì¼ì‹œì •ì§€ ì‹œê°„ í•©ì‚°
        const session = relevantSessions.find((s) => s.plan_id === plan.id);
        const pausedSeconds = session?.paused_duration_seconds || 0;
        finalDuration = Math.max(0, totalSeconds - pausedSeconds);
      }

      events.push({
        type: "complete",
        timestamp: endTime,
        durationSeconds: finalDuration,
      });
    }

    // ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬
    events.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

    return { success: true, events };
  } catch (error) {
    console.error("[sessionTimeActions] ì‹œê°„ ì´ë²¤íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‹œê°„ ì´ë²¤íŠ¸ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/timerResetActions.ts">
"use server";

import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { endStudySession } from "@/app/(student)/actions/studySessionActions";
import { revalidatePath } from "next/cache";

/**
 * í”Œëœ ê·¸ë£¹ì˜ íƒ€ì´ë¨¸ ê¸°ë¡ ì´ˆê¸°í™”
 * plan_numberë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°™ì€ ê·¸ë£¹ì˜ ëª¨ë“  í”Œëœì˜ íƒ€ì´ë¨¸ ê¸°ë¡ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 */
export async function resetPlanTimer(
  planNumber: number | null,
  planDate: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const tenantContext = await getTenantContext();

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœ ì¡°íšŒ
    let query = supabase
      .from("student_plan")
      .select("id")
      .eq("student_id", user.userId)
      .eq("plan_date", planDate);

    if (planNumber === null) {
      query = query.is("plan_number", null);
    } else {
      query = query.eq("plan_number", planNumber);
    }

    const { data: plans, error: plansError } = await query;

    if (plansError) {
      console.error("[timerResetActions] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:", plansError);
      return { success: false, error: "í”Œëœ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    if (!plans || plans.length === 0) {
      return { success: false, error: "ì´ˆê¸°í™”í•  í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    const planIds = plans.map((p) => p.id);

    // 1. í™œì„± ì„¸ì…˜ ì¢…ë£Œ
    const { data: activeSessions } = await supabase
      .from("student_study_sessions")
      .select("id")
      .in("plan_id", planIds)
      .eq("student_id", user.userId)
      .is("ended_at", null);

    if (activeSessions && activeSessions.length > 0) {
      for (const session of activeSessions) {
        await endStudySession(session.id);
      }
    }

    // 2. í•´ë‹¹ í”Œëœì˜ ëª¨ë“  ì„¸ì…˜ ì‚­ì œ (ì „ì²´ ì§„í–‰ë¥  ë°˜ì˜ì„ ìœ„í•´)
    const { error: deleteSessionsError } = await supabase
      .from("student_study_sessions")
      .delete()
      .in("plan_id", planIds)
      .eq("student_id", user.userId);

    if (deleteSessionsError) {
      console.error("[timerResetActions] ì„¸ì…˜ ì‚­ì œ ì‹¤íŒ¨:", deleteSessionsError);
      // ì„¸ì…˜ ì‚­ì œ ì‹¤íŒ¨ëŠ” ì¹˜ëª…ì ì´ì§€ ì•Šìœ¼ë¯€ë¡œ ê³„ì† ì§„í–‰
    }

    // 3. í”Œëœì˜ íƒ€ì´ë¨¸ ê¸°ë¡ ë° ì§„í–‰ë¥  ì´ˆê¸°í™”
    const updateData = {
      actual_start_time: null,
      actual_end_time: null,
      total_duration_seconds: null,
      paused_duration_seconds: 0,
      pause_count: 0,
      progress: 0,
      completed_amount: 0,
    };

    const { error: updateError } = await supabase
      .from("student_plan")
      .update(updateData)
      .in("id", planIds)
      .eq("student_id", user.userId);

    if (updateError) {
      console.error("[timerResetActions] í”Œëœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
      return { success: false, error: "íƒ€ì´ë¨¸ ê¸°ë¡ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    // 4. student_content_progressì—ì„œ plan_idë¡œ ì—°ê²°ëœ ì§„í–‰ë¥  ì‚­ì œ
    const { error: deleteProgressError } = await supabase
      .from("student_content_progress")
      .delete()
      .in("plan_id", planIds)
      .eq("student_id", user.userId);

    if (deleteProgressError) {
      console.error("[timerResetActions] ì§„í–‰ë¥  ì‚­ì œ ì‹¤íŒ¨:", deleteProgressError);
      // ì§„í–‰ë¥  ì‚­ì œ ì‹¤íŒ¨ëŠ” ì¹˜ëª…ì ì´ì§€ ì•Šìœ¼ë¯€ë¡œ ê³„ì† ì§„í–‰
    }

    revalidatePath("/today");
    revalidatePath("/camp/today");
    revalidatePath("/dashboard");
    return { success: true };
  } catch (error) {
    console.error("[timerResetActions] íƒ€ì´ë¨¸ ì´ˆê¸°í™” ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "íƒ€ì´ë¨¸ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/todayActions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getPlanById, updatePlan } from "@/lib/data/studentPlans";
import { startStudySession, endStudySession } from "@/app/(student)/actions/studySessionActions";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { formatDateString } from "@/lib/date/calendarUtils";

type PlanRecordPayload = {
  startPageOrTime: number;
  endPageOrTime: number;
  memo?: string | null;
};

/**
 * í”Œëœ ì‹œì‘ (íƒ€ì´ë¨¸ ì‹œì‘)
 *
 * ê²½í•© ë°©ì§€ ê·œì¹™:
 * 1. ë™ì‹œ ì‹¤í–‰ ê¸ˆì§€: í•œ í•™ìƒì´ ë™ì‹œì— ì—¬ëŸ¬ í”Œëœì„ RUNNING ìƒíƒœë¡œ ë‘˜ ìˆ˜ ì—†ìŒ
 * 2. ì™„ë£Œëœ í”Œëœ ì¬ì‹œì‘ ê¸ˆì§€: actual_end_timeì´ ì„¤ì •ëœ í”Œëœì€ ë‹¤ì‹œ ì‹œì‘í•  ìˆ˜ ì—†ìŒ
 *
 * @see docs/refactoring/timer_state_machine.md
 */
export async function startPlan(
  planId: string,
  timestamp?: string // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìƒì„±í•œ íƒ€ì„ìŠ¤íƒ¬í”„
): Promise<{
  success: boolean;
  sessionId?: string;
  error?: string;
  serverNow?: number;
  status?: "RUNNING";
  startedAt?: string;
  accumulatedSeconds?: number;
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const tenantContext = await getTenantContext();

    // [ê²½í•© ë°©ì§€ ê·œì¹™ 2] ì™„ë£Œëœ í”Œëœ ì¬ì‹œì‘ ë°©ì§€
    const { data: plan, error: planError } = await supabase
      .from("student_plan")
      .select("id, actual_end_time")
      .eq("id", planId)
      .eq("student_id", user.userId)
      .maybeSingle();

    if (planError) {
      console.error("[todayActions] í”Œëœ ì¡°íšŒ ì˜¤ë¥˜:", planError);
      return { success: false, error: "í”Œëœ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." };
    }

    if (!plan) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    if (plan.actual_end_time) {
      return {
        success: false,
        error: "ì´ë¯¸ ì™„ë£Œëœ í”Œëœì…ë‹ˆë‹¤. ì™„ë£Œëœ í”Œëœì€ ë‹¤ì‹œ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    // [ê²½í•© ë°©ì§€ ê·œì¹™ 1] ë™ì‹œ ì‹¤í–‰ ê¸ˆì§€
    // ë‹¤ë¥¸ í”Œëœì´ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (í˜„ì¬ í”Œëœ ì œì™¸, ì¼ì‹œì •ì§€ëœ ì„¸ì…˜ ì œì™¸)
    // ì¼ì‹œì •ì§€ëœ ì„¸ì…˜ì€ paused_atì´ ìˆê³  resumed_atì´ ì—†ëŠ” ìƒíƒœ
    const { data: activeSessions, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("plan_id, paused_at, resumed_at")
      .eq("student_id", user.userId)
      .is("ended_at", null)
      .neq("plan_id", planId);

    if (sessionError) {
      console.error("[todayActions] í™œì„± ì„¸ì…˜ ì¡°íšŒ ì˜¤ë¥˜:", sessionError);
      return { success: false, error: "í™œì„± ì„¸ì…˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." };
    }

    // ì¼ì‹œì •ì§€ë˜ì§€ ì•Šì€ ì‹¤ì œ í™œì„± ì„¸ì…˜ë§Œ í•„í„°ë§
    const trulyActiveSessions = activeSessions?.filter(
      (session) => !session.paused_at || session.resumed_at
    ) || [];

    // ë‹¤ë¥¸ í”Œëœì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì—ëŸ¬ ë°˜í™˜
    if (trulyActiveSessions.length > 0) {
      return { 
        success: false, 
        error: "ë‹¤ë¥¸ í”Œëœì˜ íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ë¨¼ì € í•´ë‹¹ í”Œëœì˜ íƒ€ì´ë¨¸ë¥¼ ì¤‘ì§€í•´ì£¼ì„¸ìš”." 
      };
    }

    // í•™ìŠµ ì„¸ì…˜ ì‹œì‘ (ë‚´ë¶€ì—ì„œ í”Œëœ ì¡°íšŒ ë° ê²€ì¦ ìˆ˜í–‰)
    const result = await startStudySession(planId);
    if (!result.success) {
      return { success: false, error: result.error };
    }

    // í”Œëœì˜ actual_start_time ì—…ë°ì´íŠ¸ (ì²˜ìŒ ì‹œì‘í•˜ëŠ” ê²½ìš°ë§Œ)
    // ì¡°íšŒ ì—†ì´ UPDATE ... WHERE actual_start_time IS NULLë¡œ ìµœì í™”
    const startTime = timestamp || new Date().toISOString();
    await supabase
      .from("student_plan")
      .update({
        actual_start_time: startTime,
      })
      .eq("id", planId)
      .eq("student_id", user.userId)
      .is("actual_start_time", null); // ì²˜ìŒ ì‹œì‘í•˜ëŠ” ê²½ìš°ë§Œ ì—…ë°ì´íŠ¸

    // ì„¸ì…˜ì˜ started_at ì¡°íšŒ (ì •í™•í•œ ì‹œì‘ ì‹œê° ì‚¬ìš©)
    let sessionStartedAt = startTime;
    if (result.sessionId) {
      const { data: session } = await supabase
        .from("student_study_sessions")
        .select("started_at")
        .eq("id", result.sessionId)
        .maybeSingle();
      
      if (session?.started_at) {
        sessionStartedAt = session.started_at;
      }
    }

    // ì„œë²„ í˜„ì¬ ì‹œê°„ ë°˜í™˜
    const serverNow = Date.now();

    // í•„ìš”í•œ ê²½ë¡œë§Œ ì¬ê²€ì¦ (ì„±ëŠ¥ ìµœì í™”)
    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { 
      success: true, 
      sessionId: result.sessionId,
      serverNow,
      status: "RUNNING" as const,
      accumulatedSeconds: 0,
      startedAt: sessionStartedAt,
    };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ì‹œì‘ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ì™„ë£Œ (ê¸°ë¡ ì €ì¥)
 */
export async function completePlan(
  planId: string,
  payload: PlanRecordPayload
): Promise<{ 
  success: boolean; 
  error?: string;
  serverNow?: number;
  status?: "COMPLETED";
  accumulatedSeconds?: number;
  startedAt?: string | null;
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const tenantContext = await getTenantContext();

  try {
    const supabase = await createSupabaseServerClient();

    // í”Œëœ ì¡°íšŒ
    const plan = await getPlanById(
      planId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!plan || !plan.content_type || !plan.content_id) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœ ì¡°íšŒ (ê°™ì€ ë…¼ë¦¬ì  í”Œëœ)
    let samePlanNumberPlans: Array<{ id: string }> = [];
    if (plan.plan_number !== null && plan.plan_number !== undefined) {
      const { data: plansWithSameNumber } = await supabase
        .from("student_plan")
        .select("id")
        .eq("student_id", user.userId)
        .eq("plan_number", plan.plan_number)
        .eq("plan_date", plan.plan_date);
      
      samePlanNumberPlans = plansWithSameNumber || [];
    } else {
      // plan_numberê°€ ì—†ìœ¼ë©´ í˜„ì¬ í”Œëœë§Œ ì²˜ë¦¬
      samePlanNumberPlans = [{ id: planId }];
    }

    // ì½˜í…ì¸  ì´ëŸ‰ ì¡°íšŒ
    let totalAmount: number | null = null;
    if (plan.content_type === "book") {
      const { data } = await supabase
        .from("books")
        .select("total_pages")
        .eq("id", plan.content_id)
        .maybeSingle();
      totalAmount = data?.total_pages ?? null;
    } else if (plan.content_type === "lecture") {
      const { data } = await supabase
        .from("lectures")
        .select("duration")
        .eq("id", plan.content_id)
        .maybeSingle();
      totalAmount = data?.duration ?? null;
    } else if (plan.content_type === "custom") {
      const { data } = await supabase
        .from("student_custom_contents")
        .select("total_page_or_time")
        .eq("id", plan.content_id)
        .maybeSingle();
      totalAmount = data?.total_page_or_time ?? null;
    }

    if (totalAmount === null || totalAmount <= 0) {
      return { success: false, error: "ì½˜í…ì¸  ì´ëŸ‰ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ì§„í–‰ë¥  ê³„ì‚°
    const completedAmount = payload.endPageOrTime - payload.startPageOrTime;
    const progress = Math.min(
      Math.round((completedAmount / totalAmount) * 100),
      100
    );

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœì˜ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
    for (const samePlan of samePlanNumberPlans) {
      await updatePlan(samePlan.id, user.userId, {
        completed_amount: completedAmount,
        progress: progress,
      });
    }

    // studentì˜ tenant_id ì¡°íšŒ (tenant_idê°€ ì—†ì–´ë„ ì§„í–‰ ê°€ëŠ¥í•˜ë„ë¡)
    const { data: student } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", user.userId)
      .maybeSingle();

    const tenantId = student?.tenant_id || tenantContext?.tenantId || null;

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœì˜ student_content_progressì— ê¸°ë¡
    for (const samePlan of samePlanNumberPlans) {
      const { data: existingPlanProgress } = await supabase
        .from("student_content_progress")
        .select("id")
        .eq("student_id", user.userId)
        .eq("plan_id", samePlan.id)
        .maybeSingle();

      const progressPayload = {
        student_id: user.userId,
        tenant_id: tenantId,
        plan_id: samePlan.id,
        content_type: plan.content_type,
        content_id: plan.content_id,
        progress: progress,
        start_page_or_time: payload.startPageOrTime,
        end_page_or_time: payload.endPageOrTime,
        completed_amount: completedAmount,
        last_updated: new Date().toISOString(),
      };

      if (existingPlanProgress) {
        await supabase
          .from("student_content_progress")
          .update(progressPayload)
          .eq("id", existingPlanProgress.id);
      } else {
        await supabase.from("student_content_progress").insert(progressPayload);
      }
    }

    // content_type + content_idë¡œë„ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì „ì²´ ì§„í–‰ë¥ )
    const { data: existingContentProgress } = await supabase
      .from("student_content_progress")
      .select("id,completed_amount")
      .eq("student_id", user.userId)
      .eq("content_type", plan.content_type)
      .eq("content_id", plan.content_id)
      .is("plan_id", null)
      .maybeSingle();

    if (existingContentProgress) {
      // ê¸°ì¡´ ì™„ë£ŒëŸ‰ì— ì¶”ê°€
      const newCompletedAmount =
        (existingContentProgress.completed_amount || 0) + completedAmount;
      const newProgress = Math.min(
        Math.round((newCompletedAmount / totalAmount) * 100),
        100
      );

      await supabase
        .from("student_content_progress")
        .update({
          completed_amount: newCompletedAmount,
          progress: newProgress,
          last_updated: new Date().toISOString(),
        })
        .eq("id", existingContentProgress.id);
    } else {
      // ìƒˆë¡œ ìƒì„±
      await supabase.from("student_content_progress").insert({
        student_id: user.userId,
        tenant_id: tenantId,
        content_type: plan.content_type,
        content_id: plan.content_id,
        completed_amount: completedAmount,
        progress: progress,
        last_updated: new Date().toISOString(),
      });
    }

    // í”Œëœì˜ actual_end_time ë° ì‹œê°„ ì •ë³´ ì—…ë°ì´íŠ¸
    const now = new Date();
    const actualEndTime = plan.actual_end_time || now.toISOString();

    // í”Œëœì˜ actual_start_time ì¡°íšŒ
    const { data: planData } = await supabase
      .from("student_plan")
      .select("actual_start_time, paused_duration_seconds, pause_count")
      .eq("id", planId)
      .eq("student_id", user.userId)
      .maybeSingle();

    let totalDurationSeconds: number | null = null;
    if (planData?.actual_start_time) {
      const startTime = new Date(planData.actual_start_time);
      const endTime = new Date(actualEndTime);
      totalDurationSeconds = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒí•˜ì—¬ ì¼ì‹œì •ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ë° ì¢…ë£Œ (ì—¬ëŸ¬ ê°œì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë°°ì—´ë¡œ ì¡°íšŒ)
    const { data: activeSessions, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("id, paused_duration_seconds, paused_at, resumed_at")
      .eq("plan_id", planId)
      .eq("student_id", user.userId)
      .is("ended_at", null)
      .order("started_at", { ascending: false }); // ìµœì‹  ì„¸ì…˜ ìš°ì„ 

    // ì—¬ëŸ¬ ì„¸ì…˜ì´ ìˆëŠ” ê²½ìš° ê°€ì¥ ìµœê·¼ ì„¸ì…˜ ì‚¬ìš©
    const activeSession = activeSessions && activeSessions.length > 0 ? activeSessions[0] : null;
    const sessionPausedDuration = activeSession?.paused_duration_seconds || 0;
    const planPausedDuration = planData?.paused_duration_seconds || 0;
    
    // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì¸ ê²½ìš° ì¼ì‹œì •ì§€ ì‹œê°„ ì¶”ê°€ ê³„ì‚°
    let currentPauseDuration = sessionPausedDuration;
    if (activeSession?.paused_at && !activeSession.resumed_at) {
      const pausedAt = new Date(activeSession.paused_at);
      const now = new Date();
      const currentPauseSeconds = Math.floor((now.getTime() - pausedAt.getTime()) / 1000);
      currentPauseDuration += currentPauseSeconds;
    }
    
    const totalPausedDuration = currentPauseDuration + planPausedDuration;
    const pauseCount = planData?.pause_count || 0;

    // í™œì„± ì„¸ì…˜ ì¢…ë£Œ (ëª¨ë“  í™œì„± ì„¸ì…˜ ì¢…ë£Œ)
    if (activeSessions && activeSessions.length > 0) {
      for (const session of activeSessions) {
        await endStudySession(session.id);
      }
    }

    // ê°™ì€ plan_numberë¥¼ ê°€ì§„ ëª¨ë“  í”Œëœì˜ ì‹œê°„ ì •ë³´ ì—…ë°ì´íŠ¸
    for (const samePlan of samePlanNumberPlans) {
      // ê° í”Œëœì˜ actual_start_time ì¡°íšŒ
      const { data: samePlanData } = await supabase
        .from("student_plan")
        .select("actual_start_time, paused_duration_seconds, pause_count")
        .eq("id", samePlan.id)
        .eq("student_id", user.userId)
        .maybeSingle();

      let samePlanTotalDurationSeconds: number | null = null;
      if (samePlanData?.actual_start_time) {
        const startTime = new Date(samePlanData.actual_start_time);
        const endTime = new Date(actualEndTime);
        samePlanTotalDurationSeconds = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);
      }

      const samePlanPausedDuration = samePlanData?.paused_duration_seconds || 0;
      const samePlanPauseCount = samePlanData?.pause_count || 0;

      // ê° í”Œëœì˜ í™œì„± ì„¸ì…˜ ì¡°íšŒ ë° ì¢…ë£Œ
      const { data: samePlanActiveSessions } = await supabase
        .from("student_study_sessions")
        .select("id, paused_duration_seconds, paused_at, resumed_at")
        .eq("plan_id", samePlan.id)
        .eq("student_id", user.userId)
        .is("ended_at", null);

      let samePlanCurrentPauseDuration = 0;
      if (samePlanActiveSessions && samePlanActiveSessions.length > 0) {
        const samePlanActiveSession = samePlanActiveSessions[0];
        samePlanCurrentPauseDuration = samePlanActiveSession.paused_duration_seconds || 0;
        
        if (samePlanActiveSession.paused_at && !samePlanActiveSession.resumed_at) {
          const pausedAt = new Date(samePlanActiveSession.paused_at);
          const now = new Date();
          const currentPauseSeconds = Math.floor((now.getTime() - pausedAt.getTime()) / 1000);
          samePlanCurrentPauseDuration += currentPauseSeconds;
        }

        // í™œì„± ì„¸ì…˜ ì¢…ë£Œ
        for (const session of samePlanActiveSessions) {
          await endStudySession(session.id);
        }
      }

      const samePlanTotalPausedDuration = samePlanCurrentPauseDuration + samePlanPausedDuration;

      // í”Œëœ ì‹œê°„ ì •ë³´ ì—…ë°ì´íŠ¸
      await supabase
        .from("student_plan")
        .update({
          actual_end_time: actualEndTime,
          total_duration_seconds: samePlanTotalDurationSeconds,
          paused_duration_seconds: samePlanTotalPausedDuration,
          pause_count: samePlanPauseCount,
        })
        .eq("id", samePlan.id)
        .eq("student_id", user.userId);
    }

    // ì™„ë£Œ ì‹œì ì˜ ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ ê³„ì‚° (ì¼ì‹œì •ì§€ ì‹œê°„ ì œì™¸)
    const finalDuration = totalDurationSeconds ? Math.max(0, totalDurationSeconds - totalPausedDuration) : 0;

    // ì„œë²„ í˜„ì¬ ì‹œê°„ ë°˜í™˜
    const serverNow = Date.now();

    // í•„ìš”í•œ ê²½ë¡œë§Œ ì¬ê²€ì¦ (ì„±ëŠ¥ ìµœì í™”)
    // ì™„ë£Œ ì‹œì—ëŠ” ëŒ€ì‹œë³´ë“œë„ ì—…ë°ì´íŠ¸ í•„ìš”
    revalidatePath("/today");
    revalidatePath("/camp/today");
    revalidatePath("/dashboard");
    return { 
      success: true,
      serverNow,
      status: "COMPLETED" as const,
      accumulatedSeconds: finalDuration,
      startedAt: null,
    };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ì™„ë£Œ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì™„ë£Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ë¯¸ë£¨ê¸° (ë‚´ì¼ë¡œ ì´ë™)
 */
export async function postponePlan(
  planId: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const tenantContext = await getTenantContext();
    const plan = await getPlanById(
      planId,
      user.userId,
      tenantContext?.tenantId || null
    );
    if (!plan) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    if (!plan.is_reschedulable) {
      return { success: false, error: "ì´ í”Œëœì€ ì¬ì¡°ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ë‚´ì¼ ë‚ ì§œ ê³„ì‚°
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    const tomorrowDate = formatDateString(tomorrow);

    await updatePlan(planId, user.userId, {
      plan_date: tomorrowDate,
    });

    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { success: true };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ë¯¸ë£¨ê¸° ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ë¯¸ë£¨ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * íƒ€ì´ë¨¸ ì‹œì‘
 */
export async function startTimer(
  planId?: string
): Promise<{ success: boolean; sessionId?: string; error?: string }> {
  const result = await startPlan(planId || "");
  if (!result.success) {
    return result;
  }

  // ì„¸ì…˜ IDëŠ” startStudySessionì—ì„œ ë°˜í™˜ë˜ì§€ë§Œ ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ì²˜ë¦¬
  return { success: true };
}

/**
 * íƒ€ì´ë¨¸ ì¢…ë£Œ
 */
export async function endTimer(
  sessionId: string
): Promise<{ success: boolean; durationSeconds?: number; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const result = await endStudySession(sessionId);
    revalidatePath("/today");
    revalidatePath("/camp/today");
    revalidatePath("/dashboard");
    return result;
  } catch (error) {
    console.error("[todayActions] íƒ€ì´ë¨¸ ì¢…ë£Œ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "íƒ€ì´ë¨¸ ì¢…ë£Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ì¼ì‹œì •ì§€
 */
export async function pausePlan(
  planId: string,
  timestamp?: string // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìƒì„±í•œ íƒ€ì„ìŠ¤íƒ¬í”„
): Promise<{ 
  success: boolean; 
  error?: string;
  serverNow?: number;
  status?: "PAUSED";
  accumulatedSeconds?: number;
  startedAt?: never; // PAUSED ìƒíƒœì—ëŠ” startedAtì´ ì—†ìŒ
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // í™œì„± ì„¸ì…˜ ì¡°íšŒ (ìµœì‹  ì„¸ì…˜ë§Œ ì¡°íšŒí•˜ì—¬ ìµœì í™”)
    const { data: activeSession, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("id, started_at, paused_at, resumed_at, paused_duration_seconds")
      .eq("plan_id", planId)
      .eq("student_id", user.userId)
      .is("ended_at", null)
      .order("started_at", { ascending: false })
      .limit(1)
      .maybeSingle(); // ìµœì‹  ì„¸ì…˜ë§Œ ì¡°íšŒ

    if (!activeSession) {
      return { success: false, error: "í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í”Œëœì„ ë¨¼ì € ì‹œì‘í•´ì£¼ì„¸ìš”." };
    }

    // ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì¸ì§€ í™•ì¸
    if (activeSession.paused_at && !activeSession.resumed_at) {
      return { success: false, error: "ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤." };
    }

    // ì„¸ì…˜ ì¼ì‹œì •ì§€
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì „ë‹¬í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©, ì—†ìœ¼ë©´ ì„œë²„ì—ì„œ ìƒì„± (í•˜ìœ„ í˜¸í™˜ì„±)
    const pauseTimestamp = timestamp || new Date().toISOString();
    
    // ì¬ê°œ í›„ ë‹¤ì‹œ ì¼ì‹œì •ì§€í•˜ëŠ” ê²½ìš°ë¥¼ ìœ„í•´ resumed_atì„ nullë¡œ ë¦¬ì…‹
    // ì´ì „ ì¼ì‹œì •ì§€ ì‹œê°„ì´ ìˆë‹¤ë©´ paused_duration_secondsì— ì´ë¯¸ ëˆ„ì ë˜ì–´ ìˆìŒ
    const { error: pauseError } = await supabase
      .from("student_study_sessions")
      .update({
        paused_at: pauseTimestamp,
        resumed_at: null, // ì¬ê°œ í›„ ë‹¤ì‹œ ì¼ì‹œì •ì§€í•  ë•Œ ë¦¬ì…‹
      })
      .eq("id", activeSession.id)
      .eq("student_id", user.userId);

    if (pauseError) {
      console.error("[todayActions] ì„¸ì…˜ ì¼ì‹œì •ì§€ ì˜¤ë¥˜:", pauseError);
      return { success: false, error: "ì„¸ì…˜ ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    // í”Œëœì˜ pause_count ì¦ê°€ (RPC í•¨ìˆ˜ë¡œ í•œ ë²ˆì˜ ì¿¼ë¦¬ë¡œ ìµœì í™”)
    const { data: newPauseCount, error: rpcError } = await supabase.rpc(
      "increment_pause_count",
      {
        p_plan_id: planId,
        p_student_id: user.userId,
      }
    );

    if (rpcError) {
      console.error("[todayActions] pause_count ì¦ê°€ ì˜¤ë¥˜:", rpcError);
      // ì¼ì‹œì •ì§€ëŠ” ì„±ê³µí–ˆìœ¼ë¯€ë¡œ ê²½ê³ ë§Œ ë¡œê·¸í•˜ê³  ê³„ì† ì§„í–‰
    }

    // ì„œë²„ í˜„ì¬ ì‹œê°„ ë°˜í™˜
    const serverNow = Date.now();

    // í”Œëœì˜ í˜„ì¬ ëˆ„ì  ì‹œê°„ ê³„ì‚° (ì„¸ì…˜ ì •ë³´ ì‚¬ìš©)
    let accumulatedSeconds = 0;
    if (activeSession?.started_at) {
      const sessionStartMs = new Date(activeSession.started_at).getTime();
      const now = Date.now();
      const elapsed = Math.floor((now - sessionStartMs) / 1000);
      const sessionPausedDuration = activeSession.paused_duration_seconds || 0;
      
      // í”Œëœì˜ paused_duration_secondsë„ ê³ ë ¤
      const { data: planData } = await supabase
        .from("student_plan")
        .select("paused_duration_seconds")
        .eq("id", planId)
        .eq("student_id", user.userId)
        .maybeSingle();
      
      const planPausedDuration = planData?.paused_duration_seconds || 0;
      accumulatedSeconds = Math.max(0, elapsed - sessionPausedDuration - planPausedDuration);
    }

    // í•„ìš”í•œ ê²½ë¡œë§Œ ì¬ê²€ì¦ (ì„±ëŠ¥ ìµœì í™”)
    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { 
      success: true,
      serverNow,
      status: "PAUSED" as const,
      accumulatedSeconds,
    };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ì¼ì‹œì •ì§€ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì¼ì‹œì •ì§€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ì¬ê°œ
 */
export async function resumePlan(
  planId: string,
  timestamp?: string // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìƒì„±í•œ íƒ€ì„ìŠ¤íƒ¬í”„
): Promise<{ 
  success: boolean; 
  error?: string;
  serverNow?: number;
  status?: "RUNNING";
  startedAt?: string | null;
  accumulatedSeconds?: number;
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // í™œì„± ì„¸ì…˜ ì¡°íšŒ (ìµœì‹  ì„¸ì…˜ë§Œ ì¡°íšŒí•˜ì—¬ ìµœì í™”)
    const { data: activeSession, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("id, started_at, paused_at, paused_duration_seconds, resumed_at")
      .eq("plan_id", planId)
      .eq("student_id", user.userId)
      .is("ended_at", null)
      .order("started_at", { ascending: false })
      .limit(1)
      .maybeSingle(); // ìµœì‹  ì„¸ì…˜ë§Œ ì¡°íšŒ

    if (!activeSession) {
      return { success: false, error: "í™œì„± ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ì¼ì‹œì •ì§€ ìƒíƒœì¸ì§€ í™•ì¸
    if (!activeSession.paused_at || activeSession.resumed_at) {
      return { success: false, error: "ì¼ì‹œì •ì§€ëœ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤." };
    }

    const pausedAt = new Date(activeSession.paused_at);
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì „ë‹¬í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©, ì—†ìœ¼ë©´ ì„œë²„ì—ì„œ ìƒì„± (í•˜ìœ„ í˜¸í™˜ì„±)
    const resumedAt = timestamp ? new Date(timestamp) : new Date();
    const pauseDuration = Math.floor((resumedAt.getTime() - pausedAt.getTime()) / 1000);
    const totalPausedDuration = (activeSession.paused_duration_seconds || 0) + pauseDuration;

    // ì„¸ì…˜ ì¬ê°œ
    await supabase
      .from("student_study_sessions")
      .update({
        resumed_at: resumedAt.toISOString(),
        paused_duration_seconds: totalPausedDuration,
      })
      .eq("id", activeSession.id);

    // í”Œëœì˜ paused_duration_seconds ì—…ë°ì´íŠ¸ ë° í˜„ì¬ ëˆ„ì  ì‹œê°„ ê³„ì‚°ì„ ìœ„í•œ ì¡°íšŒ
    const { data: planData } = await supabase
      .from("student_plan")
      .select("actual_start_time, paused_duration_seconds")
      .eq("id", planId)
      .eq("student_id", user.userId)
      .maybeSingle();

    // í”Œëœì˜ paused_duration_seconds ì—…ë°ì´íŠ¸
    const planPausedDuration = planData?.paused_duration_seconds || 0;
    await supabase
      .from("student_plan")
      .update({
        paused_duration_seconds: planPausedDuration + pauseDuration,
      })
      .eq("id", planId)
      .eq("student_id", user.userId);

    // ì„œë²„ í˜„ì¬ ì‹œê°„ ë°˜í™˜
    const serverNow = Date.now();

    let accumulatedSeconds = 0;
    let startedAt: string | null = null;
    if (planData?.actual_start_time && activeSession?.started_at) {
      const sessionStartMs = new Date(activeSession.started_at).getTime();
      const now = Date.now();
      const elapsed = Math.floor((now - sessionStartMs) / 1000);
      const sessionPausedDuration = activeSession.paused_duration_seconds || 0;
      const planPausedDuration = planData.paused_duration_seconds || 0;
      accumulatedSeconds = Math.max(0, elapsed - sessionPausedDuration - planPausedDuration);
      startedAt = activeSession.started_at;
    }

    // í•„ìš”í•œ ê²½ë¡œë§Œ ì¬ê²€ì¦ (ì„±ëŠ¥ ìµœì í™”)
    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { 
      success: true,
      serverNow,
      status: "RUNNING" as const,
      accumulatedSeconds,
      startedAt: startedAt ?? null,
    };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ì¬ê°œ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì¬ê°œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ì™„ë£Œ ì¤€ë¹„ (í™œì„± ì„¸ì…˜ ì •ë¦¬ ë° ë©”íƒ€ë°ì´í„° ë°˜í™˜)
 * 
 * Today í™”ë©´ì—ì„œ "í•™ìŠµ ì™„ë£Œ" ë²„íŠ¼ í´ë¦­ ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤.
 * í™œì„± ì„¸ì…˜ì„ ì¢…ë£Œí•˜ê³  ì™„ë£Œ ì…ë ¥ í˜ì´ì§€ì— í•„ìš”í•œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export async function preparePlanCompletion(
  planId: string
): Promise<{
  success: boolean;
  error?: string;
  plan?: {
    id: string;
    content_type: string;
    content_id: string;
    chapter: string | null;
    planned_start_page_or_time: number | null;
    planned_end_page_or_time: number | null;
    actual_start_time: string | null;
    actual_end_time: string | null;
    total_duration_seconds: number | null;
    paused_duration_seconds: number | null;
    is_reschedulable: boolean;
    plan_date: string;
  };
  hasActiveSession: boolean;
  isAlreadyCompleted: boolean;
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", hasActiveSession: false, isAlreadyCompleted: false };
  }

  const tenantContext = await getTenantContext();

  try {
    const supabase = await createSupabaseServerClient();
    const now = new Date();

    // í”Œëœ ì •ë³´ ì¡°íšŒ
    const plan = await getPlanById(
      planId,
      user.userId,
      tenantContext?.tenantId || null
    );

    if (!plan) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", hasActiveSession: false, isAlreadyCompleted: false };
    }

    // ì´ë¯¸ ì™„ë£Œëœ ê²½ìš°
    if (plan.actual_end_time) {
      return {
        success: true,
        plan: {
          id: plan.id,
          content_type: plan.content_type || "",
          content_id: plan.content_id || "",
          chapter: plan.chapter ?? null,
          planned_start_page_or_time: plan.planned_start_page_or_time ?? null,
          planned_end_page_or_time: plan.planned_end_page_or_time ?? null,
          actual_start_time: plan.actual_start_time ?? null,
          actual_end_time: plan.actual_end_time ?? null,
          total_duration_seconds: plan.total_duration_seconds ?? null,
          paused_duration_seconds: plan.paused_duration_seconds ?? null,
          is_reschedulable: plan.is_reschedulable || false,
          plan_date: plan.plan_date,
        },
        hasActiveSession: false,
        isAlreadyCompleted: true,
      };
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒ
    const { data: activeSessions, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("id, paused_duration_seconds, paused_at, resumed_at, started_at")
      .eq("plan_id", planId)
      .eq("student_id", user.userId)
      .is("ended_at", null);

    if (sessionError) {
      console.error("[todayActions] ì„¸ì…˜ ì¡°íšŒ ì˜¤ë¥˜:", sessionError);
      return { success: false, error: `ì„¸ì…˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${sessionError.message}`, hasActiveSession: false, isAlreadyCompleted: false };
    }

    const hasActiveSession = activeSessions && activeSessions.length > 0;

    // í™œì„± ì„¸ì…˜ì´ ìˆìœ¼ë©´ ì¢…ë£Œ
    if (hasActiveSession && activeSessions) {
      let newlyAccumulatedPausedSeconds = 0;

      for (const session of activeSessions) {
        let pausedSeconds = session.paused_duration_seconds || 0;

        // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì´ì—ˆë‹¤ë©´ ì¶”ê°€ ê³„ì‚°
        if (session.paused_at && !session.resumed_at) {
          const pausedAt = new Date(session.paused_at);
          const currentPause = Math.floor((now.getTime() - pausedAt.getTime()) / 1000);
          pausedSeconds += currentPause;
        }

        newlyAccumulatedPausedSeconds += pausedSeconds;
        await endStudySession(session.id);
      }

      // í”Œëœì˜ paused_duration_seconds ì—…ë°ì´íŠ¸
      const planPausedDuration = plan.paused_duration_seconds || 0;
      const updatedPausedDuration = planPausedDuration + newlyAccumulatedPausedSeconds;

      await supabase
        .from("student_plan")
        .update({
          paused_duration_seconds: updatedPausedDuration,
        })
        .eq("id", planId)
        .eq("student_id", user.userId);

      // ì—…ë°ì´íŠ¸ëœ í”Œëœ ì •ë³´ ë‹¤ì‹œ ì¡°íšŒ
      const updatedPlan = await getPlanById(
        planId,
        user.userId,
        tenantContext?.tenantId || null
      );

      if (updatedPlan) {
        revalidatePath("/today");
        revalidatePath("/camp/today");
        return {
          success: true,
          plan: {
            id: updatedPlan.id,
            content_type: updatedPlan.content_type || "",
            content_id: updatedPlan.content_id || "",
            chapter: updatedPlan.chapter ?? null,
            planned_start_page_or_time: updatedPlan.planned_start_page_or_time ?? null,
            planned_end_page_or_time: updatedPlan.planned_end_page_or_time ?? null,
            actual_start_time: updatedPlan.actual_start_time ?? null,
            actual_end_time: updatedPlan.actual_end_time ?? null,
            total_duration_seconds: updatedPlan.total_duration_seconds ?? null,
            paused_duration_seconds: updatedPlan.paused_duration_seconds ?? null,
            is_reschedulable: updatedPlan.is_reschedulable || false,
            plan_date: updatedPlan.plan_date,
          },
          hasActiveSession: false, // ì¢…ë£Œí–ˆìœ¼ë¯€ë¡œ false
          isAlreadyCompleted: false,
        };
      }
    }

    // í™œì„± ì„¸ì…˜ì´ ì—†ëŠ” ê²½ìš°
    revalidatePath("/today");
    revalidatePath("/camp/today");
    return {
      success: true,
      plan: {
        id: plan.id,
        content_type: plan.content_type || "",
        content_id: plan.content_id || "",
        chapter: plan.chapter ?? null,
        planned_start_page_or_time: plan.planned_start_page_or_time ?? null,
        planned_end_page_or_time: plan.planned_end_page_or_time ?? null,
        actual_start_time: plan.actual_start_time ?? null,
        actual_end_time: plan.actual_end_time ?? null,
        total_duration_seconds: plan.total_duration_seconds ?? null,
        paused_duration_seconds: plan.paused_duration_seconds ?? null,
        is_reschedulable: plan.is_reschedulable || false,
        plan_date: plan.plan_date,
      },
      hasActiveSession: false,
      isAlreadyCompleted: false,
    };
  } catch (error) {
    console.error("[todayActions] í”Œëœ ì™„ë£Œ ì¤€ë¹„ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì™„ë£Œ ì¤€ë¹„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      hasActiveSession: false,
      isAlreadyCompleted: false,
    };
  }
}

/**
 * í”Œëœì˜ ëª¨ë“  í™œì„± ì„¸ì…˜ ì¢…ë£Œ (ì™„ë£Œ ë²„íŠ¼ í´ë¦­ ì‹œ íƒ€ì´ë¨¸ ì¤‘ì§€ìš©)
 * @deprecated Use preparePlanCompletion instead for new code
 */
export async function stopAllActiveSessionsForPlan(
  planId: string
): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user || user.role !== "student") {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const now = new Date();

    // í”Œëœ ì •ë³´ ì¡°íšŒ (ì‹œê°„ ê³„ì‚°ìš©)
    const { data: planData, error: planError } = await supabase
      .from("student_plan")
      .select("actual_start_time, actual_end_time, paused_duration_seconds")
      .eq("id", planId)
      .eq("student_id", user.userId)
      .maybeSingle();

    if (planError || !planData) {
      console.error("[todayActions] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:", planError);
      return { success: false, error: "í”Œëœ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤." };
    }

    // í•´ë‹¹ í”Œëœì˜ ëª¨ë“  í™œì„± ì„¸ì…˜ ì¡°íšŒ (ì¼ì‹œì •ì§€ ì •ë³´ í¬í•¨)
    const { data: activeSessions, error: sessionError } = await supabase
      .from("student_study_sessions")
      .select("id, paused_duration_seconds, paused_at, resumed_at")
      .eq("plan_id", planId)
      .eq("student_id", user.userId)
      .is("ended_at", null);

    if (sessionError) {
      console.error("[todayActions] ì„¸ì…˜ ì¡°íšŒ ì˜¤ë¥˜:", sessionError);
      return { success: false, error: `ì„¸ì…˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${sessionError.message}` };
    }

    let newlyAccumulatedPausedSeconds = 0;

    if (activeSessions && activeSessions.length > 0) {
      for (const session of activeSessions) {
        let pausedSeconds = session.paused_duration_seconds || 0;

        // í˜„ì¬ ì¼ì‹œì •ì§€ ì¤‘ì´ì—ˆë‹¤ë©´ ì¶”ê°€ ê³„ì‚°
        if (session.paused_at && !session.resumed_at) {
          const pausedAt = new Date(session.paused_at);
          const currentPause = Math.floor((now.getTime() - pausedAt.getTime()) / 1000);
          pausedSeconds += currentPause;
        }

        newlyAccumulatedPausedSeconds += pausedSeconds;
        await endStudySession(session.id);
      }
    }

    const planPausedDuration = planData.paused_duration_seconds || 0;
    const updatedPausedDuration = planPausedDuration + newlyAccumulatedPausedSeconds;

    const actualEndTime = planData.actual_end_time || now.toISOString();
    const endDate = new Date(actualEndTime);

    let totalDurationSeconds: number | null = null;
    if (planData.actual_start_time) {
      const startTime = new Date(planData.actual_start_time);
      totalDurationSeconds = Math.floor((endDate.getTime() - startTime.getTime()) / 1000);
    }

    await supabase
      .from("student_plan")
      .update({
        actual_end_time: actualEndTime,
        total_duration_seconds: totalDurationSeconds,
        paused_duration_seconds: updatedPausedDuration,
      })
      .eq("id", planId)
      .eq("student_id", user.userId);

    revalidatePath("/today");
    revalidatePath("/camp/today");
    return { success: true };
  } catch (error) {
    console.error("[todayActions] ì„¸ì…˜ ì¢…ë£Œ ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì„¸ì…˜ ì¢…ë£Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="plan/[planId]/_components/PlanExecutionForm.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Plan } from "@/lib/data/studentPlans";
import { Book, Lecture, CustomContent } from "@/lib/data/studentContents";
import { StudySession } from "@/lib/data/studentSessions";
import { startPlan, completePlan, postponePlan, preparePlanCompletion } from "@/app/(student)/today/actions/todayActions";
import { usePlanTimerStore } from "@/lib/store/planTimerStore";
import { StatusBadge } from "@/app/(student)/today/_components/timer/StatusBadge";
import { useToast } from "@/components/ui/ToastProvider";

type PlanCompletionMode = "today" | "camp";

type PlanExecutionFormProps = {
  mode?: PlanCompletionMode;
  plan: Plan;
  content: Book | Lecture | CustomContent;
  activeSession: StudySession | null;
  unitLabel: string;
  relatedPlans: Plan[];
};

type FormErrors = {
  startPageOrTime?: string;
  endPageOrTime?: string;
  general?: string;
};

export function PlanExecutionForm({
  mode = "today",
  plan,
  content,
  activeSession,
  unitLabel,
  relatedPlans,
}: PlanExecutionFormProps) {
  const router = useRouter();
  const timerStore = usePlanTimerStore();
  const { showError } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [isCompleting, setIsCompleting] = useState(false);
  const [isClearingSession, setIsClearingSession] = useState(false);
  const [startPageOrTime, setStartPageOrTime] = useState<string>(
    plan.planned_start_page_or_time?.toString() || ""
  );
  const [endPageOrTime, setEndPageOrTime] = useState<string>(
    plan.planned_end_page_or_time?.toString() || ""
  );
  const [memo, setMemo] = useState("");
  const [errors, setErrors] = useState<FormErrors>({});
  const [hasActiveSession, setHasActiveSession] = useState(!!activeSession);

  // ìƒíƒœ ê²°ì •
  const isAlreadyCompleted = !!plan.actual_end_time;
  const showForm = !isAlreadyCompleted && !isCompleting;

  // íƒ€ì´ë¨¸ ì •ë¦¬ í•¸ë“¤ëŸ¬
  const handleClearSession = async () => {
    setIsClearingSession(true);
    try {
      const result = await preparePlanCompletion(plan.id);
      
      if (!result.success) {
        setErrors({ general: result.error || "íƒ€ì´ë¨¸ ì •ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
        showError(result.error || "íƒ€ì´ë¨¸ ì •ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      setHasActiveSession(false);
      // íƒ€ì´ë¨¸ ìŠ¤í† ì–´ì—ì„œ ì œê±°
      timerStore.removeTimer(plan.id);
      router.refresh();
    } catch (error) {
      console.error("[PlanExecutionForm] íƒ€ì´ë¨¸ ì •ë¦¬ ì˜¤ë¥˜:", error);
      setErrors({ general: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsClearingSession(false);
    }
  };

  const handleStart = async () => {
    setIsLoading(true);
    setErrors({});
    try {
      const result = await startPlan(plan.id);
      if (result.success) {
        setHasActiveSession(true);
        router.refresh();
      } else {
        setErrors({ general: result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
        showError(result.error || "í”Œëœ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      setErrors({ general: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  // ìœ íš¨ì„± ê²€ì‚¬
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    if (!startPageOrTime.trim()) {
      newErrors.startPageOrTime = "ì‹œì‘ ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.";
    } else {
      const start = Number(startPageOrTime);
      if (!Number.isFinite(start) || start < 0) {
        newErrors.startPageOrTime = "ì˜¬ë°”ë¥¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.";
      }
    }

    if (!endPageOrTime.trim()) {
      newErrors.endPageOrTime = "ì¢…ë£Œ ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.";
    } else {
      const end = Number(endPageOrTime);
      if (!Number.isFinite(end) || end < 0) {
        newErrors.endPageOrTime = "ì˜¬ë°”ë¥¸ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.";
      } else if (startPageOrTime.trim()) {
        const start = Number(startPageOrTime);
        if (end < start) {
          newErrors.endPageOrTime = "ì¢…ë£Œ ê°’ì€ ì‹œì‘ ê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤.";
        }
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleComplete = async () => {
    setErrors({});
    
    if (!validateForm()) {
      return;
    }

    const start = Number(startPageOrTime);
    const end = Number(endPageOrTime);

    setIsCompleting(true);
    setIsLoading(true);
    try {
      const result = await completePlan(plan.id, {
        startPageOrTime: start,
        endPageOrTime: end,
        memo: memo || null,
      });

      if (result.success) {
        // íƒ€ì´ë¨¸ ìŠ¤í† ì–´ì—ì„œ ì œê±°
        timerStore.removeTimer(plan.id);
        
        // ëª¨ë“œì— ë”°ë¥¸ ë¦¬ë‹¤ì´ë ‰íŠ¸
        if (mode === "camp") {
          // ìº í”„ ëª¨ë“œ: /camp/todayë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
          const params = new URLSearchParams();
          params.set("completedPlanId", plan.id);
          if (plan.plan_date) {
            params.set("date", plan.plan_date);
          }
          const query = params.toString();
          router.push(query ? `/camp/today?${query}` : "/camp/today");
        } else {
          // Today ëª¨ë“œ: /todayë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
          const params = new URLSearchParams();
          params.set("completedPlanId", plan.id);
          if (plan.plan_date) {
            params.set("date", plan.plan_date);
          }
          const query = params.toString();
          router.push(query ? `/today?${query}` : "/today");
        }
      } else {
        setErrors({ general: result.error || "í”Œëœ ì™„ë£Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
        showError(result.error || "í”Œëœ ì™„ë£Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        setIsCompleting(false);
      }
    } catch (error) {
      console.error("[PlanExecutionForm] ì™„ë£Œ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      setErrors({ general: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      setIsCompleting(false);
    } finally {
      setIsLoading(false);
    }
  };

  const handlePostpone = async () => {
    if (!confirm("ì´ í”Œëœì„ ë‚´ì¼ ì¼ì •ìœ¼ë¡œ ë¯¸ë£¨ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      return;
    }

    setIsLoading(true);
    setErrors({});

    try {
      const result = await postponePlan(plan.id);

      if (result.success) {
        const params = new URLSearchParams();
        if (plan.plan_date) {
          params.set("date", plan.plan_date);
        }
        const query = params.toString();

        // ëª¨ë“œì— ë”°ë¥¸ ë¦¬ë‹¤ì´ë ‰íŠ¸ ë¶„ê¸°
        if (mode === "camp") {
          router.push(query ? `/camp/today?${query}` : "/camp/today");
        } else {
          router.push(query ? `/today?${query}` : "/today");
        }
      } else {
        setErrors({ general: result.error || "í”Œëœ ë¯¸ë£¨ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." });
        showError(result.error || "í”Œëœ ë¯¸ë£¨ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      setErrors({ general: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
      showError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsLoading(false);
    }
  };

  // ìƒíƒœ D: ì´ë¯¸ ì™„ë£Œë¨
  if (isAlreadyCompleted) {
    return (
      <div className="space-y-4">
        <div className="rounded-xl border-2 border-emerald-200 bg-gradient-to-br from-emerald-50 to-white p-6 shadow-md">
          <div className="flex flex-col items-center justify-center gap-3 text-center">
            <StatusBadge status="COMPLETED" size="lg" />
            <span className="text-base font-bold text-emerald-900">ì´ í”Œëœì€ ì´ë¯¸ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</span>
            <p className="text-sm text-emerald-700">ì•„ë˜ì—ì„œ ì™„ë£Œëœ í•™ìŠµ ê¸°ë¡ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
          </div>
        </div>
      </div>
    );
  }

  // ìƒíƒœ C: ì™„ë£Œ ì²˜ë¦¬ ì¤‘
  if (isCompleting) {
    return (
      <div className="space-y-4">
        <div className="flex flex-col gap-4 rounded-xl border-2 border-dashed border-indigo-300 bg-gradient-to-br from-indigo-50 to-white p-8 text-center shadow-md">
          <div className="flex justify-center">
            <div className="h-12 w-12 animate-spin rounded-full border-4 border-indigo-200 border-t-indigo-600" />
          </div>
          <p className="text-base font-bold text-indigo-900">í•™ìŠµ ê¸°ë¡ì„ ì •ë¦¬í•˜ê³  ìˆì–´ìš”â€¦ ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</p>
        </div>
      </div>
    );
  }

  // ìƒíƒœ B: ë¯¸ì™„ë£Œ + í™œì„± ì„¸ì…˜ ìˆìŒ
  if (hasActiveSession) {
    return (
      <div className="space-y-4">
        {errors.general && (
          <div className="rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-700">
            {errors.general}
          </div>
        )}

        <div className="flex flex-col gap-4 rounded-xl border-2 border-yellow-300 bg-gradient-to-br from-yellow-50 to-white p-5 shadow-md">
          <div className="flex flex-col gap-2">
            <div className="flex items-center gap-2">
              <StatusBadge status="RUNNING" size="md" />
              <h3 className="text-base font-bold text-yellow-900">í˜„ì¬ ì´ í”Œëœì˜ íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì´ì—ìš”</h3>
            </div>
            <p className="text-sm text-yellow-800">
              í•™ìŠµ ê¸°ë¡ì„ ì…ë ¥í•˜ë ¤ë©´ ë¨¼ì € íƒ€ì´ë¨¸ë¥¼ ì¢…ë£Œí•´ì•¼ í•©ë‹ˆë‹¤.
            </p>
          </div>
          <button
            onClick={handleClearSession}
            disabled={isClearingSession || isLoading}
            className="w-full rounded-lg bg-yellow-600 px-4 py-3 text-base font-bold text-white shadow-md transition hover:bg-yellow-700 hover:shadow-lg disabled:opacity-50 active:scale-[0.98] min-h-[44px]"
          >
            {isClearingSession ? (
              <span className="flex items-center justify-center gap-2">
                <span className="h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent" />
                íƒ€ì´ë¨¸ ì •ë¦¬ ì¤‘...
              </span>
            ) : (
              "íƒ€ì´ë¨¸ ì •ë¦¬ í›„ ê¸°ë¡í•˜ê¸°"
            )}
          </button>
        </div>

        {/* í•™ìŠµ ê¸°ë¡ í¼ (ë¹„í™œì„±í™”) - íƒ€ì´ë¨¸ ì •ë¦¬ ì „ê¹Œì§€ ë¹„í™œì„±í™” */}
        <div className="flex flex-col gap-4 opacity-50">
          <h2 className="text-lg font-semibold text-gray-900">í•™ìŠµ ê¸°ë¡</h2>
          <div className="flex flex-col gap-3">
            <div className="flex flex-col gap-1.5">
              <label className="block text-sm font-semibold text-gray-700">
                ì‹œì‘ {unitLabel}
              </label>
              <input
                type="number"
                value={startPageOrTime}
                disabled
                className="w-full rounded-lg border-2 border-gray-300 bg-gray-100 px-4 py-3 text-base"
              />
            </div>
            <div className="flex flex-col gap-1.5">
              <label className="block text-sm font-semibold text-gray-700">
                ì¢…ë£Œ {unitLabel}
              </label>
              <input
                type="number"
                value={endPageOrTime}
                disabled
                className="w-full rounded-lg border-2 border-gray-300 bg-gray-100 px-4 py-3 text-base"
              />
            </div>
            <div className="flex flex-col gap-1.5">
              <label className="block text-sm font-semibold text-gray-700">
                ë©”ëª¨ (ì„ íƒ)
              </label>
              <textarea
                value={memo}
                disabled
                className="w-full rounded-lg border-2 border-gray-300 bg-gray-100 px-4 py-3 text-base"
                rows={3}
              />
            </div>
          </div>
          <div>
            <button
              disabled
              className="w-full rounded-lg bg-gray-400 px-4 py-3 text-base font-semibold text-white"
            >
              ì™„ë£Œ í™•ì •
            </button>
          </div>
        </div>
      </div>
    );
  }

  // ìƒíƒœ 4: ë¯¸ì™„ë£Œ + í™œì„± ì„¸ì…˜ ì—†ìŒ
  return (
    <div className="space-y-4">
      {errors.general && (
        <div className="rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-700">
          {errors.general}
        </div>
      )}

      {/* í•™ìŠµ ê¸°ë¡ í¼ (Primary Action) - ì‹œê°ì ìœ¼ë¡œ ê°€ì¥ ê°•ì¡° */}
      <div className="flex flex-col gap-5 rounded-xl border-2 border-indigo-200 bg-gradient-to-br from-indigo-50 to-white p-6 shadow-lg">
        <div className="flex items-center gap-2">
          <h2 className="text-xl font-bold text-gray-900">í•™ìŠµ ê¸°ë¡</h2>
          <span className="rounded-full bg-indigo-100 px-2 py-0.5 text-xs font-semibold text-indigo-700">
            í•„ìˆ˜
          </span>
        </div>
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-900">
            {mode === "camp" 
              ? "ì´ ìº í”„ ì„¸ì…˜ì—ì„œ ì‹¤ì œë¡œ í•™ìŠµí•œ ë²”ìœ„ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."
              : "ì´ë²ˆ í”Œëœì—ì„œ ì‹¤ì œë¡œ í•™ìŠµí•œ ë²”ìœ„ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."}
          </p>
          <p className="text-xs text-gray-600">
            {mode === "camp" 
              ? "ì…ë ¥í•œ ë‚´ìš©ì€ í˜„ì¬ ë¸”ë¡ì˜ í•™ìŠµ ê²°ê³¼ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤."
              : "ì…ë ¥í•œ ë‚´ìš©ì€ ì˜¤ëŠ˜ì˜ í•™ìŠµ ê¸°ë¡ìœ¼ë¡œ ì €ì¥ë˜ë©° ë‚˜ì¤‘ì— ë‹¤ì‹œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."}
          </p>
        </div>
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-1.5">
            <label className="block text-sm font-semibold text-gray-700">
              ì‹œì‘ {unitLabel} <span className="text-red-500">*</span>
            </label>
            <input
              type="number"
              value={startPageOrTime}
              onChange={(e) => {
                setStartPageOrTime(e.target.value);
                if (errors.startPageOrTime) {
                  setErrors((prev) => ({ ...prev, startPageOrTime: undefined }));
                }
              }}
              className={`w-full rounded-lg border-2 px-4 py-3 text-base font-medium transition focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 ${
                errors.startPageOrTime
                  ? "border-red-400 bg-red-50 focus:ring-red-500"
                  : "border-gray-300 bg-white focus:border-indigo-500"
              }`}
              placeholder="ì‹œì‘ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”"
            />
            {errors.startPageOrTime && (
              <p className="text-sm font-medium text-red-600">{errors.startPageOrTime}</p>
            )}
          </div>
          <div className="flex flex-col gap-1.5">
            <label className="block text-sm font-semibold text-gray-700">
              ì¢…ë£Œ {unitLabel} <span className="text-red-500">*</span>
            </label>
            <input
              type="number"
              value={endPageOrTime}
              onChange={(e) => {
                setEndPageOrTime(e.target.value);
                if (errors.endPageOrTime) {
                  setErrors((prev) => ({ ...prev, endPageOrTime: undefined }));
                }
              }}
              className={`w-full rounded-lg border-2 px-4 py-3 text-base font-medium transition focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 ${
                errors.endPageOrTime
                  ? "border-red-400 bg-red-50 focus:ring-red-500"
                  : "border-gray-300 bg-white focus:border-indigo-500"
              }`}
              placeholder="ì¢…ë£Œ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”"
            />
            {errors.endPageOrTime && (
              <p className="text-sm font-medium text-red-600">{errors.endPageOrTime}</p>
            )}
            <p className="text-xs text-gray-500">
              {mode === "camp" 
                ? "í•´ë‹¹ ë¸”ë¡ì—ì„œ ì‹¤ì œë¡œ ì™„ë£Œí•œ í•™ìŠµ ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì‹œì‘ ê°’ì€ 0 ì´ìƒì´ì–´ì•¼ í•˜ë©°, ì¢…ë£Œ ê°’ì€ ì‹œì‘ ê°’ ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ë¥¸ ë¸”ë¡ì˜ ìƒíƒœëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
                : "í”Œëœì—ì„œ ì‹¤ì œë¡œ í•™ìŠµí•œ ì‹œì‘Â·ì¢…ë£Œ ë²”ìœ„ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ì‹œì‘ ê°’ì€ 0 ì´ìƒì´ì–´ì•¼ í•˜ë©°, ì¢…ë£Œ ê°’ì€ ì‹œì‘ ê°’ ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤."}
            </p>
          </div>
          <div className="flex flex-col gap-1.5">
            <label className="block text-sm font-semibold text-gray-700">
              ë©”ëª¨ {mode === "camp" ? "(ì„ íƒ ì…ë ¥)" : "(ì„ íƒ)"}
            </label>
            <textarea
              value={memo}
              onChange={(e) => setMemo(e.target.value)}
              className="w-full rounded-lg border-2 border-gray-300 bg-white px-4 py-3 text-base font-medium transition focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
              rows={3}
              placeholder={mode === "camp" 
                ? "ìº í”„ ì§„í–‰ ì¤‘ ëŠë‚€ ì ì´ë‚˜ í•„ìš”í–ˆë˜ ë³´ì™„ í•™ìŠµì„ ê¸°ë¡í•´ ë‘ë©´ ë‹¤ìŒ ë¸”ë¡ í•™ìŠµì— ë„ì›€ì´ ë©ë‹ˆë‹¤."
                : "ì„ íƒì‚¬í•­: í•™ìŠµ ì¤‘ ëŠë‚€ ì ì´ë‚˜ ì¤‘ìš”í•œ ë‚´ìš©ì„ ì ì–´ ë‘ë©´ ë³µìŠµì— ë„ì›€ì´ ë©ë‹ˆë‹¤."}
            />
          </div>
        </div>
      </div>

      {/* ìƒíƒœ A ì•ˆë‚´ ë©”ì‹œì§€ */}
      <div className="flex flex-col gap-1 rounded-lg border border-indigo-100 bg-indigo-50 p-4">
        <p className="text-sm font-medium text-indigo-900">
          ì´ í”Œëœì˜ í•™ìŠµì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
        </p>
        <p className="text-xs text-indigo-700">
          ì´ì œ ì‹¤ì œë¡œ í•™ìŠµí•œ ë²”ìœ„ë¥¼ ì…ë ¥í•˜ê³  ì™„ë£Œë¥¼ í™•ì •í•´ ì£¼ì„¸ìš”.
        </p>
      </div>

      {/* Primary CTA: ì™„ë£Œ í™•ì • - ê°€ì¥ ëˆˆì— ë„ëŠ” ë²„íŠ¼ (ëª¨ë°”ì¼ í„°ì¹˜ ì¹œí™”ì : ìµœì†Œ 44px ë†’ì´) */}
      <div className="flex flex-col gap-2 sm:flex-row">
        <button
          onClick={handleComplete}
          disabled={isLoading || isCompleting}
          className="flex-1 rounded-xl bg-gradient-to-r from-green-600 to-green-700 px-6 py-4 text-base font-bold text-white shadow-lg transition hover:from-green-700 hover:to-green-800 hover:shadow-xl disabled:opacity-50 disabled:hover:shadow-lg active:scale-[0.98] min-h-[44px]"
        >
          {isLoading ? (
            <span className="flex items-center justify-center gap-2">
              <span className="h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent" />
              ì²˜ë¦¬ ì¤‘...
            </span>
          ) : (
            mode === "camp" ? "ë¸”ë¡ ì™„ë£Œ í™•ì •" : "ì™„ë£Œ í™•ì •"
          )}
        </button>
      </div>

      {/* íƒ€ì´ë¨¸ Â· ì¼ì • ì œì–´ (Secondary) - ëœ ëˆˆì— ë„ê²Œ í‘œì‹œ */}
      <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50/50 p-4 shadow-sm">
        <div className="flex flex-col gap-1">
          <h2 className="text-sm font-semibold text-gray-700">íƒ€ì´ë¨¸ Â· ì¼ì • ì œì–´</h2>
          <p className="text-xs text-gray-500">íƒ€ì´ë¨¸ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ê±°ë‚˜ ì¼ì • ì¡°ì •ì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.</p>
        </div>
          <div className="flex flex-col gap-2 sm:flex-row">
            <button
              onClick={handleStart}
              disabled={isLoading}
              className="flex-1 rounded-lg bg-indigo-600 px-4 py-3 text-sm font-bold text-white shadow-sm transition hover:bg-indigo-700 hover:shadow-md disabled:opacity-50 active:scale-[0.98] min-h-[44px]"
            >
              íƒ€ì´ë¨¸ ë‹¤ì‹œ ì‹¤í–‰
            </button>
            {plan.is_reschedulable && (
              <button
                onClick={handlePostpone}
                disabled={isLoading}
                className="flex-1 rounded-lg border-2 border-gray-300 bg-white px-4 py-3 text-sm font-bold text-gray-700 transition hover:bg-gray-50 hover:border-gray-400 disabled:opacity-50 active:scale-[0.98] min-h-[44px]"
              >
                ì˜¤ëŠ˜ ì¼ì • ë¯¸ë£¨ê¸°
              </button>
            )}
          </div>
        </div>


      {/* ì—°ê²°ëœ í•™ìŠµ ë¸”ë¡ (Secondary) - ëœ ëˆˆì— ë„ê²Œ í‘œì‹œ */}
      {relatedPlans.length > 1 && (
        <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50/50 p-4 shadow-sm">
          <div className="flex flex-col gap-1">
            <h3 className="text-sm font-semibold text-gray-700">ì—°ê²°ëœ í•™ìŠµ ë¸”ë¡</h3>
            <p className="text-xs text-gray-500">
                {mode === "camp" 
                  ? "ì´ ìº í”„ ë‚´ì—ì„œ ì´ì–´ì§€ëŠ” í•™ìŠµ ë¸”ë¡ë“¤ì´ì—ìš”. í˜„ì¬ ë¸”ë¡ë§Œ ì™„ë£Œë˜ë©°, ë‹¤ë¥¸ ë¸”ë¡ì˜ ìƒíƒœëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
                  : "ê°™ì€ í”Œëœ ë²ˆí˜¸ë¡œ ë¬¶ì¸ ë¸”ë¡ë“¤ì´ì—ìš”. ì´ í˜ì´ì§€ì—ì„œ ì™„ë£Œ ì²˜ë¦¬ë˜ëŠ” ê²ƒì€ í˜„ì¬ ë¸”ë¡ë§Œì´ë©°, ë‹¤ë¥¸ ë¸”ë¡ì˜ ìƒíƒœëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."}
              </p>
            </div>
            <div className="flex flex-col gap-2">
              {relatedPlans.map((relatedPlan) => {
                const isCurrent = relatedPlan.id === plan.id;
                const relatedStatus = relatedPlan.actual_end_time
                  ? "COMPLETED"
                  : relatedPlan.actual_start_time
                  ? "RUNNING"
                  : "NOT_STARTED";
                
                return (
                  <div
                    key={relatedPlan.id}
                    className={`flex items-center justify-between rounded-md px-3 py-2 text-sm ${
                      isCurrent
                        ? "border-2 border-indigo-300 bg-indigo-50"
                        : "bg-gray-50"
                    }`}
                  >
                    <div className="flex flex-col">
                      <span className="font-semibold text-gray-900">
                        ë¸”ë¡ #{relatedPlan.sequence ?? relatedPlan.block_index ?? 0}
                      </span>
                      <span className="text-xs text-gray-500">
                        {relatedPlan.planned_start_page_or_time ?? "-"} ~{" "}
                        {relatedPlan.planned_end_page_or_time ?? "-"} {unitLabel}
                      </span>
                    </div>
                    {isCurrent ? (
                      <span className="rounded-full bg-indigo-100 px-2 py-1 text-[11px] font-semibold text-indigo-700">
                        í˜„ì¬ ë¸”ë¡
                      </span>
                    ) : (
                      <StatusBadge status={relatedStatus} size="sm" />
                    )}
                  </div>
                );
              })}
            </div>
          </div>
      )}
    </div>
  );
}
</file>

<file path="plan/[planId]/page.tsx">
import { redirect, notFound } from "next/navigation";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getPlanById, getPlansForStudent, Plan } from "@/lib/data/studentPlans";
import { getBooks, getLectures, getCustomContents } from "@/lib/data/studentContents";
import { getActiveSession } from "@/lib/data/studentSessions";
import { PlanExecutionForm } from "./_components/PlanExecutionForm";
import Link from "next/link";
import {
  calculateStudyTimeFromTimestamps,
  formatTime,
  formatTimestamp,
} from "@/app/(student)/today/_utils/planGroupUtils";
import { getContainerClass } from "@/lib/constants/layout";

type PlanCompletionMode = "today" | "camp";

type PlanExecutionPageProps = {
  params: Promise<{ planId: string }>;
  searchParams: Promise<{ mode?: string }>;
};

export default async function PlanExecutionPage({ 
  params,
  searchParams,
}: PlanExecutionPageProps) {
  const { planId } = await params;
  const user = await getCurrentUser();

  if (!user || user.role !== "student") {
    redirect("/login");
  }

  const tenantContext = await getTenantContext();
  const plan = await getPlanById(planId, user.userId, tenantContext?.tenantId || null);

  if (!plan || !plan.content_type || !plan.content_id) {
    notFound();
  }

  // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ
  let content = null;
  if (plan.content_type === "book") {
    const books = await getBooks(user.userId, tenantContext?.tenantId || null);
    content = books.find((b) => b.id === plan.content_id) || null;
  } else if (plan.content_type === "lecture") {
    const lectures = await getLectures(user.userId, tenantContext?.tenantId || null);
    content = lectures.find((l) => l.id === plan.content_id) || null;
  } else if (plan.content_type === "custom") {
    const customContents = await getCustomContents(
      user.userId,
      tenantContext?.tenantId || null
    );
    content = customContents.find((c) => c.id === plan.content_id) || null;
  }

  if (!content) {
    notFound();
  }

  // íŠ¹ì • í”Œëœì˜ í™œì„± ì„¸ì…˜ í™•ì¸
  const { getSessionsInRange } = await import("@/lib/data/studentSessions");
  const activeSessionsForPlan = await getSessionsInRange({
    studentId: user.userId,
    tenantId: tenantContext?.tenantId || null,
    planId: planId,
    isActive: true,
  });
  const activeSession = activeSessionsForPlan.length > 0 ? activeSessionsForPlan[0] : null;

  let relatedPlans: Plan[] = [plan];
  if (plan.plan_number !== null && plan.plan_number !== undefined) {
    const plansOnSameDay = await getPlansForStudent({
      studentId: user.userId,
      tenantId: tenantContext?.tenantId || null,
      planDate: plan.plan_date,
    });
    relatedPlans = plansOnSameDay
      .filter((p) => p.plan_number === plan.plan_number)
      .sort((a, b) => (a.block_index ?? 0) - (b.block_index ?? 0));
  }

  const contentTypeLabels: Record<string, string> = {
    book: "ì±…",
    lecture: "ê°•ì˜",
    custom: "ì»¤ìŠ¤í…€",
  };

  const unitLabel = plan.content_type === "book" ? "í˜ì´ì§€" : "ë¶„";

  // ì˜ˆìƒ ì†Œìš” ì‹œê°„ ê³„ì‚° (ê°„ë‹¨íˆ)
  const estimatedMinutes =
    plan.planned_start_page_or_time !== null &&
    plan.planned_start_page_or_time !== undefined &&
    plan.planned_end_page_or_time !== null &&
    plan.planned_end_page_or_time !== undefined
      ? plan.planned_end_page_or_time - plan.planned_start_page_or_time
      : null;
  const hasCompletedTimer = !!(plan.actual_start_time && plan.actual_end_time);
  const formattedActualStart = plan.actual_start_time
    ? formatTimestamp(plan.actual_start_time)
    : null;
  const formattedActualEnd = plan.actual_end_time
    ? formatTimestamp(plan.actual_end_time)
    : null;
  const pureStudySeconds = hasCompletedTimer
    ? calculateStudyTimeFromTimestamps(
        plan.actual_start_time,
        plan.actual_end_time,
        plan.paused_duration_seconds
      )
    : 0;
  const formattedPureStudyTime = hasCompletedTimer ? formatTime(Math.max(0, pureStudySeconds)) : null;

  // ëª¨ë“œ ì½ê¸° (ê¸°ë³¸ê°’: "today")
  const resolvedSearchParams = await searchParams;
  const modeParam = resolvedSearchParams?.mode;
  const mode: PlanCompletionMode = modeParam === "camp" ? "camp" : "today";

  // ëª¨ë“œì— ë”°ë¥¸ ë’¤ë¡œê°€ê¸° ë§í¬
  const backLinkHref = mode === "camp" ? "/camp/today" : "/today";
  const backLinkText = mode === "camp" ? "ìº í”„ ì¼ì •ìœ¼ë¡œ ëŒì•„ê°€ê¸°" : "Todayë¡œ ëŒì•„ê°€ê¸°";

  return (
    <div className={getContainerClass("FORM", "md")}>
      <div className="flex flex-col gap-6">
        <Link
          href={backLinkHref}
          className="inline-flex items-center gap-2 text-sm font-medium text-gray-600 transition hover:text-gray-900"
        >
          <span>â†</span>
          <span>{backLinkText}</span>
        </Link>

        <div className="flex flex-col gap-8 rounded-xl border border-gray-200 bg-white p-6 shadow-sm sm:p-8">
          <div className="flex flex-col gap-3">
            <div className="flex flex-wrap items-center gap-2">
            <span className="rounded-full bg-blue-100 px-3 py-1.5 text-xs font-bold text-blue-700">
              {contentTypeLabels[plan.content_type]}
            </span>
            {plan.chapter && (
              <span className="rounded-md bg-gray-100 px-3 py-1.5 text-xs font-semibold text-gray-700">
                ì±•í„°: {plan.chapter}
              </span>
            )}
            </div>
            <h1 className="text-2xl font-bold text-gray-900 sm:text-3xl">{content.title}</h1>
            {content.subject && (
              <p className="text-sm font-medium text-gray-600">ê³¼ëª©: {content.subject}</p>
            )}
          </div>

          <div className="flex flex-col gap-3 space-y-3 rounded-lg border border-gray-200 bg-gray-50 p-4 sm:p-5">
          <div className="flex items-center justify-between text-sm">
            <span className="font-medium text-gray-600">ì˜ˆìƒ ë²”ìœ„</span>
            <span className="font-bold text-gray-900">
              {plan.planned_start_page_or_time !== null &&
              plan.planned_end_page_or_time !== null
                ? `${plan.planned_start_page_or_time} ~ ${plan.planned_end_page_or_time} ${unitLabel}`
                : "ë¯¸ì§€ì •"}
            </span>
          </div>
          {estimatedMinutes !== null && (
            <div className="flex items-center justify-between text-sm">
              <span className="font-medium text-gray-600">ì˜ˆìƒ ì†Œìš” ì‹œê°„</span>
              <span className="font-bold text-gray-900">
                ì•½ {estimatedMinutes} {unitLabel}
              </span>
            </div>
          )}
          </div>

          {hasCompletedTimer && formattedActualStart && formattedActualEnd && formattedPureStudyTime && (
            <div className="flex flex-col gap-4 rounded-xl border-2 border-emerald-200 bg-gradient-to-br from-emerald-50 to-white p-5 shadow-md">
              <h2 className="text-base font-bold text-emerald-900">í•™ìŠµ ì™„ë£Œ ê¸°ë¡</h2>
            <div className="grid gap-3 text-sm text-emerald-950 sm:grid-cols-3">
              <div className="flex flex-col gap-1 rounded-lg bg-white/80 p-3 shadow-sm">
                <span className="text-xs font-medium text-emerald-600">ì‹œì‘ ì‹œê°„</span>
                <span className="text-sm font-bold">{formattedActualStart}</span>
              </div>
              <div className="flex flex-col gap-1 rounded-lg bg-white/80 p-3 shadow-sm">
                <span className="text-xs font-medium text-emerald-600">ì¢…ë£Œ ì‹œê°„</span>
                <span className="text-sm font-bold">{formattedActualEnd}</span>
              </div>
              <div className="flex flex-col gap-1 rounded-lg bg-white/80 p-3 shadow-sm">
                <span className="text-xs font-medium text-emerald-600">ì´ í•™ìŠµ ì‹œê°„ (ì¼ì‹œì •ì§€ ì œì™¸)</span>
                <span className="text-lg font-bold text-emerald-900">{formattedPureStudyTime}</span>
              </div>
            </div>
          </div>
          )}
        </div>


        <PlanExecutionForm
          mode={mode}
          plan={plan}
          content={content}
          activeSession={activeSession}
          unitLabel={unitLabel}
          relatedPlans={relatedPlans}
        />
      </div>
    </div>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { TodayHeader } from "./_components/TodayHeader";
import { TodayPlansSection } from "./_components/TodayPlansSection";
import { TodayAchievementsSection } from "./_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "./_components/TodayPageContext";
import { CurrentLearningSection } from "./_components/CurrentLearningSection";
import { CompletionToast } from "./_components/CompletionToast";
import { EmptyState } from "@/components/molecules/EmptyState";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { formatDateString } from "@/lib/date/calendarUtils";
import { getPlanById } from "@/lib/data/studentPlans";
import { getContainerClass } from "@/lib/constants/layout";

type TodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function TodayPage({ searchParams }: TodayPageProps) {
  const pageTimer = perfTime("[today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = formatDateString(today);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ì¼ë°˜ í”Œëœ ê·¸ë£¹ í™•ì¸
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ì¼ë°˜ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§ (ìº í”„ ëª¨ë“œ ì œì™¸)
  const activePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type !== "camp" &&
      group.camp_template_id === null &&
      group.camp_invitation_id === null
  );

  // í™œì„± ì¼ë°˜ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activePlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <EmptyState
            icon="ğŸ“š"
            title="í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤"
            description="í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•˜ê³  í™œì„±í™”í•˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
          />
        </div>
      </div>
    );
  }

  // Step 4: todayPlans ìºì‹œ ì‚¬ìš©
  const todayPlansTimer = perfTime("[today] data - todayPlans");
  const todayPlansDataPromise = getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: targetProgressDate,
    camp: false, // ì¼ë°˜ ëª¨ë“œ
    includeProgress: true,
    narrowQueries: true,
    useCache: true,
    cacheTtlSeconds: 120,
  }).catch((error) => {
    console.error("[TodayPage] todayPlans ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  });

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[TodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  const [todayPlansData] = await Promise.all([todayPlansDataPromise]);
  todayPlansTimer.end();

  // todayPlansDataì—ì„œ todayProgress ì¶”ì¶œ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
  const todayProgress = todayPlansData?.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <TodayHeader />
          <CurrentLearningSection />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="_components/ActiveLearningWidget.tsx">
"use client";

import { useEffect, useState } from "react";
import { Clock, Pause, Play } from "lucide-react";
import { pausePlan, resumePlan } from "@/app/(student)/today/actions/todayActions";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { buildPlanExecutionUrl } from "@/app/(student)/today/_utils/navigationUtils";

type ActivePlan = {
  id: string;
  title: string;
  contentType: "book" | "lecture" | "custom";
  actualStartTime: string;
  pausedDurationSeconds: number;
  pauseCount: number;
  isPaused: boolean;
};

type ActiveLearningWidgetProps = {
  activePlan: ActivePlan | null;
  campMode?: boolean;
};

export function ActiveLearningWidget({ activePlan: initialActivePlan, campMode = false }: ActiveLearningWidgetProps) {
  const router = useRouter();
  const [activePlan, setActivePlan] = useState(initialActivePlan);
  const [elapsedSeconds, setElapsedSeconds] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (!activePlan || activePlan.isPaused) {
      return;
    }

    const calculateElapsed = () => {
      const start = new Date(activePlan.actualStartTime);
      const now = new Date();
      const total = Math.floor((now.getTime() - start.getTime()) / 1000);
      const paused = activePlan.pausedDurationSeconds || 0;
      return Math.max(0, total - paused);
    };

    setElapsedSeconds(calculateElapsed());

    const interval = setInterval(() => {
      setElapsedSeconds(calculateElapsed());
    }, 1000);

    return () => clearInterval(interval);
  }, [activePlan]);

  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}ì‹œê°„ ${minutes}ë¶„`;
    }
    return `${minutes}ë¶„ ${secs}ì´ˆ`;
  };

  const handlePause = async () => {
    if (!activePlan) return;
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì¼ì‹œì •ì§€ëœ ìƒíƒœë©´ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if (isLoading || activePlan.isPaused) {
      return;
    }

    setIsLoading(true);
    try {
      const result = await pausePlan(activePlan.id);
      if (result.success) {
        setActivePlan((prev) => prev ? { ...prev, isPaused: true } : null);
        router.refresh();
      } else {
        // "ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤" ì—ëŸ¬ëŠ” ë¬´ì‹œ (ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€)
        if (result.error && !result.error.includes("ì´ë¯¸ ì¼ì‹œì •ì§€ëœ ìƒíƒœì…ë‹ˆë‹¤")) {
          console.error("[ActiveLearningWidget] ì¼ì‹œì •ì§€ ì‹¤íŒ¨:", result.error);
        }
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleResume = async () => {
    if (!activePlan) return;
    setIsLoading(true);
    try {
      const result = await resumePlan(activePlan.id);
      if (result.success) {
        setActivePlan((prev) => prev ? { ...prev, isPaused: false } : null);
        router.refresh();
      }
    } finally {
      setIsLoading(false);
    }
  };

  if (!activePlan) {
    return null;
  }

  const contentTypeIcon = {
    book: "ğŸ“š",
    lecture: "ğŸ§",
    custom: "ğŸ“",
  }[activePlan.contentType];

  return (
    <div className="flex flex-col gap-4 rounded-xl border border-indigo-200 bg-gradient-to-br from-indigo-50 to-blue-50 p-6 shadow-sm">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="text-2xl">ğŸ¯</span>
          <h3 className="text-lg font-semibold text-gray-900">í˜„ì¬ í•™ìŠµ ì¤‘</h3>
        </div>
      </div>

      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <span className="text-xl">{contentTypeIcon}</span>
          <h4 className="font-semibold text-gray-900">{activePlan.title}</h4>
        </div>

        <div className="flex items-center gap-4 text-sm text-gray-600">
          <div className="flex items-center gap-1">
            <Clock className="h-4 w-4" />
            <span className="font-medium">í•™ìŠµ ì‹œê°„: {formatTime(elapsedSeconds)}</span>
          </div>
          {activePlan.pauseCount > 0 && (
            <div className="flex items-center gap-1">
              <Pause className="h-4 w-4" />
              <span>ì¼ì‹œì •ì§€ {activePlan.pauseCount}íšŒ</span>
            </div>
          )}
        </div>
      </div>

      <div className="flex gap-2">
        {activePlan.isPaused ? (
          <button
            onClick={handleResume}
            disabled={isLoading}
            className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
          >
            <Play className="h-4 w-4" />
            ë‹¤ì‹œì‹œì‘
          </button>
        ) : (
          <button
            onClick={handlePause}
            disabled={isLoading}
            className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-yellow-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-yellow-700 disabled:opacity-50"
          >
            <Pause className="h-4 w-4" />
            ì¼ì‹œì •ì§€
          </button>
        )}
        <Link
          href={buildPlanExecutionUrl(activePlan.id, campMode)}
          className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-gray-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-gray-700"
        >
          ìƒì„¸ë³´ê¸°
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="_components/MonthlyReportSection.tsx">
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import type { MonthlyReport } from "@/lib/reports/monthly";

type MonthlyReportSectionProps = {
  studentId: string;
  monthDate: Date;
};

export function MonthlyReportSection({
  studentId,
  monthDate,
}: MonthlyReportSectionProps) {
  const [data, setData] = useState<MonthlyReport | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function load() {
      try {
        setLoading(true);
        setError(null);

        // monthDateë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const monthDateStr = monthDate.toISOString().slice(0, 10);
        const response = await fetch(
          `/api/dashboard/monthly-report?monthDate=${monthDateStr}`
        );

        if (!response.ok) {
          throw new Error("ì›”ê°„ ë¦¬í¬íŠ¸ ì¡°íšŒ ì‹¤íŒ¨");
        }

        const result = await response.json();
        if (result.success && result.data) {
          setData(result.data);
        } else {
          throw new Error(result.error?.message || "ì›”ê°„ ë¦¬í¬íŠ¸ ì¡°íšŒ ì‹¤íŒ¨");
        }
      } catch (err) {
        console.error("[MonthlyReportSection] ë¡œë“œ ì‹¤íŒ¨", err);
        setError(err instanceof Error ? err.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜");
      } finally {
        setLoading(false);
      }
    }

    load();
  }, [studentId, monthDate]);

  if (loading) {
    return (
      <div className="flex flex-col gap-6">
        <div className="flex items-center justify-between">
          <h2 className="text-h2 text-gray-900">ì´ë²ˆ ë‹¬ ìš”ì•½</h2>
          <div className="flex items-center gap-3">
            <Link
              href="/report/monthly"
              className="text-sm font-medium text-indigo-600 hover:text-indigo-700"
            >
              ìƒì„¸ ë¦¬í¬íŠ¸ ë³´ê¸° â†’
            </Link>
          </div>
        </div>
        <div className="rounded-xl border border-purple-200 bg-gradient-to-br from-purple-50 to-pink-50 p-6 shadow-sm">
          <div className="flex items-center justify-center py-8">
            <p className="text-sm text-gray-500">ì›”ê°„ ë¦¬í¬íŠ¸ ë¡œë”© ì¤‘...</p>
          </div>
        </div>
      </div>
    );
  }

  if (error || !data) {
    return (
      <div className="flex flex-col gap-6">
        <div className="flex items-center justify-between">
          <h2 className="text-h2 text-gray-900">ì´ë²ˆ ë‹¬ ìš”ì•½</h2>
          <div className="flex items-center gap-3">
            <Link
              href="/report/monthly"
              className="text-sm font-medium text-indigo-600 hover:text-indigo-700"
            >
              ìƒì„¸ ë¦¬í¬íŠ¸ ë³´ê¸° â†’
            </Link>
          </div>
        </div>
        <div className="rounded-xl border border-red-200 bg-red-50 p-6 shadow-sm">
          <p className="text-sm text-red-600">
            {error || "ì›”ê°„ ë¦¬í¬íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      <div className="flex items-center justify-between">
        <h2 className="text-h2 text-gray-900">ì´ë²ˆ ë‹¬ ìš”ì•½</h2>
        <div className="flex items-center gap-3">
          <Link
            href="/report/monthly"
            className="text-sm font-medium text-indigo-600 hover:text-indigo-700"
          >
            ìƒì„¸ ë¦¬í¬íŠ¸ ë³´ê¸° â†’
          </Link>
        </div>
      </div>
      <div className="rounded-xl border border-purple-200 bg-gradient-to-br from-purple-50 to-pink-50 p-6 shadow-sm">
        <div className="grid gap-4 sm:grid-cols-4">
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">
              ì´ í•™ìŠµì‹œê°„
            </div>
            <div className="text-2xl font-bold text-purple-600">
              {Math.floor(data.totals.studyMinutes / 60)}ì‹œê°„{" "}
              {data.totals.studyMinutes % 60}ë¶„
            </div>
          </div>
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">
              í”Œëœ ì‹¤í–‰ë¥ 
            </div>
            <div className="text-2xl font-bold text-indigo-600">
              {data.totals.completionRate}%
            </div>
          </div>
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">
              ëª©í‘œ ë‹¬ì„±ë¥ 
            </div>
            <div className="text-2xl font-bold text-emerald-600">
              {data.totals.goalRate}%
            </div>
          </div>
          <div className="text-center">
            <Link
              href="/report/monthly"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì›”ê°„ ë¦¬í¬íŠ¸ ë³´ê¸°
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/RecommendationCard.tsx">
import { getRecommendations, getTopRecommendations } from "@/lib/recommendations/engine";
import { createSupabaseServerClient } from "@/lib/supabase/server";

export async function RecommendationCard() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return null;
  }

  const recommendations = await getRecommendations(supabase, user.id);
  const topRecommendations = getTopRecommendations(recommendations, 3);

  if (topRecommendations.length === 0) {
    return null;
  }

  return (
    <div className="rounded-2xl border border-blue-200 bg-gradient-to-br from-blue-50 to-indigo-50 p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        <h2 className="text-xl font-semibold text-gray-900">í•™ìŠµ ì¶”ì²œ</h2>

        <ul className="flex flex-col gap-3">
          {topRecommendations.map((rec, index) => (
            <li key={index} className="flex items-start gap-3">
              <span className="flex h-5 w-5 shrink-0 items-center justify-center rounded-full bg-blue-100 text-xs font-semibold text-blue-700">
                {index + 1}
              </span>
              <p className="flex-1 text-sm text-gray-700 leading-relaxed">{rec}</p>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="_components/TimeStatistics.tsx">
"use client";

type TimeStatisticsProps = {
  totalStudySeconds: number;
  pureStudySeconds: number;
  pausedSeconds: number;
  averagePlanMinutes: number;
};

export function TimeStatistics({
  totalStudySeconds,
  pureStudySeconds,
  pausedSeconds,
  averagePlanMinutes,
}: TimeStatisticsProps) {
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `${hours}ì‹œê°„ ${minutes}ë¶„`;
    }
    return `${minutes}ë¶„`;
  };

  return (
    <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        <h3 className="text-lg font-semibold text-gray-900">ğŸ“Š ì˜¤ëŠ˜ì˜ ì‹œê°„ ë¶„ì„</h3>
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">ì´ í•™ìŠµ ì‹œê°„</div>
            <div className="text-2xl font-bold text-indigo-600">
              {formatTime(totalStudySeconds)}
            </div>
          </div>
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">ìˆœìˆ˜ í•™ìŠµ ì‹œê°„</div>
            <div className="text-2xl font-bold text-blue-600">
              {formatTime(pureStudySeconds)}
            </div>
          </div>
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">ì¼ì‹œì •ì§€ ì‹œê°„</div>
            <div className="text-2xl font-bold text-yellow-600">
              {formatTime(pausedSeconds)}
            </div>
          </div>
          <div className="flex flex-col gap-1 text-center">
            <div className="text-sm font-medium text-gray-600">í‰ê·  í”Œëœ ì‹œê°„</div>
            <div className="text-2xl font-bold text-purple-600">
              {averagePlanMinutes}ë¶„
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_utils.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

type ContentType = "book" | "lecture" | "custom";

// ì˜¤ëŠ˜ ë‚ ì§œ ê¸°ë°˜ í”Œëœ ì¡°íšŒ
export type TodayPlan = {
  id: string;
  block_index: number;
  content_type: ContentType;
  content_id: string;
  title: string;
  subject: string | null;
  difficulty_level: string | null;
  start_time: string | null;
  end_time: string | null;
  progress: number | null;
  planned_start_page_or_time: number | null;
  planned_end_page_or_time: number | null;
  actual_start_time: string | null;
  actual_end_time: string | null;
  total_duration_seconds: number | null;
  paused_duration_seconds: number | null;
  pause_count: number | null;
};

// í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ì •ë³´
export type ActivePlan = {
  id: string;
  title: string;
  contentType: ContentType;
  actualStartTime: string;
  pausedDurationSeconds: number;
  pauseCount: number;
  isPaused: boolean;
};

type PlanRow = {
  id: string;
  block_index?: number | null;
  content_type?: string | null;
  content_id?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
};

type ContentRow = {
  id: string;
  title?: string | null;
  subject?: string | null;
  difficulty_level?: string | null;
};

type BlockRow = {
  id: string;
  day_of_week?: number | null;
  start_time?: string | null;
  end_time?: string | null;
  block_index?: number | null;
};

type ProgressRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  progress?: number | null;
};

export async function fetchTodayPlans(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string,
  dayOfWeek: number
): Promise<TodayPlan[]> {
  try {
    // 1. ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¡°íšŒ (timing ì •ë³´ í¬í•¨í•˜ì—¬ N+1 ì œê±°)
    const selectPlans = () =>
      supabase
        .from("student_plan")
        .select(
          "id,block_index,content_type,content_id,planned_start_page_or_time,planned_end_page_or_time,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count"
        )
        .eq("plan_date", todayDate)
        .order("block_index", { ascending: true });

    let { data: plans, error } = await selectPlans().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data: plans, error } = await selectPlans());
    }
    if (error) throw error;

    const planRows = (plans as PlanRow[] | null) ?? [];
    if (planRows.length === 0) {
      return [];
    }

    // 2. ë¸”ë¡ ì •ë³´ ì¡°íšŒ
    const blocks = await fetchBlocksForDay(supabase, studentId, dayOfWeek);
    const blockMap = new Map<number, BlockRow>();
    blocks.forEach((block) => {
      const blockIndex =
        typeof block.block_index === "number" && block.block_index > 0
          ? block.block_index
          : null;
      if (blockIndex) {
        blockMap.set(blockIndex, block);
      }
    });

    // 3. ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ
    const [bookMap, lectureMap, customMap] = await Promise.all([
      fetchContentMap(supabase, studentId, "books"),
      fetchContentMap(supabase, studentId, "lectures"),
      fetchContentMap(supabase, studentId, "student_custom_contents"),
    ]);

    // 4. ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // 5. í”Œëœê³¼ ì½˜í…ì¸  ë§¤í•‘
    const todayPlans: TodayPlan[] = [];

    for (const plan of planRows) {
      const contentType = toContentType(plan.content_type);
      const contentId = plan.content_id;
      const blockIndex =
        typeof plan.block_index === "number" && plan.block_index > 0
          ? plan.block_index
          : null;

      if (!contentId || !blockIndex) {
        continue;
      }

      const block = blockMap.get(blockIndex);
      const contentMeta = resolveContentMeta(
        contentId,
        contentType,
        bookMap,
        lectureMap,
        customMap
      );

      const progressKey = `${contentType}:${contentId}`;
      const progress = progressMap[progressKey] ?? null;

      // N+1 ì œê±°: timing ì •ë³´ëŠ” ì´ë¯¸ ì¡°íšŒí•œ plan ê°ì²´ì—ì„œ ê°€ì ¸ì˜´
      // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) null ê°’ìœ¼ë¡œ ì²˜ë¦¬
      const planWithTiming = plan as PlanRow & {
        actual_start_time?: string | null;
        actual_end_time?: string | null;
        total_duration_seconds?: number | null;
        paused_duration_seconds?: number | null;
        pause_count?: number | null;
      };

      todayPlans.push({
        id: plan.id,
        block_index: blockIndex,
        content_type: contentType,
        content_id: contentId,
        title: contentMeta.title,
        subject: contentMeta.subject,
        difficulty_level: contentMeta.difficulty_level,
        start_time: block?.start_time ?? null,
        end_time: block?.end_time ?? null,
        progress,
        planned_start_page_or_time: plan.planned_start_page_or_time ?? null,
        planned_end_page_or_time: plan.planned_end_page_or_time ?? null,
        actual_start_time: planWithTiming?.actual_start_time ?? null,
        actual_end_time: planWithTiming?.actual_end_time ?? null,
        total_duration_seconds: planWithTiming?.total_duration_seconds ?? null,
        paused_duration_seconds: planWithTiming?.paused_duration_seconds ?? null,
        pause_count: planWithTiming?.pause_count ?? null,
      });
    }

    return todayPlans.sort((a, b) => a.block_index - b.block_index);
  } catch (error) {
    console.error("[dashboard] ì˜¤ëŠ˜ í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

async function fetchBlocksForDay(
  supabase: SupabaseServerClient,
  studentId: string,
  dayOfWeek: number
): Promise<BlockRow[]> {
  try {
    // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("active_block_set_id")
      .eq("id", studentId)
      .maybeSingle();

    if (studentError && studentError.code !== "PGRST116") {
      console.warn("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
    }

    const activeBlockSetId = student?.active_block_set_id;

    // í™œì„± ë¸”ë¡ ì„¸íŠ¸ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
    if (!activeBlockSetId) {
      return [];
    }

    // ë¸”ë¡ ì¡°íšŒ (block_index ì»¬ëŸ¼ì´ ìˆì„ ìˆ˜ë„ ìˆê³  ì—†ì„ ìˆ˜ë„ ìˆìŒ)
    const selectBlocks = () => {
      const query = supabase
        .from("student_block_schedule")
        .select("id,day_of_week,start_time,end_time,block_index")
        .eq("day_of_week", dayOfWeek)
        .eq("block_set_id", activeBlockSetId)
        .eq("student_id", studentId);

      // block_index ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ ì •ë ¬, ì—†ìœ¼ë©´ start_timeìœ¼ë¡œ ì •ë ¬
      return query.order("block_index", { ascending: true });
    };

    let { data, error } = await selectBlocks();
    
    // block_index ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬)
    if (error && error.code === "42703") {
      // block_index ì—†ì´ ì¡°íšŒí•˜ê³  start_timeìœ¼ë¡œ ì •ë ¬
      const fallbackQuery = supabase
        .from("student_block_schedule")
        .select("id,day_of_week,start_time,end_time")
        .eq("day_of_week", dayOfWeek)
        .eq("block_set_id", activeBlockSetId)
        .eq("student_id", studentId)
        .order("start_time", { ascending: true });

      const fallbackResult = await fallbackQuery;
      // block_indexê°€ ì—†ëŠ” ê²½ìš° nullë¡œ ì±„ì›€
      data = fallbackResult.data?.map(block => ({ ...block, block_index: null })) ?? null;
      error = fallbackResult.error;
    }

    if (error) {
      console.error("[dashboard] ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", {
        error,
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint,
        studentId,
        dayOfWeek,
        activeBlockSetId,
      });
      throw error;
    }

    const blocks = (data as BlockRow[] | null) ?? [];
    
    // block_indexê°€ ì—†ëŠ” ê²½ìš° ë™ì ìœ¼ë¡œ ê³„ì‚°
    if (blocks.length > 0 && (blocks[0].block_index === null || blocks[0].block_index === undefined)) {
      return blocks.map((block, index) => ({
        ...block,
        block_index: index + 1,
      }));
    }

    return blocks;
  } catch (error) {
    console.error("[dashboard] ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", {
      error,
      message: error instanceof Error ? error.message : String(error),
      studentId,
      dayOfWeek,
    });
    return [];
  }
}

export async function fetchContentMap(
  supabase: SupabaseServerClient,
  studentId: string,
  table: "books" | "lectures" | "student_custom_contents"
): Promise<Record<string, ContentRow>> {
  try {
    const selectContents = () =>
      supabase
        .from(table)
        .select("id,title,subject,difficulty_level")
        .order("created_at", { ascending: false });

    let { data, error } = await selectContents().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectContents());
    }
    if (error) throw error;

    const rows = (data as ContentRow[] | null) ?? [];
    return rows.reduce<Record<string, ContentRow>>((acc, row) => {
      acc[row.id] = row;
      return acc;
    }, {});
  } catch (error) {
    console.error(`[dashboard] ${table} ì¡°íšŒ ì‹¤íŒ¨`, error);
    return {};
  }
}

async function fetchProgressMap(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<Record<string, number | null>> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const rows = (data as ProgressRow[] | null) ?? [];
    return rows.reduce<Record<string, number | null>>((acc, row) => {
      if (row.content_type && row.content_id) {
        const key = `${row.content_type}:${row.content_id}`;
        acc[key] = row.progress ?? null;
      }
      return acc;
    }, {});
  } catch (error) {
    console.error("[dashboard] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {};
  }
}

function resolveContentMeta(
  contentId: string,
  contentType: ContentType,
  bookMap: Record<string, ContentRow>,
  lectureMap: Record<string, ContentRow>,
  customMap: Record<string, ContentRow>
): {
  title: string;
  subject: string | null;
  difficulty_level: string | null;
} {
  const map =
    contentType === "book"
      ? bookMap
      : contentType === "lecture"
      ? lectureMap
      : customMap;

  const row = map[contentId];

  if (!row) {
    return {
      title:
        contentType === "custom"
          ? "ì»¤ìŠ¤í…€ ì½˜í…ì¸ "
          : contentType === "lecture"
          ? "ê°•ì˜ ì½˜í…ì¸ "
          : "ì±… ì½˜í…ì¸ ",
      subject: null,
      difficulty_level: null,
    };
  }

  return {
    title: row.title ?? "ì œëª© ì—†ìŒ",
    subject: row.subject ?? null,
    difficulty_level: row.difficulty_level ?? null,
  };
}

function toContentType(raw?: string | null): ContentType {
  if (raw === "lecture" || raw === "custom") {
    return raw;
  }
  return "book";
}

// ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥  ê³„ì‚°
export function calculateTodayProgress(plans: TodayPlan[]): number {
  if (plans.length === 0) {
    return 0;
  }

  const totalProgress = plans.reduce((sum, plan) => {
    return sum + (plan.progress ?? 0);
  }, 0);

  return Math.round(totalProgress / plans.length);
}

// ì „ì²´ í•™ìŠµ í†µê³„
export type LearningStatistics = {
  weekProgress: number; // ì´ë²ˆ ì£¼ ì§„í–‰ë¥  (í‰ê· )
  completedCount: number; // ì™„ë£Œëœ ì½˜í…ì¸  ìˆ˜ (progress = 100)
  inProgressCount: number; // ì§„í–‰ ì¤‘ ì½˜í…ì¸  ìˆ˜ (0 < progress < 100)
};

export async function fetchLearningStatistics(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<LearningStatistics> {
  try {
    // ì´ë²ˆ ì£¼ ë‚ ì§œ ë²”ìœ„ ê³„ì‚° (ì›”~ì¼)
    const today = new Date();
    const dayOfWeek = today.getDay();
    const monday = new Date(today);
    monday.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
    monday.setHours(0, 0, 0, 0);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);

    const weekStart = monday.toISOString().slice(0, 10);
    const weekEnd = sunday.toISOString().slice(0, 10);

    // ì´ë²ˆ ì£¼ í”Œëœ ì¡°íšŒ
    const selectWeekPlans = () =>
      supabase
        .from("student_plan")
        .select("id,content_type,content_id")
        .gte("plan_date", weekStart)
        .lte("plan_date", weekEnd);

    let { data: weekPlans, error } = await selectWeekPlans().eq(
      "student_id",
      studentId
    );
    if (error && error.code === "42703") {
      ({ data: weekPlans, error } = await selectWeekPlans());
    }
    if (error) throw error;

    const planRows = (weekPlans as PlanRow[] | null) ?? [];

    // ëª¨ë“  ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // ì´ë²ˆ ì£¼ ì§„í–‰ë¥  ê³„ì‚°
    let weekProgressSum = 0;
    let weekProgressCount = 0;

    planRows.forEach((plan) => {
      if (plan.content_type && plan.content_id) {
        const key = `${plan.content_type}:${plan.content_id}`;
        const progress = progressMap[key];
        if (progress !== null && progress !== undefined) {
          weekProgressSum += progress;
          weekProgressCount++;
        }
      }
    });

    const weekProgress =
      weekProgressCount > 0
        ? Math.round(weekProgressSum / weekProgressCount)
        : 0;

    // ì™„ë£Œ/ì§„í–‰ ì¤‘ ì½˜í…ì¸  ìˆ˜ ê³„ì‚°
    const progressValues = Object.values(progressMap);
    let completedCount = 0;
    let inProgressCount = 0;

    progressValues.forEach((progress) => {
      if (progress === 100) {
        completedCount++;
      } else if (progress !== null && progress > 0 && progress < 100) {
        inProgressCount++;
      }
    });

    return {
      weekProgress,
      completedCount,
      inProgressCount,
    };
  } catch (error) {
    console.error("[dashboard] í†µê³„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      weekProgress: 0,
      completedCount: 0,
      inProgressCount: 0,
    };
  }
}

async function calculateTotalLearningAmount(
  supabase: SupabaseServerClient,
  studentId: string,
  progressMap: Record<string, number | null>
): Promise<number> {
  try {
    // ëª¨ë“  ì§„í–‰ë¥  ë ˆì½”ë“œì—ì„œ completed_amount ì¡°íšŒ
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,completed_amount");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const progressRows = (data as Array<{
      content_type?: string | null;
      content_id?: string | null;
      completed_amount?: number | null;
    }> | null) ?? [];

    // completed_amount í•©ê³„ ê³„ì‚° (ëˆ„ì  í•™ìŠµëŸ‰)
    let totalAmount = 0;

    for (const row of progressRows) {
      const completedAmount = row.completed_amount ?? 0;
      totalAmount += completedAmount;
    }

    return totalAmount;
  } catch (error) {
    console.error("[dashboard] ëˆ„ì  í•™ìŠµëŸ‰ ê³„ì‚° ì‹¤íŒ¨", error);
    return 0;
  }
}

async function fetchContentTotal(
  supabase: SupabaseServerClient,
  studentId: string,
  contentType: ContentType,
  contentId: string
): Promise<number | null> {
  try {
    if (contentType === "book") {
      const selectBook = () =>
        supabase
          .from("books")
          .select("id,total_pages")
          .eq("id", contentId);

      let { data, error } = await selectBook().eq("student_id", studentId).maybeSingle<{ id: string; total_pages?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectBook().maybeSingle<{ id: string; total_pages?: number | null }>());
      }
      if (error) throw error;

      return data?.total_pages ?? null;
    }

    if (contentType === "lecture") {
      const selectLecture = () =>
        supabase
          .from("lectures")
          .select("id,duration")
          .eq("id", contentId);

      let { data, error } = await selectLecture().eq("student_id", studentId).maybeSingle<{ id: string; duration?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectLecture().maybeSingle<{ id: string; duration?: number | null }>());
      }
      if (error) throw error;

      return data?.duration ?? null;
    }

    if (contentType === "custom") {
      const selectCustom = () =>
        supabase
          .from("student_custom_contents")
          .select("id,total_page_or_time")
          .eq("id", contentId);

      let { data, error } = await selectCustom().eq("student_id", studentId).maybeSingle<{ id: string; total_page_or_time?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectCustom().maybeSingle<{ id: string; total_page_or_time?: number | null }>());
      }
      if (error) throw error;

      return data?.total_page_or_time ?? null;
    }

    return null;
  } catch (error) {
    console.error("[dashboard] ì½˜í…ì¸  ì´ëŸ‰ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

// ì´ë²ˆ ì£¼ ìš”ì¼ë³„ ê³„íš ë¸”ë¡ ì¹´ìš´íŠ¸
export type WeeklyBlockCount = {
  dayOfWeek: number;
  dayLabel: string;
  blockCount: number;
};

export async function fetchWeeklyBlockCounts(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<WeeklyBlockCount[]> {
  try {
    // ì´ë²ˆ ì£¼ ë‚ ì§œ ë²”ìœ„ ê³„ì‚° (ì›”~ì¼)
    const today = new Date();
    const dayOfWeek = today.getDay();
    const monday = new Date(today);
    monday.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
    monday.setHours(0, 0, 0, 0);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);

    const weekStart = monday.toISOString().slice(0, 10);
    const weekEnd = sunday.toISOString().slice(0, 10);

    // ì´ë²ˆ ì£¼ í”Œëœ ì¡°íšŒ
    const selectWeekPlans = () =>
      supabase
        .from("student_plan")
        .select("id,plan_date,block_index")
        .gte("plan_date", weekStart)
        .lte("plan_date", weekEnd);

    let { data: weekPlans, error } = await selectWeekPlans().eq(
      "student_id",
      studentId
    );
    if (error && error.code === "42703") {
      ({ data: weekPlans, error } = await selectWeekPlans());
    }
    if (error) throw error;

    const planRows = (weekPlans as Array<{
      id: string;
      plan_date?: string | null;
      block_index?: number | null;
    }> | null) ?? [];

    // ìš”ì¼ë³„ ë¸”ë¡ ì¹´ìš´íŠ¸ ê³„ì‚°
    const dayCounts = new Map<number, Set<number>>();

    planRows.forEach((plan) => {
      if (!plan.plan_date) return;
      const planDate = new Date(`${plan.plan_date}T00:00:00Z`);
      if (Number.isNaN(planDate.getTime())) return;

      const planDayOfWeek = planDate.getUTCDay();
      const blockIndex =
        typeof plan.block_index === "number" && plan.block_index > 0
          ? plan.block_index
          : null;

      if (blockIndex !== null) {
        if (!dayCounts.has(planDayOfWeek)) {
          dayCounts.set(planDayOfWeek, new Set());
        }
        dayCounts.get(planDayOfWeek)!.add(blockIndex);
      }
    });

    const weekdayLabels = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
    const result: WeeklyBlockCount[] = [];

    for (let i = 0; i < 7; i++) {
      const blockSet = dayCounts.get(i) ?? new Set();
      result.push({
        dayOfWeek: i,
        dayLabel: weekdayLabels[i],
        blockCount: blockSet.size,
      });
    }

    return result;
  } catch (error) {
    console.error("[dashboard] ì´ë²ˆ ì£¼ ë¸”ë¡ ì¹´ìš´íŠ¸ ì¡°íšŒ ì‹¤íŒ¨", error);
    const weekdayLabels = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
    return weekdayLabels.map((label, index) => ({
      dayOfWeek: index,
      dayLabel: label,
      blockCount: 0,
    }));
  }
}

// ì½˜í…ì¸ ë³„ ëˆ„ì  ì§„í–‰ë¥ 
export type ContentTypeProgress = {
  book: number;
  lecture: number;
  custom: number;
};

export async function fetchContentTypeProgress(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<ContentTypeProgress> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,progress");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const rows = (data as Array<{
      content_type?: string | null;
      progress?: number | null;
    }> | null) ?? [];

    let bookSum = 0;
    let bookCount = 0;
    let lectureSum = 0;
    let lectureCount = 0;
    let customSum = 0;
    let customCount = 0;

    rows.forEach((row) => {
      const progress = row.progress ?? null;
      if (progress === null) return;

      if (row.content_type === "book") {
        bookSum += progress;
        bookCount++;
      } else if (row.content_type === "lecture") {
        lectureSum += progress;
        lectureCount++;
      } else if (row.content_type === "custom") {
        customSum += progress;
        customCount++;
      }
    });

    return {
      book: bookCount > 0 ? Math.round(bookSum / bookCount) : 0,
      lecture: lectureCount > 0 ? Math.round(lectureSum / lectureCount) : 0,
      custom: customCount > 0 ? Math.round(customSum / customCount) : 0,
    };
  } catch (error) {
    console.error("[dashboard] ì½˜í…ì¸ ë³„ ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      book: 0,
      lecture: 0,
      custom: 0,
    };
  }
}

/**
 * ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ ë§Œ ê°„ë‹¨íˆ ì¡°íšŒ (ì „ì²´ í”Œëœ ë°ì´í„° ë¶ˆí•„ìš”)
 */
export async function fetchTodayProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string
): Promise<number> {
  try {
    // student_content_progressì™€ student_planì„ ì¡°ì¸í•˜ì—¬ ì˜¤ëŠ˜ í”Œëœì˜ ì§„í–‰ë¥ ë§Œ ì¡°íšŒ
    const { data: plans, error } = await supabase
      .from("student_plan")
      .select("id,content_type,content_id")
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    if (error) {
      // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ê¸°ë³¸ê°’ ë°˜í™˜
      if (error.code === "42703") {
        return 0;
      }
      throw error;
    }

    if (!plans || plans.length === 0) {
      return 0;
    }

    // ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // ì˜¤ëŠ˜ í”Œëœë“¤ì˜ ì§„í–‰ë¥  í‰ê·  ê³„ì‚°
    let totalProgress = 0;
    let progressCount = 0;

    for (const plan of plans) {
      if (plan.content_type && plan.content_id) {
        const key = `${plan.content_type}:${plan.content_id}`;
        const progress = progressMap[key];
        if (progress !== null && progress !== undefined) {
          totalProgress += progress;
          progressCount++;
        }
      }
    }

    return progressCount > 0 ? Math.round(totalProgress / progressCount) : 0;
  } catch (error) {
    console.error("[dashboard] ì˜¤ëŠ˜ ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return 0;
  }
}

/**
 * í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ê°„ë‹¨ ì¡°íšŒ (ì½˜í…ì¸  ë§µ ë¶ˆí•„ìš”, ìµœì†Œí•œì˜ ì •ë³´ë§Œ)
 */
export async function fetchActivePlanSimple(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string
): Promise<ActivePlan | null> {
  try {
    // ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¤‘ ì‹œì‘í–ˆì§€ë§Œ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ ì¡°íšŒ
    const selectQuery = supabase
      .from("student_plan")
      .select(
        "id,actual_start_time,actual_end_time,paused_duration_seconds,pause_count,content_type,content_id"
      )
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    // actual_start_time ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ í•„í„°ë§
    let { data: activePlans, error } = await selectQuery
      .not("actual_start_time", "is", null)
      .is("actual_end_time", null)
      .order("actual_start_time", { ascending: false })
      .limit(1);

    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ë¹ˆ ê²°ê³¼ ë°˜í™˜
    if (error && error.code === "42703") {
      return null;
    }

    if (error) throw error;
    if (!activePlans || activePlans.length === 0) {
      return null;
    }

    const plan = activePlans[0];
    if (!plan.content_type || !plan.content_id || !plan.actual_start_time) {
      return null;
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒí•˜ì—¬ ì¼ì‹œì •ì§€ ìƒíƒœ í™•ì¸
    const { data: activeSession } = await supabase
      .from("student_study_sessions")
      .select("paused_at,resumed_at")
      .eq("plan_id", plan.id)
      .eq("student_id", studentId)
      .is("ended_at", null)
      .maybeSingle();

    const isPaused = activeSession?.paused_at && !activeSession?.resumed_at;

    // ì½˜í…ì¸  ì œëª©ë§Œ ê°„ë‹¨íˆ ì¡°íšŒ (ì½˜í…ì¸  ë§µ ì „ì²´ ë¶ˆí•„ìš”)
    const contentType = toContentType(plan.content_type);
    let title = "í•™ìŠµ ì¤‘";

    try {
      if (contentType === "book") {
        const { data: book } = await supabase
          .from("books")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = book?.title || "ì±…";
      } else if (contentType === "lecture") {
        const { data: lecture } = await supabase
          .from("lectures")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = lecture?.title || "ê°•ì˜";
      } else if (contentType === "custom") {
        const { data: custom } = await supabase
          .from("student_custom_contents")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = custom?.title || "ì»¤ìŠ¤í…€ ì½˜í…ì¸ ";
      }
    } catch (contentError) {
      console.warn("[dashboard] ì½˜í…ì¸  ì œëª© ì¡°íšŒ ì‹¤íŒ¨ (ê³„ì† ì§„í–‰)", contentError);
      // ì œëª© ì¡°íšŒ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }

    return {
      id: plan.id,
      title,
      contentType,
      actualStartTime: plan.actual_start_time,
      pausedDurationSeconds: plan.paused_duration_seconds || 0,
      pauseCount: plan.pause_count || 0,
      isPaused: !!isPaused,
    };
  } catch (error) {
    console.error("[dashboard] í™œì„± í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

/**
 * í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ì¡°íšŒ (ì˜¤ëŠ˜ ë‚ ì§œ, ì‹œì‘í–ˆì§€ë§Œ ì•„ì§ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ)
 */
export async function fetchActivePlan(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string,
  contentMaps?: {
    bookMap: Record<string, ContentRow>;
    lectureMap: Record<string, ContentRow>;
    customMap: Record<string, ContentRow>;
  }
): Promise<ActivePlan | null> {
  try {
    // ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¤‘ ì‹œì‘í–ˆì§€ë§Œ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ ì¡°íšŒ
    const selectQuery = supabase
      .from("student_plan")
      .select(
        "id,actual_start_time,actual_end_time,paused_duration_seconds,pause_count,content_type,content_id"
      )
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    // actual_start_time ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ í•„í„°ë§
    let { data: activePlans, error } = await selectQuery
      .not("actual_start_time", "is", null)
      .is("actual_end_time", null)
      .order("actual_start_time", { ascending: false })
      .limit(1);

    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ë¹ˆ ê²°ê³¼ ë°˜í™˜
    if (error && error.code === "42703") {
      console.warn("[dashboard] actual_start_time ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
      return null;
    }

    if (error) throw error;
    if (!activePlans || activePlans.length === 0) {
      return null;
    }

    const plan = activePlans[0];
    if (!plan.content_type || !plan.content_id || !plan.actual_start_time) {
      return null;
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒí•˜ì—¬ ì¼ì‹œì •ì§€ ìƒíƒœ í™•ì¸
    const { data: activeSession } = await supabase
      .from("student_study_sessions")
      .select("paused_at,resumed_at")
      .eq("plan_id", plan.id)
      .eq("student_id", studentId)
      .is("ended_at", null)
      .maybeSingle();

    const isPaused = activeSession?.paused_at && !activeSession?.resumed_at;

    // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ (ì¬ì‚¬ìš© ë˜ëŠ” ìƒˆë¡œ ì¡°íšŒ)
    const contentType = toContentType(plan.content_type);
    let bookMap: Record<string, ContentRow>;
    let lectureMap: Record<string, ContentRow>;
    let customMap: Record<string, ContentRow>;

    if (contentMaps) {
      // ì „ë‹¬ë°›ì€ ì½˜í…ì¸  ë§µ ì¬ì‚¬ìš©
      ({ bookMap, lectureMap, customMap } = contentMaps);
    } else {
      // fallback: ì—†ìœ¼ë©´ ìƒˆë¡œ ì¡°íšŒ
      [bookMap, lectureMap, customMap] = await Promise.all([
        fetchContentMap(supabase, studentId, "books"),
        fetchContentMap(supabase, studentId, "lectures"),
        fetchContentMap(supabase, studentId, "student_custom_contents"),
      ]);
    }

    const contentMeta = resolveContentMeta(
      plan.content_id,
      contentType,
      bookMap,
      lectureMap,
      customMap
    );

    return {
      id: plan.id,
      title: contentMeta.title,
      contentType,
      actualStartTime: plan.actual_start_time,
      pausedDurationSeconds: plan.paused_duration_seconds || 0,
      pauseCount: plan.pause_count || 0,
      isPaused: !!isPaused,
    };
  } catch (error) {
    console.error("[dashboard] í™œì„± í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}
</file>

<file path="_utils.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

type ContentType = "book" | "lecture" | "custom";

// ì˜¤ëŠ˜ ë‚ ì§œ ê¸°ë°˜ í”Œëœ ì¡°íšŒ
export type TodayPlan = {
  id: string;
  block_index: number;
  content_type: ContentType;
  content_id: string;
  title: string;
  subject: string | null;
  difficulty_level: string | null;
  start_time: string | null;
  end_time: string | null;
  progress: number | null;
  planned_start_page_or_time: number | null;
  planned_end_page_or_time: number | null;
  actual_start_time: string | null;
  actual_end_time: string | null;
  total_duration_seconds: number | null;
  paused_duration_seconds: number | null;
  pause_count: number | null;
};

// í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ì •ë³´
export type ActivePlan = {
  id: string;
  title: string;
  contentType: ContentType;
  actualStartTime: string;
  pausedDurationSeconds: number;
  pauseCount: number;
  isPaused: boolean;
};

type PlanRow = {
  id: string;
  block_index?: number | null;
  content_type?: string | null;
  content_id?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
};

type ContentRow = {
  id: string;
  title?: string | null;
  subject?: string | null;
  difficulty_level?: string | null;
};

type BlockRow = {
  id: string;
  day_of_week?: number | null;
  start_time?: string | null;
  end_time?: string | null;
  block_index?: number | null;
};

type ProgressRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  progress?: number | null;
};

export async function fetchTodayPlans(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string,
  dayOfWeek: number
): Promise<TodayPlan[]> {
  try {
    // 1. ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¡°íšŒ (timing ì •ë³´ í¬í•¨í•˜ì—¬ N+1 ì œê±°)
    const selectPlans = () =>
      supabase
        .from("student_plan")
        .select(
          "id,block_index,content_type,content_id,planned_start_page_or_time,planned_end_page_or_time,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count"
        )
        .eq("plan_date", todayDate)
        .order("block_index", { ascending: true });

    let { data: plans, error } = await selectPlans().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data: plans, error } = await selectPlans());
    }
    if (error) throw error;

    const planRows = (plans as PlanRow[] | null) ?? [];
    if (planRows.length === 0) {
      return [];
    }

    // 2. ë¸”ë¡ ì •ë³´ ì¡°íšŒ
    const blocks = await fetchBlocksForDay(supabase, studentId, dayOfWeek);
    const blockMap = new Map<number, BlockRow>();
    blocks.forEach((block) => {
      const blockIndex =
        typeof block.block_index === "number" && block.block_index > 0
          ? block.block_index
          : null;
      if (blockIndex) {
        blockMap.set(blockIndex, block);
      }
    });

    // 3. ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ
    const [bookMap, lectureMap, customMap] = await Promise.all([
      fetchContentMap(supabase, studentId, "books"),
      fetchContentMap(supabase, studentId, "lectures"),
      fetchContentMap(supabase, studentId, "student_custom_contents"),
    ]);

    // 4. ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // 5. í”Œëœê³¼ ì½˜í…ì¸  ë§¤í•‘
    const todayPlans: TodayPlan[] = [];

    for (const plan of planRows) {
      const contentType = toContentType(plan.content_type);
      const contentId = plan.content_id;
      const blockIndex =
        typeof plan.block_index === "number" && plan.block_index > 0
          ? plan.block_index
          : null;

      if (!contentId || !blockIndex) {
        continue;
      }

      const block = blockMap.get(blockIndex);
      const contentMeta = resolveContentMeta(
        contentId,
        contentType,
        bookMap,
        lectureMap,
        customMap
      );

      const progressKey = `${contentType}:${contentId}`;
      const progress = progressMap[progressKey] ?? null;

      // N+1 ì œê±°: timing ì •ë³´ëŠ” ì´ë¯¸ ì¡°íšŒí•œ plan ê°ì²´ì—ì„œ ê°€ì ¸ì˜´
      // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) null ê°’ìœ¼ë¡œ ì²˜ë¦¬
      const planWithTiming = plan as PlanRow & {
        actual_start_time?: string | null;
        actual_end_time?: string | null;
        total_duration_seconds?: number | null;
        paused_duration_seconds?: number | null;
        pause_count?: number | null;
      };

      todayPlans.push({
        id: plan.id,
        block_index: blockIndex,
        content_type: contentType,
        content_id: contentId,
        title: contentMeta.title,
        subject: contentMeta.subject,
        difficulty_level: contentMeta.difficulty_level,
        start_time: block?.start_time ?? null,
        end_time: block?.end_time ?? null,
        progress,
        planned_start_page_or_time: plan.planned_start_page_or_time ?? null,
        planned_end_page_or_time: plan.planned_end_page_or_time ?? null,
        actual_start_time: planWithTiming?.actual_start_time ?? null,
        actual_end_time: planWithTiming?.actual_end_time ?? null,
        total_duration_seconds: planWithTiming?.total_duration_seconds ?? null,
        paused_duration_seconds: planWithTiming?.paused_duration_seconds ?? null,
        pause_count: planWithTiming?.pause_count ?? null,
      });
    }

    return todayPlans.sort((a, b) => a.block_index - b.block_index);
  } catch (error) {
    console.error("[dashboard] ì˜¤ëŠ˜ í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

async function fetchBlocksForDay(
  supabase: SupabaseServerClient,
  studentId: string,
  dayOfWeek: number
): Promise<BlockRow[]> {
  try {
    // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("active_block_set_id")
      .eq("id", studentId)
      .maybeSingle();

    if (studentError && studentError.code !== "PGRST116") {
      console.warn("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
    }

    const activeBlockSetId = student?.active_block_set_id;

    // í™œì„± ë¸”ë¡ ì„¸íŠ¸ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
    if (!activeBlockSetId) {
      return [];
    }

    // ë¸”ë¡ ì¡°íšŒ (block_index ì»¬ëŸ¼ì´ ìˆì„ ìˆ˜ë„ ìˆê³  ì—†ì„ ìˆ˜ë„ ìˆìŒ)
    const selectBlocks = () => {
      const query = supabase
        .from("student_block_schedule")
        .select("id,day_of_week,start_time,end_time,block_index")
        .eq("day_of_week", dayOfWeek)
        .eq("block_set_id", activeBlockSetId)
        .eq("student_id", studentId);

      // block_index ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ ì •ë ¬, ì—†ìœ¼ë©´ start_timeìœ¼ë¡œ ì •ë ¬
      return query.order("block_index", { ascending: true });
    };

    let { data, error } = await selectBlocks();
    
    // block_index ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬)
    if (error && error.code === "42703") {
      // block_index ì—†ì´ ì¡°íšŒí•˜ê³  start_timeìœ¼ë¡œ ì •ë ¬
      const fallbackQuery = supabase
        .from("student_block_schedule")
        .select("id,day_of_week,start_time,end_time")
        .eq("day_of_week", dayOfWeek)
        .eq("block_set_id", activeBlockSetId)
        .eq("student_id", studentId)
        .order("start_time", { ascending: true });

      const fallbackResult = await fallbackQuery;
      // block_indexê°€ ì—†ëŠ” ê²½ìš° nullë¡œ ì±„ì›€
      data = fallbackResult.data?.map(block => ({ ...block, block_index: null })) ?? null;
      error = fallbackResult.error;
    }

    if (error) {
      console.error("[dashboard] ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", {
        error,
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint,
        studentId,
        dayOfWeek,
        activeBlockSetId,
      });
      throw error;
    }

    const blocks = (data as BlockRow[] | null) ?? [];
    
    // block_indexê°€ ì—†ëŠ” ê²½ìš° ë™ì ìœ¼ë¡œ ê³„ì‚°
    if (blocks.length > 0 && (blocks[0].block_index === null || blocks[0].block_index === undefined)) {
      return blocks.map((block, index) => ({
        ...block,
        block_index: index + 1,
      }));
    }

    return blocks;
  } catch (error) {
    console.error("[dashboard] ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", {
      error,
      message: error instanceof Error ? error.message : String(error),
      studentId,
      dayOfWeek,
    });
    return [];
  }
}

export async function fetchContentMap(
  supabase: SupabaseServerClient,
  studentId: string,
  table: "books" | "lectures" | "student_custom_contents"
): Promise<Record<string, ContentRow>> {
  try {
    const selectContents = () =>
      supabase
        .from(table)
        .select("id,title,subject,difficulty_level")
        .order("created_at", { ascending: false });

    let { data, error } = await selectContents().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectContents());
    }
    if (error) throw error;

    const rows = (data as ContentRow[] | null) ?? [];
    return rows.reduce<Record<string, ContentRow>>((acc, row) => {
      acc[row.id] = row;
      return acc;
    }, {});
  } catch (error) {
    console.error(`[dashboard] ${table} ì¡°íšŒ ì‹¤íŒ¨`, error);
    return {};
  }
}

async function fetchProgressMap(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<Record<string, number | null>> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const rows = (data as ProgressRow[] | null) ?? [];
    return rows.reduce<Record<string, number | null>>((acc, row) => {
      if (row.content_type && row.content_id) {
        const key = `${row.content_type}:${row.content_id}`;
        acc[key] = row.progress ?? null;
      }
      return acc;
    }, {});
  } catch (error) {
    console.error("[dashboard] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {};
  }
}

function resolveContentMeta(
  contentId: string,
  contentType: ContentType,
  bookMap: Record<string, ContentRow>,
  lectureMap: Record<string, ContentRow>,
  customMap: Record<string, ContentRow>
): {
  title: string;
  subject: string | null;
  difficulty_level: string | null;
} {
  const map =
    contentType === "book"
      ? bookMap
      : contentType === "lecture"
      ? lectureMap
      : customMap;

  const row = map[contentId];

  if (!row) {
    return {
      title:
        contentType === "custom"
          ? "ì»¤ìŠ¤í…€ ì½˜í…ì¸ "
          : contentType === "lecture"
          ? "ê°•ì˜ ì½˜í…ì¸ "
          : "ì±… ì½˜í…ì¸ ",
      subject: null,
      difficulty_level: null,
    };
  }

  return {
    title: row.title ?? "ì œëª© ì—†ìŒ",
    subject: row.subject ?? null,
    difficulty_level: row.difficulty_level ?? null,
  };
}

function toContentType(raw?: string | null): ContentType {
  if (raw === "lecture" || raw === "custom") {
    return raw;
  }
  return "book";
}

// ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥  ê³„ì‚°
export function calculateTodayProgress(plans: TodayPlan[]): number {
  if (plans.length === 0) {
    return 0;
  }

  const totalProgress = plans.reduce((sum, plan) => {
    return sum + (plan.progress ?? 0);
  }, 0);

  return Math.round(totalProgress / plans.length);
}

// ì „ì²´ í•™ìŠµ í†µê³„
export type LearningStatistics = {
  weekProgress: number; // ì´ë²ˆ ì£¼ ì§„í–‰ë¥  (í‰ê· )
  completedCount: number; // ì™„ë£Œëœ ì½˜í…ì¸  ìˆ˜ (progress = 100)
  inProgressCount: number; // ì§„í–‰ ì¤‘ ì½˜í…ì¸  ìˆ˜ (0 < progress < 100)
};

export async function fetchLearningStatistics(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<LearningStatistics> {
  try {
    // ì´ë²ˆ ì£¼ ë‚ ì§œ ë²”ìœ„ ê³„ì‚° (ì›”~ì¼)
    const today = new Date();
    const dayOfWeek = today.getDay();
    const monday = new Date(today);
    monday.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
    monday.setHours(0, 0, 0, 0);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);

    const weekStart = monday.toISOString().slice(0, 10);
    const weekEnd = sunday.toISOString().slice(0, 10);

    // ì´ë²ˆ ì£¼ í”Œëœ ì¡°íšŒ
    const selectWeekPlans = () =>
      supabase
        .from("student_plan")
        .select("id,content_type,content_id")
        .gte("plan_date", weekStart)
        .lte("plan_date", weekEnd);

    let { data: weekPlans, error } = await selectWeekPlans().eq(
      "student_id",
      studentId
    );
    if (error && error.code === "42703") {
      ({ data: weekPlans, error } = await selectWeekPlans());
    }
    if (error) throw error;

    const planRows = (weekPlans as PlanRow[] | null) ?? [];

    // ëª¨ë“  ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // ì´ë²ˆ ì£¼ ì§„í–‰ë¥  ê³„ì‚°
    let weekProgressSum = 0;
    let weekProgressCount = 0;

    planRows.forEach((plan) => {
      if (plan.content_type && plan.content_id) {
        const key = `${plan.content_type}:${plan.content_id}`;
        const progress = progressMap[key];
        if (progress !== null && progress !== undefined) {
          weekProgressSum += progress;
          weekProgressCount++;
        }
      }
    });

    const weekProgress =
      weekProgressCount > 0
        ? Math.round(weekProgressSum / weekProgressCount)
        : 0;

    // ì™„ë£Œ/ì§„í–‰ ì¤‘ ì½˜í…ì¸  ìˆ˜ ê³„ì‚°
    const progressValues = Object.values(progressMap);
    let completedCount = 0;
    let inProgressCount = 0;

    progressValues.forEach((progress) => {
      if (progress === 100) {
        completedCount++;
      } else if (progress !== null && progress > 0 && progress < 100) {
        inProgressCount++;
      }
    });

    return {
      weekProgress,
      completedCount,
      inProgressCount,
    };
  } catch (error) {
    console.error("[dashboard] í†µê³„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      weekProgress: 0,
      completedCount: 0,
      inProgressCount: 0,
    };
  }
}

async function calculateTotalLearningAmount(
  supabase: SupabaseServerClient,
  studentId: string,
  progressMap: Record<string, number | null>
): Promise<number> {
  try {
    // ëª¨ë“  ì§„í–‰ë¥  ë ˆì½”ë“œì—ì„œ completed_amount ì¡°íšŒ
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,completed_amount");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const progressRows = (data as Array<{
      content_type?: string | null;
      content_id?: string | null;
      completed_amount?: number | null;
    }> | null) ?? [];

    // completed_amount í•©ê³„ ê³„ì‚° (ëˆ„ì  í•™ìŠµëŸ‰)
    let totalAmount = 0;

    for (const row of progressRows) {
      const completedAmount = row.completed_amount ?? 0;
      totalAmount += completedAmount;
    }

    return totalAmount;
  } catch (error) {
    console.error("[dashboard] ëˆ„ì  í•™ìŠµëŸ‰ ê³„ì‚° ì‹¤íŒ¨", error);
    return 0;
  }
}

async function fetchContentTotal(
  supabase: SupabaseServerClient,
  studentId: string,
  contentType: ContentType,
  contentId: string
): Promise<number | null> {
  try {
    if (contentType === "book") {
      const selectBook = () =>
        supabase
          .from("books")
          .select("id,total_pages")
          .eq("id", contentId);

      let { data, error } = await selectBook().eq("student_id", studentId).maybeSingle<{ id: string; total_pages?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectBook().maybeSingle<{ id: string; total_pages?: number | null }>());
      }
      if (error) throw error;

      return data?.total_pages ?? null;
    }

    if (contentType === "lecture") {
      const selectLecture = () =>
        supabase
          .from("lectures")
          .select("id,duration")
          .eq("id", contentId);

      let { data, error } = await selectLecture().eq("student_id", studentId).maybeSingle<{ id: string; duration?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectLecture().maybeSingle<{ id: string; duration?: number | null }>());
      }
      if (error) throw error;

      return data?.duration ?? null;
    }

    if (contentType === "custom") {
      const selectCustom = () =>
        supabase
          .from("student_custom_contents")
          .select("id,total_page_or_time")
          .eq("id", contentId);

      let { data, error } = await selectCustom().eq("student_id", studentId).maybeSingle<{ id: string; total_page_or_time?: number | null }>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectCustom().maybeSingle<{ id: string; total_page_or_time?: number | null }>());
      }
      if (error) throw error;

      return data?.total_page_or_time ?? null;
    }

    return null;
  } catch (error) {
    console.error("[dashboard] ì½˜í…ì¸  ì´ëŸ‰ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

// ì´ë²ˆ ì£¼ ìš”ì¼ë³„ ê³„íš ë¸”ë¡ ì¹´ìš´íŠ¸
export type WeeklyBlockCount = {
  dayOfWeek: number;
  dayLabel: string;
  blockCount: number;
};

export async function fetchWeeklyBlockCounts(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<WeeklyBlockCount[]> {
  try {
    // ì´ë²ˆ ì£¼ ë‚ ì§œ ë²”ìœ„ ê³„ì‚° (ì›”~ì¼)
    const today = new Date();
    const dayOfWeek = today.getDay();
    const monday = new Date(today);
    monday.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));
    monday.setHours(0, 0, 0, 0);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);

    const weekStart = monday.toISOString().slice(0, 10);
    const weekEnd = sunday.toISOString().slice(0, 10);

    // ì´ë²ˆ ì£¼ í”Œëœ ì¡°íšŒ
    const selectWeekPlans = () =>
      supabase
        .from("student_plan")
        .select("id,plan_date,block_index")
        .gte("plan_date", weekStart)
        .lte("plan_date", weekEnd);

    let { data: weekPlans, error } = await selectWeekPlans().eq(
      "student_id",
      studentId
    );
    if (error && error.code === "42703") {
      ({ data: weekPlans, error } = await selectWeekPlans());
    }
    if (error) throw error;

    const planRows = (weekPlans as Array<{
      id: string;
      plan_date?: string | null;
      block_index?: number | null;
    }> | null) ?? [];

    // ìš”ì¼ë³„ ë¸”ë¡ ì¹´ìš´íŠ¸ ê³„ì‚°
    const dayCounts = new Map<number, Set<number>>();

    planRows.forEach((plan) => {
      if (!plan.plan_date) return;
      const planDate = new Date(`${plan.plan_date}T00:00:00Z`);
      if (Number.isNaN(planDate.getTime())) return;

      const planDayOfWeek = planDate.getUTCDay();
      const blockIndex =
        typeof plan.block_index === "number" && plan.block_index > 0
          ? plan.block_index
          : null;

      if (blockIndex !== null) {
        if (!dayCounts.has(planDayOfWeek)) {
          dayCounts.set(planDayOfWeek, new Set());
        }
        dayCounts.get(planDayOfWeek)!.add(blockIndex);
      }
    });

    const weekdayLabels = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
    const result: WeeklyBlockCount[] = [];

    for (let i = 0; i < 7; i++) {
      const blockSet = dayCounts.get(i) ?? new Set();
      result.push({
        dayOfWeek: i,
        dayLabel: weekdayLabels[i],
        blockCount: blockSet.size,
      });
    }

    return result;
  } catch (error) {
    console.error("[dashboard] ì´ë²ˆ ì£¼ ë¸”ë¡ ì¹´ìš´íŠ¸ ì¡°íšŒ ì‹¤íŒ¨", error);
    const weekdayLabels = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
    return weekdayLabels.map((label, index) => ({
      dayOfWeek: index,
      dayLabel: label,
      blockCount: 0,
    }));
  }
}

// ì½˜í…ì¸ ë³„ ëˆ„ì  ì§„í–‰ë¥ 
export type ContentTypeProgress = {
  book: number;
  lecture: number;
  custom: number;
};

export async function fetchContentTypeProgress(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<ContentTypeProgress> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,progress");

    let { data, error } = await selectProgress().eq("student_id", studentId);
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }
    if (error) throw error;

    const rows = (data as Array<{
      content_type?: string | null;
      progress?: number | null;
    }> | null) ?? [];

    let bookSum = 0;
    let bookCount = 0;
    let lectureSum = 0;
    let lectureCount = 0;
    let customSum = 0;
    let customCount = 0;

    rows.forEach((row) => {
      const progress = row.progress ?? null;
      if (progress === null) return;

      if (row.content_type === "book") {
        bookSum += progress;
        bookCount++;
      } else if (row.content_type === "lecture") {
        lectureSum += progress;
        lectureCount++;
      } else if (row.content_type === "custom") {
        customSum += progress;
        customCount++;
      }
    });

    return {
      book: bookCount > 0 ? Math.round(bookSum / bookCount) : 0,
      lecture: lectureCount > 0 ? Math.round(lectureSum / lectureCount) : 0,
      custom: customCount > 0 ? Math.round(customSum / customCount) : 0,
    };
  } catch (error) {
    console.error("[dashboard] ì½˜í…ì¸ ë³„ ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      book: 0,
      lecture: 0,
      custom: 0,
    };
  }
}

/**
 * ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ ë§Œ ê°„ë‹¨íˆ ì¡°íšŒ (ì „ì²´ í”Œëœ ë°ì´í„° ë¶ˆí•„ìš”)
 */
export async function fetchTodayProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string
): Promise<number> {
  try {
    // student_content_progressì™€ student_planì„ ì¡°ì¸í•˜ì—¬ ì˜¤ëŠ˜ í”Œëœì˜ ì§„í–‰ë¥ ë§Œ ì¡°íšŒ
    const { data: plans, error } = await supabase
      .from("student_plan")
      .select("id,content_type,content_id")
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    if (error) {
      // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ê¸°ë³¸ê°’ ë°˜í™˜
      if (error.code === "42703") {
        return 0;
      }
      throw error;
    }

    if (!plans || plans.length === 0) {
      return 0;
    }

    // ì§„í–‰ë¥  ì¡°íšŒ
    const progressMap = await fetchProgressMap(supabase, studentId);

    // ì˜¤ëŠ˜ í”Œëœë“¤ì˜ ì§„í–‰ë¥  í‰ê·  ê³„ì‚°
    let totalProgress = 0;
    let progressCount = 0;

    for (const plan of plans) {
      if (plan.content_type && plan.content_id) {
        const key = `${plan.content_type}:${plan.content_id}`;
        const progress = progressMap[key];
        if (progress !== null && progress !== undefined) {
          totalProgress += progress;
          progressCount++;
        }
      }
    }

    return progressCount > 0 ? Math.round(totalProgress / progressCount) : 0;
  } catch (error) {
    console.error("[dashboard] ì˜¤ëŠ˜ ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return 0;
  }
}

/**
 * í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ê°„ë‹¨ ì¡°íšŒ (ì½˜í…ì¸  ë§µ ë¶ˆí•„ìš”, ìµœì†Œí•œì˜ ì •ë³´ë§Œ)
 */
export async function fetchActivePlanSimple(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string
): Promise<ActivePlan | null> {
  try {
    // ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¤‘ ì‹œì‘í–ˆì§€ë§Œ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ ì¡°íšŒ
    const selectQuery = supabase
      .from("student_plan")
      .select(
        "id,actual_start_time,actual_end_time,paused_duration_seconds,pause_count,content_type,content_id"
      )
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    // actual_start_time ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ í•„í„°ë§
    let { data: activePlans, error } = await selectQuery
      .not("actual_start_time", "is", null)
      .is("actual_end_time", null)
      .order("actual_start_time", { ascending: false })
      .limit(1);

    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ë¹ˆ ê²°ê³¼ ë°˜í™˜
    if (error && error.code === "42703") {
      return null;
    }

    if (error) throw error;
    if (!activePlans || activePlans.length === 0) {
      return null;
    }

    const plan = activePlans[0];
    if (!plan.content_type || !plan.content_id || !plan.actual_start_time) {
      return null;
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒí•˜ì—¬ ì¼ì‹œì •ì§€ ìƒíƒœ í™•ì¸
    const { data: activeSession } = await supabase
      .from("student_study_sessions")
      .select("paused_at,resumed_at")
      .eq("plan_id", plan.id)
      .eq("student_id", studentId)
      .is("ended_at", null)
      .maybeSingle();

    const isPaused = activeSession?.paused_at && !activeSession?.resumed_at;

    // ì½˜í…ì¸  ì œëª©ë§Œ ê°„ë‹¨íˆ ì¡°íšŒ (ì½˜í…ì¸  ë§µ ì „ì²´ ë¶ˆí•„ìš”)
    const contentType = toContentType(plan.content_type);
    let title = "í•™ìŠµ ì¤‘";

    try {
      if (contentType === "book") {
        const { data: book } = await supabase
          .from("books")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = book?.title || "ì±…";
      } else if (contentType === "lecture") {
        const { data: lecture } = await supabase
          .from("lectures")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = lecture?.title || "ê°•ì˜";
      } else if (contentType === "custom") {
        const { data: custom } = await supabase
          .from("student_custom_contents")
          .select("title")
          .eq("id", plan.content_id)
          .eq("student_id", studentId)
          .maybeSingle();
        title = custom?.title || "ì»¤ìŠ¤í…€ ì½˜í…ì¸ ";
      }
    } catch (contentError) {
      console.warn("[dashboard] ì½˜í…ì¸  ì œëª© ì¡°íšŒ ì‹¤íŒ¨ (ê³„ì† ì§„í–‰)", contentError);
      // ì œëª© ì¡°íšŒ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }

    return {
      id: plan.id,
      title,
      contentType,
      actualStartTime: plan.actual_start_time,
      pausedDurationSeconds: plan.paused_duration_seconds || 0,
      pauseCount: plan.pause_count || 0,
      isPaused: !!isPaused,
    };
  } catch (error) {
    console.error("[dashboard] í™œì„± í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

/**
 * í™œì„± í•™ìŠµ ì¤‘ì¸ í”Œëœ ì¡°íšŒ (ì˜¤ëŠ˜ ë‚ ì§œ, ì‹œì‘í–ˆì§€ë§Œ ì•„ì§ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ)
 */
export async function fetchActivePlan(
  supabase: SupabaseServerClient,
  studentId: string,
  todayDate: string,
  contentMaps?: {
    bookMap: Record<string, ContentRow>;
    lectureMap: Record<string, ContentRow>;
    customMap: Record<string, ContentRow>;
  }
): Promise<ActivePlan | null> {
  try {
    // ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¤‘ ì‹œì‘í–ˆì§€ë§Œ ì™„ë£Œí•˜ì§€ ì•Šì€ í”Œëœ ì¡°íšŒ
    const selectQuery = supabase
      .from("student_plan")
      .select(
        "id,actual_start_time,actual_end_time,paused_duration_seconds,pause_count,content_type,content_id"
      )
      .eq("student_id", studentId)
      .eq("plan_date", todayDate);

    // actual_start_time ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ í•„í„°ë§
    let { data: activePlans, error } = await selectQuery
      .not("actual_start_time", "is", null)
      .is("actual_end_time", null)
      .order("actual_start_time", { ascending: false })
      .limit(1);

    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (42703 ì—ëŸ¬) ë¹ˆ ê²°ê³¼ ë°˜í™˜
    if (error && error.code === "42703") {
      console.warn("[dashboard] actual_start_time ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
      return null;
    }

    if (error) throw error;
    if (!activePlans || activePlans.length === 0) {
      return null;
    }

    const plan = activePlans[0];
    if (!plan.content_type || !plan.content_id || !plan.actual_start_time) {
      return null;
    }

    // í™œì„± ì„¸ì…˜ ì¡°íšŒí•˜ì—¬ ì¼ì‹œì •ì§€ ìƒíƒœ í™•ì¸
    const { data: activeSession } = await supabase
      .from("student_study_sessions")
      .select("paused_at,resumed_at")
      .eq("plan_id", plan.id)
      .eq("student_id", studentId)
      .is("ended_at", null)
      .maybeSingle();

    const isPaused = activeSession?.paused_at && !activeSession?.resumed_at;

    // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ (ì¬ì‚¬ìš© ë˜ëŠ” ìƒˆë¡œ ì¡°íšŒ)
    const contentType = toContentType(plan.content_type);
    let bookMap: Record<string, ContentRow>;
    let lectureMap: Record<string, ContentRow>;
    let customMap: Record<string, ContentRow>;

    if (contentMaps) {
      // ì „ë‹¬ë°›ì€ ì½˜í…ì¸  ë§µ ì¬ì‚¬ìš©
      ({ bookMap, lectureMap, customMap } = contentMaps);
    } else {
      // fallback: ì—†ìœ¼ë©´ ìƒˆë¡œ ì¡°íšŒ
      [bookMap, lectureMap, customMap] = await Promise.all([
        fetchContentMap(supabase, studentId, "books"),
        fetchContentMap(supabase, studentId, "lectures"),
        fetchContentMap(supabase, studentId, "student_custom_contents"),
      ]);
    }

    const contentMeta = resolveContentMeta(
      plan.content_id,
      contentType,
      bookMap,
      lectureMap,
      customMap
    );

    return {
      id: plan.id,
      title: contentMeta.title,
      contentType,
      actualStartTime: plan.actual_start_time,
      pausedDurationSeconds: plan.paused_duration_seconds || 0,
      pauseCount: plan.pause_count || 0,
      isPaused: !!isPaused,
    };
  } catch (error) {
    console.error("[dashboard] í™œì„± í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="page.tsx">
export const dynamic = "force-dynamic";

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  fetchTodayProgress,
  fetchActivePlanSimple,
  type ActivePlan,
} from "./_utils";
import { ActiveLearningWidget } from "./_components/ActiveLearningWidget";
import { perfTime } from "@/lib/utils/perfLog";
import { getDashboardCategories } from "@/lib/navigation/dashboardUtils";
import { getContainerClass } from "@/lib/constants/layout";

type StudentRow = {
  id: string;
  name?: string | null;
};

export default async function DashboardPage() {
  const pageTimer = perfTime("[dashboard] render - page");
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì ê°€ì ¸ì˜¤ê¸°
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // ë¡œê·¸ì¸ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("id,name")
    .eq("id", user.id)
    .maybeSingle<StudentRow>();

  if (studentError) {
    console.error("[dashboard] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í˜ì´ì§€ëŠ” í‘œì‹œë˜ë„ë¡ í•¨
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ìµœì†Œ ë°ì´í„°ë§Œ ì¡°íšŒ
  const dataTimer = perfTime("[dashboard] data - minimal");
  const [todayProgress, activePlan] = await Promise.all([
    fetchTodayProgress(supabase, user.id, todayDate),
    fetchActivePlanSimple(supabase, user.id, todayDate),
  ]);
  dataTimer.end();

  const studentName = student?.name ?? "í•™ìƒ";

  const renderTimer = perfTime("[dashboard] render - DashboardContent");
  const page = (
    <>
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6 md:gap-8">
          {/* ìƒë‹¨: í•™ìƒ ì¸ì‚¬ + ìš”ì•½ */}
          <div className="rounded-2xl border border-gray-200 bg-white p-6 md:p-8 shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-6">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-1">
                  <h1 className="text-h1 text-gray-900">
                  ì•ˆë…•í•˜ì„¸ìš”, {studentName}ë‹˜
                </h1>
                  <p className="text-sm md:text-base text-gray-600">
                  ì˜¤ëŠ˜ë„ ì—´ì‹¬íˆ í•™ìŠµí•˜ì‹œëŠ” ëª¨ìŠµì´ ë©‹ì§‘ë‹ˆë‹¤!
                </p>
                </div>

                <div className="flex items-baseline gap-3 pt-2">
                  <span className="text-4xl md:text-5xl font-bold text-indigo-600">
                    {todayProgress}%
                  </span>
                  <span className="text-base md:text-lg text-gray-600">
                    ì˜¤ëŠ˜ í•™ìŠµ ì§„í–‰ë¥ 
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ í•™ìŠµ ì¤‘ ìœ„ì ¯ */}
          {activePlan && <ActiveLearningWidget activePlan={activePlan} />}

          {/* ì£¼ìš” ê¸°ëŠ¥ ë°”ë¡œê°€ê¸° */}
          <div className="flex flex-col gap-4 md:gap-6">
            <h2 className="text-h2 text-gray-900">ì£¼ìš” ê¸°ëŠ¥</h2>
            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 items-stretch">
              {getDashboardCategories().map((category) => {
                let description = "";
                let color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky" = "indigo";
                let iconEmoji = "ğŸ”—";

                // ì¹´í…Œê³ ë¦¬ë³„ ì„¤ëª… ë° ìƒ‰ìƒ ì„¤ì •
                switch (category.href) {
                  case "/today":
                    description = "ì˜¤ëŠ˜ì˜ í•™ìŠµ ê³„íšì„ í™•ì¸í•˜ê³  ì‹¤í–‰í•˜ì„¸ìš”";
                    color = "indigo";
                    iconEmoji = "ğŸ“…";
                    break;
                  case "/plan":
                    description = "í•™ìŠµ ê³„íšì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "blue";
                    iconEmoji = "ğŸ“‹";
                    break;
                  case "/contents":
                    description = "ì±…, ê°•ì˜, ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ë“±ë¡í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "green";
                    iconEmoji = "ğŸ“š";
                    break;
                  case "/camp":
                    description = "ìº í”„ì— ì°¸ì—¬í•˜ê³  í•™ìŠµì„ ê´€ë¦¬í•˜ì„¸ìš”";
                    color = "purple";
                    iconEmoji = "ğŸ•ï¸";
                    break;
                  case "/attendance/check-in":
                    description = "ì¶œì„ì„ ì²´í¬í•˜ê³  ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”";
                    color = "cyan";
                    iconEmoji = "âœ…";
                    break;
                  default:
                    description = "ê¸°ëŠ¥ì„ ì´ìš©í•˜ì„¸ìš”";
                }

                return (
                  <QuickActionCard
                    key={category.href}
                    href={category.href}
                    title={category.label}
                    description={description}
                    icon={iconEmoji}
                    color={color}
                  />
                );
              })}
              <QuickActionCard
                href="/scores/dashboard/unified"
                title="ì„±ì  ê´€ë¦¬"
                description="ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”"
                icon="ğŸ“"
                color="red"
              />
              <QuickActionCard
                href="/report/weekly"
                title="í•™ìŠµ ë¦¬í¬íŠ¸"
                description="ì£¼ê°„ ë° ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì„¸ìš”"
                icon="ğŸ“Š"
                color="teal"
              />
              <QuickActionCard
                href="/blocks"
                title="ì‹œê°„ë¸”ë¡ ì„¤ì •"
                description="í•™ìŠµ ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë¥¼ ì„¤ì •í•˜ì„¸ìš”"
                icon="â°"
                color="amber"
              />
            </div>
          </div>
        </div>
      </section>
    </>
  );
  renderTimer.end();
  pageTimer.end();
  return page;
}


function QuickActionCard({
  href,
  title,
  description,
  icon,
  color,
}: {
  href: string;
  title: string;
  description: string;
  icon: string;
  color: "indigo" | "blue" | "purple" | "orange" | "green" | "red" | "teal" | "cyan" | "amber" | "pink" | "violet" | "emerald" | "sky";
}) {
  const colorClasses = {
    indigo:
      "border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-indigo-100/50 dark:from-indigo-900/30 dark:to-indigo-800/20 hover:from-indigo-100 hover:to-indigo-200/50 dark:hover:from-indigo-800/40 dark:hover:to-indigo-700/30 text-indigo-900 dark:text-indigo-200 hover:shadow-lg",
    blue: "border-blue-200 dark:border-blue-800 bg-gradient-to-br from-blue-50 to-blue-100/50 dark:from-blue-900/30 dark:to-blue-800/20 hover:from-blue-100 hover:to-blue-200/50 dark:hover:from-blue-800/40 dark:hover:to-blue-700/30 text-blue-900 dark:text-blue-200 hover:shadow-lg",
    purple:
      "border-purple-200 dark:border-purple-800 bg-gradient-to-br from-purple-50 to-purple-100/50 dark:from-purple-900/30 dark:to-purple-800/20 hover:from-purple-100 hover:to-purple-200/50 dark:hover:from-purple-800/40 dark:hover:to-purple-700/30 text-purple-900 dark:text-purple-200 hover:shadow-lg",
    orange:
      "border-orange-200 dark:border-orange-800 bg-gradient-to-br from-orange-50 to-orange-100/50 dark:from-orange-900/30 dark:to-orange-800/20 hover:from-orange-100 hover:to-orange-200/50 dark:hover:from-orange-800/40 dark:hover:to-orange-700/30 text-orange-900 dark:text-orange-200 hover:shadow-lg",
    green: "border-green-200 dark:border-green-800 bg-gradient-to-br from-green-50 to-green-100/50 dark:from-green-900/30 dark:to-green-800/20 hover:from-green-100 hover:to-green-200/50 dark:hover:from-green-800/40 dark:hover:to-green-700/30 text-green-900 dark:text-green-200 hover:shadow-lg",
    red: "border-red-200 dark:border-red-800 bg-gradient-to-br from-red-50 to-red-100/50 dark:from-red-900/30 dark:to-red-800/20 hover:from-red-100 hover:to-red-200/50 dark:hover:from-red-800/40 dark:hover:to-red-700/30 text-red-900 dark:text-red-200 hover:shadow-lg",
    teal: "border-teal-200 dark:border-teal-800 bg-gradient-to-br from-teal-50 to-teal-100/50 dark:from-teal-900/30 dark:to-teal-800/20 hover:from-teal-100 hover:to-teal-200/50 dark:hover:from-teal-800/40 dark:hover:to-teal-700/30 text-teal-900 dark:text-teal-200 hover:shadow-lg",
    cyan: "border-cyan-200 dark:border-cyan-800 bg-gradient-to-br from-cyan-50 to-cyan-100/50 dark:from-cyan-900/30 dark:to-cyan-800/20 hover:from-cyan-100 hover:to-cyan-200/50 dark:hover:from-cyan-800/40 dark:hover:to-cyan-700/30 text-cyan-900 dark:text-cyan-200 hover:shadow-lg",
    amber: "border-amber-200 dark:border-amber-800 bg-gradient-to-br from-amber-50 to-amber-100/50 dark:from-amber-900/30 dark:to-amber-800/20 hover:from-amber-100 hover:to-amber-200/50 dark:hover:from-amber-800/40 dark:hover:to-amber-700/30 text-amber-900 dark:text-amber-200 hover:shadow-lg",
    pink: "border-pink-200 dark:border-pink-800 bg-gradient-to-br from-pink-50 to-pink-100/50 dark:from-pink-900/30 dark:to-pink-800/20 hover:from-pink-100 hover:to-pink-200/50 dark:hover:from-pink-800/40 dark:hover:to-pink-700/30 text-pink-900 dark:text-pink-200 hover:shadow-lg",
    violet: "border-violet-200 dark:border-violet-800 bg-gradient-to-br from-violet-50 to-violet-100/50 dark:from-violet-900/30 dark:to-violet-800/20 hover:from-violet-100 hover:to-violet-200/50 dark:hover:from-violet-800/40 dark:hover:to-violet-700/30 text-violet-900 dark:text-violet-200 hover:shadow-lg",
    emerald: "border-emerald-200 dark:border-emerald-800 bg-gradient-to-br from-emerald-50 to-emerald-100/50 dark:from-emerald-900/30 dark:to-emerald-800/20 hover:from-emerald-100 hover:to-emerald-200/50 dark:hover:from-emerald-800/40 dark:hover:to-emerald-700/30 text-emerald-900 dark:text-emerald-200 hover:shadow-lg",
    sky: "border-sky-200 dark:border-sky-800 bg-gradient-to-br from-sky-50 to-sky-100/50 dark:from-sky-900/30 dark:to-sky-800/20 hover:from-sky-100 hover:to-sky-200/50 dark:hover:from-sky-800/40 dark:hover:to-sky-700/30 text-sky-900 dark:text-sky-200 hover:shadow-lg",
  };

  return (
    <Link
      href={href}
      className={`h-full rounded-xl border-2 p-5 md:p-6 transition-all duration-200 hover:scale-[1.02] flex flex-col ${colorClasses[color]}`}
    >
      <div className="flex flex-col gap-3 flex-1">
        <div className="flex items-start gap-3 md:gap-4">
          <span className="text-2xl md:text-3xl flex-shrink-0">{icon}</span>
          <div className="flex flex-col gap-1 flex-1 min-w-0">
            <h3 className="text-base md:text-lg font-semibold">{title}</h3>
            <p className="text-xs md:text-sm opacity-80 line-clamp-2">{description}</p>
          </div>
        </div>
        {/* mt-autoëŠ” flexbox ë‚´ë¶€ì—ì„œ í•˜ë‹¨ ì •ë ¬ì„ ìœ„í•´ ì‚¬ìš© (Spacing-First ì •ì±… ì˜ˆì™¸ í—ˆìš©) */}
        <div className="flex justify-end mt-auto">
          <span className="text-lg md:text-xl">â†’</span>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="_components/RecalculateButton.tsx">
"use client";

import { useTransition, useState } from "react";
import { useRouter } from "next/navigation";
import { recalculateRiskIndex } from "../_actions";

export function RecalculateButton() {
  const [isPending, startTransition] = useTransition();
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleRecalculate = () => {
    setError(null);
    startTransition(async () => {
      try {
        const result = await recalculateRiskIndex();
        if (result.success) {
          router.refresh();
        } else {
          setError(result.error ?? "ì¬ê³„ì‚°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "ì¬ê³„ì‚°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  return (
    <div className="flex flex-col gap-2">
      <button
        onClick={handleRecalculate}
        disabled={isPending}
        className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50"
      >
        {isPending ? "ì¬ê³„ì‚° ì¤‘..." : "Risk Index ì¬ê³„ì‚°"}
      </button>
      {error && (
        <p className="text-xs text-red-600">{error}</p>
      )}
    </div>
  );
}
</file>

<file path="_components/RiskIndexList.tsx">
"use client";

import Link from "next/link";
import {
  useRecharts,
  ChartLoadingSkeleton,
} from "@/components/charts/LazyRecharts";
import { getRiskColorHex, getRiskColor } from "@/lib/constants/colors";
import { cn } from "@/lib/cn";
import ProgressBar from "@/components/atoms/ProgressBar";

export type SubjectRiskAnalysis = {
  subject: string;
  risk_score: number;
  recent_grade_trend: number;
  consistency_score: number;
  mastery_estimate: number;
  recent3AvgGrade: number;
  gradeChange: number;
  scoreVariance: number;
  improvementRate: number;
};

type RiskIndexListProps = {
  analyses: SubjectRiskAnalysis[];
};

const getTrendIcon = (trend: number): string => {
  if (trend > 0) return "ğŸ“ˆ"; // ìƒìŠ¹
  if (trend < 0) return "ğŸ“‰"; // í•˜ë½
  return "â¡ï¸"; // ìœ ì§€
};

const getTrendText = (trend: number): string => {
  if (trend > 0) return "ìƒìŠ¹";
  if (trend < 0) return "í•˜ë½";
  return "ìœ ì§€";
};

export function RiskIndexList({ analyses }: RiskIndexListProps) {
  const { recharts, loading } = useRecharts();

  const chartData = analyses.map((a) => ({
    name: a.subject,
    "Risk Index": Math.round(a.risk_score),
  }));

  return (
    <div className="flex flex-col gap-6">
      {/* Risk Index ì°¨íŠ¸ */}
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <h2 className="text-xl font-semibold text-gray-900">
            ê³¼ëª©ë³„ Risk Index
          </h2>
          {loading || !recharts ? (
            <ChartLoadingSkeleton height={400} />
          ) : (
            (() => {
              const { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell } = recharts;
              return (
                <ResponsiveContainer width="100%" height={400}>
                  <BarChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis
                      dataKey="name"
                      angle={-45}
                      textAnchor="end"
                      height={80}
                      interval={0}
                    />
                    <YAxis domain={[0, 100]} label={{ value: "Risk Index", angle: -90, position: "insideLeft" }} />
                    <Tooltip
                      formatter={(value: number) => [`${value}ì `, "Risk Index"]}
                    />
                    <Legend />
                    <Bar dataKey="Risk Index" name="Risk Index">
                      {chartData.map((entry, index) => (
                        <Cell
                          key={`cell-${index}`}
                          fill={getRiskColorHex(entry["Risk Index"])}
                        />
                      ))}
                    </Bar>
                  </BarChart>
                </ResponsiveContainer>
              );
            })()
          )}
        </div>
      </div>

      {/* ì·¨ì•½ ê³¼ëª© ë¦¬ìŠ¤íŠ¸ */}
      <div className="rounded-lg border border-gray-200 bg-white shadow-sm">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-xl font-semibold text-gray-900">ì·¨ì•½ ê³¼ëª© ìƒì„¸ ë¶„ì„</h2>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ê³¼ëª©
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  Risk Index
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ë“±ê¸‰ ì¶”ì´
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ìµœê·¼ 3íšŒ í‰ê· 
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ì¼ê´€ì„±
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ìˆ™ë ¨ë„
                </th>
                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-700">
                  ì‘ì—…
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {analyses.map((analysis) => (
                <tr key={analysis.subject} className="hover:bg-gray-50">
                  <td className="px-4 py-3 text-sm font-medium text-gray-900">
                    {analysis.subject}
                  </td>
                  <td className="px-4 py-3 text-sm">
                    <div className="flex items-center gap-2">
                      {(() => {
                        const riskColor = getRiskColor(analysis.risk_score);
                        return (
                          <div className={cn("h-3 w-16 rounded-full", riskColor.bg)} />
                        );
                      })()}
                      <span className="font-semibold">
                        {Math.round(analysis.risk_score)}ì 
                      </span>
                    </div>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-700">
                    <div className="flex items-center gap-1">
                      <span>{getTrendIcon(analysis.recent_grade_trend)}</span>
                      <span>{getTrendText(analysis.recent_grade_trend)}</span>
                      {analysis.gradeChange !== 0 && (
                        <span className="text-xs text-gray-500">
                          ({analysis.gradeChange > 0 ? "+" : ""}
                          {analysis.gradeChange.toFixed(1)})
                        </span>
                      )}
                    </div>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-700">
                    {analysis.recent3AvgGrade > 0
                      ? `${analysis.recent3AvgGrade.toFixed(1)}ë“±ê¸‰`
                      : "-"}
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-700">
                    <div className="flex items-center gap-2">
                      <div className="w-16">
                        <ProgressBar
                          value={analysis.consistency_score}
                          color="blue"
                          height="sm"
                        />
                      </div>
                      <span>{Math.round(analysis.consistency_score)}%</span>
                    </div>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-700">
                    <div className="flex items-center gap-2">
                      <div className="w-16">
                        <ProgressBar
                          value={analysis.mastery_estimate}
                          color="green"
                          height="sm"
                        />
                      </div>
                      <span>{Math.round(analysis.mastery_estimate)}%</span>
                    </div>
                  </td>
                  <td className="px-4 py-3 text-sm">
                    <Link
                      href="/plan/new-group"
                      className="inline-flex items-center justify-center rounded-lg border border-indigo-300 bg-white px-3 py-1.5 text-xs font-semibold text-indigo-700 transition hover:bg-indigo-50"
                    >
                      í•™ìŠµ í”Œëœ ìƒì„±
                    </Link>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Risk Index ì„¤ëª… */}
      <div className="rounded-xl border border-blue-200 bg-blue-50 p-4">
        <div className="flex flex-col gap-2">
          <h3 className="text-sm font-semibold text-blue-900">
            Risk Index ê³„ì‚° ê¸°ì¤€
          </h3>
          <ul className="text-sm text-blue-800 flex flex-col gap-1 list-disc list-inside">
          <li>
            <strong>ìµœê·¼ 3íšŒ ë“±ê¸‰ í‰ê·  (40%)</strong>: ìµœê·¼ 3ë²ˆì˜ ì‹œí—˜ ë“±ê¸‰ í‰ê· 
          </li>
          <li>
            <strong>ë“±ê¸‰ í•˜ë½ íŒ¨ë„í‹° (30%)</strong>: ìµœê·¼ ë“±ê¸‰ì´ í•˜ë½í–ˆì„ ê²½ìš° ìœ„í—˜ë„ ì¦ê°€
          </li>
          <li>
            <strong>ì›ì ìˆ˜ í¸ì°¨ (20%)</strong>: ì ìˆ˜ ë³€ë™ì„±ì´ í´ìˆ˜ë¡ ìœ„í—˜ë„ ì¦ê°€
          </li>
          <li>
            <strong>ê°œì„ ìœ¨ ë¶€ì¡± (10%)</strong>: í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ì„±ì·¨ë„ ê°œì„ ì´ ë¶€ì¡±í•  ê²½ìš° ìœ„í—˜ë„ ì¦ê°€
          </li>
          <li>
            <strong>Risk Index 70ì  ì´ìƒ</strong>: ë§¤ìš° ìœ„í—˜ (ì¦‰ì‹œ ì§‘ì¤‘ í•™ìŠµ í•„ìš”)
          </li>
          <li>
            <strong>Risk Index 50-69ì </strong>: ìœ„í—˜ (ì§‘ì¤‘ í•™ìŠµ ê¶Œì¥)
          </li>
          <li>
            <strong>Risk Index 30-49ì </strong>: ì£¼ì˜ (ì§€ì†ì  ëª¨ë‹ˆí„°ë§ í•„ìš”)
          </li>
          <li>
            <strong>Risk Index 0-29ì </strong>: ì–‘í˜¸ (í˜„ì¬ ìˆ˜ì¤€ ìœ ì§€)
          </li>
          </ul>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="patterns/_components/PatternAnalysisView.tsx">
"use client";

import ProgressBar from "@/components/atoms/ProgressBar";
import { createHeightStyle } from "@/lib/utils/cssVariables";

type DayStats = {
  totalSeconds: number;
  planCount: number;
};

type PatternAnalysisViewProps = {
  byDayOfWeek: Record<number, DayStats>;
  byHour: Record<number, number>;
  byDate: Record<string, DayStats>;
  mostActiveDay: { day: number; totalSeconds: number; planCount: number };
  mostActiveHour: { hour: number; seconds: number };
  averageWeeklySeconds: number;
  weeklyTrend: Array<{ week: number; totalSeconds: number }>;
  delayPercentage: number;
  weekdays: string[];
};

export function PatternAnalysisView({
  byDayOfWeek,
  byHour,
  byDate,
  mostActiveDay,
  mostActiveHour,
  averageWeeklySeconds,
  weeklyTrend,
  delayPercentage,
  weekdays,
}: PatternAnalysisViewProps) {
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `${hours}ì‹œê°„ ${minutes}ë¶„`;
    }
    return `${minutes}ë¶„`;
  };

  const formatHour = (hour: number): string => {
    return `${hour}ì‹œ`;
  };

  // ìš”ì¼ë³„ ìµœëŒ€ê°’ ê³„ì‚° (ë¹„ìœ¨ ê³„ì‚°ìš©)
  const maxDaySeconds = Math.max(...Object.values(byDayOfWeek).map((s) => s.totalSeconds), 1);

  // ì‹œê°„ëŒ€ë³„ ìµœëŒ€ê°’ ê³„ì‚°
  const maxHourSeconds = Math.max(...Object.values(byHour), 1);

  // ì£¼ê°„ íŠ¸ë Œë“œ ìµœëŒ€ê°’
  const maxWeekSeconds = Math.max(...weeklyTrend.map((w) => w.totalSeconds), 1);

  return (
    <div className="space-y-6">
      {/* ì£¼ìš” ì¸ì‚¬ì´íŠ¸ */}
      <div className="grid gap-4 sm:grid-cols-3">
        <div className="rounded-xl border border-indigo-200 bg-indigo-50 p-6">
          <div className="flex flex-col gap-1">
            <div className="text-sm font-medium text-indigo-700">ê°€ì¥ í™œë°œí•œ ìš”ì¼</div>
            <div className="text-2xl font-bold text-indigo-900">
              {weekdays[mostActiveDay.day]}ìš”ì¼
            </div>
            <div className="text-sm text-indigo-600">
              {formatTime(mostActiveDay.totalSeconds)} ({mostActiveDay.planCount}ê°œ í”Œëœ)
            </div>
          </div>
        </div>

        <div className="rounded-xl border border-blue-200 bg-blue-50 p-6">
          <div className="flex flex-col gap-1">
            <div className="text-sm font-medium text-blue-700">ê°€ì¥ í™œë°œí•œ ì‹œê°„ëŒ€</div>
            <div className="text-2xl font-bold text-blue-900">
              {formatHour(mostActiveHour.hour)}
            </div>
            <div className="text-sm text-blue-600">
              {formatTime(mostActiveHour.seconds)} í•™ìŠµ
            </div>
          </div>
        </div>

        <div className="rounded-xl border border-purple-200 bg-purple-50 p-6">
          <div className="flex flex-col gap-1">
            <div className="text-sm font-medium text-purple-700">ì£¼ê°„ í‰ê·  í•™ìŠµ ì‹œê°„</div>
            <div className="text-2xl font-bold text-purple-900">
              {formatTime(averageWeeklySeconds)}
            </div>
            <div className="text-sm text-purple-600">ìµœê·¼ 4ì£¼ í‰ê· </div>
          </div>
        </div>
      </div>

      {/* í•™ìŠµ ì§€ì—° ê°ì§€ */}
      {delayPercentage > 10 && (
        <div className="rounded-xl border border-yellow-200 bg-yellow-50 p-6">
          <div className="flex items-start gap-3">
            <span className="text-2xl">âš ï¸</span>
            <div className="flex-1">
              <div className="flex flex-col gap-3">
                <div className="flex flex-col gap-2">
                  <h3 className="text-lg font-semibold text-yellow-900">í•™ìŠµ ì§€ì—° ê°ì§€</h3>
                  <p className="text-sm text-yellow-800">
                    ìµœê·¼ 3ì¼ê°„ì˜ í‰ê·  í•™ìŠµ ì‹œê°„ì´ ì´ì „ 3ì¼ ëŒ€ë¹„ {delayPercentage}% ê°ì†Œí–ˆìŠµë‹ˆë‹¤.
                  </p>
                </div>
                <div className="rounded-lg bg-white dark:bg-gray-800 p-3">
                  <div className="flex flex-col gap-2">
                    <p className="text-sm font-medium text-yellow-900 dark:text-yellow-100">ğŸ’¡ ì œì•ˆ:</p>
                    <ul className="list-inside list-disc space-y-1 text-sm text-yellow-800 dark:text-yellow-200">
                  <li>ì£¼ë§ì— ë³´ì¶© í•™ìŠµ ì‹œê°„ì„ ì¶”ê°€í•´ë³´ì„¸ìš”</li>
                  <li>ì¼ë¶€ í”Œëœì„ ë‹¤ìŒ ì£¼ë¡œ ì´ë™í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•´ë³´ì„¸ìš”</li>
                      <li>í•™ìŠµ ëª©í‘œë¥¼ ì¬ê²€í† í•´ë³´ì„¸ìš”</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* ìš”ì¼ë³„ í•™ìŠµ ë¶„í¬ */}
      <div className="rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">ìš”ì¼ë³„ í•™ìŠµ ë¶„í¬</h2>
          <div className="flex flex-col gap-3">
            {weekdays.map((day, index) => {
              const stats = byDayOfWeek[index] || { totalSeconds: 0, planCount: 0 };
              const percentage = (stats.totalSeconds / maxDaySeconds) * 100;

              return (
                <div key={index} className="flex items-center gap-4">
                  <div className="w-12 text-sm font-medium text-gray-700 dark:text-gray-300">{day}</div>
                  <div className="flex-1">
                    <div className="flex flex-col gap-1">
                      <div className="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400">
                        <span>{formatTime(stats.totalSeconds)}</span>
                        <span>{stats.planCount}ê°œ í”Œëœ</span>
                      </div>
                      <ProgressBar
                        value={percentage}
                        max={100}
                        color="indigo"
                        height="sm"
                      />
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>

      {/* ì‹œê°„ëŒ€ë³„ í•™ìŠµ ë¶„í¬ */}
      <div className="rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">ì‹œê°„ëŒ€ë³„ í•™ìŠµ ë¶„í¬</h2>
          <div className="grid grid-cols-12 gap-2">
            {Array.from({ length: 24 }, (_, hour) => {
              const seconds = byHour[hour] || 0;
              const percentage = (seconds / maxHourSeconds) * 100;
              const height = Math.max(percentage, 5); // ìµœì†Œ 5% ë†’ì´

              return (
                <div key={hour} className="flex flex-col items-center gap-1">
                  <div className="text-xs text-gray-600 dark:text-gray-400">{hour}</div>
                  <div className="relative w-full">
                    <div
                      className="w-full rounded-t bg-indigo-600 transition-all"
                      style={createHeightStyle(height, "20px")}
                      title={`${formatHour(hour)}: ${formatTime(seconds)}`}
                    />
                  </div>
                </div>
              );
            })}
          </div>
          <div className="text-center text-xs text-gray-500 dark:text-gray-400">
            ê° ë§‰ëŒ€ëŠ” í•´ë‹¹ ì‹œê°„ëŒ€ì— ì‹œì‘í•œ í•™ìŠµì˜ ì´ ì‹œê°„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤
          </div>
        </div>
      </div>

      {/* ì£¼ê°„ í•™ìŠµ ì¶”ì´ */}
      <div className="rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">ì£¼ê°„ í•™ìŠµ ì¶”ì´</h2>
          <div className="flex flex-col gap-3">
            {weeklyTrend.map((week) => {
              const percentage = (week.totalSeconds / maxWeekSeconds) * 100;

              return (
                <div key={week.week} className="flex items-center gap-4">
                  <div className="w-20 text-sm font-medium text-gray-700 dark:text-gray-300">
                    {week.week}ì£¼ ì „
                  </div>
                  <div className="flex-1">
                    <div className="flex flex-col gap-1">
                      <div className="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400">
                        <span>{formatTime(week.totalSeconds)}</span>
                      </div>
                      <ProgressBar
                        value={percentage}
                        max={100}
                        color="violet"
                        height="sm"
                      />
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>

      {/* í•™ìŠµ íˆíŠ¸ë§µ (ìµœê·¼ 4ì£¼) */}
      <div className="rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 p-6 shadow-sm">
        <div className="flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">í•™ìŠµ ê°•ë„ íˆíŠ¸ë§µ</h2>
          <div className="overflow-x-auto">
            <div className="inline-block min-w-full">
              <div className="flex flex-col gap-2">
                <div className="grid grid-cols-8 gap-1">
                  <div className="text-xs text-gray-600 dark:text-gray-400"></div>
                  {weekdays.map((day) => (
                    <div key={day} className="text-center text-xs font-medium text-gray-700 dark:text-gray-300">
                      {day}
                    </div>
                  ))}
                </div>
                {Array.from({ length: 4 }, (_, weekIndex) => {
                  const weekStart = new Date();
                  weekStart.setDate(weekStart.getDate() - (weekIndex * 7) - 6);

                  return (
                    <div key={weekIndex} className="grid grid-cols-8 gap-1">
                      <div className="text-xs text-gray-600 dark:text-gray-400">
                        {4 - weekIndex}ì£¼ ì „
                      </div>
                      {weekdays.map((_, dayIndex) => {
                        const date = new Date(weekStart);
                        date.setDate(weekStart.getDate() + dayIndex);
                        const dateStr = date.toISOString().slice(0, 10);
                        const stats = byDate[dateStr] || { totalSeconds: 0, planCount: 0 };

                        // ê°•ë„ ê³„ì‚° (0-3 ë ˆë²¨)
                        const maxSeconds = Math.max(
                          ...Object.values(byDate).map((s) => s.totalSeconds),
                          1
                        );
                        const intensity = Math.min(
                          Math.floor((stats.totalSeconds / maxSeconds) * 4),
                          3
                        );

                        const intensityColors = [
                          "bg-gray-100 dark:bg-gray-700", // 0
                          "bg-green-200 dark:bg-green-900", // 1
                          "bg-green-400 dark:bg-green-700", // 2
                          "bg-green-600 dark:bg-green-600", // 3
                        ];

                        return (
                          <div
                            key={dayIndex}
                            className={`aspect-square rounded ${intensityColors[intensity]}`}
                            title={`${dateStr}: ${formatTime(stats.totalSeconds)}`}
                          />
                        );
                      })}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
          <div className="flex items-center justify-center gap-4 text-xs text-gray-600 dark:text-gray-400">
          <div className="flex items-center gap-1">
            <div className="h-3 w-3 rounded bg-gray-100 dark:bg-gray-700" />
            <span>ë‚®ìŒ</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="h-3 w-3 rounded bg-green-200 dark:bg-green-900" />
            <span>ë³´í†µ</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="h-3 w-3 rounded bg-green-400 dark:bg-green-700" />
            <span>ë†’ìŒ</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="h-3 w-3 rounded bg-green-600 dark:bg-green-600" />
            <span>ë§¤ìš° ë†’ìŒ</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  );
}
</file>

<file path="patterns/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { PatternAnalysisView } from "./_components/PatternAnalysisView";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

export default async function PatternAnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // ìµœê·¼ 4ì£¼ ë°ì´í„° ì¡°íšŒ
  const fourWeeksAgo = new Date(today);
  fourWeeksAgo.setDate(today.getDate() - 28);
  fourWeeksAgo.setHours(0, 0, 0, 0);

  const startDate = fourWeeksAgo.toISOString().slice(0, 10);
  const endDate = today.toISOString().slice(0, 10);

  // ìµœê·¼ 4ì£¼ê°„ì˜ í”Œëœ ë° ì‹œê°„ ë°ì´í„° ì¡°íšŒ
  const { data: plans } = await supabase
    .from("student_plan")
    .select(
      "plan_date,total_duration_seconds,paused_duration_seconds,actual_start_time,actual_end_time,block_index"
    )
    .eq("student_id", user.id)
    .gte("plan_date", startDate)
    .lte("plan_date", endDate)
    .not("total_duration_seconds", "is", null);

  // ìš”ì¼ë³„ í†µê³„ ê³„ì‚°
  const byDayOfWeek: Record<number, { totalSeconds: number; planCount: number }> = {};
  const byHour: Record<number, number> = {};
  const byDate: Record<string, { totalSeconds: number; planCount: number }> = {};

  plans?.forEach((plan) => {
    if (!plan.plan_date) return;

    const date = new Date(plan.plan_date);
    const dayOfWeek = date.getDay();
    const dateStr = plan.plan_date;

    // ìš”ì¼ë³„ í†µê³„
    if (!byDayOfWeek[dayOfWeek]) {
      byDayOfWeek[dayOfWeek] = { totalSeconds: 0, planCount: 0 };
    }
    byDayOfWeek[dayOfWeek].totalSeconds += plan.total_duration_seconds || 0;
    byDayOfWeek[dayOfWeek].planCount += 1;

    // ë‚ ì§œë³„ í†µê³„
    if (!byDate[dateStr]) {
      byDate[dateStr] = { totalSeconds: 0, planCount: 0 };
    }
    byDate[dateStr].totalSeconds += plan.total_duration_seconds || 0;
    byDate[dateStr].planCount += 1;

    // ì‹œê°„ëŒ€ë³„ í†µê³„ (actual_start_time ê¸°ì¤€)
    if (plan.actual_start_time) {
      const startTime = new Date(plan.actual_start_time);
      const hour = startTime.getHours();
      byHour[hour] = (byHour[hour] || 0) + (plan.total_duration_seconds || 0);
    }
  });

  // ê°€ì¥ í™œë°œí•œ ìš”ì¼ ì°¾ê¸°
  const mostActiveDay = Object.entries(byDayOfWeek).reduce(
    (max, [day, stats]) => {
      return stats.totalSeconds > max.totalSeconds
        ? { day: Number(day), ...stats }
        : max;
    },
    { day: 0, totalSeconds: 0, planCount: 0 }
  );

  // ê°€ì¥ í™œë°œí•œ ì‹œê°„ëŒ€ ì°¾ê¸°
  const mostActiveHour = Object.entries(byHour).reduce(
    (max, [hour, seconds]) => {
      return seconds > max.seconds ? { hour: Number(hour), seconds } : max;
    },
    { hour: 0, seconds: 0 }
  );

  // ì£¼ê°„ í‰ê·  í•™ìŠµ ì‹œê°„ ê³„ì‚°
  const weekCount = 4;
  const totalSeconds = Object.values(byDate).reduce(
    (sum, stats) => sum + stats.totalSeconds,
    0
  );
  const averageWeeklySeconds = totalSeconds / weekCount;

  // ìµœê·¼ ì£¼ê°„ í•™ìŠµ ì‹œê°„ ì¶”ì´
  const weeklyTrend: Array<{ week: number; totalSeconds: number }> = [];
  for (let week = 0; week < 4; week++) {
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() - (week * 7) - 6);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    const weekStartStr = weekStart.toISOString().slice(0, 10);
    const weekEndStr = weekEnd.toISOString().slice(0, 10);

    const weekSeconds = Object.entries(byDate)
      .filter(([date]) => date >= weekStartStr && date <= weekEndStr)
      .reduce((sum, [, stats]) => sum + stats.totalSeconds, 0);

    weeklyTrend.push({
      week: 4 - week,
      totalSeconds: weekSeconds,
    });
  }

  // í•™ìŠµ ì§€ì—° ê°ì§€ (ìµœê·¼ 3ì¼ í‰ê·  vs ì´ì „ 3ì¼ í‰ê· )
  const recent3Days = Object.entries(byDate)
    .filter(([date]) => {
      const d = new Date(date);
      const daysDiff = Math.floor((today.getTime() - d.getTime()) / (1000 * 60 * 60 * 24));
      return daysDiff >= 0 && daysDiff < 3;
    })
    .reduce((sum, [, stats]) => sum + stats.totalSeconds, 0) / 3;

  const previous3Days = Object.entries(byDate)
    .filter(([date]) => {
      const d = new Date(date);
      const daysDiff = Math.floor((today.getTime() - d.getTime()) / (1000 * 60 * 60 * 24));
      return daysDiff >= 3 && daysDiff < 6;
    })
    .reduce((sum, [, stats]) => sum + stats.totalSeconds, 0) / 3;

  const delayPercentage =
    previous3Days > 0
      ? Math.round(((previous3Days - recent3Days) / previous3Days) * 100)
      : 0;

  const weekdays = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="í•™ìŠµ íŒ¨í„´ ë¶„ì„"
          description="ìµœê·¼ 4ì£¼ê°„ì˜ í•™ìŠµ íŒ¨í„´ì„ ë¶„ì„í•˜ê³  ê°œì„ ì ì„ ì°¾ì•„ë³´ì„¸ìš”"
        />

        <PatternAnalysisView
          byDayOfWeek={byDayOfWeek}
          byHour={byHour}
          byDate={byDate}
          mostActiveDay={mostActiveDay}
          mostActiveHour={mostActiveHour}
          averageWeeklySeconds={averageWeeklySeconds}
          weeklyTrend={weeklyTrend}
          delayPercentage={delayPercentage}
          weekdays={weekdays}
        />
      </div>
    </section>
  );
}
</file>

<file path="time/_components/TimeAnalysisView.tsx">
"use client";

import ProgressBar from "@/components/atoms/ProgressBar";
import { Card, CardContent } from "@/components/molecules/Card";

type TimeStats = {
  totalSeconds: number;
  pausedSeconds: number;
  byContentType?: Record<string, number>;
  byDayOfWeek?: Record<number, number>;
};

type TimeAnalysisViewProps = {
  todayStats: TimeStats;
  weekStats: TimeStats & { byContentType: Record<string, number> };
  monthStats: TimeStats & { byDayOfWeek: Record<number, number> };
};

export function TimeAnalysisView({
  todayStats,
  weekStats,
  monthStats,
}: TimeAnalysisViewProps) {
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `${hours}ì‹œê°„ ${minutes}ë¶„`;
    }
    return `${minutes}ë¶„`;
  };

  const pureStudySeconds = (stats: TimeStats) =>
    Math.max(0, stats.totalSeconds - stats.pausedSeconds);

  const weekdays = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
  const contentTypeLabels: Record<string, string> = {
    book: "ğŸ“š êµì¬",
    lecture: "ğŸ§ ê°•ì˜",
    custom: "ğŸ“ ì»¤ìŠ¤í…€",
  };

  return (
    <div className="flex flex-col gap-6">
      {/* ì˜¤ëŠ˜ì˜ ì‹œê°„ í†µê³„ */}
      <Card padding="md">
        <CardContent className="flex flex-col gap-4">
          <h2 className="text-h2 text-text-primary">ì˜¤ëŠ˜ì˜ ì‹œê°„</h2>
        <div className="grid gap-4 sm:grid-cols-3">
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì´ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-primary-600">
              {formatTime(todayStats.totalSeconds)}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ìˆœìˆ˜ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-info-600">
              {formatTime(pureStudySeconds(todayStats))}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì¼ì‹œì •ì§€ ì‹œê°„</div>
            <div className="text-h2 text-warning-600">
              {formatTime(todayStats.pausedSeconds)}
            </div>
          </div>
        </div>
        </CardContent>
      </Card>

      {/* ì´ë²ˆ ì£¼ ì‹œê°„ í†µê³„ */}
      <Card padding="md">
        <CardContent className="flex flex-col gap-4">
          <h2 className="text-h2 text-text-primary">ì´ë²ˆ ì£¼ ì‹œê°„</h2>
        <div className="grid gap-4 sm:grid-cols-3">
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì´ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-primary-600">
              {formatTime(weekStats.totalSeconds)}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ìˆœìˆ˜ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-info-600">
              {formatTime(pureStudySeconds(weekStats))}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì¼ì‹œì •ì§€ ì‹œê°„</div>
            <div className="text-h2 text-warning-600">
              {formatTime(weekStats.pausedSeconds)}
            </div>
          </div>
        </div>

        {/* ì½˜í…ì¸ ë³„ ë¶„í¬ */}
        {Object.keys(weekStats.byContentType).length > 0 && (
          <div className="flex flex-col gap-3">
            <h3 className="text-body-2-bold text-text-secondary">ì½˜í…ì¸ ë³„ í•™ìŠµ ì‹œê°„</h3>
            <div className="flex flex-col gap-2">
              {Object.entries(weekStats.byContentType)
                .sort(([, a], [, b]) => b - a)
                .map(([type, seconds]) => (
                  <div key={type} className="flex items-center justify-between">
                    <span className="text-body-2 text-text-secondary">
                      {contentTypeLabels[type] || type}
                    </span>
                    <span className="text-body-2-bold text-text-primary">
                      {formatTime(seconds)}
                    </span>
                  </div>
                ))}
            </div>
          </div>
        )}
        </CardContent>
      </Card>

      {/* ì´ë²ˆ ë‹¬ ì‹œê°„ í†µê³„ */}
      <Card padding="md">
        <CardContent className="flex flex-col gap-4">
          <h2 className="text-h2 text-text-primary">ì´ë²ˆ ë‹¬ ì‹œê°„</h2>
        <div className="grid gap-4 sm:grid-cols-3">
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì´ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-primary-600">
              {formatTime(monthStats.totalSeconds)}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ìˆœìˆ˜ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-info-600">
              {formatTime(pureStudySeconds(monthStats))}
            </div>
          </div>
          <div className="text-center flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì¼ì‹œì •ì§€ ì‹œê°„</div>
            <div className="text-h2 text-warning-600">
              {formatTime(monthStats.pausedSeconds)}
            </div>
          </div>
        </div>

        {/* ìš”ì¼ë³„ ë¶„í¬ */}
        {Object.keys(monthStats.byDayOfWeek).length > 0 && (
          <div className="flex flex-col gap-3">
            <h3 className="text-body-2-bold text-text-secondary">ìš”ì¼ë³„ í•™ìŠµ ì‹œê°„</h3>
            <div className="flex flex-col gap-2">
              {weekdays.map((day, index) => {
                const seconds = monthStats.byDayOfWeek[index] || 0;
                const maxSeconds = Math.max(...Object.values(monthStats.byDayOfWeek), 1);
                const percentage = (seconds / maxSeconds) * 100;

                return (
                  <div key={index} className="flex items-center gap-3">
                    <div className="w-12 text-body-2 text-text-secondary">{day}</div>
                    <div className="flex-1">
                      <ProgressBar
                        value={percentage}
                        color="indigo"
                        height="md"
                      />
                    </div>
                    <div className="w-20 text-right text-body-2-bold text-text-primary">
                      {formatTime(seconds)}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="time/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { TimeAnalysisView } from "./_components/TimeAnalysisView";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

export default async function TimeAnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
  const weekStart = new Date(today);
  const dayOfWeek = today.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  weekStart.setDate(today.getDate() + mondayOffset);
  weekStart.setHours(0, 0, 0, 0);
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekStart.getDate() + 6);
  weekEnd.setHours(23, 59, 59, 999);
  const weekStartStr = weekStart.toISOString().slice(0, 10);
  const weekEndStr = weekEnd.toISOString().slice(0, 10);

  // ì´ë²ˆ ë‹¬ ë²”ìœ„ ê³„ì‚°
  const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
  monthStart.setHours(0, 0, 0, 0);
  const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
  monthEnd.setHours(23, 59, 59, 999);
  const monthStartStr = monthStart.toISOString().slice(0, 10);
  const monthEndStr = monthEnd.toISOString().slice(0, 10);

  // ì˜¤ëŠ˜ì˜ ì‹œê°„ í†µê³„
  const { data: todayPlans } = await supabase
    .from("student_plan")
    .select("total_duration_seconds,paused_duration_seconds")
    .eq("student_id", user.id)
    .eq("plan_date", todayDate)
    .not("total_duration_seconds", "is", null);

  const todayStats = todayPlans?.reduce(
    (acc, plan) => {
      acc.totalSeconds += plan.total_duration_seconds || 0;
      acc.pausedSeconds += plan.paused_duration_seconds || 0;
      return acc;
    },
    { totalSeconds: 0, pausedSeconds: 0 }
  ) || { totalSeconds: 0, pausedSeconds: 0 };

  // ì´ë²ˆ ì£¼ ì‹œê°„ í†µê³„
  const { data: weekPlans } = await supabase
    .from("student_plan")
    .select("total_duration_seconds,paused_duration_seconds,content_type")
    .eq("student_id", user.id)
    .gte("plan_date", weekStartStr)
    .lte("plan_date", weekEndStr)
    .not("total_duration_seconds", "is", null);

  const weekStats = weekPlans?.reduce(
    (acc, plan) => {
      acc.totalSeconds += plan.total_duration_seconds || 0;
      acc.pausedSeconds += plan.paused_duration_seconds || 0;
      if (plan.content_type) {
        acc.byContentType[plan.content_type] =
          (acc.byContentType[plan.content_type] || 0) + (plan.total_duration_seconds || 0);
      }
      return acc;
    },
    {
      totalSeconds: 0,
      pausedSeconds: 0,
      byContentType: {} as Record<string, number>,
    }
  ) || {
    totalSeconds: 0,
    pausedSeconds: 0,
    byContentType: {},
  };

  // ì´ë²ˆ ë‹¬ ì‹œê°„ í†µê³„
  const { data: monthPlans } = await supabase
    .from("student_plan")
    .select("total_duration_seconds,paused_duration_seconds,plan_date")
    .eq("student_id", user.id)
    .gte("plan_date", monthStartStr)
    .lte("plan_date", monthEndStr)
    .not("total_duration_seconds", "is", null);

  const monthStats = monthPlans?.reduce(
    (acc, plan) => {
      acc.totalSeconds += plan.total_duration_seconds || 0;
      acc.pausedSeconds += plan.paused_duration_seconds || 0;
      if (plan.plan_date) {
        const date = new Date(plan.plan_date);
        const dayOfWeek = date.getDay();
        acc.byDayOfWeek[dayOfWeek] =
          (acc.byDayOfWeek[dayOfWeek] || 0) + (plan.total_duration_seconds || 0);
      }
      return acc;
    },
    {
      totalSeconds: 0,
      pausedSeconds: 0,
      byDayOfWeek: {} as Record<number, number>,
    }
  ) || {
    totalSeconds: 0,
    pausedSeconds: 0,
    byDayOfWeek: {},
  };

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì‹œê°„ ë¶„ì„"
          description="í•™ìŠµ ì‹œê°„ì„ ë¶„ì„í•˜ê³  íŒ¨í„´ì„ íŒŒì•…í•˜ì„¸ìš”"
        />

        <TimeAnalysisView
          todayStats={todayStats}
          weekStats={weekStats}
          monthStats={monthStats}
        />
      </div>
    </section>
  );
}
</file>

<file path="_actions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  calculateAllRiskIndices,
  saveRiskAnalysis,
  type SubjectRiskAnalysis,
} from "./_utils";

// Risk Index ì¬ê³„ì‚° ë° ì €ì¥
export async function recalculateRiskIndex(): Promise<{
  success: boolean;
  error?: string;
  analyses?: SubjectRiskAnalysis[];
}> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  try {
    const analyses = await calculateAllRiskIndices(supabase, user.id);
    await saveRiskAnalysis(supabase, user.id, analyses);

    revalidatePath("/analysis");
    return { success: true, analyses };
  } catch (error) {
    console.error("[analysis] Risk Index ê³„ì‚° ì‹¤íŒ¨", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Risk Index ê³„ì‚°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="_utils.ts">
type SupabaseServerClient = Awaited<
  ReturnType<typeof import("@/lib/supabase/server").createSupabaseServerClient>
>;

export type ScoreRow = {
  id: string;
  course?: string | null;
  course_detail?: string | null;
  grade?: number | null;
  raw_score?: number | null;
  test_date?: string | null;
  semester?: string | null;
  created_at?: string | null;
};

export type ProgressRow = {
  content_type?: string | null;
  content_id?: string | null;
  progress?: number | null;
  last_updated?: string | null;
};

export type PlanRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  plan_date?: string | null;
  completed_amount?: number | null;
};

export type ContentRow = {
  id: string;
  subject?: string | null;
  difficulty_level?: string | null;
};

export type SubjectRiskAnalysis = {
  subject: string;
  risk_score: number; // 0-100
  recent_grade_trend: number; // -1 (í•˜ë½), 0 (ìœ ì§€), 1 (ìƒìŠ¹)
  consistency_score: number; // 0-100 (ë†’ì„ìˆ˜ë¡ ì¼ê´€ì )
  mastery_estimate: number; // 0-100 (ë†’ì„ìˆ˜ë¡ ìˆ™ë ¨ë„ ë†’ìŒ)
  recent3AvgGrade: number;
  gradeChange: number; // ìµœê·¼ ë“±ê¸‰ ë³€í™”
  scoreVariance: number; // ì›ì ìˆ˜ í¸ì°¨
  improvementRate: number; // í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ì„±ì·¨ë„ ê°œì„ ìœ¨
};

/**
 * âš ï¸ DEPRECATED: ì´ íŒŒì¼ì€ ë ˆê±°ì‹œ student_scores í…Œì´ë¸”ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * 
 * ìƒˆ êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”:
 * - ë‚´ì‹  ì„±ì : student_internal_scores í…Œì´ë¸” ì‚¬ìš©
 * - ëª¨ì˜ê³ ì‚¬ ì„±ì : student_mock_scores í…Œì´ë¸” ì‚¬ìš©
 * 
 * @see lib/data/scoreQueries.ts - getTermScores, getAllTermScores
 */

/**
 * ëª¨ë“  ì„±ì  ì¡°íšŒ
 * @deprecated student_scores í…Œì´ë¸” ì‚¬ìš©. getInternalScores, getMockScores ì‚¬ìš© ê¶Œì¥
 */
export async function fetchAllScores(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<ScoreRow[]> {
  try {
    const selectScores = () =>
      supabase
        .from("student_scores")
        .select(
          "id,course,course_detail,grade,raw_score,test_date,semester,created_at"
        )
        .order("test_date", { ascending: false })
        .order("created_at", { ascending: false });

    let { data, error } = await selectScores().eq("student_id", studentId);

    if (error && error.code === "42703") {
      ({ data, error } = await selectScores());
    }

    if (error) throw error;

    return (data as ScoreRow[] | null) ?? [];
  } catch (error) {
    console.error("[analysis] ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

// í•™ìŠµ ì§„í–‰ë¥  ì¡°íšŒ
export async function fetchProgressMap(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<Record<string, ProgressRow>> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress,last_updated");

    let { data, error } = await selectProgress().eq("student_id", studentId);

    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }

    if (error) throw error;

    const rows = (data as ProgressRow[] | null) ?? [];
    return rows.reduce<Record<string, ProgressRow>>((acc, row) => {
      if (row.content_type && row.content_id) {
        const key = `${row.content_type}:${row.content_id}`;
        acc[key] = row;
      }
      return acc;
    }, {});
  } catch (error) {
    console.error("[analysis] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {};
  }
}

// í•™ìŠµ í”Œëœ ì¡°íšŒ (í•™ìŠµ ì‹œê°„ ê³„ì‚°ìš©)
export async function fetchPlansForSubject(
  supabase: SupabaseServerClient,
  studentId: string,
  subject: string
): Promise<PlanRow[]> {
  try {
    // ì½˜í…ì¸  ì¡°íšŒ (subjectë¡œ í•„í„°ë§)
    const selectBooks = () =>
      supabase.from("books").select("id").eq("subject", subject);
    const selectLectures = () =>
      supabase.from("lectures").select("id").eq("subject", subject);
    const selectCustom = () =>
      supabase.from("student_custom_contents").select("id").eq("subject", subject);

    const [books, lectures, custom] = await Promise.all([
      selectBooks().eq("student_id", studentId),
      selectLectures().eq("student_id", studentId),
      selectCustom().eq("student_id", studentId),
    ]);

    // 42703 fallback
    let bookIds: string[] = [];
    let lectureIds: string[] = [];
    let customIds: string[] = [];

    if (books.error && books.error.code === "42703") {
      const { data } = await selectBooks();
      bookIds = (data ?? []).map((b) => b.id);
    } else if (books.data) {
      bookIds = books.data.map((b) => b.id);
    }

    if (lectures.error && lectures.error.code === "42703") {
      const { data } = await selectLectures();
      lectureIds = (data ?? []).map((l) => l.id);
    } else if (lectures.data) {
      lectureIds = lectures.data.map((l) => l.id);
    }

    if (custom.error && custom.error.code === "42703") {
      const { data } = await selectCustom();
      customIds = (data ?? []).map((c) => c.id);
    } else if (custom.data) {
      customIds = custom.data.map((c) => c.id);
    }

    if (bookIds.length === 0 && lectureIds.length === 0 && customIds.length === 0) {
      return [];
    }

    // í”Œëœ ì¡°íšŒ (OR ì¡°ê±´ìœ¼ë¡œ í•œ ë²ˆì—)
    const planQueries: Promise<any>[] = [];

    if (bookIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "book")
          .in("content_id", bookIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (lectureIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "lecture")
          .in("content_id", lectureIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (customIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "custom")
          .in("content_id", customIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (planQueries.length === 0) return [];

    const planResults = await Promise.all(planQueries);
    const allPlans: PlanRow[] = [];

    planResults.forEach((result, index) => {
      if (result.error && result.error.code === "42703") {
        // fallback ì²˜ë¦¬ (ê° ì¿¼ë¦¬ ì¬ì‹œë„)
        // ê°„ë‹¨íˆ ë¹ˆ ë°°ì—´ ë°˜í™˜
        return;
      }
      if (result.data) {
        allPlans.push(...(result.data as PlanRow[]));
      }
    });

    return allPlans;
  } catch (error) {
    console.error("[analysis] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

// Risk Index ê³„ì‚°
export function calculateRiskIndex(
  subject: string,
  scores: ScoreRow[],
  plans: PlanRow[],
  progressMap: Record<string, ProgressRow>
): SubjectRiskAnalysis {
  // í•´ë‹¹ ê³¼ëª©ì˜ ì„±ì ë§Œ í•„í„°ë§
  const subjectScores = scores
    .filter((s) => s.course?.toLowerCase().trim() === subject.toLowerCase().trim())
    .filter((s) => s.grade !== null && s.grade !== undefined)
    .sort((a, b) => {
      const dateA = a.test_date ? new Date(a.test_date).getTime() : 0;
      const dateB = b.test_date ? new Date(b.test_date).getTime() : 0;
      return dateB - dateA; // ìµœì‹ ìˆœ
    });

  if (subjectScores.length === 0) {
    return {
      subject,
      risk_score: 0,
      recent_grade_trend: 0,
      consistency_score: 100,
      mastery_estimate: 0,
      recent3AvgGrade: 0,
      gradeChange: 0,
      scoreVariance: 0,
      improvementRate: 0,
    };
  }

  const validGrades = subjectScores
    .map((s) => s.grade!)
    .filter((g): g is number => g !== null && g !== undefined);
  const validRawScores = subjectScores
    .map((s) => s.raw_score)
    .filter((r): r is number => r !== null && r !== undefined);

  // 1. ìµœê·¼ 3íšŒ ë“±ê¸‰ í‰ê· 
  const recent3Grades = validGrades.slice(0, 3);
  const recent3AvgGrade =
    recent3Grades.length > 0
      ? recent3Grades.reduce((a, b) => a + b, 0) / recent3Grades.length
      : validGrades[0] ?? 0;

  // 2. ìµœê·¼ ë“±ê¸‰ ë³€í™” (í•˜ë½ = ìœ„í—˜ë„ ì¦ê°€)
  let gradeChange = 0;
  let recentGradeTrend = 0; // -1 (í•˜ë½), 0 (ìœ ì§€), 1 (ìƒìŠ¹)
  if (validGrades.length >= 2) {
    const latest = validGrades[0];
    const previous = validGrades[1];
    gradeChange = latest - previous; // ì–‘ìˆ˜ë©´ í•˜ë½ (ë‚˜ë¹ ì§)
    if (gradeChange > 0) {
      recentGradeTrend = -1; // í•˜ë½
    } else if (gradeChange < 0) {
      recentGradeTrend = 1; // ìƒìŠ¹
    } else {
      recentGradeTrend = 0; // ìœ ì§€
    }
  }

  // 3. ë‚œì´ë„ ëŒ€ë¹„ raw_score í¸ì°¨
  let scoreVariance = 0;
  if (validRawScores.length >= 2) {
    const mean = validRawScores.reduce((a, b) => a + b, 0) / validRawScores.length;
    const variance =
      validRawScores.reduce((sum, score) => {
        return sum + Math.pow(score - mean, 2);
      }, 0) / validRawScores.length;
    scoreVariance = Math.sqrt(variance);
  }

  // 4. í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ì„±ì·¨ë„ ê°œì„ ìœ¨
  // í”Œëœì˜ completed_amount í•©ê³„ë¥¼ í•™ìŠµ ì‹œê°„ìœ¼ë¡œ ê°„ì£¼
  const totalLearningTime = plans.reduce((sum, plan) => {
    return sum + (plan.completed_amount ?? 0);
  }, 0);

  // ê°œì„ ìœ¨: ìµœê·¼ ë“±ê¸‰ì´ ê°œì„ ë˜ì—ˆëŠ”ì§€ì™€ í•™ìŠµ ì‹œê°„ì˜ ë¹„ìœ¨
  let improvementRate = 0;
  if (validGrades.length >= 2) {
    const latestGrade = validGrades[0];
    const oldestGrade = validGrades[validGrades.length - 1];
    const gradeImprovement = oldestGrade - latestGrade; // ì–‘ìˆ˜ë©´ ê°œì„  (ë“±ê¸‰ì´ ë‚®ì•„ì§)
    
    if (totalLearningTime > 0) {
      // í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ë“±ê¸‰ ê°œì„ ë„ (ë“±ê¸‰ 1ë‹¨ê³„ ê°œì„ ë‹¹ í•™ìŠµ ì‹œê°„ ë¹„ìœ¨)
      improvementRate = (gradeImprovement / totalLearningTime) * 1000; // ìŠ¤ì¼€ì¼ ì¡°ì •
    } else {
      // í•™ìŠµ ì‹œê°„ì´ ì—†ìœ¼ë©´ ë“±ê¸‰ ë³€í™”ë§Œìœ¼ë¡œ ì¶”ì •
      improvementRate = gradeImprovement * 10; // ë“±ê¸‰ 1ë‹¨ê³„ = 10ì 
    }
  }

  // ì¼ê´€ì„± ì ìˆ˜ (ë“±ê¸‰ í¸ì°¨ê°€ ì‘ì„ìˆ˜ë¡ ë†’ìŒ)
  let consistencyScore = 100;
  if (validGrades.length >= 2) {
    const gradeMean = validGrades.reduce((a, b) => a + b, 0) / validGrades.length;
    const gradeVariance =
      validGrades.reduce((sum, grade) => {
        return sum + Math.pow(grade - gradeMean, 2);
      }, 0) / validGrades.length;
    const gradeStdDev = Math.sqrt(gradeVariance);
    // í‘œì¤€í¸ì°¨ê°€ 0ì´ë©´ 100ì , 2 ì´ìƒì´ë©´ 0ì 
    consistencyScore = Math.max(0, 100 - gradeStdDev * 50);
  }

  // ìˆ™ë ¨ë„ ì¶”ì • (ìµœê·¼ ë“±ê¸‰ì´ ì¢‹ì„ìˆ˜ë¡, ì¼ê´€ì„±ì´ ë†’ì„ìˆ˜ë¡ ë†’ìŒ)
  // 1ë“±ê¸‰=100, 5ë“±ê¸‰=50, 9ë“±ê¸‰=0
  const gradeBasedMastery = ((9 - recent3AvgGrade) / 8) * 100;
  const masteryEstimate = (gradeBasedMastery * 0.7 + consistencyScore * 0.3);

  // Risk Score ê³„ì‚° (0-100, ë†’ì„ìˆ˜ë¡ ìœ„í—˜)
  let riskScore = 0;

  // 1. ìµœê·¼ 3íšŒ í‰ê·  ë“±ê¸‰ (40%)
  const gradeRisk = ((recent3AvgGrade - 1) / 8) * 100;
  riskScore += gradeRisk * 0.4;

  // 2. ë“±ê¸‰ í•˜ë½ íŒ¨ë„í‹° (30%)
  if (gradeChange > 0) {
    riskScore += Math.min(100, gradeChange * 20) * 0.3;
  }

  // 3. ì›ì ìˆ˜ í¸ì°¨ (20%)
  // í¸ì°¨ê°€ 20 ì´ìƒì´ë©´ ìœ„í—˜
  const varianceRisk = Math.min(100, (scoreVariance / 20) * 100);
  riskScore += varianceRisk * 0.2;

  // 4. ê°œì„ ìœ¨ ë¶€ì¡± íŒ¨ë„í‹° (10%)
  // ê°œì„ ìœ¨ì´ ë‚®ê±°ë‚˜ ìŒìˆ˜ë©´ ìœ„í—˜
  if (improvementRate <= 0) {
    riskScore += 50 * 0.1;
  } else if (improvementRate < 1) {
    riskScore += (1 - improvementRate) * 50 * 0.1;
  }

  riskScore = Math.min(100, Math.max(0, riskScore));

  return {
    subject,
    risk_score: riskScore,
    recent_grade_trend: recentGradeTrend,
    consistency_score: consistencyScore,
    mastery_estimate: masteryEstimate,
    recent3AvgGrade,
    gradeChange,
    scoreVariance,
    improvementRate,
  };
}

// ëª¨ë“  ê³¼ëª©ì˜ Risk Index ê³„ì‚°
export async function calculateAllRiskIndices(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<SubjectRiskAnalysis[]> {
  const [scores, progressMap] = await Promise.all([
    fetchAllScores(supabase, studentId),
    fetchProgressMap(supabase, studentId),
  ]);

  // ê³¼ëª© ëª©ë¡ ì¶”ì¶œ
  const subjects = new Set<string>();
  scores.forEach((score) => {
    if (score.course) {
      subjects.add(score.course.toLowerCase().trim());
    }
  });

  const analyses: SubjectRiskAnalysis[] = [];

  for (const subject of subjects) {
    const plans = await fetchPlansForSubject(supabase, studentId, subject);
    const analysis = calculateRiskIndex(subject, scores, plans, progressMap);
    analyses.push(analysis);
  }

  // Risk Score ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì„ìˆ˜ë¡ ìœ„í—˜)
  return analyses.sort((a, b) => b.risk_score - a.risk_score);
}

// student_analysis í…Œì´ë¸”ì— ì €ì¥
export async function saveRiskAnalysis(
  supabase: SupabaseServerClient,
  studentId: string,
  analyses: SubjectRiskAnalysis[]
): Promise<void> {
  try {
    // ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
    const deleteQuery = () =>
      supabase.from("student_analysis").delete().eq("student_id", studentId);

    let { error: deleteError } = await deleteQuery();

    if (deleteError && deleteError.code === "42703") {
      // student_id ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ ì‚­ì œ ì‹œë„
      const { error } = await supabase.from("student_analysis").delete();
      if (error && error.code !== "PGRST116") {
        // PGRST116ì€ "no rows found" ì—ëŸ¬, ë¬´ì‹œ ê°€ëŠ¥
        throw error;
      }
    } else if (deleteError && deleteError.code !== "PGRST116") {
      throw deleteError;
    }

    // studentì˜ tenant_id ì¡°íšŒ
    const { data: student } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", studentId)
      .single();

    if (!student || !student.tenant_id) {
      console.error("[analysis] í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    // ìƒˆ ë°ì´í„° ì‚½ì…
    const insertData = analyses.map((analysis) => ({
      student_id: studentId,
      tenant_id: student.tenant_id,
      subject: analysis.subject,
      risk_score: analysis.risk_score,
      recent_grade_trend: analysis.recent_grade_trend,
      consistency_score: analysis.consistency_score,
      mastery_estimate: analysis.mastery_estimate,
    }));

    if (insertData.length === 0) return;

    const insertQuery = () => supabase.from("student_analysis").insert(insertData);

    let { error: insertError } = await insertQuery();

    if (insertError && insertError.code === "42703") {
      // student_id ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì œê±°í•˜ê³  ì¬ì‹œë„
      const fallbackData = insertData.map(({ student_id: _studentId, ...rest }) => rest);
      ({ error: insertError } = await supabase
        .from("student_analysis")
        .insert(fallbackData));
    }

    if (insertError) throw insertError;
  } catch (error) {
    console.error("[analysis] Risk Analysis ì €ì¥ ì‹¤íŒ¨", error);
    // ì €ì¥ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  }
}
</file>

<file path="_utils.ts">
type SupabaseServerClient = Awaited<
  ReturnType<typeof import("@/lib/supabase/server").createSupabaseServerClient>
>;

export type ScoreRow = {
  id: string;
  course?: string | null;
  course_detail?: string | null;
  grade?: number | null;
  raw_score?: number | null;
  test_date?: string | null;
  semester?: string | null;
  created_at?: string | null;
};

export type ProgressRow = {
  content_type?: string | null;
  content_id?: string | null;
  progress?: number | null;
  last_updated?: string | null;
};

export type PlanRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  plan_date?: string | null;
  completed_amount?: number | null;
};

export type ContentRow = {
  id: string;
  subject?: string | null;
  difficulty_level?: string | null;
};

export type SubjectRiskAnalysis = {
  subject: string;
  risk_score: number; // 0-100
  recent_grade_trend: number; // -1 (í•˜ë½), 0 (ìœ ì§€), 1 (ìƒìŠ¹)
  consistency_score: number; // 0-100 (ë†’ì„ìˆ˜ë¡ ì¼ê´€ì )
  mastery_estimate: number; // 0-100 (ë†’ì„ìˆ˜ë¡ ìˆ™ë ¨ë„ ë†’ìŒ)
  recent3AvgGrade: number;
  gradeChange: number; // ìµœê·¼ ë“±ê¸‰ ë³€í™”
  scoreVariance: number; // ì›ì ìˆ˜ í¸ì°¨
  improvementRate: number; // í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ì„±ì·¨ë„ ê°œì„ ìœ¨
};

/**
 * âš ï¸ DEPRECATED: ì´ íŒŒì¼ì€ ë ˆê±°ì‹œ student_scores í…Œì´ë¸”ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * 
 * ìƒˆ êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”:
 * - ë‚´ì‹  ì„±ì : student_internal_scores í…Œì´ë¸” ì‚¬ìš©
 * - ëª¨ì˜ê³ ì‚¬ ì„±ì : student_mock_scores í…Œì´ë¸” ì‚¬ìš©
 * 
 * @see lib/data/scoreQueries.ts - getTermScores, getAllTermScores
 */

/**
 * ëª¨ë“  ì„±ì  ì¡°íšŒ
 * @deprecated student_scores í…Œì´ë¸” ì‚¬ìš©. getInternalScores, getMockScores ì‚¬ìš© ê¶Œì¥
 */
export async function fetchAllScores(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<ScoreRow[]> {
  try {
    const selectScores = () =>
      supabase
        .from("student_scores")
        .select(
          "id,course,course_detail,grade,raw_score,test_date,semester,created_at"
        )
        .order("test_date", { ascending: false })
        .order("created_at", { ascending: false });

    let { data, error } = await selectScores().eq("student_id", studentId);

    if (error && error.code === "42703") {
      ({ data, error } = await selectScores());
    }

    if (error) throw error;

    return (data as ScoreRow[] | null) ?? [];
  } catch (error) {
    console.error("[analysis] ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

// í•™ìŠµ ì§„í–‰ë¥  ì¡°íšŒ
export async function fetchProgressMap(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<Record<string, ProgressRow>> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress,last_updated");

    let { data, error } = await selectProgress().eq("student_id", studentId);

    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress());
    }

    if (error) throw error;

    const rows = (data as ProgressRow[] | null) ?? [];
    return rows.reduce<Record<string, ProgressRow>>((acc, row) => {
      if (row.content_type && row.content_id) {
        const key = `${row.content_type}:${row.content_id}`;
        acc[key] = row;
      }
      return acc;
    }, {});
  } catch (error) {
    console.error("[analysis] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return {};
  }
}

// í•™ìŠµ í”Œëœ ì¡°íšŒ (í•™ìŠµ ì‹œê°„ ê³„ì‚°ìš©)
export async function fetchPlansForSubject(
  supabase: SupabaseServerClient,
  studentId: string,
  subject: string
): Promise<PlanRow[]> {
  try {
    // ì½˜í…ì¸  ì¡°íšŒ (subjectë¡œ í•„í„°ë§)
    const selectBooks = () =>
      supabase.from("books").select("id").eq("subject", subject);
    const selectLectures = () =>
      supabase.from("lectures").select("id").eq("subject", subject);
    const selectCustom = () =>
      supabase.from("student_custom_contents").select("id").eq("subject", subject);

    const [books, lectures, custom] = await Promise.all([
      selectBooks().eq("student_id", studentId),
      selectLectures().eq("student_id", studentId),
      selectCustom().eq("student_id", studentId),
    ]);

    // 42703 fallback
    let bookIds: string[] = [];
    let lectureIds: string[] = [];
    let customIds: string[] = [];

    if (books.error && books.error.code === "42703") {
      const { data } = await selectBooks();
      bookIds = (data ?? []).map((b) => b.id);
    } else if (books.data) {
      bookIds = books.data.map((b) => b.id);
    }

    if (lectures.error && lectures.error.code === "42703") {
      const { data } = await selectLectures();
      lectureIds = (data ?? []).map((l) => l.id);
    } else if (lectures.data) {
      lectureIds = lectures.data.map((l) => l.id);
    }

    if (custom.error && custom.error.code === "42703") {
      const { data } = await selectCustom();
      customIds = (data ?? []).map((c) => c.id);
    } else if (custom.data) {
      customIds = custom.data.map((c) => c.id);
    }

    if (bookIds.length === 0 && lectureIds.length === 0 && customIds.length === 0) {
      return [];
    }

    // í”Œëœ ì¡°íšŒ (OR ì¡°ê±´ìœ¼ë¡œ í•œ ë²ˆì—)
    const planQueries: Promise<any>[] = [];

    if (bookIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "book")
          .in("content_id", bookIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (lectureIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "lecture")
          .in("content_id", lectureIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (customIds.length > 0) {
      const selectPlans = () =>
        supabase
          .from("student_plan")
          .select("id,content_type,content_id,plan_date,completed_amount")
          .eq("content_type", "custom")
          .in("content_id", customIds);

      const query = selectPlans().eq("student_id", studentId);
      planQueries.push((async () => {
        const { data } = await query;
        return data ?? [];
      })());
    }

    if (planQueries.length === 0) return [];

    const planResults = await Promise.all(planQueries);
    const allPlans: PlanRow[] = [];

    planResults.forEach((result, index) => {
      if (result.error && result.error.code === "42703") {
        // fallback ì²˜ë¦¬ (ê° ì¿¼ë¦¬ ì¬ì‹œë„)
        // ê°„ë‹¨íˆ ë¹ˆ ë°°ì—´ ë°˜í™˜
        return;
      }
      if (result.data) {
        allPlans.push(...(result.data as PlanRow[]));
      }
    });

    return allPlans;
  } catch (error) {
    console.error("[analysis] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

// Risk Index ê³„ì‚°
export function calculateRiskIndex(
  subject: string,
  scores: ScoreRow[],
  plans: PlanRow[],
  progressMap: Record<string, ProgressRow>
): SubjectRiskAnalysis {
  // í•´ë‹¹ ê³¼ëª©ì˜ ì„±ì ë§Œ í•„í„°ë§
  const subjectScores = scores
    .filter((s) => s.course?.toLowerCase().trim() === subject.toLowerCase().trim())
    .filter((s) => s.grade !== null && s.grade !== undefined)
    .sort((a, b) => {
      const dateA = a.test_date ? new Date(a.test_date).getTime() : 0;
      const dateB = b.test_date ? new Date(b.test_date).getTime() : 0;
      return dateB - dateA; // ìµœì‹ ìˆœ
    });

  if (subjectScores.length === 0) {
    return {
      subject,
      risk_score: 0,
      recent_grade_trend: 0,
      consistency_score: 100,
      mastery_estimate: 0,
      recent3AvgGrade: 0,
      gradeChange: 0,
      scoreVariance: 0,
      improvementRate: 0,
    };
  }

  const validGrades = subjectScores
    .map((s) => s.grade!)
    .filter((g): g is number => g !== null && g !== undefined);
  const validRawScores = subjectScores
    .map((s) => s.raw_score)
    .filter((r): r is number => r !== null && r !== undefined);

  // 1. ìµœê·¼ 3íšŒ ë“±ê¸‰ í‰ê· 
  const recent3Grades = validGrades.slice(0, 3);
  const recent3AvgGrade =
    recent3Grades.length > 0
      ? recent3Grades.reduce((a, b) => a + b, 0) / recent3Grades.length
      : validGrades[0] ?? 0;

  // 2. ìµœê·¼ ë“±ê¸‰ ë³€í™” (í•˜ë½ = ìœ„í—˜ë„ ì¦ê°€)
  let gradeChange = 0;
  let recentGradeTrend = 0; // -1 (í•˜ë½), 0 (ìœ ì§€), 1 (ìƒìŠ¹)
  if (validGrades.length >= 2) {
    const latest = validGrades[0];
    const previous = validGrades[1];
    gradeChange = latest - previous; // ì–‘ìˆ˜ë©´ í•˜ë½ (ë‚˜ë¹ ì§)
    if (gradeChange > 0) {
      recentGradeTrend = -1; // í•˜ë½
    } else if (gradeChange < 0) {
      recentGradeTrend = 1; // ìƒìŠ¹
    } else {
      recentGradeTrend = 0; // ìœ ì§€
    }
  }

  // 3. ë‚œì´ë„ ëŒ€ë¹„ raw_score í¸ì°¨
  let scoreVariance = 0;
  if (validRawScores.length >= 2) {
    const mean = validRawScores.reduce((a, b) => a + b, 0) / validRawScores.length;
    const variance =
      validRawScores.reduce((sum, score) => {
        return sum + Math.pow(score - mean, 2);
      }, 0) / validRawScores.length;
    scoreVariance = Math.sqrt(variance);
  }

  // 4. í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ì„±ì·¨ë„ ê°œì„ ìœ¨
  // í”Œëœì˜ completed_amount í•©ê³„ë¥¼ í•™ìŠµ ì‹œê°„ìœ¼ë¡œ ê°„ì£¼
  const totalLearningTime = plans.reduce((sum, plan) => {
    return sum + (plan.completed_amount ?? 0);
  }, 0);

  // ê°œì„ ìœ¨: ìµœê·¼ ë“±ê¸‰ì´ ê°œì„ ë˜ì—ˆëŠ”ì§€ì™€ í•™ìŠµ ì‹œê°„ì˜ ë¹„ìœ¨
  let improvementRate = 0;
  if (validGrades.length >= 2) {
    const latestGrade = validGrades[0];
    const oldestGrade = validGrades[validGrades.length - 1];
    const gradeImprovement = oldestGrade - latestGrade; // ì–‘ìˆ˜ë©´ ê°œì„  (ë“±ê¸‰ì´ ë‚®ì•„ì§)
    
    if (totalLearningTime > 0) {
      // í•™ìŠµ ì‹œê°„ ëŒ€ë¹„ ë“±ê¸‰ ê°œì„ ë„ (ë“±ê¸‰ 1ë‹¨ê³„ ê°œì„ ë‹¹ í•™ìŠµ ì‹œê°„ ë¹„ìœ¨)
      improvementRate = (gradeImprovement / totalLearningTime) * 1000; // ìŠ¤ì¼€ì¼ ì¡°ì •
    } else {
      // í•™ìŠµ ì‹œê°„ì´ ì—†ìœ¼ë©´ ë“±ê¸‰ ë³€í™”ë§Œìœ¼ë¡œ ì¶”ì •
      improvementRate = gradeImprovement * 10; // ë“±ê¸‰ 1ë‹¨ê³„ = 10ì 
    }
  }

  // ì¼ê´€ì„± ì ìˆ˜ (ë“±ê¸‰ í¸ì°¨ê°€ ì‘ì„ìˆ˜ë¡ ë†’ìŒ)
  let consistencyScore = 100;
  if (validGrades.length >= 2) {
    const gradeMean = validGrades.reduce((a, b) => a + b, 0) / validGrades.length;
    const gradeVariance =
      validGrades.reduce((sum, grade) => {
        return sum + Math.pow(grade - gradeMean, 2);
      }, 0) / validGrades.length;
    const gradeStdDev = Math.sqrt(gradeVariance);
    // í‘œì¤€í¸ì°¨ê°€ 0ì´ë©´ 100ì , 2 ì´ìƒì´ë©´ 0ì 
    consistencyScore = Math.max(0, 100 - gradeStdDev * 50);
  }

  // ìˆ™ë ¨ë„ ì¶”ì • (ìµœê·¼ ë“±ê¸‰ì´ ì¢‹ì„ìˆ˜ë¡, ì¼ê´€ì„±ì´ ë†’ì„ìˆ˜ë¡ ë†’ìŒ)
  // 1ë“±ê¸‰=100, 5ë“±ê¸‰=50, 9ë“±ê¸‰=0
  const gradeBasedMastery = ((9 - recent3AvgGrade) / 8) * 100;
  const masteryEstimate = (gradeBasedMastery * 0.7 + consistencyScore * 0.3);

  // Risk Score ê³„ì‚° (0-100, ë†’ì„ìˆ˜ë¡ ìœ„í—˜)
  let riskScore = 0;

  // 1. ìµœê·¼ 3íšŒ í‰ê·  ë“±ê¸‰ (40%)
  const gradeRisk = ((recent3AvgGrade - 1) / 8) * 100;
  riskScore += gradeRisk * 0.4;

  // 2. ë“±ê¸‰ í•˜ë½ íŒ¨ë„í‹° (30%)
  if (gradeChange > 0) {
    riskScore += Math.min(100, gradeChange * 20) * 0.3;
  }

  // 3. ì›ì ìˆ˜ í¸ì°¨ (20%)
  // í¸ì°¨ê°€ 20 ì´ìƒì´ë©´ ìœ„í—˜
  const varianceRisk = Math.min(100, (scoreVariance / 20) * 100);
  riskScore += varianceRisk * 0.2;

  // 4. ê°œì„ ìœ¨ ë¶€ì¡± íŒ¨ë„í‹° (10%)
  // ê°œì„ ìœ¨ì´ ë‚®ê±°ë‚˜ ìŒìˆ˜ë©´ ìœ„í—˜
  if (improvementRate <= 0) {
    riskScore += 50 * 0.1;
  } else if (improvementRate < 1) {
    riskScore += (1 - improvementRate) * 50 * 0.1;
  }

  riskScore = Math.min(100, Math.max(0, riskScore));

  return {
    subject,
    risk_score: riskScore,
    recent_grade_trend: recentGradeTrend,
    consistency_score: consistencyScore,
    mastery_estimate: masteryEstimate,
    recent3AvgGrade,
    gradeChange,
    scoreVariance,
    improvementRate,
  };
}

// ëª¨ë“  ê³¼ëª©ì˜ Risk Index ê³„ì‚°
export async function calculateAllRiskIndices(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<SubjectRiskAnalysis[]> {
  const [scores, progressMap] = await Promise.all([
    fetchAllScores(supabase, studentId),
    fetchProgressMap(supabase, studentId),
  ]);

  // ê³¼ëª© ëª©ë¡ ì¶”ì¶œ
  const subjects = new Set<string>();
  scores.forEach((score) => {
    if (score.course) {
      subjects.add(score.course.toLowerCase().trim());
    }
  });

  const analyses: SubjectRiskAnalysis[] = [];

  for (const subject of subjects) {
    const plans = await fetchPlansForSubject(supabase, studentId, subject);
    const analysis = calculateRiskIndex(subject, scores, plans, progressMap);
    analyses.push(analysis);
  }

  // Risk Score ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì„ìˆ˜ë¡ ìœ„í—˜)
  return analyses.sort((a, b) => b.risk_score - a.risk_score);
}

// student_analysis í…Œì´ë¸”ì— ì €ì¥
export async function saveRiskAnalysis(
  supabase: SupabaseServerClient,
  studentId: string,
  analyses: SubjectRiskAnalysis[]
): Promise<void> {
  try {
    // ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
    const deleteQuery = () =>
      supabase.from("student_analysis").delete().eq("student_id", studentId);

    let { error: deleteError } = await deleteQuery();

    if (deleteError && deleteError.code === "42703") {
      // student_id ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ ì‚­ì œ ì‹œë„
      const { error } = await supabase.from("student_analysis").delete();
      if (error && error.code !== "PGRST116") {
        // PGRST116ì€ "no rows found" ì—ëŸ¬, ë¬´ì‹œ ê°€ëŠ¥
        throw error;
      }
    } else if (deleteError && deleteError.code !== "PGRST116") {
      throw deleteError;
    }

    // studentì˜ tenant_id ì¡°íšŒ
    const { data: student } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", studentId)
      .single();

    if (!student || !student.tenant_id) {
      console.error("[analysis] í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    // ìƒˆ ë°ì´í„° ì‚½ì…
    const insertData = analyses.map((analysis) => ({
      student_id: studentId,
      tenant_id: student.tenant_id,
      subject: analysis.subject,
      risk_score: analysis.risk_score,
      recent_grade_trend: analysis.recent_grade_trend,
      consistency_score: analysis.consistency_score,
      mastery_estimate: analysis.mastery_estimate,
    }));

    if (insertData.length === 0) return;

    const insertQuery = () => supabase.from("student_analysis").insert(insertData);

    let { error: insertError } = await insertQuery();

    if (insertError && insertError.code === "42703") {
      // student_id ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì œê±°í•˜ê³  ì¬ì‹œë„
      const fallbackData = insertData.map(({ student_id: _studentId, ...rest }) => rest);
      ({ error: insertError } = await supabase
        .from("student_analysis")
        .insert(fallbackData));
    }

    if (insertError) throw insertError;
  } catch (error) {
    console.error("[analysis] Risk Analysis ì €ì¥ ì‹¤íŒ¨", error);
    // ì €ì¥ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  }
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { calculateAllRiskIndices, saveRiskAnalysis } from "./_utils";
import { RiskIndexList } from "./_components/RiskIndexList";
import { RecalculateButton } from "./_components/RecalculateButton";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type AnalysisRow = {
  id: string;
  subject: string | null;
  risk_score: number | null;
  recent_grade_trend: number | null;
  consistency_score: number | null;
  mastery_estimate: number | null;
  updated_at: string | null;
};

export default async function AnalysisPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ì €ì¥ëœ ë¶„ì„ ë°ì´í„° ì¡°íšŒ
  const selectAnalysis = () =>
    supabase
      .from("student_analysis")
      .select(
        "id,subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate,updated_at"
      )
      .order("risk_score", { ascending: false });

  let { data: savedAnalyses, error } = await selectAnalysis().eq(
    "student_id",
    user.id
  );

  if (error && error.code === "42703") {
    ({ data: savedAnalyses, error } = await selectAnalysis());
  }

  // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìˆìŒ)
  if (error && error.code !== "PGRST116") {
    console.error("[analysis] ë¶„ì„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const analyses =
    (savedAnalyses as AnalysisRow[] | null) ?? [];

  // ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ê³„ì‚°
  let riskAnalyses = analyses.map((a) => ({
    subject: a.subject ?? "",
    risk_score: a.risk_score ?? 0,
    recent_grade_trend: a.recent_grade_trend ?? 0,
    consistency_score: a.consistency_score ?? 100,
    mastery_estimate: a.mastery_estimate ?? 0,
    recent3AvgGrade: 0,
    gradeChange: 0,
    scoreVariance: 0,
    improvementRate: 0,
  }));

  if (riskAnalyses.length === 0) {
    // ì‹¤ì‹œê°„ ê³„ì‚°
    try {
      const calculated = await calculateAllRiskIndices(supabase, user.id);
      riskAnalyses = calculated;
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì €ì¥ ì‹œë„
      saveRiskAnalysis(supabase, user.id, calculated).catch(console.error);
    } catch (error) {
      console.error("[analysis] ì‹¤ì‹œê°„ ê³„ì‚° ì‹¤íŒ¨", error);
    }
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="ì·¨ì•½ ê³¼ëª© ë¶„ì„"
          description="ì„±ì  ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì·¨ì•½ ê³¼ëª©ì˜ Risk Indexë¥¼ ë¶„ì„í•©ë‹ˆë‹¤."
          action={
            <div className="flex gap-2">
              <RecalculateButton />
              <Link
                href="/scores"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ì„±ì  ê´€ë¦¬
              </Link>
            </div>
          }
        />

        {riskAnalyses.length === 0 ? (
          <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-12 text-center shadow-sm">
            <p className="text-lg text-gray-500">
              ë¶„ì„í•  ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
            </p>
            <Link
              href="/scores/dashboard"
              className="inline-block rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
            >
              ì„±ì  ê´€ë¦¬ë¡œ ì´ë™
            </Link>
          </div>
        ) : (
          <RiskIndexList analyses={riskAnalyses} />
        )}
      </div>
    </section>
  );
}
</file>

<file path="_components/AcademyScheduleManagement.tsx">
"use client";

import { useEffect, useState, useTransition } from "react";
import { supabase } from "@/lib/supabase/client";
import { 
  createAcademy, 
  updateAcademy, 
  deleteAcademy,
  addAcademySchedule, 
  updateAcademySchedule, 
  deleteAcademySchedule 
} from "@/app/(student)/actions/planGroupActions";
import type { AcademySchedule, Academy } from "@/lib/types/plan";
import { Trash2, Pencil, X, Plus } from "lucide-react";
import { EmptyState } from "@/components/ui/EmptyState";
import { validateAcademyScheduleOverlap } from "@/lib/validation/scheduleValidator";
import { SuspenseFallback } from "@/components/ui/LoadingSkeleton";

type AcademyScheduleManagementProps = {
  studentId: string;
  onAddRequest?: () => void;
  isAddingAcademy?: boolean;
};

const weekdayLabels = ["ì¼ìš”ì¼", "ì›”ìš”ì¼", "í™”ìš”ì¼", "ìˆ˜ìš”ì¼", "ëª©ìš”ì¼", "ê¸ˆìš”ì¼", "í† ìš”ì¼"];

type AcademyWithSchedules = Academy & {
  schedules: AcademySchedule[];
};

export default function AcademyScheduleManagement({
  studentId,
  onAddRequest,
  isAddingAcademy = false,
}: AcademyScheduleManagementProps) {
  const [academies, setAcademies] = useState<AcademyWithSchedules[]>([]);
  const [loading, setLoading] = useState(true);
  
  // í•™ì› ê´€ë¦¬ ìƒíƒœ
  const [editingAcademyId, setEditingAcademyId] = useState<string | null>(null);
  const [newAcademyName, setNewAcademyName] = useState("");
  const [newAcademyTravelTime, setNewAcademyTravelTime] = useState("60");
  
  // í•™ì› ì¼ì • ê´€ë¦¬ ìƒíƒœ
  const [selectedAcademyId, setSelectedAcademyId] = useState<string | null>(null);
  const [isAddingSchedule, setIsAddingSchedule] = useState(false);
  const [editingScheduleId, setEditingScheduleId] = useState<string | null>(null);
  const [selectedDays, setSelectedDays] = useState<number[]>([]);
  const [scheduleStartTime, setScheduleStartTime] = useState("09:00");
  const [scheduleEndTime, setScheduleEndTime] = useState("10:00");
  const [scheduleSubject, setScheduleSubject] = useState("");
  
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      // í•™ìƒë³„ í•™ì› ëª©ë¡ ì¡°íšŒ
      const { data: academiesData, error: academiesError } = await supabase
        .from("academies")
        .select("id,tenant_id,student_id,name,travel_time,created_at,updated_at")
        .eq("student_id", studentId)
        .order("name", { ascending: true });

      if (academiesError) {
        console.error("[AcademyScheduleManagement] í•™ì› ì¡°íšŒ ì‹¤íŒ¨", academiesError);
        setAcademies([]);
        setLoading(false);
        return;
      }

      const academiesList = (academiesData as Academy[]) ?? [];

      // ê° í•™ì›ì˜ ì¼ì • ì¡°íšŒ
      const academiesWithSchedules = await Promise.all(
        academiesList.map(async (academy) => {
          const { data: schedulesData, error: schedulesError } = await supabase
            .from("academy_schedules")
            .select(
              "id,tenant_id,student_id,academy_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at"
            )
            .eq("academy_id", academy.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          if (schedulesError) {
            console.error(`[AcademyScheduleManagement] í•™ì› ì¼ì • ì¡°íšŒ ì‹¤íŒ¨ (academy: ${academy.id})`, schedulesError);
            return { ...academy, schedules: [] };
          }

          return {
            ...academy,
            schedules: (schedulesData as AcademySchedule[]) ?? [],
          };
        })
      );

      setAcademies(academiesWithSchedules);
      
      // ì²« ë²ˆì§¸ í•™ì›ì„ ê¸°ë³¸ ì„ íƒ
      if (academiesWithSchedules.length > 0 && !selectedAcademyId) {
        setSelectedAcademyId(academiesWithSchedules[0].id);
      }
    } catch (error: unknown) {
      console.error("í•™ì› ì¼ì • ë¡œë“œ ì‹¤íŒ¨:", error);
    } finally {
      setLoading(false);
    }
  };

  // í•™ì› ì¶”ê°€
  const handleAddAcademy = async () => {
    if (!newAcademyName.trim()) {
      alert("í•™ì› ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("name", newAcademyName.trim());
        formData.append("travel_time", newAcademyTravelTime);

        await createAcademy(formData);

        setNewAcademyName("");
        setNewAcademyTravelTime("60");
        onAddRequest?.(); // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ìƒíƒœ í† ê¸€ ìš”ì²­

        await loadData();
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : "í•™ì› ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        alert(errorMessage);
      }
    });
  };

  // í•™ì› ìˆ˜ì • ì‹œì‘
  const handleStartEditAcademy = (academy: Academy) => {
    setEditingAcademyId(academy.id);
    setNewAcademyName(academy.name);
    setNewAcademyTravelTime(String(academy.travel_time));
    onAddRequest?.(); // isAddingAcademyê°€ falseë¡œ ë³€ê²½ë˜ë„ë¡ ìš”ì²­
  };

  // í•™ì› ìˆ˜ì •
  const handleUpdateAcademy = async () => {
    if (!editingAcademyId || !newAcademyName.trim()) {
      alert("í•™ì› ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("academy_id", editingAcademyId);
        formData.append("name", newAcademyName.trim());
        formData.append("travel_time", newAcademyTravelTime);

        await updateAcademy(formData);

        setEditingAcademyId(null);
        setNewAcademyName("");
        setNewAcademyTravelTime("60");

        await loadData();
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : "í•™ì› ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        alert(errorMessage);
      }
    });
  };

  // í•™ì› ì‚­ì œ
  const handleDeleteAcademy = async (academyId: string) => {
    if (!confirm("ì´ í•™ì›ê³¼ ëª¨ë“  ì¼ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("academy_id", academyId);

        await deleteAcademy(formData);

        if (selectedAcademyId === academyId) {
          setSelectedAcademyId(null);
        }

        await loadData();
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : "í•™ì› ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        alert(errorMessage);
      }
    });
  };

  // í•™ì› ì¼ì • ì¶”ê°€
  const handleAddSchedule = async () => {
    if (!selectedAcademyId) {
      alert("í•™ì›ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    if (selectedDays.length === 0) {
      alert("ìš”ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    if (!scheduleSubject.trim()) {
      alert("ê³¼ëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    if (scheduleStartTime >= scheduleEndTime) {
      alert("ì¢…ë£Œ ì‹œê°„ì€ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ëŠ¦ì–´ì•¼ í•©ë‹ˆë‹¤.");
      return;
    }

    const selectedAcademy = academies.find((a) => a.id === selectedAcademyId);
    if (!selectedAcademy) return;

    // ê²¹ì¹¨ ê²€ì¦
    const newSchedules = selectedDays.map((day) => ({
      day_of_week: day,
      start_time: scheduleStartTime,
      end_time: scheduleEndTime,
      academy_name: selectedAcademy.name,
      subject: scheduleSubject.trim(),
      travel_time: selectedAcademy.travel_time,
    }));

    // ê¸°ì¡´ ì¼ì •ê³¼ ê²¹ì¹¨ í™•ì¸
    for (const newSchedule of newSchedules) {
      const validation = validateAcademyScheduleOverlap(
        newSchedule,
        selectedAcademySchedules.map(s => ({
          day_of_week: s.day_of_week,
          start_time: s.start_time,
          end_time: s.end_time,
          academy_name: s.academy_name ?? undefined,
          subject: s.subject ?? undefined,
          travel_time: s.travel_time ?? undefined,
        }))
      );
      if (!validation.isValid) {
        alert(
          `${weekdayLabels[newSchedule.day_of_week]}ì— ê²¹ì¹˜ëŠ” í•™ì› ì¼ì •ì´ ìˆìŠµë‹ˆë‹¤. ì‹œê°„ì„ ì¡°ì •í•´ì£¼ì„¸ìš”.`
        );
        return;
      }
    }

    startTransition(async () => {
      try {
        // ì„ íƒí•œ ëª¨ë“  ìš”ì¼ì— ëŒ€í•´ ì¼ì • ì¶”ê°€
        for (const day of selectedDays) {
          const formData = new FormData();
          formData.append("day_of_week", String(day));
          formData.append("start_time", scheduleStartTime);
          formData.append("end_time", scheduleEndTime);
          formData.append("academy_name", selectedAcademy.name);
          formData.append("subject", scheduleSubject.trim());

          await addAcademySchedule(formData);
        }

        // í¼ ì´ˆê¸°í™”
        setSelectedDays([]);
        setScheduleStartTime("09:00");
        setScheduleEndTime("10:00");
        setScheduleSubject("");
        setIsAddingSchedule(false);

        await loadData();
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : "í•™ì› ì¼ì • ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        alert(errorMessage);
      }
    });
  };

  // í•™ì› ì¼ì • ìˆ˜ì • ì‹œì‘
  const handleStartEditSchedule = (schedule: AcademySchedule) => {
    setEditingScheduleId(schedule.id);
    setSelectedDays([schedule.day_of_week]);
    setScheduleStartTime(schedule.start_time);
    setScheduleEndTime(schedule.end_time);
    setScheduleSubject(schedule.subject || "");
    setIsAddingSchedule(false);
  };

  // í•™ì› ì¼ì • ìˆ˜ì •
  const handleUpdateSchedule = async () => {
    if (!editingScheduleId || selectedDays.length === 0 || !scheduleSubject.trim()) {
      alert("ìš”ì¼ê³¼ ê³¼ëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    if (scheduleStartTime >= scheduleEndTime) {
      alert("ì¢…ë£Œ ì‹œê°„ì€ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ëŠ¦ì–´ì•¼ í•©ë‹ˆë‹¤.");
      return;
    }

    const selectedAcademy = academies.find((a) => a.id === selectedAcademyId);
    if (!selectedAcademy) return;

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("schedule_id", editingScheduleId);
        formData.append("day_of_week", String(selectedDays[0])); // ìˆ˜ì • ì‹œì—ëŠ” ì²« ë²ˆì§¸ ìš”ì¼ë§Œ
        formData.append("start_time", scheduleStartTime);
        formData.append("end_time", scheduleEndTime);
        formData.append("academy_name", selectedAcademy.name);
        formData.append("subject", scheduleSubject.trim());

        await updateAcademySchedule(formData);

        // í¼ ì´ˆê¸°í™”
        setEditingScheduleId(null);
        setSelectedDays([]);
        setScheduleStartTime("09:00");
        setScheduleEndTime("10:00");
        setScheduleSubject("");

        await loadData();
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : "í•™ì› ì¼ì • ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        alert(errorMessage);
      }
    });
  };

  // í•™ì› ì¼ì • ì‚­ì œ
  const handleDeleteSchedule = async (scheduleId: string) => {
    if (!confirm("ì´ í•™ì› ì¼ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("schedule_id", scheduleId);

        await deleteAcademySchedule(formData);

        await loadData();
      } catch (error: unknown) {
        console.error("[AcademyScheduleManagement] í•™ì› ì¼ì • ì‚­ì œ ì‹¤íŒ¨", error);
        
        // ì—ëŸ¬ ë©”ì‹œì§€ ì¶”ì¶œ
        let errorMessage = "í•™ì› ì¼ì • ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        if (error instanceof Error) {
          errorMessage = error.message || errorMessage;
        } else if (error && typeof error === "object" && "message" in error) {
          errorMessage = String(error.message) || errorMessage;
        }
        
        alert(errorMessage);
      }
    });
  };

  // ìš”ì¼ ì„ íƒ í† ê¸€
  const toggleDay = (day: number) => {
    if (selectedDays.includes(day)) {
      setSelectedDays(selectedDays.filter((d) => d !== day));
    } else {
      setSelectedDays([...selectedDays, day]);
    }
  };

  const selectedAcademy = academies.find((a) => a.id === selectedAcademyId);
  const selectedAcademySchedules = selectedAcademy?.schedules ?? [];

  // ìš”ì¼ë³„ë¡œ ì¼ì • ê·¸ë£¹í™”
  const schedulesByDay = selectedAcademySchedules.reduce((acc, schedule) => {
    const day = schedule.day_of_week;
    if (!acc[day]) acc[day] = [];
    acc[day].push(schedule);
    return acc;
  }, {} as Record<number, AcademySchedule[]>);

  if (loading) {
    return (
      <div className="flex items-center justify-center p-12">
        <SuspenseFallback />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      <div className="rounded-lg border border-blue-200 bg-blue-50 p-4 text-sm text-blue-800">
        <div className="flex flex-col gap-1">
          <p className="font-medium">ğŸ“Œ í•™ì› ë‹¨ìœ„ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.</p>
          <p className="text-xs text-blue-700">
            í•™ì›ì„ ë“±ë¡í•˜ê³ , ê° í•™ì›ì— ëŒ€í•´ ìš”ì¼ë³„ ì¼ì •ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>
      </div>

      {/* ë¹ˆ ìƒíƒœ */}
      {academies.length === 0 && !isAddingAcademy && (
        <EmptyState
          title="ë“±ë¡ëœ í•™ì›ì´ ì—†ìŠµë‹ˆë‹¤"
          description="ë‹¤ë‹ˆëŠ” í•™ì›ì„ ì¶”ê°€í•˜ê³  ì¼ì •ì„ ê´€ë¦¬í•˜ì„¸ìš”."
          icon="ğŸ«"
        />
      )}

      {/* í•™ì› ëª©ë¡ ë° ê´€ë¦¬ */}
      {(academies.length > 0 || isAddingAcademy || editingAcademyId) && (
        <div className="rounded-lg border border-gray-200 bg-white p-6">
          <div className="flex flex-col gap-4">
            {academies.length > 0 && (
              <div>
                <h3 className="text-lg font-semibold text-gray-900">í•™ì› ëª©ë¡</h3>
              </div>
            )}

            {/* í•™ì› ì¶”ê°€/ìˆ˜ì • í¼ */}
            {(isAddingAcademy || editingAcademyId) && (
              <div className="rounded-lg border border-gray-200 bg-gray-50 p-4">
                <div className="flex flex-col gap-3">
                  <h4 className="text-sm font-semibold text-gray-900">
                    {editingAcademyId ? "í•™ì› ìˆ˜ì •" : "í•™ì› ì¶”ê°€"}
                  </h4>
                  <div className="grid gap-4 md:grid-cols-2">
                    <div className="flex flex-col gap-1">
                      <label className="block text-xs font-medium text-gray-700">
                        í•™ì› ì´ë¦„ <span className="text-red-500">*</span>
                      </label>
                <input
                  type="text"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                  placeholder="ì˜ˆ: ìˆ˜í•™ í•™ì›"
                  value={newAcademyName}
                  onChange={(e) => setNewAcademyName(e.target.value)}
                />
                    </div>
                    <div className="flex flex-col gap-1">
                      <label className="block text-xs font-medium text-gray-700">
                        ì´ë™ì‹œê°„ (ë¶„) <span className="text-red-500">*</span>
                      </label>
                <input
                  type="number"
                  min="0"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                  placeholder="60"
                  value={newAcademyTravelTime}
                  onChange={(e) => setNewAcademyTravelTime(e.target.value)}
                />
                    </div>
                  </div>
                  <div className="flex gap-2">
              <button
                type="button"
                onClick={editingAcademyId ? handleUpdateAcademy : handleAddAcademy}
                disabled={isPending || !newAcademyName.trim()}
                className="rounded-lg bg-gray-900 px-4 py-2 text-sm font-medium text-white hover:bg-gray-800 disabled:cursor-not-allowed disabled:bg-gray-400"
              >
                {isPending ? (editingAcademyId ? "ìˆ˜ì • ì¤‘..." : "ì¶”ê°€ ì¤‘...") : (editingAcademyId ? "ìˆ˜ì •" : "ì¶”ê°€")}
              </button>
              <button
                type="button"
                onClick={() => {
                  onAddRequest?.(); // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ìƒíƒœ í† ê¸€ ìš”ì²­
                  setEditingAcademyId(null);
                  setNewAcademyName("");
                  setNewAcademyTravelTime("60");
                }}
                disabled={isPending}
                className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50"
              >
                ì·¨ì†Œ
              </button>
                </div>
              </div>
              </div>
            )}

            {/* í•™ì› ëª©ë¡ */}
          {academies.length > 0 ? (
            <div className="flex flex-col gap-2">
            {academies.map((academy) => (
              <div
                key={academy.id}
                className={`flex items-center justify-between rounded-lg border px-4 py-3 ${
                  selectedAcademyId === academy.id
                    ? "border-gray-900 bg-gray-50"
                    : "border-gray-200 bg-white"
                }`}
              >
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <button
                      type="button"
                      onClick={() => setSelectedAcademyId(academy.id)}
                      className="text-sm font-medium text-gray-900 hover:text-gray-700"
                    >
                      {academy.name}
                    </button>
                    {selectedAcademyId === academy.id && (
                      <span className="text-xs text-gray-500">(ì„ íƒë¨)</span>
                    )}
                  </div>
                  <div className="text-xs text-gray-500">
                    ì´ë™ì‹œê°„: {academy.travel_time}ë¶„ | ì¼ì •: {academy.schedules.length}ê°œ
                  </div>
                </div>
                <div className="pl-4 flex gap-1">
                  <button
                    type="button"
                    onClick={() => handleStartEditAcademy(academy)}
                    disabled={isPending || editingAcademyId !== null}
                    className="rounded p-1 text-gray-600 hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50"
                    title="ìˆ˜ì •"
                  >
                    <Pencil className="h-4 w-4" />
                  </button>
                  <button
                    type="button"
                    onClick={() => handleDeleteAcademy(academy.id)}
                    disabled={isPending || editingAcademyId !== null}
                    className="rounded p-1 text-red-600 hover:bg-red-50 disabled:cursor-not-allowed disabled:opacity-50"
                    title="ì‚­ì œ"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>
            ))}
            </div>
          ) : (
            <p className="text-sm text-gray-500">ë“±ë¡ëœ í•™ì›ì´ ì—†ìŠµë‹ˆë‹¤. ìœ„ì—ì„œ í•™ì›ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.</p>
          )}

          {!selectedAcademy && academies.length > 0 && (
            <div className="rounded-lg border border-gray-200 bg-white p-6 text-center">
              <p className="text-sm text-gray-500">ìœ„ì—ì„œ í•™ì›ì„ ì„ íƒí•´ì£¼ì„¸ìš”.</p>
            </div>
          )}
          </div>
        </div>
      )}

      {/* ì„ íƒëœ í•™ì›ì˜ ì¼ì • ê´€ë¦¬ */}
      {selectedAcademy && (
        <div className="rounded-lg border border-gray-200 bg-white p-6">
          <div className="flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <div className="flex flex-col gap-1">
                <h3 className="text-lg font-semibold text-gray-900">{selectedAcademy.name}</h3>
                <p className="text-xs text-gray-500">ì´ë™ì‹œê°„: {selectedAcademy.travel_time}ë¶„</p>
              </div>
            {!isAddingSchedule && !editingScheduleId && (
              <button
                type="button"
                onClick={() => {
                  setIsAddingSchedule(true);
                  setEditingScheduleId(null);
                  setSelectedDays([]);
                  setScheduleStartTime("09:00");
                  setScheduleEndTime("10:00");
                  setScheduleSubject("");
                }}
                className="flex items-center gap-2 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                <Plus className="h-4 w-4" />
                ì¼ì • ì¶”ê°€
              </button>
            )}
            </div>

            {/* ì¼ì • ì¶”ê°€/ìˆ˜ì • í¼ */}
            {(isAddingSchedule || editingScheduleId) && (
              <div className="rounded-lg border border-gray-200 bg-gray-50 p-4">
                <div className="flex flex-col gap-3">
                  <h4 className="text-sm font-semibold text-gray-900">
                    {editingScheduleId ? "ì¼ì • ìˆ˜ì •" : "ì¼ì • ì¶”ê°€"}
                  </h4>
                  <div className="flex flex-col gap-4">
                    <div className="flex flex-col gap-2">
                      <label className="block text-xs font-medium text-gray-700">
                        ìš”ì¼ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥) <span className="text-red-500">*</span>
                      </label>
                  <div className="flex flex-wrap gap-2">
                    {weekdayLabels.map((label, index) => (
                      <button
                        key={index}
                        type="button"
                        onClick={() => toggleDay(index)}
                        className={`rounded-lg border px-3 py-1.5 text-xs font-medium transition-colors ${
                          selectedDays.includes(index)
                            ? "border-gray-900 bg-gray-900 text-white"
                            : "border-gray-300 bg-white text-gray-700 hover:bg-gray-50"
                        }`}
                      >
                        {label}
                      </button>
                    ))}
                    </div>
                  </div>
                  <div className="grid gap-4 md:grid-cols-3">
                    <div className="flex flex-col gap-1">
                      <label className="block text-xs font-medium text-gray-700">
                        ì‹œì‘ ì‹œê°„ <span className="text-red-500">*</span>
                      </label>
                    <input
                      type="time"
                      className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                      value={scheduleStartTime}
                      onChange={(e) => setScheduleStartTime(e.target.value)}
                    />
                    </div>
                    <div className="flex flex-col gap-1">
                      <label className="block text-xs font-medium text-gray-700">
                        ì¢…ë£Œ ì‹œê°„ <span className="text-red-500">*</span>
                      </label>
                    <input
                      type="time"
                      className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                      value={scheduleEndTime}
                      onChange={(e) => setScheduleEndTime(e.target.value)}
                    />
                    </div>
                    <div className="flex flex-col gap-1">
                      <label className="block text-xs font-medium text-gray-700">
                        ê³¼ëª© <span className="text-red-500">*</span>
                      </label>
                    <input
                      type="text"
                      className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                      placeholder="ì˜ˆ: ìˆ˜í•™"
                      value={scheduleSubject}
                      onChange={(e) => setScheduleSubject(e.target.value)}
                    />
                  </div>
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={editingScheduleId ? handleUpdateSchedule : handleAddSchedule}
                    disabled={
                      isPending ||
                      selectedDays.length === 0 ||
                      !scheduleSubject.trim() ||
                      scheduleStartTime >= scheduleEndTime
                    }
                    className="rounded-lg bg-gray-900 px-4 py-2 text-sm font-medium text-white hover:bg-gray-800 disabled:cursor-not-allowed disabled:bg-gray-400"
                  >
                    {isPending
                      ? editingScheduleId
                        ? "ìˆ˜ì • ì¤‘..."
                        : "ì¶”ê°€ ì¤‘..."
                      : editingScheduleId
                        ? "ìˆ˜ì •"
                        : "ì¶”ê°€"}
                  </button>
                  <button
                    type="button"
                    onClick={() => {
                      setIsAddingSchedule(false);
                      setEditingScheduleId(null);
                      setSelectedDays([]);
                      setScheduleStartTime("09:00");
                      setScheduleEndTime("10:00");
                      setScheduleSubject("");
                    }}
                    disabled={isPending}
                    className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50"
                  >
                    ì·¨ì†Œ
                  </button>
                </div>
              </div>
            </div>
            )}

          {/* ì¼ì • ëª©ë¡ (ìš”ì¼ë³„ ê·¸ë£¹í™”) */}
          {selectedAcademySchedules.length > 0 ? (
            <div className="flex flex-col gap-3">
              {Object.entries(schedulesByDay).map(([day, daySchedules]) => (
                <div key={day} className="rounded-lg border border-gray-200 bg-gray-50 p-4">
                  <div className="flex flex-col gap-2">
                    <h4 className="text-sm font-semibold text-gray-900">
                      {weekdayLabels[Number(day)]}
                    </h4>
                    <div className="flex flex-col gap-2">
                    {daySchedules.map((schedule) => (
                      <div
                        key={schedule.id}
                        className="flex items-center justify-between rounded border border-gray-200 bg-white px-3 py-2"
                      >
                        <div className="flex-1">
                          <div className="flex flex-col gap-1">
                            <div className="text-sm font-medium text-gray-900">
                              {schedule.start_time} ~ {schedule.end_time}
                            </div>
                            <div className="text-xs text-gray-500">
                              {schedule.subject}
                            </div>
                          </div>
                        </div>
                        <div className="pl-4 flex gap-1">
                          <button
                            type="button"
                            onClick={() => handleStartEditSchedule(schedule)}
                            disabled={isPending || editingScheduleId !== null}
                            className="rounded p-1 text-gray-600 hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50"
                            title="ìˆ˜ì •"
                          >
                            <Pencil className="h-4 w-4" />
                          </button>
                          <button
                            type="button"
                            onClick={() => handleDeleteSchedule(schedule.id)}
                            disabled={isPending || editingScheduleId !== null}
                            className="rounded p-1 text-red-600 hover:bg-red-50 disabled:cursor-not-allowed disabled:opacity-50"
                            title="ì‚­ì œ"
                          >
                            <Trash2 className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-sm text-gray-500">ë“±ë¡ëœ ì¼ì •ì´ ì—†ìŠµë‹ˆë‹¤. ìœ„ì—ì„œ ì¼ì •ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.</p>
          )}
        </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="_components/BlockForm.tsx">
"use client";

import { useState, useActionState, useEffect } from "react";
import { addBlock, addBlocksToMultipleDays } from "@/app/actions/blocks";

type BlockFormState = {
  error: string | null;
  success: boolean;
};

const initialState: BlockFormState = {
  error: null,
  success: false,
};

type BlockFormProps = {
  onClose?: () => void;
  blockSetId?: string | null;
  onBlockChange?: (setId: string) => void | Promise<void>;
};

export default function BlockForm({ onClose, blockSetId, onBlockChange }: BlockFormProps) {
  const [selectedWeekdays, setSelectedWeekdays] = useState<number[]>([]);
  const [startTime, setStartTime] = useState<string>("");
  const [endTime, setEndTime] = useState<string>("");

  const [state, formAction, isPending] = useActionState(
    async (
      _prev: BlockFormState,
      formData: FormData
    ): Promise<BlockFormState> => {
      try {
        // ì£¼ì¤‘ íŒ¨í„´ ì¼ê´„ ì¶”ê°€ ëª¨ë“œë§Œ ì‚¬ìš©
        const weekdayFormData = new FormData();
        weekdayFormData.append("target_days", selectedWeekdays.join(","));
        weekdayFormData.append("start_time", formData.get("start_time") as string);
        weekdayFormData.append("end_time", formData.get("end_time") as string);
        
        // íŠ¹ì • ì„¸íŠ¸ì— ì¶”ê°€í•˜ëŠ” ê²½ìš°
        if (blockSetId) {
          weekdayFormData.append("block_set_id", blockSetId);
        }

        await addBlocksToMultipleDays(weekdayFormData);
        return { error: null, success: true };
      } catch (err: any) {
        // INFO: ì ‘ë‘ì‚¬ê°€ ìˆëŠ” ë©”ì‹œì§€ëŠ” ë¶€ë¶„ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
        const message = err.message || String(err);
        if (message.startsWith("INFO: ")) {
          return { error: message.replace("INFO: ", ""), success: true };
        }
        return { error: message, success: false };
      }
    },
    initialState
  );

  const toggleWeekday = (day: number) => {
    setSelectedWeekdays((prev) =>
      prev.includes(day) ? prev.filter((d) => d !== day) : [...prev, day]
    );
  };

  // ì„±ê³µ ì‹œ í¼ ë¦¬ì…‹ ë° ë‹«ê¸°
  useEffect(() => {
    if (state.success) {
      setSelectedWeekdays([]);
      setStartTime("");
      setEndTime("");
      
      // í•´ë‹¹ ì„¸íŠ¸ì˜ ë¸”ë¡ë§Œ ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ ì„¸íŠ¸ëŠ” ì˜í–¥ ì—†ìŒ)
      if (blockSetId && onBlockChange) {
        onBlockChange(blockSetId);
      }
      
      // ì„±ê³µ í›„ 1.5ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹«ê¸°
      const timer = setTimeout(() => {
        if (onClose) {
          onClose();
        }
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [state.success, onClose, blockSetId, onBlockChange]);

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="flex flex-col gap-4 bg-white rounded-lg p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto shadow-lg">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-gray-900">
            ìƒˆ ì‹œê°„ ë¸”ë¡ ì¶”ê°€
          </h2>
          {onClose && (
            <button
              type="button"
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
              disabled={isPending}
            >
              <span className="text-2xl">Ã—</span>
            </button>
          )}
        </div>

        {state.error && !state.success && (
          <div className="p-3 text-sm text-red-700 bg-red-50 border border-red-200 rounded">
            {state.error}
          </div>
        )}

        {state.success && (
          <div className="p-3 text-sm text-green-700 bg-green-50 border border-green-200 rounded">
            {state.error && (state.error.includes("ìš”ì¼ì— ë¸”ë¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤") || state.error.includes("ìš”ì¼ì— ì´"))
              ? state.error // ë¶€ë¶„ ì„±ê³µ ì •ë³´ ë©”ì‹œì§€ í‘œì‹œ
              : "ì£¼ì¤‘ íŒ¨í„´ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."}
          </div>
        )}

        <form action={formAction} className="flex flex-col gap-4">
          <div className="flex flex-col gap-2">
            <label className="block text-sm font-medium text-gray-700">
              ì¶”ê°€í•  ìš”ì¼ ì„ íƒ
            </label>
            <div className="flex flex-wrap gap-2">
              {[
                { value: 0, label: "ì¼" },
                { value: 1, label: "ì›”" },
                { value: 2, label: "í™”" },
                { value: 3, label: "ìˆ˜" },
                { value: 4, label: "ëª©" },
                { value: 5, label: "ê¸ˆ" },
                { value: 6, label: "í† " },
              ].map((day) => (
                <button
                  key={day.value}
                  type="button"
                  onClick={() => toggleWeekday(day.value)}
                  className={`px-4 py-2 text-sm font-medium rounded-lg transition-colors ${
                    selectedWeekdays.includes(day.value)
                      ? "bg-indigo-600 text-white"
                      : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                  }`}
                >
                  {day.label}ìš”ì¼
                </button>
              ))}
            </div>
            {selectedWeekdays.length === 0 && (
              <p className="text-xs text-amber-600">
                ì¶”ê°€í•  ìš”ì¼ì„ ìµœì†Œ 1ê°œ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.
              </p>
            )}
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="flex flex-col gap-2">
              <label className="block text-sm font-medium text-gray-700">
                ì‹œì‘ ì‹œê°„
              </label>
              <input
                type="time"
                name="start_time"
                value={startTime}
                onChange={(e) => setStartTime(e.target.value)}
                className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                required
              />
            </div>

            <div className="flex flex-col gap-2">
              <label className="block text-sm font-medium text-gray-700">
                ì¢…ë£Œ ì‹œê°„
              </label>
              <input
                type="time"
                name="end_time"
                value={endTime}
                onChange={(e) => setEndTime(e.target.value)}
                className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                required
              />
            </div>
          </div>

          <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <p className="text-sm text-blue-800">
              ğŸ’¡ <strong>íŒ:</strong> ì„ íƒí•œ ìš”ì¼ë“¤ì— ë™ì¼í•œ ì‹œê°„ ë¸”ë¡ì´ ì¼ê´„ ì¶”ê°€ë©ë‹ˆë‹¤.
              <br />
              ì˜ˆ: ì›”, ìˆ˜, ê¸ˆ ì„ íƒ - ì˜¤ì „ 10ì‹œ ~ ì˜¤í›„ 7ì‹œ / í™”, ëª© ì„ íƒ - ì˜¤í›„ 3ì‹œ ~ ì˜¤í›„ 8ì‹œ
            </p>
          </div>

          <div className="flex gap-2">
            <button
              type="submit"
              disabled={
                isPending ||
                selectedWeekdays.length === 0 ||
                !startTime ||
                !endTime
              }
              className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg font-medium hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isPending ? "ì €ì¥ ì¤‘..." : "ì£¼ì¤‘ íŒ¨í„´ ì¼ê´„ ì¶”ê°€í•˜ê¸°"}
            </button>
            {onClose && (
              <button
                type="button"
                onClick={onClose}
                disabled={isPending}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg font-medium hover:bg-gray-300 transition-colors disabled:opacity-50"
              >
                ì·¨ì†Œ
              </button>
            )}
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="_components/BlockManagementContainer.tsx">
"use client";

import { useState, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Plus } from "lucide-react";
import { SectionHeader } from "@/components/ui/SectionHeader";
import BlockManagementTabs, { type ManagementTab } from "./BlockManagementTabs";
import type { PlanGroup } from "@/lib/types/plan";

type BlockManagementContainerProps = {
  studentId: string;
  initialBlockSets?: Array<{ id: string; name: string; blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }> }>;
  initialActiveSetId?: string | null;
  initialBlocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>;
  initialPlanGroups?: PlanGroup[];
};

export default function BlockManagementContainer({
  studentId,
  initialBlockSets = [],
  initialActiveSetId = null,
  initialBlocks = [],
  initialPlanGroups = [],
}: BlockManagementContainerProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const tabParam = searchParams?.get("tab");
  
  const [activeTab, setActiveTab] = useState<ManagementTab>(() => {
    if (tabParam === "exclusions") return "exclusions";
    if (tabParam === "academy") return "academy";
    return "blocks";
  });
  const [isCreatingBlockSet, setIsCreatingBlockSet] = useState(false);
  const [isAddingExclusion, setIsAddingExclusion] = useState(false);
  const [isAddingAcademy, setIsAddingAcademy] = useState(false);

  // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë³€ê²½ ì‹œ íƒ­ ì „í™˜
  useEffect(() => {
    if (tabParam === "exclusions") setActiveTab("exclusions");
    else if (tabParam === "academy") setActiveTab("academy");
    else if (tabParam === "blocks") setActiveTab("blocks");
  }, [tabParam]);

  // íƒ­ ë³€ê²½ ì‹œ URL ì—…ë°ì´íŠ¸
  const handleTabChange = (tab: ManagementTab) => {
    setActiveTab(tab);
    const params = new URLSearchParams(searchParams?.toString() || "");
    params.set("tab", tab);
    router.push(`/blocks?${params.toString()}`);
  };

  const handleBlockSetCreateRequest = () => {
    setIsCreatingBlockSet(!isCreatingBlockSet);
  };

  const handleExclusionAddRequest = () => {
    setIsAddingExclusion(!isAddingExclusion);
  };

  const handleAcademyAddRequest = () => {
    setIsAddingAcademy(!isAddingAcademy);
  };

  const getActionButton = () => {
    switch (activeTab) {
      case "blocks":
        if (initialBlockSets.length >= 5) return null;
        return (
          <button
            type="button"
            onClick={handleBlockSetCreateRequest}
            disabled={isCreatingBlockSet}
            className="inline-flex items-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:opacity-50"
          >
            <Plus className="h-4 w-4" />
            ìƒˆ ë¸”ë¡ ì„¸íŠ¸ ì¶”ê°€
          </button>
        );
      case "exclusions":
        return (
          <button
            type="button"
            onClick={handleExclusionAddRequest}
            disabled={isAddingExclusion}
            className="inline-flex items-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:opacity-50"
          >
            <Plus className="h-4 w-4" />
            ì œì™¸ì¼ ì¶”ê°€
          </button>
        );
      case "academy":
        return (
          <button
            type="button"
            onClick={handleAcademyAddRequest}
            disabled={isAddingAcademy}
            className="inline-flex items-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:cursor-not-allowed disabled:opacity-50"
          >
            <Plus className="h-4 w-4" />
            í•™ì› ì¶”ê°€
          </button>
        );
      default:
        return null;
    }
  };

  return (
    <div className="flex flex-col gap-6">
      <SectionHeader
        level="h1"
        title="ì‹œê°„ ë¸”ë¡ ê´€ë¦¬"
        description="ë¸”ë¡ ì„¸íŠ¸, í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì •ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
        action={getActionButton()}
      />

      <BlockManagementTabs
        studentId={studentId}
        initialBlockSets={initialBlockSets}
        initialActiveSetId={initialActiveSetId}
        initialBlocks={initialBlocks}
        initialPlanGroups={initialPlanGroups}
        activeTab={activeTab}
        onTabChange={handleTabChange}
        onBlockSetCreateRequest={handleBlockSetCreateRequest}
        onExclusionAddRequest={handleExclusionAddRequest}
        onAcademyAddRequest={handleAcademyAddRequest}
        isCreatingBlockSet={isCreatingBlockSet}
        isAddingExclusion={isAddingExclusion}
        isAddingAcademy={isAddingAcademy}
      />
    </div>
  );
}
</file>

<file path="_components/BlockManagementTabs.tsx">
"use client";

import BlockSetManagement from "./BlockSetManagement";
import ExclusionManagement from "./ExclusionManagement";
import AcademyScheduleManagement from "./AcademyScheduleManagement";
import type { PlanGroup } from "@/lib/types/plan";

export type ManagementTab = "blocks" | "exclusions" | "academy";

type BlockManagementTabsProps = {
  studentId: string;
  initialBlockSets?: Array<{ id: string; name: string; blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }> }>;
  initialActiveSetId?: string | null;
  initialBlocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>;
  initialPlanGroups?: PlanGroup[];
  activeTab: ManagementTab;
  onTabChange?: (tab: ManagementTab) => void;
  onBlockSetCreateRequest?: () => void;
  onExclusionAddRequest?: () => void;
  onAcademyAddRequest?: () => void;
  isCreatingBlockSet?: boolean;
  isAddingExclusion?: boolean;
  isAddingAcademy?: boolean;
};

export default function BlockManagementTabs({
  studentId,
  initialBlockSets = [],
  initialActiveSetId = null,
  initialBlocks = [],
  initialPlanGroups = [],
  activeTab,
  onTabChange,
  onBlockSetCreateRequest,
  onExclusionAddRequest,
  onAcademyAddRequest,
  isCreatingBlockSet = false,
  isAddingExclusion = false,
  isAddingAcademy = false,
}: BlockManagementTabsProps) {
  const handleTabChange = (tab: ManagementTab) => {
    onTabChange?.(tab);
  };

  return (
    <div className="flex flex-col gap-6">
      {/* íƒ­ ë©”ë‰´ */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex gap-4">
          <button
            type="button"
            onClick={() => handleTabChange("blocks")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "blocks"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            ë¸”ë¡ ì„¸íŠ¸
          </button>
          <button
            type="button"
            onClick={() => handleTabChange("exclusions")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "exclusions"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            í•™ìŠµ ì œì™¸ ì¼ì •
          </button>
          <button
            type="button"
            onClick={() => handleTabChange("academy")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "academy"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            í•™ì› ì¼ì •
          </button>
        </nav>
      </div>

      {/* íƒ­ ë‚´ìš© */}
      <div>
        {activeTab === "blocks" && (
          <BlockSetManagement
            studentId={studentId}
            initialBlockSets={initialBlockSets}
            initialActiveSetId={initialActiveSetId}
            initialBlocks={initialBlocks}
            onCreateSetRequest={onBlockSetCreateRequest}
            creating={isCreatingBlockSet}
          />
        )}
        {activeTab === "exclusions" && (
          <ExclusionManagement
            studentId={studentId}
            onAddRequest={onExclusionAddRequest}
            isAdding={isAddingExclusion}
          />
        )}
        {activeTab === "academy" && (
          <AcademyScheduleManagement
            studentId={studentId}
            onAddRequest={onAcademyAddRequest}
            isAddingAcademy={isAddingAcademy}
          />
        )}
      </div>
    </div>
  );
}
</file>

<file path="_components/BlockSetManagement.tsx">
"use client";

import { useEffect, useState, useCallback, useMemo } from "react";
import { useRouter } from "next/navigation";
import { supabase } from "@/lib/supabase/client";
import BlocksViewer from "./BlocksViewer";

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
  block_set_id: string | null;
  block_index?: number | null;
};

type BlockSet = {
  id: string;
  name: string;
  description: string | null;
  display_order: number;
  blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>;
};

type BlockSetManagementProps = {
  studentId: string;
  initialBlockSets?: Array<{ 
    id: string; 
    name: string; 
    description?: string | null;
    display_order?: number;
    blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }> 
  }>;
  initialActiveSetId?: string | null;
  initialBlocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>;
  onCreateSetRequest?: () => void;
  creating?: boolean;
};

export default function BlockSetManagement({
  studentId,
  initialBlockSets = [],
  initialActiveSetId = null,
  initialBlocks = [],
  onCreateSetRequest,
  creating = false,
}: BlockSetManagementProps) {
  const router = useRouter();
  const [blocks, setBlocks] = useState<Block[]>(initialBlocks);
  const [blockSets, setBlockSets] = useState<BlockSet[]>(initialBlockSets.map(set => ({
    id: set.id,
    name: set.name,
    description: ('description' in set ? set.description : null) ?? null,
    display_order: ('display_order' in set ? set.display_order : 0) ?? 0,
    blocks: set.blocks ?? [],
  })));
  const [activeSetId, setActiveSetId] = useState<string | null>(initialActiveSetId);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // íŠ¹ì • ì„¸íŠ¸ì˜ ë¸”ë¡ë§Œ ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ ì„¸íŠ¸ëŠ” ì˜í–¥ ì—†ìŒ)
  const updateSetBlocks = useCallback(async (setId: string) => {
    try {
      const { data: blocks, error } = await supabase
        .from("student_block_schedule")
        .select("id, day_of_week, start_time, end_time")
        .eq("block_set_id", setId)
        .eq("student_id", studentId)
        .order("day_of_week")
        .order("start_time");

      if (error) {
        console.error(`ì„¸íŠ¸ ${setId}ì˜ ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:`, error);
        return;
      }

      const setBlocks = (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [];

      // í•´ë‹¹ ì„¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ ì„¸íŠ¸ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€)
      setBlockSets((prevSets) =>
        prevSets.map((set) =>
          set.id === setId
            ? { ...set, blocks: setBlocks }
            : set // ë‹¤ë¥¸ ì„¸íŠ¸ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
        )
      );
    } catch (error) {
      console.error(`ì„¸íŠ¸ ${setId}ì˜ ë¸”ë¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:`, error);
    }
  }, [studentId]);

  // ì „ì²´ ë°ì´í„° ë¡œë“œ (ì„¸íŠ¸ ì¶”ê°€/ì‚­ì œ ì‹œì—ë§Œ ì‚¬ìš©)
  const loadData = useCallback(async (targetSetId?: string | null, skipLoadingState = false) => {
    try {
      if (!skipLoadingState) {
        setIsLoading(true);
        setError(null);
      }

      // targetSetIdê°€ ì œê³µë˜ë©´ ì¦‰ì‹œ ì‚¬ìš© (ì„œë²„ ì¡°íšŒ ìƒëµí•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ)
      const currentActiveSetId = targetSetId !== undefined ? targetSetId : null;

      // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ê³¼ ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡, ëª¨ë“  ë¸”ë¡ì„ ë³‘ë ¬ë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
      const [blocksResult, setsResult, allBlocksResult] = await Promise.all([
        // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë§Œ ì¡°íšŒ
        (() => {
          const query = supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time, block_set_id")
            .eq("student_id", studentId)
            .order("day_of_week")
            .order("start_time");
          
          if (currentActiveSetId) {
            query.eq("block_set_id", currentActiveSetId);
          }
          
          return query;
        })(),
        // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
        supabase
          .from("student_block_sets")
          .select("*")
          .eq("student_id", studentId)
          .order("display_order")
          .order("created_at"),
        // ëª¨ë“  ë¸”ë¡ ì¡°íšŒ (ì„¸íŠ¸ë³„ ê·¸ë£¹í™”ìš©)
        supabase
          .from("student_block_schedule")
          .select("id, day_of_week, start_time, end_time, block_set_id")
          .eq("student_id", studentId)
          .order("day_of_week")
          .order("start_time"),
      ]);

      const { data: blocksData, error: blocksError } = blocksResult;
      const { data: sets, error: setsError } = setsResult;
      const { data: allBlocks, error: allBlocksError } = allBlocksResult;
      
      if (blocksError) {
        throw new Error(`ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨: ${blocksError.message}`);
      }

      if (setsError) {
        throw new Error(`ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨: ${setsError.message}`);
      }

      if (allBlocksError) {
        console.warn("ì „ì²´ ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", allBlocksError);
      }

      // ë¸”ë¡ ë°ì´í„°ë¥¼ ë¨¼ì € ì—…ë°ì´íŠ¸í•˜ì—¬ ê¹œë¹¡ì„ ë°©ì§€
      const newBlocks = (blocksData as Block[]) ?? [];
      
      // ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì¦‰ì‹œ ìˆ˜í–‰
      setActiveSetId(currentActiveSetId);
      setBlocks(newBlocks);

      // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ì— ë¸”ë¡ ì •ë³´ ì¶”ê°€ (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ê·¸ë£¹í™”)
      const updatedSets = (sets as BlockSet[]) ?? [];
      const allBlocksArray = (allBlocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? [];

      // ê¸°ì¡´ ì„¸íŠ¸ì˜ ë¸”ë¡ ì •ë³´ë¥¼ ìœ ì§€í•˜ë©´ì„œ ì—…ë°ì´íŠ¸
      setBlockSets((prevSets) => {
        const setsWithBlocks = updatedSets.map((set) => {
          // ê¸°ì¡´ ì„¸íŠ¸ ì •ë³´ í™•ì¸
          const existingSet = prevSets.find(s => s.id === set.id);
          
          // í•´ë‹¹ ì„¸íŠ¸ì˜ ë¸”ë¡ ì¡°íšŒ
          const setBlocks = allBlocksArray
            .filter((block) => block.block_set_id === set.id)
            .map(({ id, day_of_week, start_time, end_time }) => ({
              id,
              day_of_week,
              start_time,
              end_time,
            }));

          // ê¸°ì¡´ ì„¸íŠ¸ê°€ ìˆê³  ë¸”ë¡ì´ ìˆìœ¼ë©´ ê¸°ì¡´ ë¸”ë¡ ìœ ì§€, ì—†ìœ¼ë©´ ìƒˆë¡œ ì¡°íšŒí•œ ë¸”ë¡ ì‚¬ìš©
          return {
            ...set,
            blocks: existingSet?.blocks && existingSet.blocks.length > 0 && setBlocks.length === 0
              ? existingSet.blocks // ê¸°ì¡´ ë¸”ë¡ ìœ ì§€ (ìƒˆë¡œ ì¡°íšŒí•œ ê²°ê³¼ê°€ ë¹„ì–´ìˆì„ ë•Œë§Œ)
              : setBlocks, // ìƒˆë¡œ ì¡°íšŒí•œ ë¸”ë¡ ì‚¬ìš©
          };
        });

        return setsWithBlocks;
      });
      
      // ì„±ê³µ ì‹œ ì—ëŸ¬ ìƒíƒœ ì´ˆê¸°í™”
      setError(null);
    } catch (error: any) {
      console.error("ë¸”ë¡ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
      
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ êµ¬ë¶„
      const isNetworkError = 
        error?.message?.includes("Failed to fetch") ||
        error?.message?.includes("NetworkError") ||
        error?.message?.includes("network") ||
        error?.code === "ECONNABORTED" ||
        error?.code === "ETIMEDOUT";
      
      const errorMessage = isNetworkError
        ? "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        : error?.message || "ë¸”ë¡ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
      
      setError(errorMessage);
    } finally {
      if (!skipLoadingState) {
        setIsLoading(false);
      }
    }
  }, [studentId]);

  // ì´ˆê¸° ë§ˆìš´íŠ¸ ì‹œì—ëŠ” ì„œë²„ì—ì„œ ë°›ì€ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ì¶”ê°€ ì¡°íšŒ ë¶ˆí•„ìš”
  // ë‹¨, ì„œë²„ ë°ì´í„°ì™€ í´ë¼ì´ì–¸íŠ¸ ë°ì´í„° ë™ê¸°í™”ë¥¼ ìœ„í•´ í•œ ë²ˆë§Œ í™•ì¸
  // loadDataëŠ” useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, ì˜ì¡´ì„±ì—ì„œ ì œê±°í•˜ê³ 
  // í•„ìš”í•œ ê°’ë§Œ ì˜ì¡´ì„±ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ë¬´í•œ ë£¨í”„ ë°©ì§€
  const initialBlocksLength = initialBlocks.length;
  const initialBlockSetsLength = initialBlockSets.length;
  
  useEffect(() => {
    // ì„œë²„ì—ì„œ ë°›ì€ initialBlocksê°€ ìˆìœ¼ë©´ ì¶”ê°€ ì¡°íšŒí•˜ì§€ ì•ŠìŒ
    // ì—†ê±°ë‚˜ ë°ì´í„°ê°€ ë¹„ì–´ìˆì„ ë•Œë§Œ ì¡°íšŒ
    if (initialBlocksLength === 0 && initialBlockSetsLength === 0) {
      loadData(undefined, true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialBlocksLength, initialBlockSetsLength]); // loadDataëŠ” ì•ˆì •ì ì´ë¯€ë¡œ ì˜ì¡´ì„±ì—ì„œ ì œì™¸

  // initialActiveSetIdê°€ ë³€ê²½ë˜ë©´ ìƒíƒœ ì—…ë°ì´íŠ¸ (íƒ­ ì „í™˜ í›„ ë³µê·€ ì‹œ)
  useEffect(() => {
    if (initialActiveSetId !== activeSetId) {
      setActiveSetId(initialActiveSetId);
      loadData(initialActiveSetId, true); // íƒ­ ì „í™˜ ì‹œì—ë„ ë¡œë”© ìƒíƒœ í‘œì‹œí•˜ì§€ ì•ŠìŒ
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialActiveSetId, activeSetId]); // loadDataëŠ” ì•ˆì •ì ì´ë¯€ë¡œ ì˜ì¡´ì„±ì—ì„œ ì œì™¸

  // initialBlockSetsì˜ ì„¸íŠ¸ ID ëª©ë¡ë§Œ ì¶”ì  (ì„¸íŠ¸ ì¶”ê°€/ì‚­ì œ ê°ì§€ìš©)
  const initialSetIds = useMemo(() => {
    return initialBlockSets.map(s => s.id).sort().join(',');
  }, [initialBlockSets]);

  const currentSetIds = useMemo(() => {
    return blockSets.map(s => s.id).sort().join(',');
  }, [blockSets]);

  // ì„¸íŠ¸ ì¶”ê°€/ì‚­ì œ ì‹œ ì²˜ë¦¬ (ì „ì²´ ë¦¬ë¡œë“œ ì—†ì´ í•„ìš”í•œ ì„¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸)
  useEffect(() => {
    if (initialSetIds !== currentSetIds) {
      const initialIdsArray = initialSetIds.split(',').filter(Boolean);
      const currentIdsArray = currentSetIds.split(',').filter(Boolean);
      
      // ìƒˆë¡œ ì¶”ê°€ëœ ì„¸íŠ¸ ID ì°¾ê¸°
      const newSetIds = initialIdsArray.filter(id => !currentIdsArray.includes(id));
      
      // ì‚­ì œëœ ì„¸íŠ¸ ID ì°¾ê¸°
      const deletedSetIds = currentIdsArray.filter(id => !initialIdsArray.includes(id));
      
      // ì‚­ì œëœ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´ ìƒíƒœì—ì„œ ì œê±°
      if (deletedSetIds.length > 0) {
        setBlockSets((prevSets) => prevSets.filter(set => !deletedSetIds.includes(set.id)));
      }
      
      // ìƒˆë¡œ ì¶”ê°€ëœ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì„¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ì„¸íŠ¸ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€)
      if (newSetIds.length > 0) {
        // ìƒˆë¡œ ì¶”ê°€ëœ ì„¸íŠ¸ë“¤ì˜ ë¸”ë¡ë§Œ ì¡°íšŒ
        Promise.all(newSetIds.map(setId => updateSetBlocks(setId))).then(() => {
          // ì„¸íŠ¸ ëª©ë¡ì€ ì„œë²„ì—ì„œ ë°›ì€ initialBlockSetsë¡œ ì—…ë°ì´íŠ¸
          const newSets = initialBlockSets
            .filter(set => newSetIds.includes(set.id))
            .map(set => ({
              id: set.id,
              name: set.name,
              description: ('description' in set ? set.description : null) ?? null,
              display_order: ('display_order' in set ? set.display_order : 0) ?? 0,
              blocks: set.blocks ?? [],
            }));
          
          setBlockSets((prevSets) => {
            // ê¸°ì¡´ ì„¸íŠ¸ëŠ” ìœ ì§€í•˜ê³  ìƒˆ ì„¸íŠ¸ë§Œ ì¶”ê°€
            const existingSetIds = prevSets.map(s => s.id);
            const setsToAdd = newSets.filter(s => !existingSetIds.includes(s.id));
            return [...prevSets, ...setsToAdd].sort((a, b) => 
              (a.display_order ?? 0) - (b.display_order ?? 0)
            );
          });
        });
      }
    }
  }, [initialSetIds, currentSetIds, initialBlockSets, updateSetBlocks]);

  const handleSetChange = async (setId: string | null) => {
    // ë¸”ë¡ ì„¸íŠ¸ ë³€ê²½ ì‹œ ì¦‰ì‹œ activeSetIdì™€ blocks ì´ˆê¸°í™”
    // ì´ë ‡ê²Œ í•˜ë©´ ì´ì „ ì„¸íŠ¸ì˜ ë¸”ë¡ì´ ê¹œë¹¡ì´ì§€ ì•ŠìŒ
    setActiveSetId(setId);
    setBlocks([]); // ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”í•˜ì—¬ í†µê³„ê°€ ì‚¬ë¼ì§€ë„ë¡
    
    // loadData í˜¸ì¶œ (ë¡œë”© ìƒíƒœ í‘œì‹œ)
    await loadData(setId, false);
  };

  return (
    <div>
      {/* ì—ëŸ¬ ë©”ì‹œì§€ */}
      {error && (
        <div className="flex flex-col gap-3 p-4 bg-red-50 border border-red-200 rounded-lg">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0">
              <span className="text-2xl">âš ï¸</span>
            </div>
            <div className="flex flex-col gap-1 flex-1">
              <h3 className="text-sm font-semibold text-red-800">
                ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨
              </h3>
              <p className="text-sm text-red-700">{error}</p>
              <button
                type="button"
                onClick={() => loadData(activeSetId)}
                className="text-sm text-red-700 hover:text-red-900 underline font-medium"
              >
                ë‹¤ì‹œ ì‹œë„
              </button>
            </div>
          </div>
        </div>
      )}

      {/* ë¸”ë¡ ë·°ì–´ - ëª©ë¡ í˜•íƒœë¡œ í‘œì‹œ */}
      <BlocksViewer 
        key={`viewer-${activeSetId || 'none'}-${blockSets.length}`}
        blocks={blocks} 
        blockSets={blockSets} 
        activeSetId={activeSetId}
        isLoading={isLoading}
        onCreateSetSuccess={async () => {
          // ì„¸íŠ¸ ì¶”ê°€ëŠ” useEffectì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
          // router.refresh()ê°€ í˜¸ì¶œë˜ë©´ initialBlockSetsê°€ ì—…ë°ì´íŠ¸ë˜ê³ 
          // useEffectê°€ ì´ë¥¼ ê°ì§€í•˜ì—¬ í•„ìš”í•œ ì„¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸í•¨
        }}
        onBlockChange={updateSetBlocks}
        existingSetCount={blockSets.length}
        onCreateSetRequest={onCreateSetRequest}
        creating={creating}
      />
    </div>
  );
}
</file>

<file path="_components/BlockSetTabs.tsx">
"use client";

import { useState, useActionState } from "react";
import { useRouter } from "next/navigation";
import {
  createBlockSet,
  updateBlockSet,
  deleteBlockSet,
  setActiveBlockSet,
  duplicateBlockSet,
} from "@/app/actions/blockSets";
import { validateFormData, blockSetSchema } from "@/lib/validation/schemas";

type BlockSet = {
  id: string;
  name: string;
  description: string | null;
  display_order: number;
};

type BlockSetTabsProps = {
  sets: BlockSet[];
  activeSetId: string | null;
  onSetChange?: (setId: string | null) => void;
};

const MAX_SETS = 5;

export default function BlockSetTabs({
  sets,
  activeSetId,
  onSetChange,
}: BlockSetTabsProps) {
  const router = useRouter();
  const [editingId, setEditingId] = useState<string | null>(null);
  const [creating, setCreating] = useState(false);
  const [duplicatingId, setDuplicatingId] = useState<string | null>(null);

  const handleSetActive = async (setId: string) => {
    try {
      const formData = new FormData();
      formData.append("id", setId);
      await setActiveBlockSet(formData);
      
      // onSetChange ì½œë°± í˜¸ì¶œí•˜ì—¬ ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì™„ë£Œ ëŒ€ê¸°)
      if (onSetChange) {
        await onSetChange(setId);
      }
      
      // í´ë¼ì´ì–¸íŠ¸ ìƒíƒœë¡œ ê´€ë¦¬í•˜ë¯€ë¡œ refresh ë¶ˆí•„ìš”
      // router.refresh();
    } catch (error: any) {
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ êµ¬ë¶„
      const isNetworkError = 
        error?.message?.includes("Failed to fetch") ||
        error?.message?.includes("NetworkError") ||
        error?.message?.includes("network") ||
        error?.code === "ECONNABORTED" ||
        error?.code === "ETIMEDOUT";
      
      const errorMessage = isNetworkError
        ? "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        : error?.message || "í™œì„± ì„¸íŠ¸ ì „í™˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
      
      alert(errorMessage);
    }
  };

  const handleDelete = async (setId: string, setName: string) => {
    if (!confirm(`"${setName}" ì„¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? í¬í•¨ëœ ëª¨ë“  ë¸”ë¡ë„ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.`)) {
      return;
    }

    try {
      const formData = new FormData();
      formData.append("id", setId);
      await deleteBlockSet(formData);
      
      router.refresh();
    } catch (error: any) {
      alert(error.message || "ì„¸íŠ¸ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  return (
    <div className="flex flex-col gap-4">
      {/* íƒ­ í—¤ë” */}
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-gray-900">ë¸”ë¡ ì„¸íŠ¸</h2>
        <button
          type="button"
          onClick={() => setCreating(true)}
          disabled={sets.length >= MAX_SETS || creating}
          className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          + ìƒˆ ì„¸íŠ¸ ì¶”ê°€
        </button>
      </div>

      {/* ì„¸íŠ¸ ìƒì„± í¼ */}
      {creating && (
        <BlockSetCreateForm
          onSuccess={() => {
            setCreating(false);
          }}
          onCancel={() => setCreating(false)}
          existingCount={sets.length}
        />
      )}

      {/* íƒ­ ëª©ë¡ */}
      <div className="flex flex-wrap gap-2">
        {sets.map((set) => (
          <div
            key={set.id}
            className={`group relative flex items-center gap-2 px-4 py-2 rounded-lg border-2 transition-all ${
              activeSetId === set.id
                ? "border-indigo-500 bg-indigo-50"
                : "border-gray-200 bg-white hover:border-gray-300"
            }`}
          >
            {editingId === set.id ? (
              <BlockSetEditForm
                set={set}
                onSuccess={() => setEditingId(null)}
                onCancel={() => setEditingId(null)}
              />
            ) : (
              <>
                <button
                  type="button"
                  onClick={() => handleSetActive(set.id)}
                  className="flex-1 text-left"
                >
                  <div className="flex flex-col gap-0.5">
                    <div className="font-medium text-gray-900">{set.name}</div>
                    {activeSetId === set.id && (
                      <div className="text-xs text-indigo-600">í™œì„±</div>
                    )}
                  </div>
                </button>
                <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                  <button
                    type="button"
                    onClick={() => setEditingId(set.id)}
                    className="p-1 text-gray-500 hover:text-gray-700"
                    title="ì´ë¦„ ìˆ˜ì •"
                  >
                    âœï¸
                  </button>
                  <button
                    type="button"
                    onClick={() => setDuplicatingId(set.id)}
                    className="p-1 text-gray-500 hover:text-gray-700"
                    title="ë³µì œ"
                  >
                    ğŸ“‹
                  </button>
                  {sets.length > 1 && (
                    <button
                      type="button"
                      onClick={() => handleDelete(set.id, set.name)}
                      className="p-1 text-red-500 hover:text-red-700"
                      title="ì‚­ì œ"
                    >
                      ğŸ—‘ï¸
                    </button>
                  )}
                </div>
              </>
            )}
          </div>
        ))}

        {duplicatingId && (
          <BlockSetDuplicateForm
            sourceSet={sets.find((s) => s.id === duplicatingId)!}
            onSuccess={() => setDuplicatingId(null)}
            onCancel={() => setDuplicatingId(null)}
            existingCount={sets.length}
          />
        )}
      </div>

      {sets.length === 0 && (
        <div className="p-4 bg-gray-50 border border-gray-200 rounded-lg text-center">
          <p className="text-sm text-gray-600">
            ë¸”ë¡ ì„¸íŠ¸ë¥¼ ìƒì„±í•˜ì—¬ ì‹œê°„ ë¸”ë¡ì„ ê´€ë¦¬í•˜ì„¸ìš”.
          </p>
        </div>
      )}
    </div>
  );
}

type BlockSetCreateFormProps = {
  onSuccess: () => void;
  onCancel: () => void;
  existingCount: number;
};

function BlockSetCreateForm({
  onSuccess,
  onCancel,
  existingCount,
}: BlockSetCreateFormProps) {
  const router = useRouter();
  const [state, formAction, isPending] = useActionState(
    async (_prev: { error: string | null }, formData: FormData) => {
      try {
        const validation = validateFormData(formData, blockSetSchema);
        if (!validation.success) {
          const firstError = validation.errors.issues[0];
          return { error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤." };
        }

        await createBlockSet(formData);
        router.refresh();
        onSuccess();
        return { error: null };
      } catch (err: any) {
        return { error: err.message || "ì„¸íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
      }
    },
    { error: null }
  );

  if (existingCount >= MAX_SETS) {
    return (
      <div className="p-3 bg-amber-50 border border-amber-200 rounded-lg">
        <p className="text-sm text-amber-800">
          ë¸”ë¡ ì„¸íŠ¸ëŠ” ìµœëŒ€ {MAX_SETS}ê°œê¹Œì§€ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </p>
      </div>
    );
  }

  return (
    <div className="p-4 bg-white border border-gray-200 rounded-lg">
      <form action={formAction} className="flex flex-col gap-3">
        {state.error && (
          <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{state.error}</p>
        )}

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700">ì„¸íŠ¸ ì´ë¦„</label>
          <input
            type="text"
            name="name"
            placeholder="ì˜ˆ: ì—¬ë¦„ë°©í•™ìš©"
            className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
            required
            maxLength={100}
          />
        </div>

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700">ì„¤ëª… (ì„ íƒ)</label>
          <textarea
            name="description"
            placeholder="ì„¸íŠ¸ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
            className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
            rows={2}
            maxLength={500}
          />
        </div>

        <div className="flex gap-2">
          <button
            type="submit"
            disabled={isPending}
            className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-indigo-700 transition-colors disabled:opacity-50"
          >
            {isPending ? "ìƒì„± ì¤‘..." : "ìƒì„±"}
          </button>
          <button
            type="button"
            onClick={onCancel}
            disabled={isPending}
            className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors disabled:opacity-50"
          >
            ì·¨ì†Œ
          </button>
        </div>
      </form>
    </div>
  );
}

type BlockSetEditFormProps = {
  set: BlockSet;
  onSuccess: () => void;
  onCancel: () => void;
};

function BlockSetEditForm({ set, onSuccess, onCancel }: BlockSetEditFormProps) {
  const router = useRouter();
  const [state, formAction, isPending] = useActionState(
    async (_prev: { error: string | null }, formData: FormData) => {
      try {
        formData.append("id", set.id);
        const validation = validateFormData(formData, blockSetSchema);
        if (!validation.success) {
          const firstError = validation.errors.issues[0];
          return { error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤." };
        }

        await updateBlockSet(formData);
        router.refresh();
        onSuccess();
        return { error: null };
      } catch (err: any) {
        return { error: err.message || "ì„¸íŠ¸ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
      }
    },
    { error: null }
  );

  return (
    <form action={formAction} className="flex items-center gap-2">
      {state.error && (
        <p className="text-xs text-red-600 bg-red-50 p-1 rounded">{state.error}</p>
      )}
      <input
        type="text"
        name="name"
        defaultValue={set.name}
        className="px-2 py-1 border border-gray-300 rounded text-sm flex-1"
        required
        maxLength={100}
      />
      <button
        type="submit"
        disabled={isPending}
        className="px-2 py-1 bg-indigo-600 text-white text-xs rounded hover:bg-indigo-700 disabled:opacity-50"
      >
        ì €ì¥
      </button>
      <button
        type="button"
        onClick={onCancel}
        disabled={isPending}
        className="px-2 py-1 bg-gray-200 text-gray-700 text-xs rounded hover:bg-gray-300 disabled:opacity-50"
      >
        ì·¨ì†Œ
      </button>
    </form>
  );
}

type BlockSetDuplicateFormProps = {
  sourceSet: BlockSet;
  onSuccess: () => void;
  onCancel: () => void;
  existingCount: number;
};

function BlockSetDuplicateForm({
  sourceSet,
  onSuccess,
  onCancel,
  existingCount,
}: BlockSetDuplicateFormProps) {
  const router = useRouter();
  const [state, formAction, isPending] = useActionState(
    async (_prev: { error: string | null }, formData: FormData) => {
      try {
        formData.append("source_id", sourceSet.id);
        const validation = validateFormData(formData, blockSetSchema);
        if (!validation.success) {
          const firstError = validation.errors.issues[0];
          return { error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤." };
        }

        await duplicateBlockSet(formData);
        router.refresh();
        onSuccess();
        return { error: null };
      } catch (err: any) {
        return { error: err.message || "ì„¸íŠ¸ ë³µì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
      }
    },
    { error: null }
  );

  if (existingCount >= MAX_SETS) {
    return (
      <div className="p-3 bg-amber-50 border border-amber-200 rounded-lg">
        <p className="text-sm text-amber-800">
          ë¸”ë¡ ì„¸íŠ¸ëŠ” ìµœëŒ€ {MAX_SETS}ê°œê¹Œì§€ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </p>
      </div>
    );
  }

  return (
    <div className="p-4 bg-white border border-blue-200 rounded-lg">
      <form action={formAction} className="flex flex-col gap-3">
        {state.error && (
          <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{state.error}</p>
        )}

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700">ìƒˆ ì„¸íŠ¸ ì´ë¦„</label>
          <input
            type="text"
            name="name"
            placeholder={`${sourceSet.name} ë³µì‚¬ë³¸`}
            className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
            required
            maxLength={100}
          />
          <p className="text-xs text-gray-500">
            ì›ë³¸: {sourceSet.name}
          </p>
        </div>

        <div className="flex gap-2">
          <button
            type="submit"
            disabled={isPending}
            className="flex-1 bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors disabled:opacity-50"
          >
            {isPending ? "ë³µì œ ì¤‘..." : "ë³µì œ"}
          </button>
          <button
            type="button"
            onClick={onCancel}
            disabled={isPending}
            className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors disabled:opacity-50"
          >
            ì·¨ì†Œ
          </button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="_components/BlockStatistics.tsx">
"use client";

import { useMemo } from "react";
import { calculateDayDistribution, calculateBlockStatistics } from "@/lib/blocks/statistics";
import { EmptyState } from "@/components/ui/EmptyState";
import ProgressBar from "@/components/atoms/ProgressBar";
import { Card, CardContent } from "@/components/molecules/Card";

type Block = {
  day_of_week: number;
  start_time: string;
  end_time: string;
};

type BlockStatisticsProps = {
  blocks: Block[];
};

export default function BlockStatistics({ blocks }: BlockStatisticsProps) {
  // ê³„ì‚° ê²°ê³¼ë¥¼ ë©”ëª¨ì´ì œì´ì…˜í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì¬ê³„ì‚° ë°©ì§€
  const { dayDistribution, statistics } = useMemo(() => {
    if (blocks.length === 0) {
      return {
        dayDistribution: null,
        statistics: null,
      };
    }

    return {
      dayDistribution: calculateDayDistribution(blocks),
      statistics: calculateBlockStatistics(blocks),
    };
  }, [blocks]);

  if (blocks.length === 0 || !statistics || !dayDistribution) {
    return (
      <EmptyState
        icon="ğŸ“Š"
        title="í†µê³„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"
        description="ì‹œê°„ ë¸”ë¡ì„ ì¶”ê°€í•˜ë©´ í†µê³„ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
      />
    );
  }

  return (
    <div className="flex flex-col gap-6">
      {/* í†µê³„ ìš”ì•½ ì¹´ë“œ */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card padding="sm">
          <CardContent className="flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì´ ë¸”ë¡ ìˆ˜</div>
            <div className="text-h2 text-text-primary">
              {statistics.totalBlocks}ê°œ
            </div>
          </CardContent>
        </Card>
        <Card padding="sm">
          <CardContent className="flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">ì£¼ê°„ ì´ í•™ìŠµ ì‹œê°„</div>
            <div className="text-h2 text-text-primary">
              {statistics.totalHours}ì‹œê°„ {statistics.remainingMinutes}ë¶„
            </div>
          </CardContent>
        </Card>
        <Card padding="sm">
          <CardContent className="flex flex-col gap-1">
            <div className="text-body-2 text-text-secondary">í‰ê·  ë¸”ë¡ ê¸¸ì´</div>
            <div className="text-h2 text-text-primary">
              {Math.floor(statistics.averageBlockDuration / 60)}ì‹œê°„{" "}
              {statistics.averageBlockDuration % 60}ë¶„
            </div>
          </CardContent>
        </Card>
      </div>

      {/* ìš”ì¼ë³„ í•™ìŠµ ì‹œê°„ ë¶„í¬ */}
      <Card padding="md">
        <CardContent className="flex flex-col gap-4">
        <h3 className="text-h2 text-text-primary">
          ìš”ì¼ë³„ í•™ìŠµ ì‹œê°„ ë¶„í¬
        </h3>
        <div className="flex flex-col gap-3">
          {dayDistribution.distribution.map((day) => (
            <div key={day.dayIndex} className="flex items-center gap-4">
              <div className="w-12 text-body-2 text-text-secondary">
                {day.day}ìš”ì¼
              </div>
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <div className="flex-1">
                    <ProgressBar
                      value={(day.minutes / dayDistribution.maxMinutes) * 100}
                      color="indigo"
                      height="md"
                    />
                  </div>
                  <div className="w-20 text-body-2 text-text-secondary text-right">
                    {day.hours}ì‹œê°„ {day.remainingMinutes}ë¶„
                  </div>
                  <div className="w-12 text-body-2 text-text-tertiary text-right">
                    ({day.blockCount}ê°œ)
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
        </CardContent>
      </Card>

    </div>
  );
}
</file>

<file path="_components/BlocksViewer.tsx">
"use client";

import { useMemo, useState, useActionState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import BlockForm from "./BlockForm";
import { createBlockSet } from "@/app/actions/blockSets";
import { validateFormData, blockSetSchema } from "@/lib/validation/schemas";
import { EmptyState } from "@/components/ui/EmptyState";

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
  block_index?: number | null;
};

type BlockSet = {
  id: string;
  name: string;
  description?: string | null;
  display_order?: number;
  blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>;
};

type BlocksViewerProps = {
  blocks: Block[];
  blockSets: BlockSet[];
  activeSetId: string | null;
  isLoading?: boolean;
  onCreateSetSuccess?: () => void;
  onBlockChange?: (setId: string) => Promise<void>;
  existingSetCount?: number;
  onCreateSetRequest?: () => void;
  creating?: boolean;
};

const DAYS = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

export default function BlocksViewer({
  blocks,
  blockSets,
  activeSetId,
  isLoading = false,
  onCreateSetSuccess,
  onBlockChange,
  existingSetCount = 0,
  onCreateSetRequest,
  creating = false,
}: BlocksViewerProps) {
  const router = useRouter();
  
  // ê° ë¸”ë¡ ì„¸íŠ¸ë³„ ì´ ì‹œê°„ ê³„ì‚°
  const blockSetsWithStats = useMemo(() => {
    return blockSets.map((set) => {
      const setBlocks = set.blocks ?? [];
      const totalMinutes = setBlocks.reduce((acc, block) => {
        const [startH, startM] = (block.start_time ?? "00:00").split(":").map(Number);
        const [endH, endM] = (block.end_time ?? "00:00").split(":").map(Number);
        const start = startH * 60 + startM;
        const end = endH * 60 + endM;
        const duration = end - start;
        return acc + (duration > 0 ? duration : 0);
      }, 0);

      const totalHours = Math.floor(totalMinutes / 60);
      const remainingMinutes = Math.max(0, totalMinutes % 60);

      // ìš”ì¼ë³„ ë¸”ë¡ ê°œìˆ˜ ê³„ì‚°
      const dayDistribution = setBlocks.reduce((acc, block) => {
        const day = DAYS[block.day_of_week] ?? "";
        acc[day] = (acc[day] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      return {
        ...set,
        blockCount: setBlocks.length,
        totalHours,
        remainingMinutes,
        dayDistribution,
      };
    });
  }, [blockSets]);

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {[1, 2, 3].map((i) => (
          <div key={i} className="flex flex-col gap-4 bg-white border border-gray-200 rounded-lg p-6 animate-pulse">
            <div className="h-6 bg-gray-200 rounded w-3/4"></div>
            <div className="flex flex-col gap-2">
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <>

      {/* ìƒˆ ì„¸íŠ¸ ì¶”ê°€ í¼ (ëª¨ë‹¬) */}
      {creating && (
        <BlockSetCreateForm
          onSuccess={async (newSetId?: string) => {
            onCreateSetRequest?.(); // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— creating ìƒíƒœ í•´ì œ ìš”ì²­
            // ìƒˆ ì„¸íŠ¸ê°€ ìƒì„±ë˜ê³  ë¸”ë¡ì´ ì¶”ê°€ëœ ê²½ìš°, í•´ë‹¹ ì„¸íŠ¸ë§Œ ì—…ë°ì´íŠ¸
            if (newSetId && onBlockChange) {
              await onBlockChange(newSetId);
            }
            // ë°ì´í„° ìƒˆë¡œê³ ì¹¨ì„ ìœ„í•´ ì½œë°± ë¨¼ì € í˜¸ì¶œ (loadData ì™„ë£Œ ëŒ€ê¸°)
            if (onCreateSetSuccess) {
              await onCreateSetSuccess();
            }
            // loadData ì™„ë£Œ í›„ ì„œë²„ ì»´í¬ë„ŒíŠ¸ ìƒˆë¡œê³ ì¹¨
            router.refresh();
          }}
          onCancel={() => onCreateSetRequest?.()} // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— creating ìƒíƒœ í•´ì œ ìš”ì²­
          existingCount={existingSetCount}
        />
      )}

      {/* ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ */}
      {blockSetsWithStats.length > 0 ? (
        <div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {blockSetsWithStats.map((set) => (
              <div
                key={set.id}
                className={`bg-white border-2 rounded-lg p-6 transition-all hover:shadow-md flex flex-col gap-4 ${
                  activeSetId === set.id
                    ? "border-indigo-500 bg-indigo-50"
                    : "border-gray-200 hover:border-gray-300"
                }`}
              >
                {/* í—¤ë” */}
                <div className="flex items-start justify-between">
                  <div className="flex flex-1 flex-col gap-1">
                    <h3 className="text-lg font-semibold text-gray-900">{set.name}</h3>
                    {activeSetId === set.id && (
                      <span className="inline-block px-2 py-1 text-xs font-medium text-indigo-700 bg-indigo-100 rounded">
                        í™œì„±
                      </span>
                    )}
                  </div>
                  <button
                    type="button"
                    onClick={async (e) => {
                      e.stopPropagation();
                      if (!confirm(`"${set.name}" ì„¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? í¬í•¨ëœ ëª¨ë“  ë¸”ë¡ë„ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.`)) {
                        return;
                      }
                      try {
                        const { deleteBlockSet } = await import("@/app/actions/blockSets");
                        const formData = new FormData();
                        formData.append("id", set.id);
                        await deleteBlockSet(formData);
                        // ë°ì´í„° ìƒˆë¡œê³ ì¹¨ì„ ìœ„í•´ ì½œë°± ë¨¼ì € í˜¸ì¶œ (loadData ì™„ë£Œ ëŒ€ê¸°)
                        if (onCreateSetSuccess) {
                          await onCreateSetSuccess();
                        }
                        // ì„œë²„ ì»´í¬ë„ŒíŠ¸ ìƒˆë¡œê³ ì¹¨ì€ loadData ì™„ë£Œ í›„
                        router.refresh();
                      } catch (error: any) {
                        alert(error.message || "ì„¸íŠ¸ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                      }
                    }}
                    className="p-2 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
                    title="ì„¸íŠ¸ ì‚­ì œ"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      className="h-5 w-5"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                      />
                    </svg>
                  </button>
                </div>

                {/* ì„¤ëª… */}
                {set.description && (
                  <p className="text-sm text-gray-600">{set.description}</p>
                )}

                {/* í†µê³„ ì •ë³´ */}
                <div className="flex flex-col gap-2 flex-1">
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-gray-600">ë¸”ë¡ ê°œìˆ˜</span>
                    <span className="font-medium text-gray-900">{set.blockCount}ê°œ</span>
                  </div>
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-gray-600">ì£¼ê°„ ì´ ì‹œê°„</span>
                    <span className="font-medium text-gray-900">
                      {set.totalHours}ì‹œê°„ {set.remainingMinutes}ë¶„
                    </span>
                  </div>
                  {set.blockCount > 0 && (
                    <div className="flex flex-col gap-1 pt-2 border-t border-gray-200">
                      <div className="text-xs text-gray-500">ìš”ì¼ë³„ ë¸”ë¡</div>
                      <div className="flex flex-wrap gap-1">
                        {Object.entries(set.dayDistribution).map(([day, count]) => (
                          <span
                            key={day}
                            className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded"
                          >
                            {day} {count}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>

                {/* ìƒì„¸ ë³´ê¸° ë²„íŠ¼ - í•˜ë‹¨ ê³ ì • */}
                <Link
                  href={`/blocks/${set.id}`}
                  className="block w-full text-center px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition-colors mt-auto"
                >
                  ìƒì„¸ ë³´ê¸°
                </Link>
              </div>
            ))}
          </div>
        </div>
      ) : (
        <EmptyState
          title="ë“±ë¡ëœ ë¸”ë¡ ì„¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤"
          description="ìƒˆ ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬ í•™ìŠµ ì‹œê°„ì„ ê´€ë¦¬í•˜ì„¸ìš”."
          icon="ğŸ“…"
        />
      )}
    </>
  );
}

// BlockSetCreateForm ì»´í¬ë„ŒíŠ¸ (ì„¸íŠ¸ + ì‹œê°„ ë¸”ë¡ í•¨ê»˜ ì…ë ¥)
function BlockSetCreateForm({
  onSuccess,
  onCancel,
  existingCount,
}: {
  onSuccess: (newSetId?: string) => void | Promise<void>;
  onCancel: () => void;
  existingCount: number;
}) {
  const router = useRouter();
  const [selectedWeekdays, setSelectedWeekdays] = useState<number[]>([]);
  const [startTime, setStartTime] = useState<string>("");
  const [endTime, setEndTime] = useState<string>("");
  
  const [state, formAction, isPending] = useActionState(
    async (_prev: { error: string | null }, formData: FormData) => {
      try {
        // ì„¸íŠ¸ ìƒì„±
        const validation = validateFormData(formData, blockSetSchema);
        if (!validation.success) {
          const firstError = validation.errors.issues[0];
          return { error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤." };
        }

        const result = await createBlockSet(formData);
        
        // ì‹œê°„ ë¸”ë¡ì´ ì…ë ¥ëœ ê²½ìš° ì¶”ê°€
        if (selectedWeekdays.length > 0 && startTime && endTime) {
          const { addBlocksToMultipleDays } = await import("@/app/actions/blocks");
          const blockFormData = new FormData();
          blockFormData.append("target_days", selectedWeekdays.join(","));
          blockFormData.append("start_time", startTime);
          blockFormData.append("end_time", endTime);
          blockFormData.append("block_set_id", result.blockSetId);
          
          try {
            await addBlocksToMultipleDays(blockFormData);
          } catch (blockError: any) {
            // ë¸”ë¡ ì¶”ê°€ ì‹¤íŒ¨í•´ë„ ì„¸íŠ¸ëŠ” ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
            console.warn("ë¸”ë¡ ì¶”ê°€ ì‹¤íŒ¨:", blockError);
          }
        }
        
        router.refresh();
        onSuccess(result.blockSetId);
        return { error: null };
      } catch (err: any) {
        return { error: err.message || "ì„¸íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
      }
    },
    { error: null }
  );

  const toggleWeekday = (day: number) => {
    setSelectedWeekdays((prev) =>
      prev.includes(day) ? prev.filter((d) => d !== day) : [...prev, day]
    );
  };

  if (existingCount >= 5) {
    return null;
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="flex flex-col gap-4 bg-white rounded-lg p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto shadow-lg">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">ìƒˆ ë¸”ë¡ ì„¸íŠ¸ ì¶”ê°€</h3>
          <button
            type="button"
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600 transition-colors"
            disabled={isPending}
          >
            <span className="text-2xl">Ã—</span>
          </button>
        </div>
        
        <form action={formAction} className="flex flex-col gap-4">
          {state.error && (
            <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{state.error}</p>
          )}

          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-gray-700">ì„¸íŠ¸ ì´ë¦„</label>
            <input
              type="text"
              name="name"
              placeholder="ì˜ˆ: ì—¬ë¦„ë°©í•™ìš©"
              className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
              required
              maxLength={100}
            />
          </div>

          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-gray-700">ì„¤ëª… (ì„ íƒ)</label>
            <textarea
              name="description"
              placeholder="ì„¸íŠ¸ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
              className="px-3 py-2 border border-gray-300 rounded-lg text-sm"
              rows={2}
              maxLength={500}
            />
          </div>

          <div className="flex flex-col gap-3 border-t border-gray-200 pt-4">
            <h4 className="text-sm font-medium text-gray-700">ì‹œê°„ ë¸”ë¡ ì¶”ê°€ (ì„ íƒ)</h4>
            
            <div className="flex flex-col gap-2">
              <label className="text-sm font-medium text-gray-700">ì¶”ê°€í•  ìš”ì¼ ì„ íƒ</label>
              <div className="flex flex-wrap gap-2">
                {[
                  { value: 0, label: "ì¼" },
                  { value: 1, label: "ì›”" },
                  { value: 2, label: "í™”" },
                  { value: 3, label: "ìˆ˜" },
                  { value: 4, label: "ëª©" },
                  { value: 5, label: "ê¸ˆ" },
                  { value: 6, label: "í† " },
                ].map((day) => (
                  <button
                    key={day.value}
                    type="button"
                    onClick={() => toggleWeekday(day.value)}
                    className={`px-4 py-2 text-sm font-medium rounded-lg transition-colors ${
                      selectedWeekdays.includes(day.value)
                        ? "bg-indigo-600 text-white"
                        : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                    }`}
                  >
                    {day.label}ìš”ì¼
                  </button>
                ))}
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="flex flex-col gap-2">
                <label className="text-sm font-medium text-gray-700">ì‹œì‘ ì‹œê°„</label>
                <input
                  type="time"
                  value={startTime}
                  onChange={(e) => setStartTime(e.target.value)}
                  className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                />
              </div>

              <div className="flex flex-col gap-2">
                <label className="text-sm font-medium text-gray-700">ì¢…ë£Œ ì‹œê°„</label>
                <input
                  type="time"
                  value={endTime}
                  onChange={(e) => setEndTime(e.target.value)}
                  className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                />
              </div>
            </div>
          </div>

          <div className="flex gap-2">
            <button
              type="submit"
              disabled={isPending}
              className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-indigo-700 transition-colors disabled:opacity-50"
            >
              {isPending ? "ìƒì„± ì¤‘..." : "ìƒì„±"}
            </button>
            <button
              type="button"
              onClick={onCancel}
              disabled={isPending}
              className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors disabled:opacity-50"
            >
              ì·¨ì†Œ
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="_components/BlockTimeline.tsx">
"use client";

import { useMemo } from "react";
import { calculateAutoTimeRange } from "@/lib/blocks/timeRange";
import { EmptyState } from "@/components/ui/EmptyState";
import { createHeightPxStyle, createBlockStyle } from "@/lib/utils/cssVariables";

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
  block_index?: number | null;
};

type BlockTimelineProps = {
  blocks: Block[];
};

const DAYS = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

/**
 * ì‹œê°„ ë¬¸ìì—´ì„ ë¶„ ë‹¨ìœ„ë¡œ ë³€í™˜
 */
function timeToMinutes(time: string): number {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
}

/**
 * ë¸”ë¡ì˜ ìœ„ì¹˜ì™€ ë†’ì´ ê³„ì‚° (ì‹œê°„ ë²”ìœ„ ê¸°ì¤€)
 */
function calculateBlockPosition(
  block: Block,
  timeRangeStartHour: number,
  hourHeight: number
) {
  const startMinutes = timeToMinutes(block.start_time);
  const endMinutes = timeToMinutes(block.end_time);
  
  // ì‹œê°„ ë²”ìœ„ì˜ ì‹œì‘ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ì  ìœ„ì¹˜ ê³„ì‚°
  const rangeStartMinutes = timeRangeStartHour * 60;
  
  // ë¸”ë¡ì˜ ì‹œì‘ ì‹œê°„ì´ ë²”ìœ„ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì•ì— ìˆìœ¼ë©´ 0ë¶€í„° ì‹œì‘
  const relativeStart = Math.max(0, startMinutes - rangeStartMinutes);
  const relativeEnd = Math.max(0, endMinutes - rangeStartMinutes);
  
  const top = (relativeStart / 60) * hourHeight;
  const height = ((relativeEnd - relativeStart) / 60) * hourHeight;
  
  return { top, height };
}

export default function BlockTimeline({ blocks }: BlockTimelineProps) {
  // ë¸”ë¡ì´ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœ í‘œì‹œ
  if (blocks.length === 0) {
    return (
      <EmptyState
        icon="ğŸ“…"
        title="íƒ€ì„í…Œì´ë¸” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"
        description="ì‹œê°„ ë¸”ë¡ì„ ì¶”ê°€í•˜ë©´ ì£¼ê°„ íƒ€ì„í…Œì´ë¸”ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
      />
    );
  }

  // ì‹œê°„ ì˜ì—­ ê³„ì‚° (ìë™ ëª¨ë“œë§Œ ì‚¬ìš©)
  const autoTimeRange = useMemo(() => calculateAutoTimeRange(blocks), [blocks]);
  const timeRange = autoTimeRange;
  
  const HOURS = timeRange.hours;
  const hourHeight = 80; // 1ì‹œê°„ = 80px

  const blocksByDay = useMemo(
    () => DAYS.map((_, dayIndex) => blocks.filter((b) => b.day_of_week === dayIndex)),
    [blocks]
  );

  return (
    <div className="w-full">
      <div className="w-full overflow-x-auto">
        <div className="min-w-[800px]">
          {/* ì‹œê°„ ì¶• */}
          <div className="flex border-b border-gray-200">
            <div className="w-20 flex-shrink-0 p-2 text-xs font-medium text-gray-500">
              ì‹œê°„
            </div>
            {DAYS.map((day) => (
              <div
                key={day}
                className="flex-1 p-2 text-center text-sm font-medium text-gray-700 border-l border-gray-200"
              >
                {day}ìš”ì¼
              </div>
            ))}
          </div>

          {/* íƒ€ì„ë¼ì¸ ê·¸ë¦¬ë“œ */}
          <div className="relative border-b border-gray-200">
            {/* ì‹œê°„ ë¼ì¸ */}
            <div className="flex">
              <div className="w-20 flex-shrink-0">
                {HOURS.map((hour) => (
                  <div
                    key={hour}
                    className="border-t border-gray-100 flex items-start justify-end pr-2 pt-1"
                    style={createHeightPxStyle(hourHeight)}
                  >
                    <span className="text-xs text-gray-400">{hour}ì‹œ</span>
                  </div>
                ))}
              </div>

              {/* ìš”ì¼ë³„ ì»¬ëŸ¼ */}
              {blocksByDay.map((dayBlocks, dayIndex) => (
                <div
                  key={dayIndex}
                  className="flex-1 relative border-l border-gray-200"
                >
                  {/* ì‹œê°„ ìŠ¬ë¡¯ */}
                  <div
                    className="relative"
                    style={createHeightPxStyle(HOURS.length * hourHeight)}
                  >
                    {HOURS.map((hour) => (
                      <div
                        key={hour}
                        className="border-t border-gray-100"
                        style={createHeightPxStyle(hourHeight)}
                        aria-hidden="true"
                      />
                    ))}

                    {/* ë¸”ë¡ë“¤ (ì½ê¸° ì „ìš©) */}
                    {dayBlocks.map((block) => {
                      const { top, height } = calculateBlockPosition(
                        block,
                        timeRange.startHour,
                        hourHeight
                      );
                      
                      // ì‹œê°„ ë²”ìœ„ ë°–ì˜ ë¸”ë¡ì€ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                      const blockStartHour = Math.floor(timeToMinutes(block.start_time) / 60);
                      const blockEndHour = Math.ceil(timeToMinutes(block.end_time) / 60);
                      if (blockEndHour < timeRange.startHour || blockStartHour > timeRange.endHour) {
                        return null;
                      }

                      // ë¸”ë¡ ê¸¸ì´ ê³„ì‚° (ë¶„ ë‹¨ìœ„)
                      const blockDurationMinutes = Math.round((height / hourHeight) * 60);

                      return (
                        <div
                          key={block.id}
                          className="absolute left-1 right-1 rounded-lg bg-indigo-100 border border-indigo-300 p-2"
                          style={createBlockStyle(top, height, "40px")}
                        >
                          <div className="flex flex-col gap-1 h-full">
                            <span className="text-xs font-medium text-indigo-900">
                              {block.start_time} ~ {block.end_time}
                            </span>
                            <span className="text-xs text-indigo-700">
                              {blockDurationMinutes}ë¶„
                            </span>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="_components/ExclusionManagement.tsx">
"use client";

import { useEffect, useState, useTransition } from "react";
import { supabase } from "@/lib/supabase/client";
import { addPlanExclusion, deletePlanExclusion } from "@/app/(student)/actions/planGroupActions";
import type { PlanExclusion } from "@/lib/types/plan";
import { Trash2 } from "lucide-react";
import { EmptyState } from "@/components/ui/EmptyState";

type ExclusionManagementProps = {
  studentId: string;
  onAddRequest?: () => void;
  isAdding?: boolean;
};

const exclusionTypes = [
  { value: "íœ´ê°€", label: "íœ´ê°€" },
  { value: "ê°œì¸ì‚¬ì •", label: "ê°œì¸ì‚¬ì •" },
  { value: "íœ´ì¼ì§€ì •", label: "íœ´ì¼ì§€ì •" },
  { value: "ê¸°íƒ€", label: "ê¸°íƒ€" },
] as const;

export default function ExclusionManagement({
  studentId,
  onAddRequest,
  isAdding = false,
}: ExclusionManagementProps) {
  const [planExclusions, setPlanExclusions] = useState<PlanExclusion[]>([]);
  const [loading, setLoading] = useState(true);
  const [newExclusionDate, setNewExclusionDate] = useState("");
  const [newExclusionType, setNewExclusionType] = useState<"íœ´ê°€" | "ê°œì¸ì‚¬ì •" | "íœ´ì¼ì§€ì •" | "ê¸°íƒ€">("íœ´ê°€");
  const [newExclusionReason, setNewExclusionReason] = useState("");
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      // í•™ìƒë³„ ì „ì—­ ì œì™¸ì¼ ì¡°íšŒ
      const { data: exclusions, error } = await supabase
        .from("plan_exclusions")
        .select("id,tenant_id,student_id,exclusion_date,exclusion_type,reason,created_at")
        .eq("student_id", studentId)
        .order("exclusion_date", { ascending: true });

      if (error) {
        console.error("[ExclusionManagement] ì œì™¸ì¼ ì¡°íšŒ ì‹¤íŒ¨", error);
        setPlanExclusions([]);
      } else {
        setPlanExclusions((exclusions as PlanExclusion[]) ?? []);
      }
    } catch (error: any) {
      console.error("í•™ìŠµ ì œì™¸ ì¼ì • ë¡œë“œ ì‹¤íŒ¨:", error);
      
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ êµ¬ë¶„
      const isNetworkError = 
        error?.message?.includes("Failed to fetch") ||
        error?.message?.includes("NetworkError") ||
        error?.message?.includes("network") ||
        error?.code === "ECONNABORTED" ||
        error?.code === "ETIMEDOUT";
      
      if (isNetworkError) {
        console.warn("ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ë°œìƒ - ì¼ë¶€ ë°ì´í„°ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-12">
        <p className="text-sm text-gray-500">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  const handleAddExclusion = async () => {
    if (!newExclusionDate) {
      alert("ë‚ ì§œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      return;
    }

    // í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì¤‘ë³µ ì²´í¬
    const existingDate = planExclusions.find(
      (e) => e.exclusion_date === newExclusionDate
    );
    if (existingDate) {
      alert(`ì´ë¯¸ ë“±ë¡ëœ ì œì™¸ì¼ì…ë‹ˆë‹¤: ${newExclusionDate}`);
      return;
    }

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("exclusion_date", newExclusionDate);
        formData.append("exclusion_type", newExclusionType);
        if (newExclusionReason.trim()) {
          formData.append("reason", newExclusionReason.trim());
        }

        await addPlanExclusion(formData);

        // í¼ ì´ˆê¸°í™”
        setNewExclusionDate("");
        setNewExclusionReason("");
        onAddRequest?.(); // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ìƒíƒœ í† ê¸€ ìš”ì²­

        // ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
        await loadData();
      } catch (error: any) {
        alert(error.message || "ì œì™¸ì¼ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  const handleDeleteExclusion = async (exclusionId: string) => {
    if (!confirm("ì´ ì œì™¸ì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    startTransition(async () => {
      try {
        const formData = new FormData();
        formData.append("exclusion_id", exclusionId);

        await deletePlanExclusion(formData);

        // ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
        await loadData();
      } catch (error: any) {
        alert(error.message || "ì œì™¸ì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  // ìœ í˜•ë³„ë¡œ ê·¸ë£¹í™”
  const exclusionsByType = planExclusions.reduce((acc, exclusion) => {
    const type = exclusion.exclusion_type;
    if (!acc[type]) {
      acc[type] = [];
    }
    acc[type].push(exclusion);
    return acc;
  }, {} as Record<string, PlanExclusion[]>);

  // ìœ í˜•ë³„ë¡œ ì •ë ¬ëœ í‚¤ ë°°ì—´ (exclusionTypes ìˆœì„œëŒ€ë¡œ)
  const typeKeys = exclusionTypes
    .map((type) => type.value)
    .filter((type) => exclusionsByType[type] && exclusionsByType[type].length > 0);

  return (
    <div className="flex flex-col gap-6">
      <div className="flex flex-col gap-1 rounded-lg border border-blue-200 bg-blue-50 p-4 text-sm text-blue-800">
        <p className="font-medium">ğŸ“Œ í•™ìŠµ ì œì™¸ ì¼ì •ì€ í•™ìƒë³„ ì „ì—­ìœ¼ë¡œ ê´€ë¦¬ë©ë‹ˆë‹¤.</p>
        <p className="text-xs text-blue-700">
          ë“±ë¡í•œ ì œì™¸ì¼ì€ ëª¨ë“  í”Œëœ ê·¸ë£¹ì—ì„œ ê³µí†µìœ¼ë¡œ ì ìš©ë©ë‹ˆë‹¤.
        </p>
      </div>

      <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-6">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">í•™ìŠµ ì œì™¸ ì¼ì •</h3>
        </div>

        {/* ì œì™¸ì¼ ì¶”ê°€ í¼ */}
        {isAdding && (
          <div className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50 p-4">
            <div className="grid gap-4 md:grid-cols-3">
              <div className="flex flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  ë‚ ì§œ <span className="text-red-500">*</span>
                </label>
                <input
                  type="date"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                  value={newExclusionDate}
                  onChange={(e) => setNewExclusionDate(e.target.value)}
                />
              </div>
              <div className="flex flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  ìœ í˜• <span className="text-red-500">*</span>
                </label>
                <select
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                  value={newExclusionType}
                  onChange={(e) =>
                    setNewExclusionType(e.target.value as typeof newExclusionType)
                  }
                >
                  {exclusionTypes.map((type) => (
                    <option key={type.value} value={type.value}>
                      {type.label}
                    </option>
                  ))}
                </select>
              </div>
              <div className="flex flex-col gap-1">
                <label className="block text-xs font-medium text-gray-700">
                  ì‚¬ìœ  (ì„ íƒì‚¬í•­)
                </label>
                <input
                  type="text"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:border-gray-900 focus:outline-none"
                  placeholder="ì˜ˆ: ê°€ì¡± ì—¬í–‰"
                  value={newExclusionReason}
                  onChange={(e) => setNewExclusionReason(e.target.value)}
                />
              </div>
            </div>
            <div className="flex gap-2">
              <button
                type="button"
                onClick={handleAddExclusion}
                disabled={isPending || !newExclusionDate}
                className="rounded-lg bg-gray-900 px-4 py-2 text-sm font-medium text-white hover:bg-gray-800 disabled:cursor-not-allowed disabled:bg-gray-400"
              >
                {isPending ? "ì¶”ê°€ ì¤‘..." : "ì¶”ê°€"}
              </button>
              <button
                type="button"
                onClick={() => {
                  onAddRequest?.(); // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ìƒíƒœ í† ê¸€ ìš”ì²­
                  setNewExclusionDate("");
                  setNewExclusionReason("");
                }}
                disabled={isPending}
                className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50"
              >
                ì·¨ì†Œ
              </button>
            </div>
          </div>
        )}

        {/* ë¹ˆ ìƒíƒœ */}
        {planExclusions.length === 0 && !isAdding && (
          <EmptyState
            title="ë“±ë¡ëœ í•™ìŠµ ì œì™¸ ì¼ì •ì´ ì—†ìŠµë‹ˆë‹¤"
            description="íœ´ê°€ë‚˜ ê°œì¸ ì‚¬ì •ìœ¼ë¡œ í•™ìŠµí•˜ì§€ ì•ŠëŠ” ë‚ ì„ ë“±ë¡í•˜ì„¸ìš”."
            icon="ğŸ—“ï¸"
          />
        )}

        {/* ì œì™¸ì¼ ëª©ë¡ (ìœ í˜•ë³„ ê·¸ë£¹í™”) */}
        {planExclusions.length > 0 && (
          <div className="flex flex-col gap-4">
            {typeKeys.map((type) => {
              const typeLabel = exclusionTypes.find((t) => t.value === type)?.label || type;
              const exclusions = exclusionsByType[type].sort(
                (a, b) => a.exclusion_date.localeCompare(b.exclusion_date)
              );

              return (
                <div key={type} className="flex flex-col gap-3 rounded-lg border border-gray-200 bg-gray-50 p-4">
                  <h4 className="text-sm font-semibold text-gray-900">
                    {typeLabel} ({exclusions.length}ê°œ)
                  </h4>
                  <div className="flex flex-col gap-2">
                    {exclusions.map((exclusion) => (
                      <div
                        key={exclusion.id}
                        className="flex items-center justify-between gap-4 rounded-lg border border-gray-200 bg-white px-4 py-3"
                      >
                        <div className="flex flex-col gap-1 flex-1">
                          <div className="text-sm font-medium text-gray-900">
                            {exclusion.exclusion_date}
                          </div>
                          {exclusion.reason && (
                            <div className="text-xs text-gray-500">
                              {exclusion.reason}
                            </div>
                          )}
                        </div>
                        <button
                          type="button"
                          onClick={() => handleDeleteExclusion(exclusion.id)}
                          disabled={isPending}
                          className="rounded p-1 text-red-600 hover:bg-red-50 disabled:cursor-not-allowed disabled:opacity-50"
                          title="ì‚­ì œ"
                        >
                          <Trash2 className="h-4 w-4" />
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="_components/InvalidBlockWarning.tsx">
"use client";

import { isValidBlock } from "@/lib/blocks/statistics";

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
};

type InvalidBlockWarningProps = {
  blocks: Block[];
};

const DAYS = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

export default function InvalidBlockWarning({ blocks }: InvalidBlockWarningProps) {
  const invalidBlocks = blocks.filter((block) => !isValidBlock(block));

  if (invalidBlocks.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col gap-3 p-4 bg-amber-50 border border-amber-200 rounded-lg">
      <div className="flex items-start gap-3">
        <div className="text-2xl">âš ï¸</div>
        <div className="flex flex-1 flex-col gap-3">
          <h3 className="text-sm font-semibold text-amber-900">
            ì˜ëª»ëœ ì‹œê°„ ë¸”ë¡ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤
          </h3>
          <p className="text-sm text-amber-800">
            ì¢…ë£Œ ì‹œê°„ì´ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ë¸”ë¡ì´ {invalidBlocks.length}ê°œ ìˆìŠµë‹ˆë‹¤.
            ì´ëŸ¬í•œ ë¸”ë¡ì€ í†µê³„ ê³„ì‚°ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.
          </p>
          <div className="flex flex-col gap-1">
            {invalidBlocks.map((block) => (
              <div
                key={block.id}
                className="text-xs text-amber-700 bg-amber-100 px-2 py-1 rounded"
              >
                {DAYS[block.day_of_week]}ìš”ì¼: {block.start_time} ~ {block.end_time}
                {" (ì¢…ë£Œ ì‹œê°„ì´ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìŒ)"}
              </div>
            ))}
          </div>
          <p className="text-xs text-amber-700">
            íƒ€ì„í…Œì´ë¸”ì—ì„œ í•´ë‹¹ ë¸”ë¡ì„ í´ë¦­í•˜ì—¬ ìˆ˜ì •í•˜ê±°ë‚˜ ì‚­ì œí•´ì£¼ì„¸ìš”.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="[setId]/_components/BlockList.tsx">
"use client";

import { useState, useActionState } from "react";
import { useRouter } from "next/navigation";
import { updateBlock, deleteBlock } from "@/app/actions/blocks";
import { validateFormData, blockSchema } from "@/lib/validation/schemas";
import { EmptyState } from "@/components/ui/EmptyState";

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
};

type BlockListProps = {
  blocks: Block[];
  blockSetId: string;
  onAddBlock?: () => void;
};

const DAYS = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

export default function BlockList({ blocks, blockSetId, onAddBlock }: BlockListProps) {
  const router = useRouter();
  const [editingId, setEditingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const handleEdit = async (blockId: string, formData: FormData) => {
    try {
      formData.append("id", blockId);
      const validation = validateFormData(formData, blockSchema);
      if (!validation.success) {
        const firstError = validation.errors.issues[0];
        alert(firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return;
      }

      await updateBlock(formData);
      setEditingId(null);
      router.refresh();
    } catch (error: any) {
      console.error("ë¸”ë¡ ìˆ˜ì • ì‹¤íŒ¨:", error);
      alert(error.message || "ë¸”ë¡ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  const handleDelete = async (blockId: string) => {
    if (!confirm("ì´ ë¸”ë¡ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const formData = new FormData();
      formData.append("id", blockId);
      await deleteBlock(formData);
      setDeletingId(null);
      router.refresh();
    } catch (error: any) {
      console.error("ë¸”ë¡ ì‚­ì œ ì‹¤íŒ¨:", error);
      alert(error.message || "ë¸”ë¡ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
  };

  // ìš”ì¼ë³„ë¡œ ê·¸ë£¹í™”
  const blocksByDay = DAYS.map((day, dayIndex) => ({
    day,
    dayIndex,
    blocks: blocks.filter((b) => b.day_of_week === dayIndex),
  })).filter((group) => group.blocks.length > 0);

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-medium text-gray-900">ì‹œê°„ ë¸”ë¡ ëª©ë¡</h2>
        {onAddBlock && (
          <button
            type="button"
            onClick={onAddBlock}
            className="p-2 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors"
            title="ë¸”ë¡ ì¶”ê°€"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-5 w-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 4v16m8-8H4"
              />
            </svg>
          </button>
        )}
      </div>
      {blocksByDay.length === 0 ? (
        <EmptyState
          icon="â°"
          title="ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤"
          description="ìœ„ì˜ + ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì‹œê°„ ë¸”ë¡ì„ ì¶”ê°€í•˜ì„¸ìš”."
        />
      ) : (
        <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
          <div className="divide-y divide-gray-200">
            {blocksByDay.map(({ day, dayIndex, blocks: dayBlocks }) => (
            <div key={dayIndex} className="flex flex-col gap-3 p-4">
              <h3 className="text-sm font-semibold text-gray-900">{day}ìš”ì¼</h3>
              <div className="flex flex-col gap-2">
                {dayBlocks.map((block) => {
                  const isEditing = editingId === block.id;
                  const isDeleting = deletingId === block.id;

                  if (isEditing) {
                    return (
                      <BlockEditForm
                        key={block.id}
                        block={block}
                        onSave={(formData) => handleEdit(block.id, formData)}
                        onCancel={() => setEditingId(null)}
                      />
                    );
                  }

                  return (
                    <div
                      key={block.id}
                      className="flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors"
                    >
                      <div className="flex items-center gap-4">
                        <span className="text-sm font-medium text-gray-900">
                          {block.start_time} ~ {block.end_time}
                        </span>
                        <span className="text-xs text-gray-500">
                          {Math.round(
                            ((new Date(`2000-01-01T${block.end_time}`).getTime() -
                              new Date(`2000-01-01T${block.start_time}`).getTime()) /
                              60000)
                          )}ë¶„
                        </span>
                      </div>
                      <div className="flex items-center gap-2">
                        <button
                          type="button"
                          onClick={() => setEditingId(block.id)}
                          disabled={isDeleting}
                          className="px-3 py-1 text-sm text-indigo-600 hover:text-indigo-700 hover:bg-indigo-50 rounded transition-colors disabled:opacity-50"
                        >
                          ìˆ˜ì •
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            setDeletingId(block.id);
                            handleDelete(block.id);
                          }}
                          disabled={isDeleting}
                          className="px-3 py-1 text-sm text-red-600 hover:text-red-700 hover:bg-red-50 rounded transition-colors disabled:opacity-50"
                        >
                          {isDeleting ? "ì‚­ì œ ì¤‘..." : "ì‚­ì œ"}
                        </button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ))}
          </div>
        </div>
      )}
    </div>
  );
}

type BlockEditFormProps = {
  block: Block;
  onSave: (formData: FormData) => void;
  onCancel: () => void;
};

function BlockEditForm({ block, onSave, onCancel }: BlockEditFormProps) {
  const [state, formAction, isPending] = useActionState(
    async (_prev: { error: string | null }, formData: FormData) => {
      try {
        await onSave(formData);
        return { error: null };
      } catch (err: any) {
        return { error: err.message || "ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
      }
    },
    { error: null }
  );

  return (
    <div className="p-4 bg-white border-2 border-indigo-500 rounded-lg">
      <form action={formAction} className="flex flex-col gap-3">
        {state.error && (
          <p className="text-xs text-red-600 bg-red-50 p-2 rounded">{state.error}</p>
        )}

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-gray-700">ìš”ì¼</label>
          <select
            name="day"
            defaultValue={block.day_of_week}
            className="text-sm border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
            required
          >
            {DAYS.map((day, index) => (
              <option key={index} value={index}>
                {day}ìš”ì¼
              </option>
            ))}
          </select>
        </div>

        <div className="grid grid-cols-2 gap-3">
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-gray-700">ì‹œì‘ ì‹œê°„</label>
            <input
              type="time"
              name="start_time"
              defaultValue={block.start_time}
              className="text-sm border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-gray-700">ì¢…ë£Œ ì‹œê°„</label>
            <input
              type="time"
              name="end_time"
              defaultValue={block.end_time}
              className="text-sm border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
        </div>

        <div className="flex gap-2">
          <button
            type="submit"
            disabled={isPending}
            className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-indigo-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isPending ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
          </button>
          <button
            type="button"
            onClick={onCancel}
            disabled={isPending}
            className="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-300 transition-colors disabled:opacity-50"
          >
            ì·¨ì†Œ
          </button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="[setId]/_components/BlockSetDetail.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import BlockStatistics from "../../_components/BlockStatistics";
import BlockTimeline from "../../_components/BlockTimeline";
import InvalidBlockWarning from "../../_components/InvalidBlockWarning";
import BlockList from "./BlockList";
import BlockForm from "../../_components/BlockForm";

type BlockSet = {
  id: string;
  name: string;
  description: string | null;
  display_order: number;
};

type Block = {
  id: string;
  day_of_week: number;
  start_time: string;
  end_time: string;
};

type BlockSetDetailProps = {
  blockSet: BlockSet;
  blocks: Block[];
  isActive: boolean;
};

type DetailTab = "list" | "statistics" | "timeline";

export default function BlockSetDetail({
  blockSet,
  blocks,
  isActive,
}: BlockSetDetailProps) {
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<DetailTab>("list");
  const [showBlockForm, setShowBlockForm] = useState(false);

  const handleBack = () => {
    router.push("/blocks");
  };

  const handleAddBlock = () => {
    setShowBlockForm(true);
  };

  return (
    <div className="flex flex-col gap-6">
      {/* ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ë° í—¤ë” */}
      <div className="flex flex-col gap-4">
        <button
          type="button"
          onClick={handleBack}
          className="text-sm text-gray-600 hover:text-gray-900 transition-colors flex items-center gap-2"
        >
          <span>â†</span>
          <span>ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°</span>
        </button>
        
        <div className="flex items-start justify-between">
          <div className="flex flex-col gap-2">
            <h1 className="text-2xl font-semibold text-gray-900">
              {blockSet.name}
            </h1>
            {blockSet.description && (
              <p className="text-sm text-gray-600">{blockSet.description}</p>
            )}
            {isActive && (
              <span className="inline-block px-3 py-1 text-sm font-medium text-indigo-700 bg-indigo-100 rounded">
                í™œì„± ì„¸íŠ¸
              </span>
            )}
          </div>
        </div>
      </div>

      {/* ì˜ëª»ëœ ë¸”ë¡ ê²½ê³  */}
      {blocks.length > 0 && (
        <div>
          <InvalidBlockWarning blocks={blocks} />
        </div>
      )}

      {/* ìƒˆ ë¸”ë¡ ì¶”ê°€ í¼ (ëª¨ë‹¬) */}
      {showBlockForm && (
        <BlockForm 
          onClose={() => {
            setShowBlockForm(false);
            router.refresh();
          }}
          blockSetId={blockSet.id}
        />
      )}

      {/* íƒ­ ë©”ë‰´ */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex gap-4">
          <button
            type="button"
            onClick={() => setActiveTab("list")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "list"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            ì‹œê°„ ë¸”ë¡ ëª©ë¡
          </button>
          <button
            type="button"
            onClick={() => setActiveTab("statistics")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "statistics"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            í†µê³„ ë° ì¸ì‚¬ì´íŠ¸
          </button>
          <button
            type="button"
            onClick={() => setActiveTab("timeline")}
            className={`border-b-2 px-1 pb-4 text-sm font-medium transition-colors ${
              activeTab === "timeline"
                ? "border-gray-900 text-gray-900"
                : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
            }`}
          >
            ì£¼ê°„ íƒ€ì„í…Œì´ë¸”
          </button>
        </nav>
      </div>

      {/* íƒ­ ë‚´ìš© */}
      <div className="flex flex-col gap-8">
        {activeTab === "list" && (
          <BlockList 
            blocks={blocks} 
            blockSetId={blockSet.id}
            onAddBlock={handleAddBlock}
          />
        )}
        {activeTab === "statistics" && (
          <div>
            <BlockStatistics blocks={blocks} />
          </div>
        )}
        {activeTab === "timeline" && (
          <div>
            <div className="bg-white border border-gray-200 rounded-lg p-4 md:p-6 overflow-x-auto">
              <BlockTimeline blocks={blocks} />
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="[setId]/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import BlockSetDetail from "./_components/BlockSetDetail";
import { getContainerClass } from "@/lib/constants/layout";

type PageProps = {
  params: Promise<{ setId: string }>;
};

export default async function BlockSetDetailPage({ params }: PageProps) {
  const { setId } = await params;
  
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: blockSet, error: setError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("id", setId)
    .eq("student_id", user.id)
    .single();

  if (setError || !blockSet) {
    redirect("/blocks");
  }

  // í•´ë‹¹ ì„¸íŠ¸ì˜ ë¸”ë¡ ì¡°íšŒ
  const { data: blocks, error: blocksError } = await supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time")
    .eq("block_set_id", setId)
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í™œì„± ì„¸íŠ¸ ì—¬ë¶€ í™•ì¸
  const { data: student } = await supabase
    .from("students")
    .select("active_block_set_id")
    .eq("id", user.id)
    .maybeSingle();

  const isActive = student?.active_block_set_id === setId;

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockSetDetail
        blockSet={blockSet}
        blocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? []}
        isActive={isActive}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import BlockManagementContainer from "./_components/BlockManagementContainer";
import { getContainerClass } from "@/lib/constants/layout";

export default async function BlocksPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) redirect("/login");

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (í™œì„± ì„¸íŠ¸ í¬í•¨)
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .maybeSingle();

  if (studentError && studentError.code !== "PGRST116") {
    console.error("í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentError);
  }

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ ì¡°íšŒ
  const { data: blockSetsData, error: blockSetsError } = await supabase
    .from("student_block_sets")
    .select("id, name, description, display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: true })
    .order("created_at", { ascending: true });

  if (blockSetsError) {
    console.error("ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", blockSetsError);
  }

  // ê° ë¸”ë¡ ì„¸íŠ¸ì˜ ì‹œê°„ ë¸”ë¡ ì¡°íšŒ
  const blockSets = blockSetsData
    ? await Promise.all(
        blockSetsData.map(async (set) => {
          const { data: blocks } = await supabase
            .from("student_block_schedule")
            .select("id, day_of_week, start_time, end_time")
            .eq("block_set_id", set.id)
            .eq("student_id", user.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          return {
            ...set,
            blocks: (blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string }>) ?? [],
          };
        })
      )
    : [];

  // í™œì„± ì„¸íŠ¸ ê²°ì •
  let activeSetId: string | null = student?.active_block_set_id ?? null;
  
  // í™œì„± ì„¸íŠ¸ê°€ ì—†ê³  ë¸”ë¡ ì„¸íŠ¸ê°€ ìˆìœ¼ë©´, ë¸”ë¡ì´ ìˆëŠ” ì²« ë²ˆì§¸ ì„¸íŠ¸ë¥¼ í™œì„± ì„¸íŠ¸ë¡œ ì‚¬ìš©
  if (!activeSetId && blockSets && blockSets.length > 0) {
    for (const set of blockSets) {
      if (set.blocks && set.blocks.length > 0) {
        activeSetId = set.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        const { error: updateError } = await supabase
          .from("students")
          .update({ active_block_set_id: set.id })
          .eq("id", user.id);
        
        if (updateError) {
          console.error("í™œì„± ì„¸íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", updateError);
        }
        break;
      }
    }
  }

  // í™œì„± ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ë§Œ ì¡°íšŒ
  const blocksQuery = supabase
    .from("student_block_schedule")
    .select("id, day_of_week, start_time, end_time, block_set_id")
    .eq("student_id", user.id)
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (activeSetId) {
    blocksQuery.eq("block_set_id", activeSetId);
  }

  const { data: blocks, error: blocksError } = await blocksQuery;
  
  if (blocksError) {
    console.error("ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
  }

  // í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (í•™ìŠµ ì œì™¸ ì¼ì •, í•™ì› ì¼ì • í‘œì‹œìš©)
  const planGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    tenantId: student?.tenant_id ?? null,
    includeDeleted: false,
  });

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <BlockManagementContainer
        studentId={user.id}
        initialBlockSets={blockSets}
        initialActiveSetId={activeSetId}
        initialBlocks={(blocks as Array<{ id: string; day_of_week: number; start_time: string; end_time: string; block_set_id: string | null }>) ?? []}
        initialPlanGroups={planGroups}
      />
    </section>
  );
}
</file>

<file path="_components/CampFlowIndicator.tsx">
import { cn } from "@/lib/cn";
import { Check, Clock, Play } from "lucide-react";

interface CampFlowStep {
  id: string;
  label: string;
  description: string;
  status: "completed" | "active" | "pending";
}

interface CampFlowIndicatorProps {
  currentStep: "participation" | "review" | "planning" | "activation";
  invitation: {
    status: string;
    isDraft: boolean;
    hasPlans: boolean;
    planGroupStatus: string | null;
  };
  className?: string;
}

export function CampFlowIndicator({ currentStep, invitation, className }: CampFlowIndicatorProps) {
  const getSteps = (): CampFlowStep[] => {
    const steps: CampFlowStep[] = [
      {
        id: "participation",
        label: "ì°¸ì—¬ ì •ë³´ ì œì¶œ",
        description: "ìº í”„ í”„ë¡œê·¸ë¨ ì°¸ì—¬ ì •ë³´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤",
        status: invitation.status === "pending" && invitation.isDraft 
          ? "active" 
          : invitation.status === "accepted" || invitation.hasPlans
          ? "completed"
          : "pending"
      },
      {
        id: "review",
        label: "ê´€ë¦¬ì ê²€í† ",
        description: "ì œì¶œëœ ì •ë³´ë¥¼ ê²€í† í•˜ê³  í”Œëœì„ ìƒì„±í•©ë‹ˆë‹¤",
        status: invitation.status === "accepted" && !invitation.hasPlans
          ? "active"
          : invitation.hasPlans
          ? "completed"
          : "pending"
      },
      {
        id: "planning",
        label: "í”Œëœ ìƒì„± ì™„ë£Œ",
        description: "í•™ìŠµ í”Œëœì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        status: invitation.hasPlans && invitation.planGroupStatus !== "active"
          ? "active"
          : invitation.planGroupStatus === "active"
          ? "completed"
          : "pending"
      },
      {
        id: "activation",
        label: "í•™ìŠµ ì‹œì‘",
        description: "í”Œëœì´ í™œì„±í™”ë˜ì–´ í•™ìŠµì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
        status: invitation.planGroupStatus === "active"
          ? "completed"
          : invitation.hasPlans
          ? "active"
          : "pending"
      },
    ];

    return steps;
  };

  const steps = getSteps();

  const getStepIcon = (status: CampFlowStep["status"]) => {
    switch (status) {
      case "completed":
        return <Check className="h-4 w-4 text-white" />;
      case "active":
        return <Clock className="h-4 w-4 text-white" />;
      case "pending":
        return <div className="h-2 w-2 rounded-full bg-gray-400" />;
    }
  };

  const getStepColor = (status: CampFlowStep["status"]) => {
    switch (status) {
      case "completed":
        return "bg-green-500";
      case "active":
        return "bg-indigo-500";
      case "pending":
        return "bg-gray-300";
    }
  };

  return (
    <div className={cn("flex flex-col gap-4 rounded-lg border border-gray-200 bg-white p-4", className)}>
      <h3 className="text-sm font-semibold text-gray-900">ì§„í–‰ ìƒíƒœ</h3>
      
      <div className="flex flex-col gap-4">
        {steps.map((step, index) => (
          <div key={step.id} className="flex items-start gap-3">
            {/* Icon */}
            <div className={cn(
              "flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-full",
              getStepColor(step.status)
            )}>
              {getStepIcon(step.status)}
            </div>

            {/* Content */}
            <div className="flex flex-col gap-0.5 flex-1 min-w-0">
              <div className="flex items-center gap-2">
                <h4 className={cn(
                  "text-sm font-semibold",
                  step.status === "active" ? "text-indigo-600" : "text-gray-900"
                )}>
                  {step.label}
                </h4>
                {step.status === "active" && (
                  <span className="inline-flex items-center gap-1 rounded-full bg-indigo-100 px-2 py-0.5 text-xs font-medium text-indigo-800">
                    <Play className="h-3 w-3" />
                    ì§„í–‰ ì¤‘
                  </span>
                )}
                {step.status === "completed" && (
                  <span className="text-xs text-green-600">ì™„ë£Œ</span>
                )}
              </div>
              <p className={cn(
                "text-xs",
                step.status === "pending" ? "text-gray-400" : "text-gray-600"
              )}>
                {step.description}
              </p>
            </div>

            {/* Connector line (except for last item) */}
            {index < steps.length - 1 && (
              <div className={cn(
                "absolute left-[31px] top-10 h-6 w-0.5",
                step.status === "completed" ? "bg-green-500" : "bg-gray-200"
              )} />
            )}
          </div>
        ))}
      </div>
    </div>
  );
}

// Compact version for cards
export function CampFlowCompact({ invitation }: { invitation: CampFlowIndicatorProps["invitation"] }) {
  const getCurrentStepLabel = () => {
    if (invitation.status === "pending" && invitation.isDraft) {
      return { label: "ì°¸ì—¬ ì •ë³´ ì‘ì„± ì¤‘", color: "text-yellow-600", bgColor: "bg-yellow-100" };
    }
    if (invitation.status === "accepted" && !invitation.hasPlans) {
      return { label: "ê´€ë¦¬ì ê²€í†  ì¤‘", color: "text-blue-600", bgColor: "bg-blue-100" };
    }
    if (invitation.hasPlans && invitation.planGroupStatus !== "active") {
      return { label: "í”Œëœ ìƒì„± ì™„ë£Œ", color: "text-indigo-600", bgColor: "bg-indigo-100" };
    }
    if (invitation.planGroupStatus === "active") {
      return { label: "í•™ìŠµ ì§„í–‰ ì¤‘", color: "text-green-600", bgColor: "bg-green-100" };
    }
    return { label: "ëŒ€ê¸° ì¤‘", color: "text-gray-600", bgColor: "bg-gray-100" };
  };

  const stepInfo = getCurrentStepLabel();

  return (
    <div className={cn(
      "inline-flex items-center gap-1.5 rounded-full px-2.5 py-1 text-xs font-medium",
      stepInfo.bgColor,
      stepInfo.color
    )}>
      <div className="h-1.5 w-1.5 rounded-full bg-current animate-pulse" />
      {stepInfo.label}
    </div>
  );
}
</file>

<file path="_components/CampInvitationActions.tsx">
"use client";

import Link from "next/link";

type CampInvitationActionsProps = {
  invitation: {
    id: string;
    status: string;
    isDraft: boolean;
    planGroupId: string | null;
    planGroupStatus: string | null;
    hasPlans: boolean;
  };
};

export function CampInvitationActions({
  invitation,
}: CampInvitationActionsProps) {
  return (
    <div
      className="flex flex-col items-end gap-2"
      onClick={(e) => e.stopPropagation()}
    >
      {/* ì´ˆëŒ€ ìƒíƒœê°€ pendingì¸ ê²½ìš° */}
      {invitation.status === "pending" && !invitation.isDraft && (
        <Link
          href={`/camp/${invitation.id}`}
          className="inline-flex items-center justify-center rounded-lg bg-yellow-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-yellow-700 shadow-sm"
          onClick={(e) => e.stopPropagation()}
        >
          ì°¸ì—¬í•˜ê¸°
        </Link>
      )}
      {invitation.status === "pending" && invitation.isDraft && (
        <Link
          href={`/camp/${invitation.id}`}
          className="inline-flex items-center justify-center rounded-lg bg-orange-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-orange-700 shadow-sm"
          onClick={(e) => e.stopPropagation()}
        >
          ì´ì–´ì„œ ì‘ì„±
        </Link>
      )}

      {/* ì´ˆëŒ€ ìƒíƒœê°€ acceptedì´ê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° */}
      {invitation.status === "accepted" &&
        invitation.planGroupId &&
        invitation.hasPlans && (
          <>
            {invitation.planGroupStatus === "active" ? (
              <Link
                href="/camp/today"
                className="inline-flex items-center justify-center gap-2 rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 shadow-sm"
                onClick={(e) => e.stopPropagation()}
              >
                <svg
                  className="h-4 w-4"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                  />
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  />
                </svg>
                í•™ìŠµ ì‹œì‘í•˜ê¸°
              </Link>
            ) : invitation.planGroupStatus === "paused" ? (
              <>
                <Link
                  href="/camp/today"
                  className="inline-flex items-center justify-center gap-2 rounded-lg bg-orange-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-orange-700 shadow-sm"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg
                    className="h-4 w-4"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                    />
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                    />
                  </svg>
                  í•™ìŠµ ì¬ê°œí•˜ê¸°
                </Link>
                <Link
                  href={`/plan/group/${invitation.planGroupId}?camp=true`}
                  className="inline-flex items-center justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
                  onClick={(e) => e.stopPropagation()}
                >
                  í”Œëœ ë³´ê¸°
                </Link>
              </>
            ) : (
              <Link
                href={`/plan/group/${invitation.planGroupId}?camp=true`}
                className="inline-flex items-center justify-center gap-2 rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
                onClick={(e) => e.stopPropagation()}
              >
                <svg
                  className="h-4 w-4"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                  />
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                  />
                </svg>
                í”Œëœ ë³´ê¸°
              </Link>
            )}
          </>
        )}

      {/* ì´ˆëŒ€ ìƒíƒœê°€ acceptedì´ì§€ë§Œ í”Œëœì´ ì•„ì§ ì—†ëŠ” ê²½ìš° */}
      {invitation.status === "accepted" &&
        (!invitation.planGroupId || !invitation.hasPlans) && (
          <span className="inline-flex items-center rounded-full bg-blue-100 px-3 py-1 text-xs font-medium text-blue-800">
            ì°¸ì—¬ ì™„ë£Œ
          </span>
        )}
    </div>
  );
}
</file>

<file path="_components/CampInvitationCard.tsx">
"use client";

import { useRouter } from "next/navigation";
import Link from "next/link";
import { CampInvitationActions } from "./CampInvitationActions";

type CampInvitationCardProps = {
  invitation: {
    id: string;
    status: string;
    isDraft: boolean;
    planGroupId: string | null;
    planGroupStatus: string | null;
    hasPlans: boolean;
    periodStart: string | null;
    periodEnd: string | null;
    template?: {
      name?: string;
      program_type?: string;
      description?: string;
      camp_location?: string | null;
      camp_start_date?: string | null;
      camp_end_date?: string | null;
    } | null;
  };
  detailLink: string;
};

export function CampInvitationCard({
  invitation,
  detailLink,
}: CampInvitationCardProps) {
  const router = useRouter();

  const handleCardClick = (e: React.MouseEvent<HTMLDivElement>) => {
    // ë²„íŠ¼ì´ë‚˜ ë§í¬ë¥¼ í´ë¦­í•œ ê²½ìš°ëŠ” ë„¤ë¹„ê²Œì´ì…˜í•˜ì§€ ì•ŠìŒ
    const target = e.target as HTMLElement;
    if (
      target.closest("a") ||
      target.closest("button") ||
      target.tagName === "A" ||
      target.tagName === "BUTTON"
    ) {
      return;
    }
    router.push(detailLink);
  };

  return (
    <div
      onClick={handleCardClick}
      className="block cursor-pointer rounded-lg border border-gray-200 bg-white p-6 transition hover:border-indigo-300 hover:shadow-md"
    >
      <div className="flex items-start justify-between gap-4">
        <div className="flex flex-col gap-2 flex-1">
          <div className="flex items-center gap-2">
            {invitation.template?.program_type && (
              <span className="inline-flex items-center rounded-full bg-indigo-100 px-2.5 py-1 text-xs font-medium text-indigo-800">
                {invitation.template.program_type}
              </span>
            )}
          </div>
          <h3 className="text-lg font-semibold text-gray-900">
            {invitation.template?.name || "ìº í”„ í”„ë¡œê·¸ë¨"}
          </h3>
          {invitation.template?.description && (
            <p className="text-sm text-gray-500">
              {invitation.template.description}
            </p>
          )}
          {/* ìº í”„ ì¥ì†Œ */}
          {invitation.template?.camp_location && (
            <p className="text-sm text-gray-500">
              ì¥ì†Œ: {invitation.template.camp_location}
            </p>
          )}
          {/* ìº í”„ ê¸°ê°„ */}
          {invitation.template?.camp_start_date && invitation.template?.camp_end_date && (
            <p className="text-sm text-gray-500">
              ê¸°ê°„: {new Date(invitation.template.camp_start_date).toLocaleDateString("ko-KR", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })} ~ {new Date(invitation.template.camp_end_date).toLocaleDateString("ko-KR", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })}
            </p>
          )}
          {/* í”Œëœ ìƒíƒœ í‘œì‹œ */}
          <div className="flex flex-col gap-3">
            {invitation.planGroupId ? (
              <>
                {/* ìƒíƒœ ë±ƒì§€ ë° ì„¤ëª… */}
                <div className="flex flex-wrap items-center gap-2">
                  {(() => {
                    const status = invitation.planGroupStatus;

                    // ì´ˆëŒ€ ìƒíƒœê°€ pendingì´ê³  í”Œëœ ê·¸ë£¹ì´ draftì¸ ê²½ìš°
                    if (invitation.status === "pending" && status === "draft") {
                      return (
                        <>
                          <span className="inline-flex items-center rounded-full bg-yellow-100 px-2.5 py-1 text-xs font-medium text-yellow-800">
                            ì‘ì„± ì¤‘
                          </span>
                          <Link
                            href={`/camp/${invitation.id}`}
                            className="text-sm font-medium text-indigo-600 hover:text-indigo-800"
                            onClick={(e) => e.stopPropagation()}
                          >
                            ì´ì–´ì„œ ì‘ì„±í•˜ê¸° â†’
                          </Link>
                        </>
                      );
                    }

                    // í”Œëœì´ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš°
                    if (!invitation.hasPlans) {
                      if (status === "draft" || status === "saved") {
                        return (
                          <>
                            <span className="inline-flex items-center rounded-full bg-blue-100 px-2.5 py-1 text-xs font-medium text-blue-800">
                              ê´€ë¦¬ì ê²€í†  ì¤‘
                            </span>
                            <span className="text-xs text-gray-500">
                              í”Œëœ ìƒì„± ëŒ€ê¸° ì¤‘
                            </span>
                          </>
                        );
                      }
                    }

                    // í”Œëœì´ ìƒì„±ëœ ê²½ìš° ìƒíƒœë³„ í‘œì‹œ
                    if (invitation.hasPlans) {
                      if (status === "active") {
                        return (
                          <>
                            <span className="inline-flex items-center rounded-full bg-green-100 px-2.5 py-1 text-xs font-medium text-green-800">
                              í•™ìŠµ ì‹œì‘ ê°€ëŠ¥
                            </span>
                            {invitation.periodStart && invitation.periodEnd && (
                              <span className="text-xs text-gray-500">
                                {new Date(invitation.periodStart).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })} ~ {new Date(invitation.periodEnd).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })}
                              </span>
                            )}
                          </>
                        );
                      } else if (status === "paused") {
                        return (
                          <>
                            <span className="inline-flex items-center rounded-full bg-orange-100 px-2.5 py-1 text-xs font-medium text-orange-800">
                              ì¼ì‹œì •ì§€ë¨
                            </span>
                            {invitation.periodStart && invitation.periodEnd && (
                              <span className="text-xs text-gray-500">
                                {new Date(invitation.periodStart).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })} ~ {new Date(invitation.periodEnd).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })}
                              </span>
                            )}
                          </>
                        );
                      } else if (status === "completed") {
                        return (
                          <>
                            <span className="inline-flex items-center rounded-full bg-gray-100 px-2.5 py-1 text-xs font-medium text-gray-800">
                              ì™„ë£Œë¨
                            </span>
                            {invitation.periodStart && invitation.periodEnd && (
                              <span className="text-xs text-gray-500">
                                {new Date(invitation.periodStart).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })} ~ {new Date(invitation.periodEnd).toLocaleDateString("ko-KR", { month: "long", day: "numeric" })}
                              </span>
                            )}
                          </>
                        );
                      } else if (status === "saved" || status === "draft") {
                        return (
                          <>
                            <span className="inline-flex items-center rounded-full bg-blue-100 px-2.5 py-1 text-xs font-medium text-blue-800">
                              í”Œëœ ìƒì„± ì™„ë£Œ
                            </span>
                            <span className="text-xs text-gray-500">
                              í™œì„±í™” ëŒ€ê¸° ì¤‘
                            </span>
                          </>
                        );
                      }
                    }

                    return null;
                  })()}
                </div>

                {/* ì§„í–‰ ë‹¨ê³„ í‘œì‹œ */}
                <div className="flex items-center gap-2 text-xs text-gray-500">
                  <span className={invitation.status === "pending" && invitation.isDraft ? "font-medium text-gray-700" : ""}>
                    â‘  ì°¸ì—¬ ì •ë³´ ì œì¶œ
                  </span>
                  <span>â†’</span>
                  <span className={invitation.status === "accepted" && !invitation.hasPlans ? "font-medium text-gray-700" : ""}>
                    â‘¡ í”Œëœ ìƒì„±
                  </span>
                  <span>â†’</span>
                  <span className={invitation.hasPlans && invitation.planGroupStatus === "active" ? "font-medium text-indigo-600" : ""}>
                    â‘¢ í•™ìŠµ ì‹œì‘
                  </span>
                </div>
              </>
            ) : invitation.status === "pending" ? (
              <div className="flex items-center gap-2 text-xs text-gray-500">
                <span className="font-medium text-gray-700">â‘  ì°¸ì—¬ ì •ë³´ ì œì¶œ</span>
                <span>â†’</span>
                <span>â‘¡ í”Œëœ ìƒì„±</span>
                <span>â†’</span>
                <span>â‘¢ í•™ìŠµ ì‹œì‘</span>
              </div>
            ) : null}
          </div>
        </div>
        <CampInvitationActions
          invitation={{
            id: invitation.id,
            status: invitation.status,
            isDraft: invitation.isDraft,
            planGroupId: invitation.planGroupId,
            planGroupStatus: invitation.planGroupStatus,
            hasPlans: invitation.hasPlans,
          }}
        />
      </div>
    </div>
  );
}
</file>

<file path="_components/CampInvitationCardNew.tsx">
"use client";

import { useRouter } from "next/navigation";
import Link from "next/link";
import { CampCard } from "../../plan/_shared/PlanCard";
import { StepProgress } from "../../plan/_shared/ProgressIndicator";
import { CampInvitationActions } from "./CampInvitationActions";

type CampInvitationCardProps = {
  invitation: {
    id: string;
    status: string;
    isDraft: boolean;
    planGroupId: string | null;
    planGroupStatus: string | null;
    hasPlans: boolean;
    periodStart: string | null;
    periodEnd: string | null;
    template?: {
      name?: string;
      program_type?: string;
      description?: string;
    } | null;
  };
  detailLink: string;
};

export function CampInvitationCard({
  invitation,
  detailLink,
}: CampInvitationCardProps) {
  const router = useRouter();

  const handleCardClick = (e: React.MouseEvent<HTMLDivElement>) => {
    const target = e.target as HTMLElement;
    if (
      target.closest("a") ||
      target.closest("button") ||
      target.tagName === "A" ||
      target.tagName === "BUTTON"
    ) {
      return;
    }
    router.push(detailLink);
  };

  // Determine badges and status
  const badges = [];
  let customStatus: string | undefined;

  if (invitation.status === "pending" && invitation.isDraft) {
    badges.push({ label: "ì‘ì„± ì¤‘", variant: "warning" as const });
  } else if (invitation.status === "accepted") {
    if (!invitation.hasPlans) {
      badges.push({ label: "ê´€ë¦¬ì ê²€í†  ì¤‘", variant: "info" as const });
    } else if (invitation.planGroupStatus === "active") {
      badges.push({ label: "í•™ìŠµ ì‹œì‘ ê°€ëŠ¥", variant: "success" as const });
      customStatus = "active";
    } else if (invitation.planGroupStatus === "paused") {
      badges.push({ label: "ì¼ì‹œì •ì§€ë¨", variant: "warning" as const });
      customStatus = "paused";
    } else if (invitation.planGroupStatus === "completed") {
      badges.push({ label: "ì™„ë£Œë¨", variant: "default" as const });
      customStatus = "completed";
    } else if (invitation.planGroupStatus === "saved" || invitation.planGroupStatus === "draft") {
      badges.push({ label: "í”Œëœ ìƒì„± ì™„ë£Œ", variant: "info" as const });
    }
  }

  // Prepare metadata
  const metadata = [];
  if (invitation.periodStart && invitation.periodEnd && invitation.hasPlans) {
    metadata.push({
      label: "í•™ìŠµ ê¸°ê°„",
      value: `${new Date(invitation.periodStart).toLocaleDateString("ko-KR", { 
        month: "long", day: "numeric" 
      })} ~ ${new Date(invitation.periodEnd).toLocaleDateString("ko-KR", { 
        month: "long", day: "numeric" 
      })}`
    });
  }

  // Prepare step progress
  const steps = [
    {
      label: "â‘  ì°¸ì—¬ ì •ë³´ ì œì¶œ",
      isActive: invitation.status === "pending" && invitation.isDraft,
      isCompleted: invitation.status === "accepted"
    },
    {
      label: "â‘¡ í”Œëœ ìƒì„±",
      isActive: invitation.status === "accepted" && !invitation.hasPlans,
      isCompleted: invitation.hasPlans
    },
    {
      label: "â‘¢ í•™ìŠµ ì‹œì‘",
      isActive: invitation.hasPlans && invitation.planGroupStatus === "active",
      isCompleted: false
    },
  ];

  return (
    <CampCard
      title={invitation.template?.name || "ìº í”„ í”„ë¡œê·¸ë¨"}
      subtitle={invitation.template?.program_type}
      description={invitation.template?.description}
      badges={badges}
      status={customStatus}
      metadata={metadata}
      onClick={handleCardClick}
      actions={
        <CampInvitationActions
          invitation={{
            id: invitation.id,
            status: invitation.status,
            isDraft: invitation.isDraft,
            planGroupId: invitation.planGroupId,
            planGroupStatus: invitation.planGroupStatus,
            hasPlans: invitation.hasPlans,
          }}
        />
      }
    >
      {/* Step progress */}
      {invitation.planGroupId && (
        <StepProgress steps={steps} />
      )}
      
      {/* Continue button for draft */}
      {invitation.status === "pending" && invitation.isDraft && invitation.planGroupId && (
        <Link
          href={`/camp/${invitation.id}`}
          className="text-sm font-medium text-indigo-600 hover:text-indigo-800"
          onClick={(e) => e.stopPropagation()}
        >
          ì´ì–´ì„œ ì‘ì„±í•˜ê¸° â†’
        </Link>
      )}
    </CampCard>
  );
}
</file>

<file path="_components/CampParticipationHeader.tsx">
import Link from "next/link";
import { CampFlowIndicator } from "./CampFlowIndicator";

interface CampParticipationHeaderProps {
  template: {
    name: string;
    program_type?: string;
    description?: string | null;
  };
  invitation: {
    id: string;
    status: string;
    isDraft: boolean;
    hasPlans: boolean;
    planGroupStatus: string | null;
  };
  showBackButton?: boolean;
}

export function CampParticipationHeader({
  template,
  invitation,
  showBackButton = true,
}: CampParticipationHeaderProps) {
  return (
    <div className="flex flex-col gap-6">
      {/* Header with back button */}
      {showBackButton && (
        <div className="flex items-center justify-between rounded-lg border border-gray-200 bg-white px-4 py-3 shadow-sm">
          <Link
            href="/camp"
            className="inline-flex items-center gap-2 rounded-lg px-3 py-1.5 text-sm font-medium text-gray-700 transition hover:bg-gray-100"
          >
            <svg
              className="h-4 w-4"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M15 19l-7-7 7-7"
              />
            </svg>
            ìº í”„ ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>
      )}

      {/* Title and description */}
      <div className="flex flex-col gap-2">
        <p className="text-sm font-medium text-gray-700">ìº í”„ í”„ë¡œê·¸ë¨</p>
        <h1 className="text-3xl font-semibold text-gray-900">
          {template.name}
        </h1>
        <div className="flex flex-wrap items-center gap-2">
          {template.program_type && (
            <span className="inline-flex items-center rounded-full bg-indigo-100 px-2.5 py-0.5 text-xs font-medium text-indigo-800">
              {template.program_type}
            </span>
          )}
        </div>
        {template.description && (
          <p className="text-sm text-gray-700">{template.description}</p>
        )}
      </div>

      {/* Flow indicator */}
      <CampFlowIndicator
        currentStep={
          invitation.status === "pending" && invitation.isDraft
            ? "participation"
            : invitation.status === "accepted" && !invitation.hasPlans
            ? "review"
            : invitation.hasPlans && invitation.planGroupStatus !== "active"
            ? "planning"
            : "activation"
        }
        invitation={invitation}
      />
    </div>
  );
}
</file>

<file path="[invitationId]/submitted/page.tsx">
import Link from "next/link";
import { redirect, notFound } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlanGroupWithDetails } from "@/lib/data/planGroups";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getCampInvitation, getCampTemplate } from "@/lib/data/campTemplates";
import { classifyPlanContents } from "@/lib/data/planContents";
import { PlanGroupDetailView } from "@/app/(student)/plan/group/[id]/_components/PlanGroupDetailView";
import {
  planPurposeLabels,
  schedulerTypeLabels,
} from "@/lib/constants/planLabels";

type CampSubmissionDetailPageProps = {
  params: Promise<{ invitationId: string }>;
};

export default async function CampSubmissionDetailPage({
  params,
}: CampSubmissionDetailPageProps) {
  const { invitationId } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // ì´ˆëŒ€ ë° í…œí”Œë¦¿ ì •ë³´ ì¡°íšŒ (ì§ì ‘ ì¡°íšŒí•˜ì—¬ ê¶Œí•œ ì²´í¬ ë¬¸ì œ íšŒí”¼)
  const invitation = await getCampInvitation(invitationId);
  if (!invitation) {
    console.warn(
      "[CampSubmissionDetailPage] ì´ˆëŒ€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
      invitationId
    );
    notFound();
  }

  // ë³¸ì¸ì˜ ì´ˆëŒ€ì¸ì§€ í™•ì¸
  if (invitation.student_id !== user.id) {
    console.warn("[CampSubmissionDetailPage] ë³¸ì¸ì˜ ì´ˆëŒ€ê°€ ì•„ë‹˜:", {
      invitation_student_id: invitation.student_id,
      current_user_id: user.id,
    });
    redirect("/camp");
  }

  const template = await getCampTemplate(invitation.camp_template_id);
  if (!template) {
    console.warn(
      "[CampSubmissionDetailPage] í…œí”Œë¦¿ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
      invitation.camp_template_id
    );
    notFound();
  }

  // ë³¸ì¸ì˜ ì´ˆëŒ€ì¸ì§€ í™•ì¸
  if (invitation.student_id !== user.id) {
    redirect("/camp");
  }

  // invitationIdë¡œ í”Œëœ ê·¸ë£¹ ì¡°íšŒ (ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ê°€ì¥ ìµœê·¼ ê²ƒë§Œ)
  const { data: planGroup, error: planGroupError } = await supabase
    .from("plan_groups")
    .select("id")
    .eq("camp_invitation_id", invitationId)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (planGroupError) {
    console.error(
      "[CampSubmissionDetailPage] í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì—ëŸ¬:",
      planGroupError
    );
    notFound();
  }

  if (!planGroup) {
    console.warn(
      "[CampSubmissionDetailPage] í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
      invitationId
    );
    notFound();
  }

  // tenantId ì¡°íšŒ
  const tenantContext = await getTenantContext();

  // í”Œëœ ê·¸ë£¹ ë° ê´€ë ¨ ë°ì´í„° ì¡°íšŒ
  let group, contents, exclusions, academySchedules;
  try {
    const result = await getPlanGroupWithDetails(
      planGroup.id,
      user.id,
      tenantContext?.tenantId || null
    );
    group = result.group;
    contents = result.contents;
    exclusions = result.exclusions;
    academySchedules = result.academySchedules;
  } catch (error) {
    console.error(
      "[CampSubmissionDetailPage] í”Œëœ ê·¸ë£¹ ìƒì„¸ ì¡°íšŒ ì—ëŸ¬:",
      error
    );
    notFound();
  }

  if (!group) {
    console.warn(
      "[CampSubmissionDetailPage] í”Œëœ ê·¸ë£¹ ìƒì„¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
      planGroup.id
    );
    notFound();
  }

  // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ ë° í•™ìƒ/ì¶”ì²œ êµ¬ë¶„
  const { studentContents, recommendedContents } = await classifyPlanContents(
    contents,
    user.id
  );

  // ìƒì„¸ í˜ì´ì§€ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
  const allContents = [...studentContents, ...recommendedContents];
  const contentsMap = new Map(allContents.map((c) => [c.content_id, c]));

  const contentsWithDetails = contents.map((content) => {
    const detail = contentsMap.get(content.content_id);
    if (!detail) {
      return {
        ...content,
        contentTitle: "ì•Œ ìˆ˜ ì—†ìŒ",
        contentSubtitle: null,
        isRecommended: false,
      };
    }

    return {
      ...content,
      contentTitle: detail.title || "ì•Œ ìˆ˜ ì—†ìŒ",
      contentSubtitle: detail.subject_category || null,
      isRecommended: detail.isRecommended,
    };
  });

  // í”Œëœ ë°ì´í„° ì¡°íšŒ
  const { data: plans } = await supabase
    .from("student_plan")
    .select("id")
    .eq("plan_group_id", planGroup.id)
    .eq("student_id", user.id)
    .limit(1);

  const hasPlans = (plans?.length || 0) > 0;

  // ìº í”„ ëª¨ë“œì¼ ë•Œ í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ ì •ë³´ ì¡°íšŒ
  let templateBlocks: Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
  }> = [];
  let templateBlockSetName: string | null = null;
  let templateBlockSetId: string | null = null;

  // ë””ë²„ê¹…: group ê°ì²´ í™•ì¸
  console.log("[CampSubmissionDetailPage] group ê°ì²´ í™•ì¸:", {
    plan_type: group.plan_type,
    camp_template_id: group.camp_template_id,
    group_id: group.id,
    has_plan_type: "plan_type" in group,
    has_camp_template_id: "camp_template_id" in group,
  });

  if (group.plan_type === "camp" && group.camp_template_id) {
    try {
      // ë””ë²„ê¹…: ì´ˆê¸° ìƒíƒœ ë¡œê·¸ (group ê°ì²´ ì „ì²´ í™•ì¸)
      console.log("[CampSubmissionDetailPage] ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹œì‘:", {
        plan_type: group.plan_type,
        camp_template_id: group.camp_template_id,
        scheduler_options_type: typeof group.scheduler_options,
        scheduler_options: group.scheduler_options,
        group_id: group.id,
        group_keys: Object.keys(group),
      });

      // scheduler_optionsê°€ ì‹¤ì œë¡œ ì¡°íšŒë˜ì—ˆëŠ”ì§€ í™•ì¸
      if (group.scheduler_options === undefined) {
        console.warn(
          "[CampSubmissionDetailPage] scheduler_optionsê°€ undefined - getPlanGroupWithDetailsì—ì„œ ì¡°íšŒë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŒ"
        );

        // ì§ì ‘ ì¡°íšŒ ì‹œë„
        const { data: directGroup, error: directError } = await supabase
          .from("plan_groups")
          .select("scheduler_options")
          .eq("id", group.id)
          .maybeSingle();

        if (directError) {
          console.error(
            "[CampSubmissionDetailPage] ì§ì ‘ ì¡°íšŒ ì—ëŸ¬:",
            directError
          );
        } else if (directGroup) {
          console.log("[CampSubmissionDetailPage] ì§ì ‘ ì¡°íšŒ ê²°ê³¼:", {
            scheduler_options: directGroup.scheduler_options,
            scheduler_options_type: typeof directGroup.scheduler_options,
          });
          // ì§ì ‘ ì¡°íšŒí•œ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          (group as any).scheduler_options = directGroup.scheduler_options;
        }
      }

      // template_data ì•ˆì „í•˜ê²Œ íŒŒì‹±
      let templateData: any = null;
      if (template.template_data) {
        if (typeof template.template_data === "string") {
          try {
            templateData = JSON.parse(template.template_data);
          } catch (parseError) {
            console.error(
              "[CampSubmissionDetailPage] template_data íŒŒì‹± ì—ëŸ¬:",
              parseError
            );
            templateData = null;
          }
        } else {
          templateData = template.template_data;
        }
      }

      console.log("[CampSubmissionDetailPage] template_data íŒŒì‹± ê²°ê³¼:", {
        has_template_data: !!templateData,
        block_set_id: templateData?.block_set_id,
      });

      // block_set_id ì°¾ê¸°: camp_template_idë¡œ ì§ì ‘ ì¡°íšŒ (ê°€ì¥ ì§ì ‘ì ì´ê³  ëª…í™•í•œ ë°©ë²•)
      let blockSetId: string | null = null;

      // 1. ì—°ê²° í…Œì´ë¸”ì—ì„œ ì§ì ‘ ì¡°íšŒ (ê°€ì¥ ì§ì ‘ì ì´ê³  ëª…í™•í•œ ë°©ë²•)
      if (group.camp_template_id) {
        const { data: templateBlockSetLink } = await supabase
          .from("camp_template_block_sets")
          .select("tenant_block_set_id")
          .eq("camp_template_id", group.camp_template_id)
          .maybeSingle();

        if (templateBlockSetLink) {
          blockSetId = templateBlockSetLink.tenant_block_set_id;
          console.log(
            "[CampSubmissionDetailPage] ì—°ê²° í…Œì´ë¸”ì—ì„œ block_set_id ë°œê²¬:",
            blockSetId
          );
        } else {
          console.warn(
            "[CampSubmissionDetailPage] ì—°ê²° í…Œì´ë¸”ì—ì„œ block_set_idë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
            {
              camp_template_id: group.camp_template_id,
            }
          );
        }
      }

      // 2. scheduler_optionsì—ì„œ template_block_set_id í™•ì¸ (Fallback)
      if (!blockSetId && group.scheduler_options) {
        let schedulerOptions: any = null;
        if (typeof group.scheduler_options === "string") {
          try {
            schedulerOptions = JSON.parse(group.scheduler_options);
            console.log(
              "[CampSubmissionDetailPage] scheduler_options íŒŒì‹± ì„±ê³µ (string):",
              schedulerOptions
            );
          } catch (parseError) {
            console.error(
              "[CampSubmissionDetailPage] scheduler_options íŒŒì‹± ì—ëŸ¬:",
              parseError
            );
          }
        } else {
          schedulerOptions = group.scheduler_options;
          console.log(
            "[CampSubmissionDetailPage] scheduler_options (object):",
            schedulerOptions
          );
        }

        if (schedulerOptions?.template_block_set_id) {
          blockSetId = schedulerOptions.template_block_set_id;
          console.log(
            "[CampSubmissionDetailPage] scheduler_optionsì—ì„œ template_block_set_id ë°œê²¬ (Fallback):",
            blockSetId
          );
        } else {
          console.warn(
            "[CampSubmissionDetailPage] scheduler_optionsì— template_block_set_id ì—†ìŒ:",
            {
              scheduler_options_keys: schedulerOptions
                ? Object.keys(schedulerOptions)
                : [],
              scheduler_options: schedulerOptions,
            }
          );
        }
      }

      // 3. template_dataì—ì„œ block_set_id í™•ì¸ (í•˜ìœ„ í˜¸í™˜ì„±, ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ ë°ì´í„°ìš©)
      if (!blockSetId && templateData?.block_set_id) {
        blockSetId = templateData.block_set_id;
        console.log(
          "[CampSubmissionDetailPage] template_dataì—ì„œ block_set_id ë°œê²¬ (í•˜ìœ„ í˜¸í™˜ì„±):",
          blockSetId
        );
      }

      console.log("[CampSubmissionDetailPage] ìµœì¢… blockSetId:", blockSetId);

      if (blockSetId) {
        // í…Œë„ŒíŠ¸ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
        let templateBlockSet: { id: string; name: string } | null = null;

        // tenant_idë¡œ ì¡°íšŒ (ë³´ì•ˆì„ ìœ„í•´)
        if (tenantContext?.tenantId) {
          const { data: blockSetData, error: blockSetError } = await supabase
            .from("tenant_block_sets")
            .select("id, name")
            .eq("id", blockSetId)
            .eq("tenant_id", tenantContext.tenantId)
            .maybeSingle();

          console.log("[CampSubmissionDetailPage] í…Œë„ŒíŠ¸ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ:", {
            found: !!blockSetData,
            block_set: blockSetData,
            error: blockSetError,
            block_set_id: blockSetId,
            tenant_id: tenantContext.tenantId,
          });

          if (blockSetError) {
            console.error(
              "[CampSubmissionDetailPage] í…Œë„ŒíŠ¸ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì—ëŸ¬:",
              {
                error: blockSetError,
                block_set_id: blockSetId,
                tenant_id: tenantContext.tenantId,
              }
            );
          } else if (blockSetData) {
            templateBlockSet = blockSetData;
            templateBlockSetId = blockSetData.id;
          } else {
            console.warn(
              "[CampSubmissionDetailPage] ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:",
              {
                block_set_id: blockSetId,
                tenant_id: tenantContext.tenantId,
              }
            );
          }
        }

        // ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì•˜ìœ¼ë©´ ë¸”ë¡ ì¡°íšŒ
        if (templateBlockSet) {
          templateBlockSetName = templateBlockSet.name;
          console.log(
            "[CampSubmissionDetailPage] í…Œë„ŒíŠ¸ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì„±ê³µ:",
            {
              id: templateBlockSet.id,
              name: templateBlockSet.name,
            }
          );

          // í…Œë„ŒíŠ¸ ë¸”ë¡ ì¡°íšŒ
          const { data: blocks, error: blocksError } = await supabase
            .from("tenant_blocks")
            .select("id, day_of_week, start_time, end_time")
            .eq("tenant_block_set_id", templateBlockSet.id)
            .order("day_of_week", { ascending: true })
            .order("start_time", { ascending: true });

          console.log("[CampSubmissionDetailPage] í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒ ê²°ê³¼:", {
            count: blocks?.length || 0,
            blocks: blocks,
            error: blocksError,
            block_set_id: templateBlockSet.id,
          });

          if (blocksError) {
            console.error("[CampSubmissionDetailPage] í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒ ì—ëŸ¬:", {
              error: blocksError,
              block_set_id: templateBlockSet.id,
            });
          } else if (blocks && blocks.length > 0) {
            templateBlocks = blocks.map((b) => ({
              id: b.id,
              day_of_week: b.day_of_week,
              start_time: b.start_time,
              end_time: b.end_time,
            }));
            console.log("[CampSubmissionDetailPage] í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒ ì„±ê³µ:", {
              count: templateBlocks.length,
              block_set_id: templateBlockSet.id,
            });
          } else {
            console.warn("[CampSubmissionDetailPage] í…œí”Œë¦¿ ë¸”ë¡ì´ ì—†ìŒ:", {
              block_set_id: templateBlockSet.id,
              block_set_name: templateBlockSet.name,
            });
          }
        }
      } else {
        console.warn(
          "[CampSubmissionDetailPage] block_set_idë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:",
          {
            template_id: group.camp_template_id,
            template_data_has_block_set_id: !!templateData?.block_set_id,
            scheduler_options_has_template_block_set_id:
              !!(typeof group.scheduler_options === "object"
                ? (group.scheduler_options as any)?.template_block_set_id
                : null),
          }
        );
      }
    } catch (error) {
      console.error(
        "[CampSubmissionDetailPage] í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒ ì¤‘ ì—ëŸ¬:",
        error
      );
    }
  }

  // ë””ë²„ê¹…: ë Œë”ë§ ì§ì „ ê°’ í™•ì¸
  console.log("[CampSubmissionDetailPage] ë Œë”ë§ ì§ì „ ê°’ í™•ì¸:", {
    templateBlockSetName,
    templateBlocks_length: templateBlocks.length,
    templateBlocks,
    will_render: !!templateBlockSetName,
    plan_type: group.plan_type,
    camp_template_id: group.camp_template_id,
  });

  return (
    <section className="mx-auto w-full max-w-5xl px-4 py-6 md:py-10">
      <div className="flex flex-col gap-6">
        {/* ìƒë‹¨ ì•¡ì…˜ ë°” */}
        <div className="flex items-center justify-between rounded-lg border border-gray-200 bg-white px-4 py-3 shadow-sm">
          <Link
            href="/camp"
            className="inline-flex items-center gap-2 rounded-lg px-3 py-1.5 text-sm font-medium text-gray-700 transition hover:bg-gray-100"
          >
            <svg
              className="h-4 w-4"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M15 19l-7-7 7-7"
              />
            </svg>
            ìº í”„ ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>

        {/* ì œì¶œ ì™„ë£Œ ì•ˆë‚´ ë©”ì‹œì§€ */}
        <div className="rounded-lg border border-green-200 bg-green-50 p-4">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0">
              <svg
                className="h-5 w-5 text-green-600"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
            </div>
            <div className="flex flex-1 flex-col gap-1">
              <h3 className="text-sm font-semibold text-green-900">
                ìº í”„ ì°¸ì—¬ ì •ë³´ ì œì¶œ ì™„ë£Œ
              </h3>
              <p className="text-sm text-green-700">
                ìº í”„ ì°¸ì—¬ ì •ë³´ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì œì¶œí–ˆìŠµë‹ˆë‹¤. ê´€ë¦¬ìê°€ ë‚¨ì€ ë‹¨ê³„ë¥¼
                ì§„í–‰í•œ í›„ í”Œëœì´ ìƒì„±ë©ë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </div>

        {/* í…œí”Œë¦¿ ì •ë³´ ì¹´ë“œ */}
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-lg font-semibold text-gray-900">
            ìº í”„ í”„ë¡œê·¸ë¨ ì •ë³´
          </h2>
          <div className="flex flex-col gap-3">
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">
                í”„ë¡œê·¸ë¨ ì´ë¦„
              </dt>
              <dd className="text-sm font-semibold text-gray-900">
                {template.name}
              </dd>
            </div>
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">
                í”„ë¡œê·¸ë¨ ìœ í˜•
              </dt>
              <dd className="text-sm font-semibold text-gray-900">
                {template.program_type}
              </dd>
            </div>
            {template.description && (
              <div className="flex flex-col gap-1">
                <dt className="text-xs font-medium text-gray-500">ì„¤ëª…</dt>
                <dd className="text-sm text-gray-700">
                  {template.description}
                </dd>
              </div>
            )}
          </div>
        </div>

        {/* ì œì¶œ ì •ë³´ ì¹´ë“œ */}
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-lg font-semibold text-gray-900">
            ì œì¶œí•œ ì •ë³´
          </h2>
          <div className="grid gap-4 border-t border-gray-100 pt-4 sm:grid-cols-2 lg:grid-cols-3">
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">í”Œëœ ì´ë¦„</dt>
              <dd className="text-sm font-semibold text-gray-900">
                {group.name || "â€”"}
              </dd>
            </div>
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">í”Œëœ ëª©ì </dt>
              <dd className="text-sm font-semibold text-gray-900">
                {group.plan_purpose
                  ? planPurposeLabels[group.plan_purpose] || group.plan_purpose
                  : "â€”"}
              </dd>
            </div>
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">
                ìŠ¤ì¼€ì¤„ëŸ¬ ìœ í˜•
              </dt>
              <dd className="text-sm font-semibold text-gray-900">
                {group.scheduler_type
                  ? schedulerTypeLabels[group.scheduler_type] ||
                    group.scheduler_type
                  : "â€”"}
              </dd>
            </div>
            <div className="flex flex-col gap-1">
              <dt className="text-xs font-medium text-gray-500">í•™ìŠµ ê¸°ê°„</dt>
              <dd className="text-sm font-semibold text-gray-900">
                {group.period_start && group.period_end
                  ? `${new Date(group.period_start).toLocaleDateString(
                      "ko-KR",
                      {
                        month: "short",
                        day: "numeric",
                      }
                    )} ~ ${new Date(group.period_end).toLocaleDateString(
                      "ko-KR",
                      {
                        month: "short",
                        day: "numeric",
                      }
                    )}`
                  : "â€”"}
              </dd>
            </div>
            {group.target_date && (
              <div className="flex flex-col gap-1">
                <dt className="text-xs font-medium text-gray-500">ëª©í‘œ ë‚ ì§œ</dt>
                <dd className="text-sm font-semibold text-gray-900">
                  {new Date(group.target_date).toLocaleDateString("ko-KR")}
                </dd>
              </div>
            )}
          </div>

          {/* ë¸”ë¡ ì„¸íŠ¸ ì •ë³´ */}
          {templateBlockSetName && (
            <div className="flex flex-col gap-2 border-t border-gray-100 pt-4">
              <label className="text-xs font-medium text-gray-500">
                ë¸”ë¡ ì„¸íŠ¸
              </label>
              <div className="flex flex-col gap-3">
                <div>
                  <p className="text-sm font-semibold text-gray-900">
                    {templateBlockSetName}
                  </p>
                </div>
                {templateBlocks.length > 0 ? (
                  <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
                    {templateBlocks.map((block) => (
                      <div
                        key={block.id}
                        className="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2"
                      >
                        <div className="text-sm font-medium text-gray-900">
                          {
                            [
                              "ì¼ìš”ì¼",
                              "ì›”ìš”ì¼",
                              "í™”ìš”ì¼",
                              "ìˆ˜ìš”ì¼",
                              "ëª©ìš”ì¼",
                              "ê¸ˆìš”ì¼",
                              "í† ìš”ì¼",
                            ][block.day_of_week]
                          }
                        </div>
                        <div className="text-xs text-gray-600">
                          {block.start_time} ~ {block.end_time}
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-sm text-gray-500">
                    ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤.
                  </p>
                )}
              </div>
            </div>
          )}
        </div>

        {/* íƒ­ ì»¨í…ì¸  ì˜ì—­ */}
        <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <PlanGroupDetailView
            group={group}
            contents={contents}
            exclusions={exclusions}
            academySchedules={academySchedules}
            contentsWithDetails={contentsWithDetails}
            canEdit={false}
            groupId={planGroup.id}
            hasPlans={hasPlans}
            campSubmissionMode={true}
            templateBlocks={templateBlocks}
            templateBlockSetName={templateBlockSetName}
            templateBlockSetId={templateBlockSetId}
            campTemplateId={group.camp_template_id}
          />
        </div>
      </div>
    </section>
  );
}
</file>

<file path="[invitationId]/page.tsx">
import { redirect, notFound } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCampInvitationWithTemplate } from "../../actions/campActions";
import { PlanGroupWizard } from "../../plan/new-group/_components/PlanGroupWizard";
import { fetchAllStudentContents } from "@/lib/data/planContents";
import { fetchBlockSetsWithBlocks } from "@/lib/data/blockSets";
import { getPlanGroupWithDetails } from "@/lib/data/planGroups";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getContainerClass } from "@/lib/constants/layout";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import Link from "next/link";
import { inlineButtonBase } from "@/lib/utils/darkMode";

type CampParticipationPageProps = {
  params: Promise<{ invitationId: string }>;
};

export default async function CampParticipationPage({
  params,
}: CampParticipationPageProps) {
  const { invitationId } = await params;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // ì´ˆëŒ€ ë° í…œí”Œë¦¿ ì •ë³´ ì¡°íšŒ
  const result = await getCampInvitationWithTemplate(invitationId);
  if (!result.success || !result.invitation || !result.template) {
    notFound();
  }

  const { invitation, template } = result;

  // ì´ë¯¸ ì°¸ì—¬ ì™„ë£Œí•œ ê²½ìš° í”Œëœ ìƒì„± ì—¬ë¶€ì— ë”°ë¼ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (invitation.status === "accepted") {
    // camp_invitation_idë¡œ í”Œëœ ê·¸ë£¹ ì°¾ê¸° (ì—¬ëŸ¬ ê°œì¼ ê²½ìš° ê°€ì¥ ìµœê·¼ ê²ƒë§Œ)
    const { data: planGroup, error: planGroupError } = await supabase
      .from("plan_groups")
      .select("id")
      .eq("camp_invitation_id", invitationId)
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (planGroupError) {
      console.error(
        "[CampParticipationPage] í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì—ëŸ¬:",
        planGroupError
      );
      // ì—ëŸ¬ ë°œìƒ ì‹œ ì œì¶œ ì™„ë£Œ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      redirect(`/camp/${invitationId}/submitted`);
    }

    if (planGroup) {
      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .eq("student_id", user.id)
        .limit(1);

      const hasPlans = (plans?.length || 0) > 0;

      // í”Œëœì´ ìƒì„±ë˜ì—ˆìœ¼ë©´ í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ, ì•„ë‹ˆë©´ ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
      if (hasPlans) {
        redirect(`/plan/group/${planGroup.id}`);
      } else {
        redirect(`/camp/${invitationId}/submitted`);
      }
    } else {
      // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì œì¶œ ì™„ë£Œ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
      redirect(`/camp/${invitationId}/submitted`);
    }
  }

  // Draft í”Œëœ ê·¸ë£¹ ì¡°íšŒ (pending ìƒíƒœì¼ ë•Œë§Œ)
  let draftData: any = undefined;
  if (invitation.status === "pending") {
    const { data: draftGroup } = await supabase
      .from("plan_groups")
      .select("id, status")
      .eq("camp_invitation_id", invitationId)
      .eq("status", "draft")
      .maybeSingle();

    if (draftGroup) {
      try {
        const currentUser = await getCurrentUser();
        const tenantContext = await getTenantContext();
        const { group, contents, exclusions, academySchedules } =
          await getPlanGroupWithDetails(
            draftGroup.id,
            currentUser?.userId || user.id,
            tenantContext?.tenantId
          );

        if (group && group.status === "draft") {
          // ë°ì´í„° ë³€í™˜ í•¨ìˆ˜ ì‚¬ìš©
          const { transformPlanGroupToWizardData } = await import(
            "@/lib/utils/planGroupTransform"
          );
          draftData = await transformPlanGroupToWizardData(
            group,
            contents,
            exclusions,
            academySchedules,
            user.id
          );
        }
      } catch (error) {
        console.error("[CampParticipationPage] Draft ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨", error);
        // ì—ëŸ¬ ë°œìƒ ì‹œ draft ë°ì´í„° ì—†ì´ ì§„í–‰
      }
    }
  }

  // í…œí”Œë¦¿ ë°ì´í„°ë¥¼ initialDataë¡œ ë³€í™˜
  const templateData = template.template_data;

  // ê°œë°œ í™˜ê²½ì—ì„œ ë””ë²„ê¹… ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[CampParticipationPage] í…œí”Œë¦¿ ë°ì´í„° ê²€ì¦:", {
      period_start: templateData?.period_start,
      period_end: templateData?.period_end,
      block_set_id: templateData?.block_set_id,
      scheduler_type: templateData?.scheduler_type,
      exclusions: templateData?.exclusions?.length || 0,
      academy_schedules: templateData?.academy_schedules?.length || 0,
    });
  }

  // í…œí”Œë¦¿ ë°ì´í„° í•„ìˆ˜ í•„ë“œ ê²€ì¦
  const validationErrors: string[] = [];
  if (!templateData?.period_start || !templateData?.period_end) {
    validationErrors.push("í…œí”Œë¦¿ì— í•™ìŠµ ê¸°ê°„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
  }
  // block_set_id ê²€ì¦ì€ ë¸”ë¡ì„¸íŠ¸ ì¡°íšŒ í›„ì— ìˆ˜í–‰ (ìƒˆë¡œìš´ ì—°ê²° í…Œì´ë¸” ë°©ì‹)
  if (!templateData?.scheduler_type) {
    validationErrors.push("í…œí”Œë¦¿ì— ìŠ¤ì¼€ì¤„ëŸ¬ ìœ í˜•ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
  }

  // ë‚ ì§œ í˜•ì‹ ê²€ì¦
  if (templateData?.period_start && templateData?.period_end) {
    const startDate = new Date(templateData.period_start);
    const endDate = new Date(templateData.period_end);

    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      validationErrors.push(
        "í…œí”Œë¦¿ì˜ ë‚ ì§œ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (YYYY-MM-DD í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤)"
      );
    } else if (startDate > endDate) {
      validationErrors.push("í…œí”Œë¦¿ì˜ ì‹œì‘ì¼ì´ ì¢…ë£Œì¼ë³´ë‹¤ ëŠ¦ìŠµë‹ˆë‹¤.");
    }
  }

  // ë¸”ë¡ ì„¸íŠ¸ ë° ì½˜í…ì¸  ì¡°íšŒ
  const studentBlockSets = await fetchBlockSetsWithBlocks(user.id);
  const { books, lectures, custom } = await fetchAllStudentContents(user.id);

  // ìº í”„ í…œí”Œë¦¿ì˜ block_set_idëŠ” template_block_sets í…Œì´ë¸”ì˜ ID
  // í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ë° ë¸”ë¡ ëª©ë¡ì— ì¶”ê°€
  let templateBlockSet: {
    id: string;
    name: string;
    blocks?: Array<{
      id: string;
      day_of_week: number;
      start_time: string;
      end_time: string;
    }>;
  } | null = null;

  // ì—°ê²° í…Œì´ë¸”ì—ì„œ í…œí”Œë¦¿ì— ì—°ê²°ëœ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: templateBlockSetLink, error: linkError } = await supabase
    .from("camp_template_block_sets")
    .select("tenant_block_set_id")
    .eq("camp_template_id", template.id)
    .maybeSingle();

  if (linkError) {
    console.error("[CampParticipationPage] í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ ì—°ê²° ì¡°íšŒ ì‹¤íŒ¨:", linkError);
  } else if (templateBlockSetLink) {
    // ì—°ê²°ëœ ë¸”ë¡ ì„¸íŠ¸ ì •ë³´ ì¡°íšŒ
    const { data: templateBlockSetData, error: templateBlockSetError } =
      await supabase
        .from("tenant_block_sets")
        .select("id, name")
        .eq("id", templateBlockSetLink.tenant_block_set_id)
        .eq("tenant_id", template.tenant_id)
        .single();

    if (templateBlockSetError || !templateBlockSetData) {
      // ê°œë°œ í™˜ê²½ì—ì„œ ìƒì„¸ ë¡œê·¸ ì¶œë ¥
      if (process.env.NODE_ENV === "development") {
        console.error("[CampParticipationPage] í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", {
          block_set_id: templateBlockSetLink.tenant_block_set_id,
          template_id: template.id,
          tenant_id: template.tenant_id,
          error: templateBlockSetError,
        });
      }
      validationErrors.push(
        `í…œí”Œë¦¿ì˜ ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.`
      );
    } else {
      // í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ì˜ ë¸”ë¡ ì¡°íšŒ
      const { data: templateBlocks, error: templateBlocksError } =
        await supabase
          .from("tenant_blocks")
          .select("id, day_of_week, start_time, end_time")
          .eq("tenant_block_set_id", templateBlockSetData.id)
          .order("day_of_week", { ascending: true })
          .order("start_time", { ascending: true });

      if (templateBlocksError) {
        validationErrors.push(
          "í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”."
        );
      } else if (!templateBlocks || templateBlocks.length === 0) {
        validationErrors.push(
          "í…œí”Œë¦¿ì˜ ë¸”ë¡ ì„¸íŠ¸ì— ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”."
        );
      } else {
        // í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ë¥¼ blockSets ëª©ë¡ì— ì¶”ê°€ (ë§¨ ì•ì— ì¶”ê°€í•˜ì—¬ ìš°ì„  í‘œì‹œ)
        templateBlockSet = {
          id: templateBlockSetData.id,
          name: `${templateBlockSetData.name} (í…œí”Œë¦¿)`,
          blocks: templateBlocks.map((b) => ({
            id: b.id,
            day_of_week: b.day_of_week,
            start_time: b.start_time,
            end_time: b.end_time,
          })),
        };
      }
    }
  }
  
  // í•˜ìœ„ í˜¸í™˜ì„±: template_data.block_set_idë„ í™•ì¸ (ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ ë°ì´í„°ìš©)
  if (!templateBlockSet && templateData?.block_set_id) {
    const { data: legacyBlockSetData, error: legacyError } = await supabase
      .from("tenant_block_sets")
      .select("id, name")
      .eq("id", templateData.block_set_id)
      .eq("tenant_id", template.tenant_id)
      .maybeSingle();

    if (!legacyError && legacyBlockSetData) {
      const { data: legacyBlocks } = await supabase
        .from("tenant_blocks")
        .select("id, day_of_week, start_time, end_time")
        .eq("tenant_block_set_id", legacyBlockSetData.id)
        .order("day_of_week", { ascending: true })
        .order("start_time", { ascending: true });

      if (legacyBlocks && legacyBlocks.length > 0) {
        templateBlockSet = {
          id: legacyBlockSetData.id,
          name: `${legacyBlockSetData.name} (í…œí”Œë¦¿)`,
          blocks: legacyBlocks.map((b) => ({
            id: b.id,
            day_of_week: b.day_of_week,
            start_time: b.start_time,
            end_time: b.end_time,
          })),
        };
      }
    }
  }

  // ë¸”ë¡ì„¸íŠ¸ ì¡°íšŒ ì™„ë£Œ í›„ ê²€ì¦ (ìƒˆë¡œìš´ ì—°ê²° í…Œì´ë¸” ë°©ì‹ ë˜ëŠ” í•˜ìœ„ í˜¸í™˜ì„± ë°©ì‹ ëª¨ë‘ í™•ì¸)
  if (!templateBlockSet) {
    validationErrors.push("í…œí”Œë¦¿ì— ë¸”ë¡ ì„¸íŠ¸ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
  }

  // í•™ìƒ ë¸”ë¡ ì„¸íŠ¸ì™€ í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ë¥¼ í•©ì¹¨ (í…œí”Œë¦¿ ë¸”ë¡ ì„¸íŠ¸ë¥¼ ë§¨ ì•ì—)
  const blockSets = templateBlockSet
    ? [templateBlockSet, ...studentBlockSets]
    : studentBlockSets;

  // ê°œë°œ í™˜ê²½ì—ì„œ ë””ë²„ê¹… ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[CampParticipationPage] ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡:", {
      templateBlockSet: templateBlockSet
        ? {
            id: templateBlockSet.id,
            name: templateBlockSet.name,
            blocksCount: templateBlockSet.blocks?.length || 0,
          }
        : null,
      studentBlockSetsCount: studentBlockSets.length,
      totalBlockSetsCount: blockSets.length,
      templateBlockSetId: templateData?.block_set_id,
      willBeSelected: blockSets.some(
        (bs) => bs.id === templateData?.block_set_id
      ),
    });
  }

  // í…œí”Œë¦¿ ì œì™¸ì¼ì— sourceì™€ is_locked í•„ë“œ ì¶”ê°€
  const templateExclusions = (templateData?.exclusions || []).map(
    (exclusion) => ({
      ...exclusion,
      source: "template" as const,
      is_locked: true, // í…œí”Œë¦¿ì—ì„œ ì¶”ê°€í•œ ì œì™¸ì¼ì€ ì‚­ì œ ë¶ˆê°€
    })
  );

  // í…œí”Œë¦¿ í•™ì› ì¼ì •ì— sourceì™€ is_locked í•„ë“œ ì¶”ê°€
  const templateAcademySchedules = (templateData?.academy_schedules || []).map(
    (schedule) => ({
      ...schedule,
      source: "template" as const,
      is_locked: true, // í…œí”Œë¦¿ì—ì„œ ì¶”ê°€í•œ í•™ì› ì¼ì •ì€ ì‚­ì œ ë¶ˆê°€ (í•„ìš”ì‹œ)
    })
  );

  // Draft ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ í…œí”Œë¦¿ ë°ì´í„° ì‚¬ìš©
  const baseData = draftData || {
    ...templateData,
    name: template.name, // í…œí”Œë¦¿ ì´ë¦„ ì‚¬ìš©
    academy_schedules: templateAcademySchedules, // í…œí”Œë¦¿ í•™ì› ì¼ì • (í•™ìƒ ì¶”ê°€ ê°€ëŠ¥)
    student_contents: [], // í•™ìƒì´ ì„ íƒ
    recommended_contents: templateData?.recommended_contents || [], // í…œí”Œë¦¿ ì¶”ì²œ ì½˜í…ì¸ 
    exclusions: templateExclusions, // í…œí”Œë¦¿ ì œì™¸ì¼ (source, is_locked í¬í•¨)
  };

  // í•™ìƒì´ ì…ë ¥í•  ë¶€ë¶„ì€ ë¹ˆ ìƒíƒœë¡œ ì´ˆê¸°í™” (draftê°€ ì—†ì„ ë•Œë§Œ)
  const initialData = {
    ...baseData,
    // Draftê°€ ìˆìœ¼ë©´ draft ë°ì´í„° ì‚¬ìš©, ì—†ìœ¼ë©´ í…œí”Œë¦¿ ê¸°ë³¸ê°’ ì‚¬ìš©
    name: draftData?.name || template.name,
    academy_schedules: draftData?.academy_schedules || templateAcademySchedules,
    student_contents: draftData?.student_contents || [],
    recommended_contents:
      draftData?.recommended_contents ||
      templateData?.recommended_contents ||
      [],
    exclusions: draftData?.exclusions || templateExclusions,
    // ë¸”ë¡ì„¸íŠ¸ ID ëª…ì‹œì ìœ¼ë¡œ ì„¤ì • (ì—°ê²° í…Œì´ë¸”ì—ì„œ ê°€ì ¸ì˜¨ ë¸”ë¡ ì„¸íŠ¸ ID ì‚¬ìš©)
    // Draftê°€ ìˆì–´ë„ í…œí”Œë¦¿ì˜ ë¸”ë¡ ì„¸íŠ¸ë¥¼ ìš°ì„  ì‚¬ìš© (ìº í”„ ëª¨ë“œì—ì„œëŠ” í…œí”Œë¦¿ ë¸”ë¡ì„¸íŠ¸ ì‚¬ìš©)
    block_set_id: draftData?.block_set_id || templateBlockSet?.id || templateData?.block_set_id || "",
    // Draftì˜ groupId í¬í•¨ (ì €ì¥ ì‹œ ì—…ë°ì´íŠ¸ìš©)
    groupId: draftData?.groupId,
    // í…œí”Œë¦¿ ê³ ì • í•„ë“œ ì •ë³´ í¬í•¨ (í•™ìƒ ì…ë ¥ í—ˆìš© ì—¬ë¶€ ë“±)
    // templateLockedFieldsê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´ë¡œ ì´ˆê¸°í™”í•˜ì—¬ í•„ë“œê°€ ëª¨ë‘ í™œì„±í™”ë˜ë„ë¡ í•¨
    templateLockedFields: templateData?.templateLockedFields || {
      step1: {},
      step2: {},
    },
    // ê²€ì¦ ì—ëŸ¬ ì •ë³´ í¬í•¨ (PlanGroupWizardì—ì„œ ì‚¬ìš©)
    _validationErrors:
      validationErrors.length > 0 ? validationErrors : undefined,
  };

  return (
    <section className={getContainerClass("CAMP_PLAN", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1">
            <div className="flex flex-col gap-2">
              <h1 className="text-h1 text-gray-900">
                {template.name} ì°¸ì—¬í•˜ê¸°
              </h1>
              <p className="text-sm text-gray-700">
                í…œí”Œë¦¿ ê¸°ë°˜ ì •ë³´ë¥¼ í™•ì¸í•˜ê³ , í•™ì› ì¼ì •ê³¼ í•™ìŠµ ì½˜í…ì¸ ë¥¼
                ì…ë ¥í•´ì£¼ì„¸ìš”.
              </p>
            </div>
          </div>
          <Link
            href="/camp"
            className={inlineButtonBase("px-4 py-2 text-sm font-semibold")}
          >
            ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°
          </Link>
        </div>
      </div>

      <PlanGroupWizard
        initialBlockSets={blockSets || []}
        initialContents={{
          books,
          lectures,
          custom,
        }}
        initialData={{
          ...initialData,
          templateId: template.id, // í…œí”Œë¦¿ ID ì „ë‹¬ (ìº í”„ ëª¨ë“œì—ì„œ í…œí”Œë¦¿ ë¸”ë¡ ì¡°íšŒìš©)
        }}
        isCampMode={true}
        campInvitationId={invitationId}
        isEditMode={true}
      />
    </section>
  );
}
</file>

<file path="calendar/page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  getPlanGroupsForStudent,
  getPlanExclusions,
  getAcademySchedules,
} from "@/lib/data/planGroups";
import { getPlansForStudent } from "@/lib/data/studentPlans";
import { PlanCalendarView } from "@/app/(student)/plan/calendar/_components/PlanCalendarView";
import type { PlanExclusion, AcademySchedule } from "@/lib/types/plan";
import { getCampTemplate } from "@/lib/data/campTemplates";
import { requireTenantContext } from "@/lib/tenant/requireTenantContext";
import { getContainerClass } from "@/lib/constants/layout";

type CampCalendarPageProps = {
  searchParams: Promise<{ view?: string }>;
};

export default async function CampCalendarPage({
  searchParams,
}: CampCalendarPageProps) {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const params = await searchParams;
  const view =
    params.view === "week" ? "week" : params.view === "day" ? "day" : "month";

  // í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸ ì¡°íšŒ
  const tenantContext = await requireTenantContext();

  try {
    // í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ ì¡°íšŒ
    const allActivePlanGroups = await getPlanGroupsForStudent({
      studentId: user.id,
      status: "active",
    });

    // ìº í”„ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§
    const campModePlanGroups = allActivePlanGroups.filter(
      (group) =>
        group.plan_type === "camp" ||
        group.camp_template_id !== null ||
        group.camp_invitation_id !== null
    );

    // í…œí”Œë¦¿ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ì‚­ì œëœ í…œí”Œë¦¿ì˜ í”Œëœ ê·¸ë£¹ ì œì™¸)
    const activePlanGroups = await Promise.all(
      campModePlanGroups.map(async (group) => {
        // camp_template_idê°€ ìˆëŠ” ê²½ìš° í…œí”Œë¦¿ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        if (group.camp_template_id) {
          const template = await getCampTemplate(group.camp_template_id);
          // í…œí”Œë¦¿ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ null ë°˜í™˜ (í•„í„°ë§ë¨)
          return template ? group : null;
        }
        // camp_template_idê°€ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
        return group;
      })
    ).then((groups) => groups.filter((group): group is NonNullable<typeof group> => group !== null));

    if (activePlanGroups.length === 0) {
      return (
        <section className={getContainerClass("LIST", "md")}>
          <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-10 text-center">
            <div className="mx-auto flex max-w-md flex-col gap-4">
              <div className="text-6xl">ğŸ•ï¸</div>
              <h3 className="text-lg font-semibold text-gray-900">
                í™œì„±í™”ëœ ìº í”„ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤
              </h3>
              <p className="text-sm text-gray-500">
                ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ê³  í”Œëœì´ ìƒì„±ë˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </section>
      );
    }

    // í™œì„± í”Œëœ ê·¸ë£¹ì˜ ê¸°ê°„ ë²”ìœ„ ê³„ì‚°
    // period_startì™€ period_endë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ (YYYY-MM-DD í˜•ì‹)
    const dateRanges = activePlanGroups.map((group) => {
      // Date ê°ì²´ì´ë©´ ë¬¸ìì—´ë¡œ ë³€í™˜, ë¬¸ìì—´ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const startStr =
        typeof group.period_start === "string"
          ? group.period_start.slice(0, 10)
          : group.period_start
          ? String(group.period_start).slice(0, 10)
          : "";

      const endStr =
        typeof group.period_end === "string"
          ? group.period_end.slice(0, 10)
          : group.period_end
          ? String(group.period_end).slice(0, 10)
          : "";

      return {
        start: startStr,
        end: endStr,
      };
    });

    // ë‚ ì§œ ë²”ìœ„ê°€ ìœ íš¨í•œì§€ í™•ì¸í•˜ê³  ìµœì†Œ/ìµœëŒ€ ë‚ ì§œ ê³„ì‚°
    const validRanges = dateRanges.filter(
      (range) => range.start && range.end && range.start <= range.end
    );

    if (validRanges.length === 0) {
      // ì˜ëª»ëœ ë‚ ì§œ ë²”ìœ„ê°€ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
      console.error("[camp-calendar] ì˜ëª»ëœ ë‚ ì§œ ë²”ìœ„ë¥¼ ê°€ì§„ í”Œëœ ê·¸ë£¹ì´ ìˆìŠµë‹ˆë‹¤.");
      // ìœ íš¨í•˜ì§€ ì•Šì€ ë²”ìœ„ê°€ ìˆì–´ë„ ë¹ˆ ë²”ìœ„ë¡œ ì§„í–‰ (ì—ëŸ¬ UIëŠ” catchì—ì„œ ì²˜ë¦¬)
    }

    const today = new Date().toISOString().slice(0, 10);
    
    // ë‚ ì§œ ë¹„êµë¥¼ ìœ„í•´ ë¬¸ìì—´ë¡œ ë³€í™˜ëœ ë‚ ì§œë“¤ë§Œ ì‚¬ìš©
    const minDate =
      validRanges.length > 0
        ? validRanges
            .map((range) => range.start)
            .filter((date): date is string => typeof date === "string" && date.length === 10)
            .sort()[0] || today
        : today;
    
    const maxDate =
      validRanges.length > 0
        ? validRanges
            .map((range) => range.end)
            .filter((date): date is string => typeof date === "string" && date.length === 10)
            .sort((a, b) => b.localeCompare(a))[0] || today
        : today;
    
    // ìµœì¢…ì ìœ¼ë¡œ ë¬¸ìì—´ë¡œ ë³€í™˜ ë³´ì¥
    const minDateStr = typeof minDate === "string" ? minDate : new Date(minDate).toISOString().slice(0, 10);
    const maxDateStr = typeof maxDate === "string" ? maxDate : new Date(maxDate).toISOString().slice(0, 10);

    // í™œì„± í”Œëœ ê·¸ë£¹ ID ëª©ë¡
    const activeGroupIds = activePlanGroups.map((g) => g.id);

    // í™œì„± í”Œëœ ê·¸ë£¹ì— ì†í•œ í”Œëœë§Œ ì¡°íšŒ (ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ í•„í„°ë§)
    // ë‚ ì§œ í˜•ì‹ì´ ë¬¸ìì—´(YYYY-MM-DD)ì„ì„ ë³´ì¥
    const filteredPlans = await getPlansForStudent({
      studentId: user.id,
      dateRange: {
        start: minDateStr,
        end: maxDateStr,
      },
      planGroupIds: activeGroupIds, // ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ì—ì„œ í•„í„°ë§
    });

    // í”Œëœ ê·¸ë£¹ ë¶ˆì¼ì¹˜ í™•ì¸
    const planGroupIdsInPlans = [...new Set(filteredPlans.map((p) => p.plan_group_id).filter(Boolean))];
    const unmatchedGroupIds = planGroupIdsInPlans.filter((id): id is string => id != null && !activeGroupIds.includes(id));
    const hasUnmatchedPlans = unmatchedGroupIds.length > 0 || filteredPlans.some((p) => !p.plan_group_id);

    // êµê³¼ ì •ë³´ ë˜ëŠ” ì œëª©ì´ ì—†ëŠ” í”Œëœì˜ ì½˜í…ì¸  ID ìˆ˜ì§‘
    const missingContentIds = new Map<"book" | "lecture" | "custom", Set<string>>();
    missingContentIds.set("book", new Set());
    missingContentIds.set("lecture", new Set());
    missingContentIds.set("custom", new Set());
    
    filteredPlans.forEach((plan) => {
      const needsFetch = 
        (!plan.content_subject_category && !plan.content_subject) || 
        !plan.content_title;
      if (needsFetch && plan.content_id) {
        const contentType = plan.content_type;
        if (contentType && missingContentIds.has(contentType)) {
          missingContentIds.get(contentType)!.add(plan.content_id);
        }
      }
    });
    
    // ì½˜í…ì¸  í…Œì´ë¸”ì—ì„œ êµê³¼ ì •ë³´ ë° ì œëª© ì¡°íšŒ
    const contentSubjectMap = new Map<string, { subjectCategory: string | null; subject: string | null; title: string | null }>();
    
    for (const [contentType, contentIds] of missingContentIds.entries()) {
      if (contentIds.size === 0) continue;
      
      try {
        const tableName = contentType === "book" ? "books" : contentType === "lecture" ? "lectures" : "student_custom_contents";
        const selectField = contentType === "book" ? "id,subject_category,subject,title" : contentType === "lecture" ? "id,subject_category,subject,title" : "id,subject_category,subject,title";
        
        const { data, error } = await supabase
          .from(tableName)
          .select(selectField)
          .in("id", Array.from(contentIds));
        
        if (!error && data) {
          data.forEach((content: any) => {
            contentSubjectMap.set(content.id, {
              subjectCategory: content.subject_category || null,
              subject: content.subject || null,
              title: content.title || null,
            });
          });
        }
      } catch (error) {
        console.error(`[camp-calendar] ${contentType} êµê³¼ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨`, error);
      }
    }
    
    // í”Œëœì— ì½˜í…ì¸  ì •ë³´ ì¶”ê°€ (denormalized í•„ë“œ ì‚¬ìš© + ì¡°íšŒí•œ ì •ë³´ ë³´ì™„)
    const plansWithContent = filteredPlans.map((plan) => {
      // êµê³¼ ì •ë³´ (denormalized í•„ë“œ ìš°ì„ , ì—†ìœ¼ë©´ ì¡°íšŒí•œ ì •ë³´ ì‚¬ìš©, ë‘˜ ë‹¤ ì—†ìœ¼ë©´ null)
      const contentSubjectInfo = plan.content_id ? contentSubjectMap.get(plan.content_id) : null;
      const contentSubjectCategory = plan.content_subject_category || contentSubjectInfo?.subjectCategory || null;
      const contentSubject = plan.content_subject || contentSubjectInfo?.subject || null;
      
      // í”Œëœ íšŒì°¨ ì •ë³´ (sequence ì‚¬ìš©)
      let contentEpisode: string | null = null;
      if (plan.sequence !== null && plan.sequence !== undefined) {
        contentEpisode = `${plan.sequence}íšŒì°¨`;
      }
      
      return {
        ...plan,
        contentTitle: plan.content_title || contentSubjectInfo?.title || "ì œëª© ì—†ìŒ",
        contentSubject,
        contentSubjectCategory, // êµê³¼ (í•­ìƒ ì¼ê´€ë˜ê²Œ í‘œì‹œ)
        contentCategory: plan.content_category || null, // ìœ í˜•
        contentEpisode, // í”Œëœ íšŒì°¨
      };
    });

    // ì²« í”Œëœ ë‚ ì§œ ê³„ì‚° (í”Œëœì´ ìˆìœ¼ë©´ ì²« í”Œëœ ë‚ ì§œ, ì—†ìœ¼ë©´ ì˜¤ëŠ˜ ë‚ ì§œ)
    const firstPlanDate =
      plansWithContent.length > 0
        ? plansWithContent
            .map((plan) => plan.plan_date)
            .filter((date): date is string => date !== null)
            .sort()[0] || new Date().toISOString().slice(0, 10)
        : new Date().toISOString().slice(0, 10);

    // ì œì™¸ì¼ ì¡°íšŒ (í”Œëœ ê·¸ë£¹ë³„ ê´€ë¦¬)
    // í™œì„± í”Œëœ ê·¸ë£¹ë“¤ì˜ ì œì™¸ì¼ ì¡°íšŒ í›„ ë³‘í•©
    const exclusionsPromises = activePlanGroups.map((group) =>
      getPlanExclusions(group.id, tenantContext.tenantId)
    );
    const exclusionsArrays = await Promise.all(exclusionsPromises);
    
    // ì¤‘ë³µ ì œê±°: exclusion_date:exclusion_type ì¡°í•©ì´ ê°™ì€ ê²ƒì€ í•˜ë‚˜ë§Œ í‘œì‹œ
    const exclusionsMap = new Map();
    for (const exclusions of exclusionsArrays) {
      for (const exclusion of exclusions) {
        const key = `${exclusion.exclusion_date}:${exclusion.exclusion_type}`;
        if (!exclusionsMap.has(key)) {
          exclusionsMap.set(key, exclusion);
        }
      }
    }
    const exclusions = Array.from(exclusionsMap.values());

    // í•™ì›ì¼ì • ì¡°íšŒ (í”Œëœ ê·¸ë£¹ë³„ ê´€ë¦¬)
    // í™œì„± í”Œëœ ê·¸ë£¹ë“¤ì˜ í•™ì› ì¼ì • ì¡°íšŒ í›„ ë³‘í•©
    const academySchedulesPromises = activePlanGroups.map((group) =>
      getAcademySchedules(group.id, tenantContext.tenantId)
    );
    const academySchedulesArrays = await Promise.all(academySchedulesPromises);
    
    // ì¤‘ë³µ ì œê±°: day_of_week:start_time:end_time ì¡°í•©ì´ ê°™ì€ ê²ƒì€ í•˜ë‚˜ë§Œ í‘œì‹œ
    const academySchedulesMap = new Map();
    for (const schedules of academySchedulesArrays) {
      for (const schedule of schedules) {
        const key = `${schedule.day_of_week}:${schedule.start_time}:${schedule.end_time}`;
        if (!academySchedulesMap.has(key)) {
          academySchedulesMap.set(key, schedule);
        }
      }
    }
    const academySchedules = Array.from(academySchedulesMap.values());

    // í”Œëœ ê·¸ë£¹ì˜ daily_scheduleì—ì„œ ë‚ ì§œë³„ ì¼ì • íƒ€ì… ì •ë³´ ì¶”ì¶œ
    // Step7ì—ì„œ ìƒì„±ëœ ì •ë³´ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ì¬ê³„ì‚° ë¶ˆí•„ìš”)
    const dailySchedules = activePlanGroups
      .map((group) => group.daily_schedule)
      .filter((schedule): schedule is NonNullable<typeof schedule> => 
        schedule !== null && schedule !== undefined && Array.isArray(schedule)
      );

    // í†µê³„ ê³„ì‚°
    const totalPlans = plansWithContent.length;
    const completedPlans = plansWithContent.filter((p) => p.progress != null && p.progress >= 100).length;
    const activePlans = plansWithContent.filter((p) => p.actual_start_time && !p.actual_end_time).length;
    const averageProgress = totalPlans > 0
      ? Math.round(
          plansWithContent.reduce((sum, p) => sum + (p.progress || 0), 0) / totalPlans
        )
      : 0;

    return (
      <section className={getContainerClass("LIST", "md")}>
        <div className="flex flex-col gap-6">
          {/* í˜ì´ì§€ í—¤ë” - ì¹´ë“œ ìŠ¤íƒ€ì¼ */}
          <div className="rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
            <div className="flex flex-col gap-4 md:flex-row md:items-start md:justify-between">
              <div className="flex flex-1 flex-col gap-3">
                <h1 className="text-3xl font-bold text-gray-900">ìº í”„ í”Œëœ ìº˜ë¦°ë”</h1>
                <p className="text-sm text-gray-600">
                  í™œì„±í™”ëœ ìº í”„ í”Œëœ ê·¸ë£¹ì˜ í”Œëœì„ ìº˜ë¦°ë” í˜•ì‹ìœ¼ë¡œ í™•ì¸í•˜ì„¸ìš”
                </p>
                {/* í™œì„± í”Œëœ ê·¸ë£¹ ì •ë³´ í‘œì‹œ */}
                {activePlanGroups.length > 0 && (
                  <div className="flex flex-wrap items-center gap-2">
                    <span className="text-xs font-semibold text-gray-500">í™œì„± ìº í”„ í”Œëœ:</span>
                    {activePlanGroups.map((group) => (
                      <span
                        key={group.id}
                        className="inline-flex items-center gap-1.5 rounded-full bg-indigo-100 px-3 py-1.5 text-xs font-semibold text-indigo-800 border border-indigo-200"
                      >
                        <span className="h-2 w-2 rounded-full bg-indigo-600"></span>
                        {group.name || group.id.slice(0, 8)}
                      </span>
                    ))}
                  </div>
                )}
              </div>
              
              {/* í†µê³„ ìš”ì•½ */}
              <div className="flex flex-wrap gap-3 md:flex-nowrap">
                <div className="flex flex-col items-center gap-1 rounded-lg bg-gray-50 px-4 py-3 border border-gray-200 min-w-[80px]">
                  <span className="text-xs font-medium text-gray-500">ì´ í”Œëœ</span>
                  <span className="text-2xl font-bold text-gray-900">{totalPlans}</span>
                </div>
                <div className="flex flex-col items-center gap-1 rounded-lg bg-green-50 px-4 py-3 border border-green-200 min-w-[80px]">
                  <span className="text-xs font-medium text-green-700">ì™„ë£Œ</span>
                  <span className="text-2xl font-bold text-green-600">{completedPlans}</span>
                </div>
                {activePlans > 0 && (
                  <div className="flex flex-col items-center gap-1 rounded-lg bg-blue-50 px-4 py-3 border border-blue-200 min-w-[80px]">
                    <span className="text-xs font-medium text-blue-700">ì§„í–‰ì¤‘</span>
                    <span className="text-2xl font-bold text-blue-600">{activePlans}</span>
                  </div>
                )}
                {averageProgress > 0 && (
                  <div className="flex flex-col items-center gap-1 rounded-lg bg-indigo-50 px-4 py-3 border border-indigo-200 min-w-[80px]">
                    <span className="text-xs font-medium text-indigo-700">í‰ê·  ì§„í–‰ë¥ </span>
                    <span className="text-2xl font-bold text-indigo-600">{averageProgress}%</span>
                  </div>
                )}
              </div>
            </div>
            {/* ë¶ˆì¼ì¹˜ ê²½ê³  */}
            {hasUnmatchedPlans && (
              <div className="flex flex-col gap-1 rounded-lg border-2 border-yellow-300 bg-yellow-50 p-4 text-sm text-yellow-800 shadow-sm">
                <div className="font-bold">âš ï¸ í”Œëœ ê·¸ë£¹ ë¶ˆì¼ì¹˜ ê°ì§€</div>
                <div className="text-xs space-y-1">
                  {unmatchedGroupIds.length > 0 && (
                    <div>
                      í™œì„±í™”ë˜ì§€ ì•Šì€ í”Œëœ ê·¸ë£¹ì˜ í”Œëœì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤: {unmatchedGroupIds.length}ê°œ
                    </div>
                  )}
                  {filteredPlans.some((p) => !p.plan_group_id) && (
                    <div>
                      í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” í”Œëœì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤: {filteredPlans.filter((p) => !p.plan_group_id).length}ê°œ
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>

          <PlanCalendarView
            plans={plansWithContent}
            view={view}
            minDate={minDateStr}
            maxDate={maxDateStr}
            initialDate={firstPlanDate}
            exclusions={exclusions}
            academySchedules={academySchedules}
            dailySchedules={dailySchedules}
          />
        </div>
      </section>
    );
  } catch (error) {
    console.error("[camp-calendar] ìº í”„ í”Œëœ ìº˜ë¦°ë” ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨", error);
    
    // ì‚¬ìš©ì ì¹œí™”ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
    return (
      <section className={getContainerClass("LIST", "md")}>
        <div className="rounded-xl border border-red-200 bg-red-50 p-10 text-center">
          <div className="mx-auto flex max-w-md flex-col gap-4">
            <div className="text-6xl">âš ï¸</div>
            <h3 className="text-lg font-semibold text-red-900">
              ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-red-700">
              ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”. ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.
            </p>
          </div>
        </div>
      </section>
    );
  }
}
</file>

<file path="today/page.tsx">
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import type { ReadonlyURLSearchParams } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import type { TodayProgress } from "@/lib/metrics/todayProgress";
import { TodayHeader } from "@/app/(student)/today/_components/TodayHeader";
import { TodayPlansSection } from "@/app/(student)/today/_components/TodayPlansSection";
import { TodayAchievementsSection } from "@/app/(student)/today/_components/TodayAchievementsSection";
import { TodayPageContextProvider } from "@/app/(student)/today/_components/TodayPageContext";
import { CurrentLearningSection } from "@/app/(student)/today/_components/CurrentLearningSection";
import { CompletionToast } from "@/app/(student)/today/_components/CompletionToast";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCampTemplate } from "@/lib/data/campTemplates";
import { getPlanById } from "@/lib/data/studentPlans";
import { getTodayPlans } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";
import { getContainerClass } from "@/lib/constants/layout";

type CampTodayPageProps = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function CampTodayPage({ searchParams }: CampTodayPageProps) {
  const pageTimer = perfTime("[camp/today] render - page");
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "student") {
    pageTimer.end();
    redirect("/login");
  }

  const user = await getCurrentUser();
  const tenantContext = await getTenantContext();

  const resolveSearchParams = async () => {
    return await searchParams;
  };

  const resolvedSearchParams = await resolveSearchParams();

  const isSearchParamsLike = (
    value: unknown
  ): value is URLSearchParams | ReadonlyURLSearchParams => {
    return (
      typeof value === "object" &&
      value !== null &&
      typeof (value as URLSearchParams).get === "function"
    );
  };

  const normalizeParam = (
    value: string | string[] | undefined | null
  ): string | undefined => {
    if (Array.isArray(value)) {
      return value[0];
    }
    return value ?? undefined;
  };

  const getParam = (key: string): string | undefined => {
    if (isSearchParamsLike(resolvedSearchParams)) {
      return resolvedSearchParams.get(key) ?? undefined;
    }
    if (
      resolvedSearchParams &&
      typeof resolvedSearchParams === "object" &&
      !Array.isArray(resolvedSearchParams)
    ) {
      const record = resolvedSearchParams as Record<
        string,
        string | string[] | undefined
      >;
      return normalizeParam(record[key]);
    }
    return undefined;
  };

  const dateParam = getParam("date");
  const viewParam = getParam("view");
  const completedPlanIdParam = getParam("completedPlanId");

  const requestedDate =
    typeof dateParam === "string" && /^\d{4}-\d{2}-\d{2}$/.test(dateParam)
      ? dateParam
      : undefined;

  const requestedView =
    viewParam === "single" || viewParam === "daily" ? viewParam : "daily";

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  const targetProgressDate = requestedDate ?? todayDate;

  // í™œì„±í™”ëœ ìº í”„ í”Œëœ ê·¸ë£¹ í™•ì¸ ë° í…œí”Œë¦¿ ê²€ì¦
  const supabase = await createSupabaseServerClient();
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId: userId,
    status: "active",
  });

  // ìº í”„ ëª¨ë“œ í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§
  const campModePlanGroups = allActivePlanGroups.filter(
    (group) =>
      group.plan_type === "camp" ||
      group.camp_template_id !== null ||
      group.camp_invitation_id !== null
  );

  // í…œí”Œë¦¿ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ì‚­ì œëœ í…œí”Œë¦¿ì˜ í”Œëœ ê·¸ë£¹ ì œì™¸)
  const activeCampPlanGroups = await Promise.all(
    campModePlanGroups.map(async (group) => {
      // camp_template_idê°€ ìˆëŠ” ê²½ìš° í…œí”Œë¦¿ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
      if (group.camp_template_id) {
        const template = await getCampTemplate(group.camp_template_id);
        // í…œí”Œë¦¿ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ null ë°˜í™˜ (í•„í„°ë§ë¨)
        return template ? group : null;
      }
      // camp_template_idê°€ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
      return group;
    })
  ).then((groups) => groups.filter((group): group is NonNullable<typeof group> => group !== null));

  // í™œì„± ìº í”„ í”Œëœ ê·¸ë£¹ì´ ì—†ì„ ë•Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
  if (activeCampPlanGroups.length === 0) {
    pageTimer.end();
    return (
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-1">
              <h1 className="text-2xl font-bold text-gray-900">ìº í”„ í•™ìŠµê´€ë¦¬</h1>
              <p className="text-sm text-gray-600">
                ìº í”„ í”Œëœì„ í™•ì¸í•˜ê³  í•™ìŠµì„ ì§„í–‰í•˜ì„¸ìš”
              </p>
            </div>
          </div>
          <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-10 text-center">
            <div className="mx-auto flex max-w-md flex-col gap-4">
              <div className="text-6xl">ğŸ•ï¸</div>
              <h3 className="text-lg font-semibold text-gray-900">
                í™œì„±í™”ëœ ìº í”„ í”Œëœ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤
              </h3>
              <p className="text-sm text-gray-500">
                ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ê³  í”Œëœì´ í™œì„±í™”ë˜ë©´ ì—¬ê¸°ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ (í† ìŠ¤íŠ¸ìš©)
  let completedPlanTitle: string | null = null;
  if (completedPlanIdParam) {
    try {
      const completedPlan = await getPlanById(
        completedPlanIdParam,
        userId,
        tenantContext?.tenantId || null
      );
      if (completedPlan) {
        completedPlanTitle = completedPlan.content_title || null;
      }
    } catch (error) {
      console.error("[CampTodayPage] ì™„ë£Œëœ í”Œëœ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
  }

  // Single server-side fetch for today's plans to avoid double-fetch
  // TodayPageContent is rendered twice (main + sidebar), and without this,
  // each instance would trigger its own client-side fetch via PlanViewContainer
  // This also includes todayProgress calculation, eliminating the need for a separate progress query
  const todayPlansTimer = perfTime("[camp/today] data - todayPlans");
  const todayPlansData = await getTodayPlans({
    studentId: userId,
    tenantId: tenantContext?.tenantId || null,
    date: requestedDate,
    camp: true,
    includeProgress: true, // Include progress to avoid separate /api/today/progress call
    narrowQueries: true, // Optimize: only fetch progress/sessions for relevant plans
    useCache: true, // Use cache for repeated calls
    cacheTtlSeconds: 60, // 1 minute TTL for camp mode (shorter than default)
  });
  todayPlansTimer.end();

  // Extract todayProgress from the result (computed in-memory, no additional DB query)
  // This replaces the previous ~0.6-1.28s calculateTodayProgress call
  const todayProgress: TodayProgress = todayPlansData.todayProgress ?? {
    todayStudyMinutes: 0,
    planCompletedCount: 0,
    planTotalCount: 0,
    achievementScore: 0,
  };

  // todayPlansDataë¥¼ PlansResponse í˜•íƒœë¡œ ë³€í™˜
  const plansDataForContext = todayPlansData
    ? {
        plans: todayPlansData.plans,
        sessions: todayPlansData.sessions,
        planDate: todayPlansData.planDate,
        isToday: todayPlansData.isToday,
        serverNow: todayPlansData.serverNow,
        todayProgress: todayPlansData.todayProgress,
      }
    : undefined;

  const page = (
    <TodayPageContextProvider
      initialProgressDate={targetProgressDate}
      initialProgress={todayProgress}
      initialPlansData={plansDataForContext}
    >
      <div className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-1">
              <h1 className="text-2xl font-bold text-gray-900">ìº í”„ í•™ìŠµê´€ë¦¬</h1>
              <p className="text-sm text-gray-600">
                ìº í”„ í”Œëœì„ í™•ì¸í•˜ê³  í•™ìŠµì„ ì§„í–‰í•˜ì„¸ìš”
              </p>
            </div>
          </div>
          <CurrentLearningSection campMode={true} />
          <CompletionToast completedPlanId={completedPlanIdParam} planTitle={completedPlanTitle} />
          <div className="grid grid-cols-1 gap-6 lg:grid-cols-12">
            <div className="lg:col-span-8">
              <TodayPlansSection
                initialMode={requestedView}
                initialPlanDate={requestedDate}
                userId={userId}
                campMode={true}
                initialPlansData={plansDataForContext}
              />
            </div>
            <div className="lg:col-span-4">
              <div className="sticky top-6 flex flex-col gap-4">
                <TodayAchievementsSection />
              </div>
            </div>
          </div>
        </div>
      </div>
    </TodayPageContextProvider>
  );
  pageTimer.end();
  return page;
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentCampInvitations } from "../actions/campActions";
import { CampInvitationCard } from "./_components/CampInvitationCard";
import { getContainerClass } from "@/lib/constants/layout";

export default async function CampPage() {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  const result = await getStudentCampInvitations();

  // í”Œëœ ê·¸ë£¹ ë° í”Œëœ ìƒì„± ìƒíƒœ ì¡°íšŒ
  const invitationsWithPlanStatus = await Promise.all(
    (result.success && result.invitations.length > 0 ? result.invitations : []).map(async (invitation) => {
      // í”Œëœ ê·¸ë£¹ ì¡°íšŒ (acceptedì™€ pending ëª¨ë‘ ì¡°íšŒ)
      const { data: planGroup } = await supabase
        .from("plan_groups")
        .select("id, status, period_start, period_end")
        .eq("camp_invitation_id", invitation.id)
        .maybeSingle();

      if (!planGroup) {
        return { 
          ...invitation, 
          planGroupId: null, 
          planGroupStatus: null,
          hasPlans: false,
          isDraft: false,
          periodStart: null,
          periodEnd: null,
        };
      }

      // í”Œëœ ìƒì„± ì—¬ë¶€ í™•ì¸
      const { data: plans } = await supabase
        .from("student_plan")
        .select("id")
        .eq("plan_group_id", planGroup.id)
        .limit(1);

      return {
        ...invitation,
        planGroupId: planGroup.id,
        planGroupStatus: planGroup.status,
        hasPlans: (plans?.length || 0) > 0,
        isDraft: planGroup.status === "draft",
        periodStart: planGroup.period_start || null,
        periodEnd: planGroup.period_end || null,
      };
    })
  );

  return (
    <section className={getContainerClass("LIST", "lg")}>
      <div className="flex flex-col gap-8">
        <div className="flex flex-col gap-2">
          <p className="text-sm font-medium text-gray-500">ìº í”„ í”„ë¡œê·¸ë¨</p>
          <h1 className="text-3xl font-semibold text-gray-900">ìº í”„ ì°¸ì—¬</h1>
          <p className="text-sm text-gray-500">
            ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì— ì°¸ì—¬í•˜ì„¸ìš”.
          </p>
        </div>
        {!result.success || invitationsWithPlanStatus.length === 0 ? (
        <div className="rounded-lg border border-gray-200 bg-white p-8 text-center">
          <p className="text-gray-500">ì´ˆëŒ€ë°›ì€ ìº í”„ í”„ë¡œê·¸ë¨ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="grid gap-4">
          {invitationsWithPlanStatus.map((invitation) => {
            // í´ë¦­ ì‹œ ì´ë™í•  ê²½ë¡œ ê²°ì •
            const getDetailLink = () => {
              // pending ìƒíƒœì¸ ê²½ìš° í•­ìƒ ì°¸ì—¬ í˜ì´ì§€ë¡œ
              if (invitation.status === "pending") {
                return `/camp/${invitation.id}`;
              }
              
              // accepted ìƒíƒœì¸ ê²½ìš°
              if (invitation.status === "accepted") {
                // í”Œëœ ê·¸ë£¹ì´ ìˆê³  í”Œëœì´ ìƒì„±ëœ ê²½ìš° í”Œëœ ê·¸ë£¹ ìƒì„¸ë¡œ (ìº í”„ ëª¨ë“œ í‘œì‹œ)
                if (invitation.planGroupId && invitation.hasPlans) {
                  return `/plan/group/${invitation.planGroupId}?camp=true`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ìˆì§€ë§Œ í”Œëœì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ê²½ìš° ì œì¶œ ì™„ë£Œ ìƒì„¸ë¡œ
                // (ì œì¶œ ì™„ë£Œ í˜ì´ì§€ëŠ” í”Œëœ ê·¸ë£¹ì´ í•„ìˆ˜ì´ë¯€ë¡œ planGroupIdê°€ ìˆì„ ë•Œë§Œ)
                if (invitation.planGroupId) {
                  return `/camp/${invitation.id}/submitted`;
                }
                // í”Œëœ ê·¸ë£¹ì´ ì—†ëŠ” ê²½ìš°ëŠ” ì´ìƒí•œ ì¼€ì´ìŠ¤ì´ë¯€ë¡œ ì°¸ì—¬ í˜ì´ì§€ë¡œ (ì•ˆì „ì¥ì¹˜)
                return `/camp/${invitation.id}`;
              }
              
              // ê¸°ë³¸ê°’: ì°¸ì—¬ í˜ì´ì§€ (ì•ˆì „ì¥ì¹˜)
              return `/camp/${invitation.id}`;
            };

            const detailLink = getDetailLink();

            // templateì˜ null ê°’ì„ undefinedë¡œ ë³€í™˜í•˜ì—¬ íƒ€ì… í˜¸í™˜ì„± í™•ë³´
            const invitationForCard = {
              ...invitation,
              template: invitation.template
                ? {
                    name: invitation.template.name,
                    program_type: invitation.template.program_type || undefined,
                    description: invitation.template.description ?? undefined,
                    camp_location: invitation.template.camp_location ?? undefined,
                    camp_start_date: invitation.template.camp_start_date ?? undefined,
                    camp_end_date: invitation.template.camp_end_date ?? undefined,
                  }
                : null,
            };

            return (
              <CampInvitationCard
                key={invitation.id}
                invitation={invitationForCard}
                detailLink={detailLink}
              />
            );
          })}
        </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="admin/studentData.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getPlansForStudent } from "@/lib/data/studentPlans";
import { getBooks, getLectures, getCustomContents } from "@/lib/data/studentContents";
import { getSessionsInRange } from "@/lib/data/studentSessions";
import { getGoalsForStudent } from "@/lib/data/studentGoals";
import { getWeeklyStudyTimeSummary, getWeeklyPlanSummary } from "@/lib/reports/weekly";
import { getMonthlyReportData } from "@/lib/reports/monthly";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * ê´€ë¦¬ììš©: í•™ìƒì˜ í”Œëœ ëª©ë¡ ì¡°íšŒ
 */
export async function getStudentPlansForAdmin(
  studentId: string,
  dateRange?: { start: string; end: string }
) {
  try {
    const filters: Parameters<typeof getPlansForStudent>[0] = {
      studentId,
      tenantId: null,
    };

    if (dateRange) {
      filters.dateRange = dateRange;
    }

    return await getPlansForStudent(filters);
  } catch (error) {
    console.error("[admin/studentData] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

/**
 * ê´€ë¦¬ììš©: í•™ìƒì˜ í•™ìŠµì‹œê°„ ì¡°íšŒ
 */
export async function getStudentStudyTimeForAdmin(
  studentId: string,
  dateRange: { start: Date; end: Date }
) {
  try {
    const supabase = await createSupabaseServerClient();
    return await getWeeklyStudyTimeSummary(supabase, studentId, dateRange.start, dateRange.end);
  } catch (error) {
    console.error("[admin/studentData] í•™ìŠµì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      totalSeconds: 0,
      totalMinutes: 0,
      totalHours: 0,
      byDay: [],
      bySubject: [],
      byContentType: [],
    };
  }
}

/**
 * ê´€ë¦¬ììš©: í•™ìƒì˜ ì½˜í…ì¸  ì‚¬ìš© í˜„í™© ì¡°íšŒ
 */
export async function getStudentContentUsageForAdmin(studentId: string) {
  try {
    const supabase = await createSupabaseServerClient();
    const [books, lectures, customContents] = await Promise.allSettled([
      getBooks(studentId, null),
      getLectures(studentId, null),
      getCustomContents(studentId, null),
    ]);

    // ì§„í–‰ë¥  ì¡°íšŒ
    const { data: progressData, error: progressError } = await supabase
      .from("student_content_progress")
      .select("content_type,content_id,progress,completed_amount")
      .eq("student_id", studentId);

    const progressMap = new Map<string, { progress: number; completedAmount: number }>();
    if (!progressError && progressData) {
      progressData.forEach((p) => {
        if (p.content_type && p.content_id) {
          const key = `${p.content_type}:${p.content_id}`;
          progressMap.set(key, {
            progress: p.progress ?? 0,
            completedAmount: p.completed_amount ?? 0,
          });
        }
      });
    }

    return {
      books: books.status === "fulfilled" ? books.value : [],
      lectures: lectures.status === "fulfilled" ? lectures.value : [],
      customContents: customContents.status === "fulfilled" ? customContents.value : [],
      progressMap,
    };
  } catch (error) {
    console.error("[admin/studentData] ì½˜í…ì¸  ì‚¬ìš© í˜„í™© ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      books: [],
      lectures: [],
      customContents: [],
      progressMap: new Map(),
    };
  }
}

/**
 * ê´€ë¦¬ììš©: í•™ìƒì˜ ì„±ì  ë³€í™” ì¡°íšŒ
 */
export async function getStudentScoreTrendForAdmin(studentId: string) {
  try {
    const supabase = await createSupabaseServerClient();

    // ë‚´ì‹  ì„±ì  ì¡°íšŒ
    const { data: schoolScores, error: schoolError } = await supabase
      .from("student_internal_scores") // student_school_scores â†’ student_internal_scores
      .select("id,grade,semester,subject_name,grade_score,test_date")
      .eq("student_id", studentId)
      .order("test_date", { ascending: true });

    // ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ
    const { data: mockScores, error: mockError } = await supabase
      .from("student_mock_scores")
      .select("id,grade,subject_name,grade_score,test_date,exam_type")
      .eq("student_id", studentId)
      .order("test_date", { ascending: true });

    return {
      schoolScores: schoolError ? [] : (schoolScores ?? []),
      mockScores: mockError ? [] : (mockScores ?? []),
    };
  } catch (error) {
    console.error("[admin/studentData] ì„±ì  ë³€í™” ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      schoolScores: [],
      mockScores: [],
    };
  }
}

/**
 * ê´€ë¦¬ììš©: í•™ìƒì˜ ë¶„ì„ ë¦¬í¬íŠ¸ ì¡°íšŒ
 */
export async function getStudentAnalysisForAdmin(studentId: string) {
  try {
    const supabase = await createSupabaseServerClient();

    // ì´ë²ˆ ì£¼ ë‚ ì§œ ë²”ìœ„
    const today = new Date();
    const dayOfWeek = today.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    // ì´ë²ˆ ë‹¬ ë‚ ì§œ ë²”ìœ„
    const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
    monthStart.setHours(0, 0, 0, 0);

    const [weeklyStudyTime, weeklyPlanSummary, monthlyReport] = await Promise.allSettled([
      getWeeklyStudyTimeSummary(supabase, studentId, weekStart, weekEnd),
      getWeeklyPlanSummary(supabase, studentId, weekStart, weekEnd),
      getMonthlyReportData(supabase, studentId, today),
    ]);

    // ìœ„í—˜ ë¶„ì„ ì¡°íšŒ
    const { data: riskAnalysis, error: riskError } = await supabase
      .from("student_analysis")
      .select("subject,risk_score,recent_grade_trend,consistency_score,mastery_estimate")
      .eq("student_id", studentId)
      .order("risk_score", { ascending: false });

    return {
      weeklyStudyTime:
        weeklyStudyTime.status === "fulfilled" ? weeklyStudyTime.value : null,
      weeklyPlanSummary:
        weeklyPlanSummary.status === "fulfilled" ? weeklyPlanSummary.value : null,
      monthlyReport: monthlyReport.status === "fulfilled" ? monthlyReport.value : null,
      riskAnalysis: riskError ? [] : (riskAnalysis ?? []),
    };
  } catch (error) {
    console.error("[admin/studentData] ë¶„ì„ ë¦¬í¬íŠ¸ ì¡°íšŒ ì‹¤íŒ¨", error);
    return {
      weeklyStudyTime: null,
      weeklyPlanSummary: null,
      monthlyReport: null,
      riskAnalysis: [],
    };
  }
}
</file>

<file path="core/baseRepository.ts">
/**
 * ê¸°ë³¸ Repository íŒ¨í„´
 * ê³µí†µ CRUD ì‘ì—…ì„ ìœ„í•œ ë² ì´ìŠ¤ í´ë˜ìŠ¤
 */

import type { SupabaseServerClient } from "./types";
import { executeQuery, executeSingleQuery } from "./queryBuilder";
import { createSupabaseServerClient } from "@/lib/supabase/server";

/**
 * Repository ì˜µì…˜
 */
export interface RepositoryOptions {
  /**
   * Supabase í´ë¼ì´ì–¸íŠ¸ (ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ìë™ ìƒì„±)
   */
  supabase?: SupabaseServerClient;
  /**
   * í…Œì´ë¸” ì´ë¦„
   */
  tableName: string;
  /**
   * ì—ëŸ¬ ë¡œê¹… ì»¨í…ìŠ¤íŠ¸
   */
  context?: string;
}

/**
 * ê¸°ë³¸ Repository í´ë˜ìŠ¤
 * 
 * @example
 * ```typescript
 * class StudentRepository extends BaseRepository<Student> {
 *   constructor(supabase?: SupabaseServerClient) {
 *     super({
 *       tableName: "students",
 *       context: "[data/students]",
 *       supabase,
 *     });
 *   }
 * }
 * ```
 */
export abstract class BaseRepository<T extends { id: string }> {
  protected supabase: SupabaseServerClient;
  protected tableName: string;
  protected context: string;

  constructor(options: RepositoryOptions) {
    this.tableName = options.tableName;
    this.context = options.context || `[data/${options.tableName}]`;
    this.supabase = options.supabase as SupabaseServerClient;
  }

  /**
   * Supabase í´ë¼ì´ì–¸íŠ¸ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ ìƒì„±)
   */
  protected async getSupabase(): Promise<SupabaseServerClient> {
    if (this.supabase) {
      return this.supabase;
    }
    return await createSupabaseServerClient();
  }

  /**
   * IDë¡œ ë‹¨ì¼ ë ˆì½”ë“œ ì¡°íšŒ
   */
  async findById(id: string): Promise<T | null> {
    const supabase = await this.getSupabase();
    return executeSingleQuery<T>(
      async () => {
        const result = await supabase
          .from(this.tableName)
          .select("*")
          .eq("id", id)
          .maybeSingle();
        return result;
      },
      {
        context: this.context,
        defaultValue: null,
      }
    );
  }

  /**
   * ì—¬ëŸ¬ IDë¡œ ë ˆì½”ë“œ ì¡°íšŒ
   */
  async findByIds(ids: string[]): Promise<T[]> {
    if (ids.length === 0) {
      return [];
    }

    const supabase = await this.getSupabase();
    const result = await executeQuery<T[]>(
      async () => {
        const queryResult = await supabase
          .from(this.tableName)
          .select("*")
          .in("id", ids);
        return queryResult;
      },
      {
        context: this.context,
        defaultValue: [],
      }
    );

    return result ?? [];
  }

  /**
   * ë ˆì½”ë“œ ìƒì„±
   */
  async create(data: Omit<T, "id" | "created_at" | "updated_at">): Promise<{
    success: boolean;
    data?: T;
    error?: string;
  }> {
    const supabase = await this.getSupabase();
    const { data: created, error } = await supabase
      .from(this.tableName)
      .insert(data as unknown)
      .select()
      .single();

    if (error) {
      return {
        success: false,
        error: error.message || "ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return {
      success: true,
      data: created as T,
    };
  }

  /**
   * ë ˆì½”ë“œ ì—…ë°ì´íŠ¸
   */
  async update(
    id: string,
    data: Partial<Omit<T, "id" | "created_at" | "updated_at">>
  ): Promise<{
    success: boolean;
    data?: T;
    error?: string;
  }> {
    const supabase = await this.getSupabase();
    const { data: updated, error } = await supabase
      .from(this.tableName)
      .update(data as unknown)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      return {
        success: false,
        error: error.message || "ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return {
      success: true,
      data: updated as T,
    };
  }

  /**
   * ë ˆì½”ë“œ ì‚­ì œ (Hard Delete)
   */
  async delete(id: string): Promise<{
    success: boolean;
    error?: string;
  }> {
    const supabase = await this.getSupabase();
    const { error } = await supabase
      .from(this.tableName)
      .delete()
      .eq("id", id);

    if (error) {
      return {
        success: false,
        error: error.message || "ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return { success: true };
  }

  /**
   * ë ˆì½”ë“œ Soft Delete (deleted_at ì„¤ì •)
   */
  async softDelete(id: string): Promise<{
    success: boolean;
    error?: string;
  }> {
    const supabase = await this.getSupabase();
    const { error } = await supabase
      .from(this.tableName)
      .update({ deleted_at: new Date().toISOString() })
      .eq("id", id);

    if (error) {
      return {
        success: false,
        error: error.message || "ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return { success: true };
  }
}
</file>

<file path="core/errorHandler.ts">
/**
 * ê³µí†µ ì—ëŸ¬ ì²˜ë¦¬ ìœ í‹¸ë¦¬í‹°
 * ë°ì´í„° í˜ì¹­ í•¨ìˆ˜ì—ì„œ ì¼ê´€ëœ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ë“¤
 */

import type { PostgrestError } from "@supabase/supabase-js";

/**
 * Supabase ì—ëŸ¬ íƒ€ì…
 */
export type SupabaseError = PostgrestError;

/**
 * ì—ëŸ¬ ì²˜ë¦¬ ì˜µì…˜
 */
export type ErrorHandlingOptions = {
  /**
   * ì—ëŸ¬ ë¡œê¹… ì—¬ë¶€
   * @default true
   */
  logError?: boolean;
  /**
   * ì—ëŸ¬ ë¡œê¹… ì‹œ ì‚¬ìš©í•  ì»¨í…ìŠ¤íŠ¸ (íŒŒì¼ëª…, í•¨ìˆ˜ëª… ë“±)
   */
  context?: string;
  /**
   * ì—ëŸ¬ ë°œìƒ ì‹œ ë°˜í™˜í•  ê¸°ë³¸ê°’
   */
  defaultValue?: unknown;
  /**
   * ë¬´ì‹œí•  ì—ëŸ¬ ì½”ë“œ ëª©ë¡ (ì˜ˆ: PGRST116 - no rows returned)
   */
  ignoreErrorCodes?: string[];
};

/**
 * ê¸°ë³¸ ë¬´ì‹œí•  ì—ëŸ¬ ì½”ë“œ
 */
const DEFAULT_IGNORE_ERROR_CODES = ["PGRST116"];

/**
 * ì—ëŸ¬ë¥¼ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•˜ê³  ë¡œê¹…
 */
export function handleQueryError(
  error: PostgrestError | null,
  options: ErrorHandlingOptions = {}
): boolean {
  if (!error) {
    return false;
  }

  const {
    logError = true,
    context = "[data]",
    ignoreErrorCodes = DEFAULT_IGNORE_ERROR_CODES,
  } = options;

  // ë¬´ì‹œí•  ì—ëŸ¬ ì½”ë“œì¸ ê²½ìš°
  if (ignoreErrorCodes.includes(error.code || "")) {
    return false; // ì—ëŸ¬ê°€ ì•„ë‹ˆë¯€ë¡œ ì²˜ë¦¬í•  í•„ìš” ì—†ìŒ
  }

  // ì—ëŸ¬ ë¡œê¹…
  if (logError) {
    // ì—ëŸ¬ ê°ì²´ë¥¼ ì•ˆì „í•˜ê²Œ ì§ë ¬í™”
    const errorInfo: Record<string, unknown> = {};
    
    // ê¸°ë³¸ ì†ì„± ì¶”ì¶œ
    if (error.message) {
      errorInfo.message = error.message;
    }
    if (error.code) {
      errorInfo.code = error.code;
    }
    
    // ì—ëŸ¬ ê°ì²´ì˜ ëª¨ë“  ì—´ê±° ê°€ëŠ¥í•œ ì†ì„± ì¶”ì¶œ
    try {
      Object.keys(error).forEach((key) => {
        const value = (error as unknown as Record<string, unknown>)[key];
        // ìˆœí™˜ ì°¸ì¡° ë°©ì§€ ë° ì§ë ¬í™” ê°€ëŠ¥í•œ ê°’ë§Œ í¬í•¨
        if (value !== null && typeof value !== "function" && typeof value !== "object") {
          errorInfo[key] = value;
        } else if (typeof value === "object" && value !== null) {
          try {
            // ê°ì²´ì¸ ê²½ìš° JSON ì§ë ¬í™” ì‹œë„
            JSON.stringify(value);
            errorInfo[key] = value;
          } catch {
            // ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ë¬¸ìì—´ë¡œ ë³€í™˜
            errorInfo[key] = String(value);
          }
        }
      });
    } catch (e) {
      // ì†ì„± ì¶”ì¶œ ì‹¤íŒ¨ ì‹œ ìµœì†Œí•œì˜ ì •ë³´ë¼ë„ ë¡œê¹…
      errorInfo.errorString = String(error);
    }
    
    // PostgrestErrorì˜ í‘œì¤€ ì†ì„±ë“¤ ëª…ì‹œì ìœ¼ë¡œ í™•ì¸
    if ("details" in error && error.details) {
      errorInfo.details = error.details;
    }
    if ("hint" in error && error.hint) {
      errorInfo.hint = error.hint;
    }
    if ("statusCode" in error && (error as { statusCode?: unknown }).statusCode) {
      errorInfo.statusCode = (error as { statusCode?: unknown }).statusCode;
    }

    // ìµœì†Œí•œì˜ ì •ë³´ê°€ ìˆëŠ”ì§€ í™•ì¸
    if (Object.keys(errorInfo).length === 0) {
      errorInfo.errorString = String(error);
      errorInfo.errorType = typeof error;
      errorInfo.errorConstructor = error?.constructor?.name || "Unknown";
    }

    console.error(`${context} ì¿¼ë¦¬ ì—ëŸ¬:`, errorInfo);
  }

  return true; // ì—ëŸ¬ê°€ ìˆìŒ
}

/**
 * ì—ëŸ¬ê°€ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸ (ë¬´ì‹œí•  ì—ëŸ¬ ì½”ë“œ ì œì™¸)
 */
export function isError(
  error: PostgrestError | null,
  ignoreErrorCodes: string[] = DEFAULT_IGNORE_ERROR_CODES
): boolean {
  if (!error) {
    return false;
  }

  return !ignoreErrorCodes.includes(error.code || "");
}

/**
 * 42703 ì—ëŸ¬ ì½”ë“œ í™•ì¸ (ì»¬ëŸ¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œ)
 */
export function isColumnNotFoundError(error: PostgrestError | null): boolean {
  return error?.code === "42703";
}
</file>

<file path="core/index.ts">
/**
 * ë°ì´í„° í˜ì¹­ ì½”ì–´ ëª¨ë“ˆ
 * ê³µí†µ ë°ì´í„° í˜ì¹­ íŒ¨í„´ì„ ì œê³µí•˜ëŠ” ëª¨ë“ˆë“¤
 */

export * from "./types";
export * from "./errorHandler";
export * from "./queryBuilder";
export * from "./baseRepository";
</file>

<file path="core/queryBuilder.ts">
/**
 * Supabase ì¿¼ë¦¬ ë¹Œë” ë˜í¼
 * ì¼ê´€ëœ ì¿¼ë¦¬ íŒ¨í„´ì„ ì œê³µí•˜ëŠ” í—¬í¼ í•¨ìˆ˜ë“¤
 */

import type { PostgrestError } from "@supabase/supabase-js";
import type { SupabaseServerClient } from "./types";
import { handleQueryError, isColumnNotFoundError } from "./errorHandler";

/**
 * ì¿¼ë¦¬ ì‹¤í–‰ ì˜µì…˜
 */
export type QueryOptions = {
  /**
   * ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ ë°˜í™˜ê°’
   */
  defaultValue?: unknown;
  /**
   * ì—ëŸ¬ ë¡œê¹… ì»¨í…ìŠ¤íŠ¸
   */
  context?: string;
  /**
   * Fallback ì¿¼ë¦¬ í•¨ìˆ˜ (42703 ì—ëŸ¬ ë°œìƒ ì‹œ ì‚¬ìš©)
   */
  fallbackQuery?: () => Promise<{ data: unknown; error: PostgrestError | null }>;
};

/**
 * ì•ˆì „í•œ ì¿¼ë¦¬ ì‹¤í–‰
 * 
 * @param queryFn - ì‹¤í–‰í•  ì¿¼ë¦¬ í•¨ìˆ˜
 * @param options - ì¿¼ë¦¬ ì˜µì…˜
 * @returns ì¿¼ë¦¬ ê²°ê³¼ ë°ì´í„° ë˜ëŠ” ê¸°ë³¸ê°’
 */
export async function executeQuery<T>(
  queryFn: () => Promise<{ data: T | null; error: PostgrestError | null }>,
  options: QueryOptions = {}
): Promise<T | null> {
  const { defaultValue = null, context = "[data]", fallbackQuery } = options;

  try {
    const { data, error } = await queryFn();

    if (error) {
      // 42703 ì—ëŸ¬ëŠ” ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°ì´ë¯€ë¡œ fallbackì´ ìˆìœ¼ë©´ ì‚¬ìš©
      if (isColumnNotFoundError(error)) {
        if (fallbackQuery) {
          const fallbackResult = await fallbackQuery();
          if (!fallbackResult.error) {
            return (fallbackResult.data as T | null) ?? (defaultValue as T | null);
          }
        }
      }

      handleQueryError(error, {
        context,
      });
      return defaultValue as T | null;
    }

    return data ?? (defaultValue as T | null);
  } catch (error) {
    handleQueryError(error as PostgrestError, {
      context,
    });
    return defaultValue as T | null;
  }
}

/**
 * ë‹¨ì¼ ë ˆì½”ë“œ ì¡°íšŒ
 */
export async function executeSingleQuery<T>(
  queryFn: () => Promise<{ data: T[] | null; error: PostgrestError | null }>,
  options: QueryOptions = {}
): Promise<T | null> {
  const result = await executeQuery<T[]>(queryFn, options);
  if (!result || !Array.isArray(result) || result.length === 0) {
    return null;
  }
  return result[0];
}

/**
 * ì—¬ëŸ¬ ì¿¼ë¦¬ë¥¼ ë³‘ë ¬ë¡œ ì‹¤í–‰
 */
export async function executeQueriesParallel<T>(
  queries: Array<() => Promise<{ data: T | null; error: PostgrestError | null }>>,
  options: QueryOptions = {}
): Promise<Array<T | null>> {
  const results = await Promise.allSettled(
    queries.map((queryFn) => executeQuery(queryFn, options))
  );

  return results.map((result) =>
    result.status === "fulfilled" ? result.value : (options.defaultValue as T | null)
  );
}
</file>

<file path="core/types.ts">
/**
 * ê³µí†µ íƒ€ì… ì •ì˜
 */

import type { createSupabaseServerClient } from "@/lib/supabase/server";

/**
 * Supabase ì„œë²„ í´ë¼ì´ì–¸íŠ¸ íƒ€ì…
 */
export type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * ê¸°ë³¸ ì—”í‹°í‹° íƒ€ì…
 */
export interface BaseEntity {
  id: string;
  created_at?: string | null;
  updated_at?: string | null;
}

/**
 * Soft Deleteë¥¼ ì§€ì›í•˜ëŠ” ì—”í‹°í‹° íƒ€ì…
 */
export interface SoftDeletableEntity extends BaseEntity {
  deleted_at?: string | null;
}

/**
 * Tenantë¥¼ ê°€ì§„ ì—”í‹°í‹° íƒ€ì…
 */
export interface TenantEntity extends BaseEntity {
  tenant_id?: string | null;
}

/**
 * ì¿¼ë¦¬ í•„í„° ê¸°ë³¸ íƒ€ì…
 */
export interface BaseFilters {
  tenantId?: string | null;
  includeDeleted?: boolean;
}

/**
 * í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜
 */
export interface PaginationOptions {
  page?: number;
  pageSize?: number;
  limit?: number;
  offset?: number;
}

/**
 * ì •ë ¬ ì˜µì…˜
 */
export interface SortOptions {
  orderBy?: string;
  orderDirection?: "asc" | "desc";
}

/**
 * ì¿¼ë¦¬ ê²°ê³¼ íƒ€ì…
 */
export interface QueryResult<T> {
  data: T | null;
  error: unknown;
}

/**
 * ëª©ë¡ ì¡°íšŒ ê²°ê³¼ íƒ€ì…
 */
export interface ListResult<T> {
  items: T[];
  total?: number;
  page?: number;
  pageSize?: number;
}
</file>

<file path="admins.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

export type Admin = {
  id: string;
  tenant_id?: string | null;
  role: "admin" | "consultant";
  created_at?: string | null;
};

/**
 * Admin IDë¡œ Admin ì¡°íšŒ
 */
export async function getAdminById(
  adminId: string,
  tenantId?: string | null
): Promise<Admin | null> {
  const supabase = await createSupabaseServerClient();

  const selectAdmin = () =>
    supabase
      .from("admin_users")
      .select("id,tenant_id,role,created_at")
      .eq("id", adminId);

  let query = selectAdmin();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<Admin>();

  if (error && error.code === "42703") {
    ({ data, error } = await selectAdmin().maybeSingle<Admin>());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[data/admins] Admin ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * Tenant IDë¡œ Admin ëª©ë¡ ì¡°íšŒ
 */
export async function listAdminsByTenant(
  tenantId: string | null
): Promise<Admin[]> {
  const supabase = await createSupabaseServerClient();

  if (!tenantId) {
    return [];
  }

  const selectAdmins = () =>
    supabase
      .from("admin_users")
      .select("id,tenant_id,role,created_at")
      .eq("tenant_id", tenantId)
      .order("created_at", { ascending: false });

  let { data, error } = await selectAdmins();

  if (error && error.code === "42703") {
    ({ data, error } = await selectAdmins());
  }

  if (error) {
    console.error("[data/admins] Admin ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Admin[] | null) ?? [];
}
</file>

<file path="blockSets.ts">
/**
 * ë¸”ë¡ ì„¸íŠ¸ ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
 * ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ í•¨ìˆ˜
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type BlockSetWithBlocks = {
  id: string;
  name: string;
  blocks: Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
  }>;
};

/**
 * í•™ìƒì˜ ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ì„ ì¡°íšŒí•˜ê³  ê° ì„¸íŠ¸ì˜ ë¸”ë¡ ì •ë³´ë¥¼ í¬í•¨í•˜ì—¬ ë°˜í™˜
 * 
 * ìµœì í™”: N+1 ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¸”ë¡ ì„¸íŠ¸ì™€ ë¸”ë¡ì„ ë³‘ë ¬ë¡œ ì¡°íšŒí•œ í›„ JavaScriptì—ì„œ ê·¸ë£¹í™”
 * 
 * @param studentId í•™ìƒ ID
 * @returns ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ (ê° ì„¸íŠ¸ì— ë¸”ë¡ ì •ë³´ í¬í•¨)
 */
export async function fetchBlockSetsWithBlocks(
  studentId: string
): Promise<BlockSetWithBlocks[]> {
  const supabase = await createSupabaseServerClient();

  // ë¸”ë¡ ì„¸íŠ¸ ëª©ë¡ê³¼ ëª¨ë“  ë¸”ë¡ì„ ë³‘ë ¬ë¡œ ì¡°íšŒ (N+1 ë¬¸ì œ í•´ê²°)
  const [blockSetsResult, blocksResult] = await Promise.all([
    supabase
      .from("student_block_sets")
      .select("id, name")
      .eq("student_id", studentId)
      .order("display_order", { ascending: true }),
    supabase
      .from("student_block_schedule")
      .select("id, block_set_id, day_of_week, start_time, end_time")
      .eq("student_id", studentId)
      .order("day_of_week", { ascending: true })
      .order("start_time", { ascending: true }),
  ]);

  const { data: blockSetsData, error: setsError } = blockSetsResult;
  const { data: allBlocks, error: blocksError } = blocksResult;

  if (setsError) {
    console.error("[blockSets] ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:", setsError);
    return [];
  }

  if (blocksError) {
    console.error("[blockSets] ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨:", blocksError);
    // ë¸”ë¡ ì¡°íšŒ ì‹¤íŒ¨ ì‹œ ë¹ˆ ë¸”ë¡ ë°°ì—´ë¡œ ì²˜ë¦¬
  }

  if (!blockSetsData || blockSetsData.length === 0) {
    return [];
  }

  // ë¸”ë¡ì„ block_set_idë¡œ ê·¸ë£¹í™”
  const blocksBySetId = new Map<string, Array<{
    id: string;
    day_of_week: number;
    start_time: string;
    end_time: string;
  }>>();

  if (allBlocks) {
    for (const block of allBlocks) {
      if (!block.block_set_id) continue;
      
      if (!blocksBySetId.has(block.block_set_id)) {
        blocksBySetId.set(block.block_set_id, []);
      }
      
      blocksBySetId.get(block.block_set_id)!.push({
        id: block.id,
        day_of_week: block.day_of_week,
        start_time: block.start_time,
        end_time: block.end_time,
      });
    }
  }

  // ë¸”ë¡ ì„¸íŠ¸ì— ë¸”ë¡ ì •ë³´ ë§¤í•‘
  return blockSetsData.map((set) => ({
    id: set.id,
    name: set.name,
    blocks: blocksBySetId.get(set.id) ?? [],
  }));
}
</file>

<file path="campTemplates.ts">
// ìº í”„ í…œí”Œë¦¿ ë° ì´ˆëŒ€ ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { CampTemplate, CampInvitation } from "@/lib/types/plan";
import type { WizardData } from "@/app/(student)/plan/new-group/_components/PlanGroupWizard";

/**
 * ìº í”„ í…œí”Œë¦¿ ì¡°íšŒ
 */
export async function getCampTemplate(templateId: string): Promise<CampTemplate | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("camp_templates")
    .select("*")
    .eq("id", templateId)
    .maybeSingle();

  if (error) {
    // PGRST116ì€ ê²°ê³¼ê°€ 0ê°œì¼ ë•Œ ë°œìƒí•˜ëŠ” ì •ìƒì ì¸ ì—ëŸ¬ (í…œí”Œë¦¿ì´ ì—†ëŠ” ê²½ìš°)
    if (error.code !== "PGRST116") {
      console.error("[data/campTemplates] í…œí”Œë¦¿ ì¡°íšŒ ì‹¤íŒ¨", {
        templateId,
        errorCode: error.code,
        errorMessage: error.message,
        errorDetails: error.details,
        errorHint: error.hint,
      });
    } else if (process.env.NODE_ENV === "development") {
      console.warn("[data/campTemplates] í…œí”Œë¦¿ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ (PGRST116)", {
        templateId,
      });
    }
    return null;
  }

  if (!data && process.env.NODE_ENV === "development") {
    console.warn("[data/campTemplates] í…œí”Œë¦¿ ì¡°íšŒ ê²°ê³¼ê°€ null", {
      templateId,
    });
  }

  return data as CampTemplate | null;
}

/**
 * ìº í”„ í…œí”Œë¦¿ ìƒì„±
 */
export async function createCampTemplate(data: {
  tenant_id: string;
  name: string;
  description?: string;
  program_type: string;
  template_data: Partial<WizardData> | null;
  created_by: string;
  camp_start_date?: string;
  camp_end_date?: string;
  camp_location?: string;
}): Promise<{ success: boolean; templateId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const insertData: {
    tenant_id: string;
    name: string;
    description: string | null;
    program_type: string;
    template_data: Partial<WizardData> | null;
    status: "draft";
    created_by?: string;
    camp_start_date?: string;
    camp_end_date?: string;
    camp_location?: string;
  } = {
    tenant_id: data.tenant_id,
    name: data.name,
    description: data.description || null,
    program_type: data.program_type,
    template_data: data.template_data,
    status: "draft",
  };

  // created_byëŠ” users í…Œì´ë¸”ì´ ìˆì„ ë•Œë§Œ ì¶”ê°€
  if (data.created_by) {
    insertData.created_by = data.created_by;
  }

  // ìº í”„ ê¸°ê°„ ë° ì¥ì†Œ í•„ë“œ ì¶”ê°€
  if (data.camp_start_date) {
    insertData.camp_start_date = data.camp_start_date;
  }
  if (data.camp_end_date) {
    insertData.camp_end_date = data.camp_end_date;
  }
  if (data.camp_location) {
    insertData.camp_location = data.camp_location;
  }

  const { data: template, error } = await supabase
    .from("camp_templates")
    .insert(insertData)
    .select("id")
    .single();

  if (error) {
    return { success: false, error: error.message };
  }

  return { success: true, templateId: template.id };
}

/**
 * ìº í”„ í…œí”Œë¦¿ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ììš©)
 */
export async function getCampTemplatesForTenant(
  tenantId: string
): Promise<CampTemplate[]> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("camp_templates")
      .select("*")
      .eq("tenant_id", tenantId)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("[data/campTemplates] í…œí”Œë¦¿ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", {
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint,
      });
      return [];
    }

    return (data || []) as CampTemplate[];
  } catch (error) {
    // ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ ì²˜ë¦¬
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[data/campTemplates] í…œí”Œë¦¿ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜ˆì™¸ ë°œìƒ", {
      message: errorMessage,
      error,
    });
    return [];
  }
}

/**
 * í•™ìƒì˜ ìº í”„ ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ
 */
export async function getCampInvitationsForStudent(
  studentId: string
): Promise<CampInvitation[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("camp_invitations")
    .select("*")
    .eq("student_id", studentId)
    .in("status", ["pending", "accepted"])
    .order("invited_at", { ascending: false });

  if (error) {
    console.error("[data/campTemplates] ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data || []) as CampInvitation[];
}

/**
 * ìº í”„ ì´ˆëŒ€ ì¡°íšŒ
 */
export async function getCampInvitation(
  invitationId: string
): Promise<CampInvitation | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("camp_invitations")
    .select("*")
    .eq("id", invitationId)
    .maybeSingle();

  if (error) {
    // PGRST116ì€ ê²°ê³¼ê°€ 0ê°œì¼ ë•Œ ë°œìƒí•˜ëŠ” ì •ìƒì ì¸ ì—ëŸ¬ (ì´ˆëŒ€ê°€ ì—†ëŠ” ê²½ìš°)
    if (error.code !== "PGRST116") {
      console.error("[data/campTemplates] ì´ˆëŒ€ ì¡°íšŒ ì‹¤íŒ¨", error);
    }
    return null;
  }

  return data as CampInvitation | null;
}

/**
 * ìº í”„ ì´ˆëŒ€ ìƒíƒœ ì—…ë°ì´íŠ¸
 */
export async function updateCampInvitationStatus(
  invitationId: string,
  status: "accepted" | "declined"
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const updateData: any = {
    status,
    updated_at: new Date().toISOString(),
  };

  if (status === "accepted") {
    updateData.accepted_at = new Date().toISOString();
  } else {
    updateData.declined_at = new Date().toISOString();
  }

  const { error } = await supabase
    .from("camp_invitations")
    .update(updateData)
    .eq("id", invitationId);

  if (error) {
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í…œí”Œë¦¿ë³„ ìº í”„ ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ììš©)
 */
export async function getCampInvitationsForTemplate(
  templateId: string
): Promise<Array<CampInvitation & { student_name?: string; student_grade?: string; student_class?: string }>> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("camp_invitations")
    .select(`
      *,
      students:student_id (
        name,
        grade,
        class
      )
    `)
    .eq("camp_template_id", templateId)
    .order("invited_at", { ascending: false });

  if (error) {
    console.error("[data/campTemplates] í…œí”Œë¦¿ë³„ ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  // í•™ìƒ ì •ë³´ë¥¼ í‰íƒ„í™”
  return (data || []).map((invitation: any) => ({
    ...invitation,
    student_name: invitation.students?.name || null,
    student_grade: invitation.students?.grade || null,
    student_class: invitation.students?.class || null,
  }));
}

export type CampTemplateImpactSummary = {
  invitationStats: {
    pending: number;
    accepted: number;
    declined: number;
  };
  planGroupStats: {
    draft: number;
    saved: number;
    active: number;
    paused: number;
    completed: number;
    cancelled: number;
  };
  totalInvitations: number;
  submittedInvitationCount: number;
  hasPendingInvites: boolean;
  hasAcceptedInvites: boolean;
  hasReviewInProgress: boolean;
  hasActivatedPlans: boolean;
};

export async function getCampTemplateImpactSummary(
  templateId: string,
  tenantId: string
): Promise<CampTemplateImpactSummary> {
  const supabase = await createSupabaseServerClient();

  const invitationStats = {
    pending: 0,
    accepted: 0,
    declined: 0,
  };

  const planGroupStats = {
    draft: 0,
    saved: 0,
    active: 0,
    paused: 0,
    completed: 0,
    cancelled: 0,
  };

  const { data: invitations, error: invitationsError } = await supabase
    .from("camp_invitations")
    .select("id, status")
    .eq("camp_template_id", templateId)
    .eq("tenant_id", tenantId);

  if (invitationsError) {
    console.error(
      "[data/campTemplates] ì´ˆëŒ€ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨",
      invitationsError
    );
  } else {
    (invitations || []).forEach((invitation) => {
      const status = invitation.status as keyof typeof invitationStats;
      if (status in invitationStats) {
        invitationStats[status]++;
      }
    });
  }

  const submittedInvitationIds = new Set<string>();
  const { data: planGroups, error: planGroupsError } = await supabase
    .from("plan_groups")
    .select("id, status, camp_invitation_id")
    .eq("camp_template_id", templateId)
    .eq("tenant_id", tenantId)
    .is("deleted_at", null);

  if (planGroupsError) {
    console.error(
      "[data/campTemplates] í”Œëœ ê·¸ë£¹ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨",
      planGroupsError
    );
  } else {
    (planGroups || []).forEach((group) => {
      if (group.camp_invitation_id) {
        submittedInvitationIds.add(group.camp_invitation_id);
      }
      const status = group.status as keyof typeof planGroupStats;
      if (status in planGroupStats) {
        planGroupStats[status]++;
      }
    });
  }

  return {
    invitationStats,
    planGroupStats,
    totalInvitations: invitations?.length || 0,
    submittedInvitationCount: submittedInvitationIds.size,
    hasPendingInvites: invitationStats.pending > 0,
    hasAcceptedInvites: invitationStats.accepted > 0,
    hasReviewInProgress:
      planGroupStats.draft > 0 || planGroupStats.saved > 0,
    hasActivatedPlans: planGroupStats.active > 0,
  };
}

/**
 * ìº í”„ ì´ˆëŒ€ ì‚­ì œ
 */
export async function deleteCampInvitation(
  invitationId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // 1. ì´ˆëŒ€ ì‚­ì œ ì „ì— ê´€ë ¨ëœ í”Œëœ ê·¸ë£¹ ì‚­ì œ
  const { deletePlanGroupByInvitationId } = await import(
    "@/lib/data/planGroups"
  );
  const planGroupResult = await deletePlanGroupByInvitationId(invitationId);

  if (!planGroupResult.success) {
    console.error(
      "[data/campTemplates] í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨",
      planGroupResult.error
    );
    return {
      success: false,
      error: `í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨: ${planGroupResult.error}`,
    };
  }

  // 2. ì´ˆëŒ€ ì‚­ì œ
  const { error } = await supabase
    .from("camp_invitations")
    .delete()
    .eq("id", invitationId);

  if (error) {
    console.error("[data/campTemplates] ì´ˆëŒ€ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ìº í”„ ì´ˆëŒ€ ì¼ê´„ ì‚­ì œ
 */
export async function deleteCampInvitations(
  invitationIds: string[]
): Promise<{ success: boolean; error?: string; count?: number }> {
  const supabase = await createSupabaseServerClient();

  // 1. ê° ì´ˆëŒ€ì— ëŒ€í•´ í”Œëœ ê·¸ë£¹ ì‚­ì œ
  const { deletePlanGroupByInvitationId } = await import(
    "@/lib/data/planGroups"
  );

  const planGroupResults = await Promise.all(
    invitationIds.map((invitationId) =>
      deletePlanGroupByInvitationId(invitationId)
    )
  );

  // í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨í•œ ê²½ìš° í™•ì¸
  const failedPlanGroupDeletes = planGroupResults.filter(
    (result) => !result.success
  );

  if (failedPlanGroupDeletes.length > 0) {
    const errorMessages = failedPlanGroupDeletes
      .map((result) => result.error)
      .join("; ");
    console.error(
      "[data/campTemplates] ì¼ë¶€ í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨",
      errorMessages
    );
    // í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ì´ˆëŒ€ ì‚­ì œëŠ” ê³„ì† ì§„í–‰ (ë°ì´í„° ì¼ê´€ì„± ìœ ì§€)
    // í•˜ì§€ë§Œ ì—ëŸ¬ë¥¼ ê¸°ë¡í•´ë‘ëŠ” ê²ƒì´ ì¢‹ìŒ
  }

  // 2. ì´ˆëŒ€ ì¼ê´„ ì‚­ì œ
  const { error } = await supabase
    .from("camp_invitations")
    .delete()
    .in("id", invitationIds);
  
  const count = error ? 0 : invitationIds.length;

  if (error) {
    console.error("[data/campTemplates] ì´ˆëŒ€ ì¼ê´„ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, count: count || 0 };
}
</file>

<file path="careerFields.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type CareerField = {
  id: string;
  name: string;
  display_order: number;
  is_active: boolean;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * ì§„ë¡œ ê³„ì—´ ëª©ë¡ ì¡°íšŒ (í™œì„±í™”ëœ í•­ëª©ë§Œ, display_order ìˆœ)
 */
export async function getCareerFields(): Promise<CareerField[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("career_fields")
    .select("*")
    .eq("is_active", true)
    .order("display_order", { ascending: true });

  if (error) {
    console.error("[data/careerFields] ì§„ë¡œ ê³„ì—´ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as CareerField[]) ?? [];
}

/**
 * ì§„ë¡œ ê³„ì—´ ëª©ë¡ ì¡°íšŒ (ëª¨ë“  í•­ëª©, ê´€ë¦¬ììš©)
 */
export async function getAllCareerFields(): Promise<CareerField[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("career_fields")
    .select("*")
    .order("display_order", { ascending: true });

  if (error) {
    console.error("[data/careerFields] ì§„ë¡œ ê³„ì—´ ì „ì²´ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as CareerField[]) ?? [];
}

/**
 * ì§„ë¡œ ê³„ì—´ ìƒì„±
 */
export async function createCareerField(
  name: string,
  displayOrder?: number
): Promise<{ success: boolean; id?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // display_orderê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ìµœëŒ€ê°’ + 1
  let order = displayOrder;
  if (order === undefined) {
    const existing = await getAllCareerFields();
    order = existing.length > 0
      ? Math.max(...existing.map(f => f.display_order)) + 1
      : 0;
  }

  const { data, error } = await supabase
    .from("career_fields")
    .insert({
      name: name.trim(),
      display_order: order,
      is_active: true,
    })
    .select("id")
    .single();

  if (error) {
    console.error("[data/careerFields] ì§„ë¡œ ê³„ì—´ ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, id: data?.id };
}

/**
 * ì§„ë¡œ ê³„ì—´ ìˆ˜ì •
 */
export async function updateCareerField(
  id: string,
  updates: Partial<{
    name: string;
    display_order: number;
    is_active: boolean;
  }>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.name !== undefined) payload.name = updates.name.trim();
  if (updates.display_order !== undefined) payload.display_order = updates.display_order;
  if (updates.is_active !== undefined) payload.is_active = updates.is_active;

  const { error } = await supabase
    .from("career_fields")
    .update(payload)
    .eq("id", id);

  if (error) {
    console.error("[data/careerFields] ì§„ë¡œ ê³„ì—´ ìˆ˜ì • ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ì§„ë¡œ ê³„ì—´ ì‚­ì œ
 */
export async function deleteCareerField(
  id: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // ì‹¤ì œ ì‚­ì œ ëŒ€ì‹  is_active = falseë¡œ ì„¤ì • (ì†Œí”„íŠ¸ ì‚­ì œ)
  const { error } = await supabase
    .from("career_fields")
    .update({ is_active: false })
    .eq("id", id);

  if (error) {
    console.error("[data/careerFields] ì§„ë¡œ ê³„ì—´ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="contentMasters.ts">
// ì½˜í…ì¸  ë§ˆìŠ¤í„° ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
// master_books, master_lectures í…Œì´ë¸” ì‚¬ìš©

import { createSupabaseServerClient, createSupabasePublicClient, createSupabaseAdminClient } from "@/lib/supabase/server";
import { getClientForRLSBypass } from "@/lib/supabase/clientSelector";
import { MasterBook, MasterLecture, MasterCustomContent, BookDetail, LectureEpisode } from "@/lib/types/plan";
import { 
  getSubjectGroups, 
  getSubjectsByGroup,
  type SubjectGroup,
  type Subject 
} from "@/lib/data/subjects";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * êµì¬ ê²€ìƒ‰ í•„í„°
 */
export type MasterBookFilters = {
  curriculum_revision_id?: string; // ê°œì •êµìœ¡ê³¼ì • IDë¡œ í•„í„°ë§
  subject_group_id?: string; // êµê³¼ ê·¸ë£¹ IDë¡œ í•„í„°ë§
  subject_id?: string; // ê³¼ëª© IDë¡œ í•„í„°ë§
  publisher_id?: string; // ì¶œíŒì‚¬ IDë¡œ í•„í„°ë§
  search?: string; // ì œëª© ê²€ìƒ‰
  difficulty?: string; // ë‚œì´ë„ í•„í„°ë§
  sort?: string; // ì •ë ¬ ì˜µì…˜
  tenantId?: string | null;
  limit?: number;
  offset?: number;
};

/**
 * ê°•ì˜ ê²€ìƒ‰ í•„í„°
 */
export type MasterLectureFilters = {
  curriculum_revision_id?: string; // ê°œì •êµìœ¡ê³¼ì • IDë¡œ í•„í„°ë§
  subject_group_id?: string; // êµê³¼ ê·¸ë£¹ IDë¡œ í•„í„°ë§
  subject_id?: string; // ê³¼ëª© IDë¡œ í•„í„°ë§
  platform_id?: string; // í”Œë«í¼ IDë¡œ í•„í„°ë§
  search?: string; // ì œëª© ê²€ìƒ‰
  difficulty?: string; // ë‚œì´ë„ í•„í„°ë§
  sort?: string; // ì •ë ¬ ì˜µì…˜
  tenantId?: string | null;
  limit?: number;
  offset?: number;
};

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê²€ìƒ‰ í•„í„°
 */
export type MasterCustomContentFilters = {
  curriculum_revision_id?: string; // ê°œì •êµìœ¡ê³¼ì • IDë¡œ í•„í„°ë§
  subject_group_id?: string; // êµê³¼ ê·¸ë£¹ IDë¡œ í•„í„°ë§
  subject_id?: string; // ê³¼ëª© IDë¡œ í•„í„°ë§
  content_type?: string; // ì½˜í…ì¸  ìœ í˜• í•„í„°ë§
  search?: string; // ì œëª© ê²€ìƒ‰
  difficulty?: string; // ë‚œì´ë„ í•„í„°ë§
  sort?: string; // ì •ë ¬ ì˜µì…˜
  tenantId?: string | null;
  limit?: number;
  offset?: number;
};

/**
 * í†µí•© ê²€ìƒ‰ í•„í„° (í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated master_books, master_lecturesë¡œ ë¶„ë¦¬ë¨. MasterBookFilters ë˜ëŠ” MasterLectureFilters ì‚¬ìš© ê¶Œì¥
 */
export type ContentMasterFilters = {
  content_type?: "book" | "lecture";
  curriculum_revision_id?: string;
  subject_group_id?: string;
  subject_id?: string;
  publisher_id?: string; // êµì¬ìš©
  platform_id?: string; // ê°•ì˜ìš©
  search?: string;
  difficulty?: string; // ë‚œì´ë„ í•„í„°ë§
  sort?: string; // ì •ë ¬ ì˜µì…˜
  tenantId?: string | null;
  limit?: number;
  offset?: number;
};

// ============================================
// êµì¬ ê´€ë ¨ í•¨ìˆ˜
// ============================================

/**
 * êµì¬ ê²€ìƒ‰
 * @param filters ê²€ìƒ‰ í•„í„°
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì , ì „ë‹¬í•˜ì§€ ì•Šìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©)
 */
export async function searchMasterBooks(
  filters: MasterBookFilters,
  supabase?: Awaited<ReturnType<typeof createSupabaseServerClient>>
): Promise<{ data: MasterBook[]; total: number }> {
  const queryClient = supabase || await createSupabaseServerClient();

  let query = queryClient
    .from("master_books")
    .select("*", { count: "exact" });

  // í•„í„° ì ìš©
  if (filters.curriculum_revision_id) {
    query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
  }
  if (filters.subject_group_id) {
    query = query.eq("subject_group_id", filters.subject_group_id);
  }
  if (filters.subject_id) {
    query = query.eq("subject_id", filters.subject_id);
  }
  if (filters.publisher_id) {
    query = query.eq("publisher_id", filters.publisher_id);
  }
  if (filters.search) {
    query = query.ilike("title", `%${filters.search}%`);
  }
  if (filters.difficulty) {
    query = query.eq("difficulty_level", filters.difficulty);
  }
  if (filters.tenantId) {
    query = query.or(`tenant_id.is.null,tenant_id.eq.${filters.tenantId}`);
  } else {
    query = query.is("tenant_id", null); // ê¸°ë³¸ì ìœ¼ë¡œ ê³µê°œ ì½˜í…ì¸ ë§Œ
  }

  // ì •ë ¬
  const sortBy = filters.sort || "updated_at_desc";
  if (sortBy === "title_asc") {
    query = query.order("title", { ascending: true });
  } else if (sortBy === "title_desc") {
    query = query.order("title", { ascending: false });
  } else if (sortBy === "difficulty_level_asc") {
    query = query.order("difficulty_level", { ascending: true });
  } else if (sortBy === "difficulty_level_desc") {
    query = query.order("difficulty_level", { ascending: false });
  } else if (sortBy === "created_at_asc") {
    query = query.order("created_at", { ascending: true });
  } else if (sortBy === "created_at_desc") {
    query = query.order("created_at", { ascending: false });
  } else {
    // ê¸°ë³¸ê°’: updated_at_desc
    query = query.order("updated_at", { ascending: false });
  }

  // í˜ì´ì§€ë„¤ì´ì…˜
  if (filters.limit) {
    query = query.limit(filters.limit);
  }
  if (filters.offset) {
    query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);
  }

  const { data, error, count } = await query;

  if (error) {
    console.error("[data/contentMasters] êµì¬ ê²€ìƒ‰ ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  const result = {
    data: (data as MasterBook[] | null) ?? [],
    total: count ?? 0,
  };

  // ë¡œê·¸: ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬ ì¡°íšŒ ê²°ê³¼
  console.log("[data/contentMasters] ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° êµì¬ ì¡°íšŒ:", {
    filters: {
      curriculum_revision_id: filters.curriculum_revision_id,
      subject_group_id: filters.subject_group_id,
      subject_id: filters.subject_id,
      publisher_id: filters.publisher_id,
      difficulty: filters.difficulty,
      sort: filters.sort,
      tenantId: filters.tenantId,
      limit: filters.limit,
    },
    result: {
      count: result.data.length,
      total: result.total,
      titles: result.data.slice(0, 3).map(b => b.title), // ì²˜ìŒ 3ê°œë§Œ
    },
  });

  return result;
}

/**
 * ë§ˆìŠ¤í„° êµì¬ ëª©ë¡ ì¡°íšŒ (ë“œë¡­ë‹¤ìš´ìš©)
 */
export async function getMasterBooksList(): Promise<Array<{ id: string; title: string }>> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("master_books")
    .select("id, title")
    .order("title", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] êµì¬ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Array<{ id: string; title: string }> | null) ?? [];
}

/**
 * êµì¬ ìƒì„¸ ì¡°íšŒ (ì„¸ë¶€ ì •ë³´ í¬í•¨)
 * subject_id, curriculum_revision_id, publisher_idë¡œë¶€í„° ê´€ë ¨ ì •ë³´ë¥¼ JOINìœ¼ë¡œ ì¡°íšŒ
 */
export async function getMasterBookById(
  bookId: string
): Promise<{ book: MasterBook & { subject_category?: string | null; subject?: string | null; publisher?: string | null; revision?: string | null }; details: BookDetail[] }> {
  const supabase = await createSupabaseServerClient();

  const [bookResult, detailsResult] = await Promise.all([
    supabase
      .from("master_books")
      .select(`
        id,
        tenant_id,
        revision,
        content_category,
        title,
        total_pages,
        difficulty_level,
        notes,
        pdf_url,
        ocr_data,
        page_analysis,
        overall_difficulty,
        updated_at,
        created_at,
        is_active,
        curriculum_revision_id,
        subject_id,
        subject_group_id,
        subject_category,
        subject,
        grade_min,
        grade_max,
        school_type,
        subtitle,
        series_name,
        author,
        publisher_id,
        publisher_name,
        isbn_10,
        isbn_13,
        edition,
        published_date,
        target_exam_type,
        description,
        toc,
        publisher_review,
        tags,
        source,
        source_product_code,
        source_url,
        cover_image_url,
        curriculum_revisions:curriculum_revision_id (
          id,
          name
        ),
        subjects:subject_id (
          id,
          name,
          subject_groups:subject_group_id (
            id,
            name
          )
        ),
        publishers:publisher_id (
          id,
          name
        )
      `)
      .eq("id", bookId)
      .maybeSingle(),
    supabase
      .from("book_details")
      .select("*")
      .eq("book_id", bookId)
      .order("display_order", { ascending: true })
      .order("page_number", { ascending: true }),
  ]);

  if (bookResult.error) {
    console.error("[data/contentMasters] êµì¬ ì¡°íšŒ ì‹¤íŒ¨", bookResult.error);
    throw new Error(bookResult.error.message || "êµì¬ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  if (detailsResult.error) {
    console.error("[data/contentMasters] êµì¬ ì„¸ë¶€ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", detailsResult.error);
    // ì„¸ë¶€ ì •ë³´ëŠ” ì„ íƒì‚¬í•­ì´ë¯€ë¡œ ì—ëŸ¬ë¥¼ ë¬´ì‹œ
  }

  const bookData = bookResult.data;
  if (!bookData) {
    return {
      book: null as any,
      details: (detailsResult.data as BookDetail[] | null) ?? [],
    };
  }

  // JOINëœ ë°ì´í„°ë¥¼ í‰íƒ„í™”í•˜ì—¬ í‘œì‹œìš© í•„ë“œ ì¶”ê°€
  // Supabaseì˜ ì¤‘ì²© SELECTëŠ” ë°°ì—´ë¡œ ë°˜í™˜ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë°°ì—´ ì²˜ë¦¬
  const curriculumRevisionRaw = (bookData as any).curriculum_revisions;
  const curriculumRevision = Array.isArray(curriculumRevisionRaw) 
    ? curriculumRevisionRaw[0] 
    : curriculumRevisionRaw;

  const subjectsRaw = (bookData as any).subjects;
  const subject = Array.isArray(subjectsRaw) 
    ? subjectsRaw[0] 
    : subjectsRaw;

  // subjectê°€ ìˆì„ ë•Œ subject_groups ì²˜ë¦¬
  const subjectGroupsRaw = subject?.subject_groups;
  const subjectGroup = Array.isArray(subjectGroupsRaw)
    ? subjectGroupsRaw[0]
    : subjectGroupsRaw;

  const publishersRaw = (bookData as any).publishers;
  const publisher = Array.isArray(publishersRaw)
    ? publishersRaw[0]
    : publishersRaw;

  // ë””ë²„ê¹…: JOIN ê²°ê³¼ í™•ì¸
  if (process.env.NODE_ENV === "development") {
    console.log("[getMasterBookById] JOIN ê²°ê³¼:", {
      bookId,
      subject_id: bookData.subject_id,
      curriculum_revision_id: bookData.curriculum_revision_id,
      hasCurriculumRevision: !!curriculumRevision,
      hasSubject: !!subject,
      hasSubjectGroup: !!subjectGroup,
      hasPublisher: !!publisher,
      curriculumRevisionRaw,
      subjectsRaw,
      subjectGroupsRaw,
      publishersRaw,
      subjectData: subject,
      subjectGroupData: subjectGroup,
    });
  }

  const book = {
    ...bookData,
    // revisionì€ curriculum_revisions.nameìœ¼ë¡œ ì„¤ì • (ì—†ìœ¼ë©´ ê¸°ì¡´ revision ìœ ì§€)
    revision: curriculumRevision?.name || bookData.revision || null,
    // subject_categoryëŠ” ì €ì¥ëœ ê°’ ìš°ì„ , JOINì€ fallback
    subject_category: bookData.subject_category || subjectGroup?.name || null,
    // subjectëŠ” ì €ì¥ëœ ê°’ ìš°ì„ , JOINì€ fallback
    subject: bookData.subject || subject?.name || null,
    // publisherëŠ” ì €ì¥ëœ ê°’ ìš°ì„ , JOINì€ fallback
    publisher: bookData.publisher_name || publisher?.name || null,
  } as MasterBook & { subject_category?: string | null; subject?: string | null; publisher?: string | null; revision?: string | null };

  return {
    book,
    details: (detailsResult.data as BookDetail[] | null) ?? [],
  };
}

// ============================================
// ê°•ì˜ ê´€ë ¨ í•¨ìˆ˜
// ============================================

/**
 * ê°•ì˜ ê²€ìƒ‰
 * @param filters ê²€ìƒ‰ í•„í„°
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì , ì „ë‹¬í•˜ì§€ ì•Šìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©)
 */
export async function searchMasterLectures(
  filters: MasterLectureFilters,
  supabase?: Awaited<ReturnType<typeof createSupabaseServerClient>>
): Promise<{ data: MasterLecture[]; total: number }> {
  const queryClient = supabase || await createSupabaseServerClient();

  let query = queryClient
    .from("master_lectures")
    .select("*", { count: "exact" });

  // í•„í„° ì ìš©
  if (filters.curriculum_revision_id) {
    query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
  }
  if (filters.subject_group_id) {
    query = query.eq("subject_group_id", filters.subject_group_id);
  }
  if (filters.subject_id) {
    query = query.eq("subject_id", filters.subject_id);
  }
  if (filters.platform_id) {
    query = query.eq("platform_id", filters.platform_id);
  }
  if (filters.search) {
    query = query.ilike("title", `%${filters.search}%`);
  }
  if (filters.difficulty) {
    query = query.eq("difficulty_level", filters.difficulty);
  }
  if (filters.tenantId) {
    query = query.or(`tenant_id.is.null,tenant_id.eq.${filters.tenantId}`);
  } else {
    query = query.is("tenant_id", null); // ê¸°ë³¸ì ìœ¼ë¡œ ê³µê°œ ì½˜í…ì¸ ë§Œ
  }

  // ì •ë ¬
  const sortBy = filters.sort || "updated_at_desc";
  if (sortBy === "title_asc") {
    query = query.order("title", { ascending: true });
  } else if (sortBy === "title_desc") {
    query = query.order("title", { ascending: false });
  } else if (sortBy === "difficulty_level_asc") {
    query = query.order("difficulty_level", { ascending: true });
  } else if (sortBy === "difficulty_level_desc") {
    query = query.order("difficulty_level", { ascending: false });
  } else if (sortBy === "created_at_asc") {
    query = query.order("created_at", { ascending: true });
  } else if (sortBy === "created_at_desc") {
    query = query.order("created_at", { ascending: false });
  } else {
    // ê¸°ë³¸ê°’: updated_at_desc
    query = query.order("updated_at", { ascending: false });
  }

  // í˜ì´ì§€ë„¤ì´ì…˜
  if (filters.limit) {
    query = query.limit(filters.limit);
  }
  if (filters.offset) {
    query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);
  }

  const { data, error, count } = await query;

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ê²€ìƒ‰ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  const result = {
    data: (data as MasterLecture[] | null) ?? [],
    total: count ?? 0,
  };

  // ë¡œê·¸: ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜ ì¡°íšŒ ê²°ê³¼
  console.log("[data/contentMasters] ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ê°•ì˜ ì¡°íšŒ:", {
    filters: {
      curriculum_revision_id: filters.curriculum_revision_id,
      subject_group_id: filters.subject_group_id,
      subject_id: filters.subject_id,
      platform_id: filters.platform_id,
      difficulty: filters.difficulty,
      sort: filters.sort,
      tenantId: filters.tenantId,
      limit: filters.limit,
    },
    result: {
      count: result.data.length,
      total: result.total,
      titles: result.data.slice(0, 3).map(l => l.title), // ì²˜ìŒ 3ê°œë§Œ
    },
  });

  return result;
}

/**
 * ê°•ì˜ ìƒì„¸ ì¡°íšŒ
 */
export async function getMasterLectureById(
  lectureId: string
): Promise<{ lecture: MasterLecture | null; episodes: LectureEpisode[] }> {
  const supabase = await createSupabaseServerClient();

  const [lectureResult, episodesResult] = await Promise.all([
    supabase
      .from("master_lectures")
      .select("*")
      .eq("id", lectureId)
      .maybeSingle<MasterLecture>(),
    supabase
      .from("lecture_episodes")
      .select("id, lecture_id, episode_number, episode_title, duration, display_order, created_at, lecture_source_url")
      .eq("lecture_id", lectureId)
      .order("display_order", { ascending: true })
      .order("episode_number", { ascending: true }),
  ]);

  if (lectureResult.error) {
    console.error("[data/contentMasters] ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨", lectureResult.error);
    throw new Error(lectureResult.error.message || "ê°•ì˜ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  if (episodesResult.error) {
    console.error("[data/contentMasters] ê°•ì˜ episode ì¡°íšŒ ì‹¤íŒ¨", episodesResult.error);
    // episodeëŠ” ì„ íƒì‚¬í•­ì´ë¯€ë¡œ ì—ëŸ¬ë¥¼ ë¬´ì‹œ
  }

  return {
    lecture: lectureResult.data,
    episodes: (episodesResult.data as LectureEpisode[] | null) ?? [],
  };
}

// ============================================
// í†µí•© í•¨ìˆ˜ (í•˜ìœ„ í˜¸í™˜ì„±)
// ============================================

/**
 * ì½˜í…ì¸  ë§ˆìŠ¤í„° ê²€ìƒ‰ (í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated searchMasterBooks ë˜ëŠ” searchMasterLectures ì‚¬ìš© ê¶Œì¥
 */
export async function searchContentMasters(
  filters: ContentMasterFilters
): Promise<{ data: any[]; total: number }> {
  if (filters.content_type === "book") {
    const result = await searchMasterBooks(filters);
    // content_type í•„ë“œ ì¶”ê°€
    const dataWithType = result.data.map((book) => ({
      ...book,
      content_type: "book" as const,
    }));
    return { data: dataWithType, total: result.total };
  } else if (filters.content_type === "lecture") {
    const result = await searchMasterLectures(filters);
    // content_type í•„ë“œ ì¶”ê°€
    const dataWithType = result.data.map((lecture) => ({
      ...lecture,
      content_type: "lecture" as const,
    }));
    return { data: dataWithType, total: result.total };
  } else {
    // ë‘˜ ë‹¤ ê²€ìƒ‰
    const [booksResult, lecturesResult] = await Promise.all([
      searchMasterBooks(filters),
      searchMasterLectures(filters),
    ]);
    // content_type í•„ë“œ ì¶”ê°€
    const booksWithType = booksResult.data.map((book) => ({
      ...book,
      content_type: "book" as const,
    }));
    const lecturesWithType = lecturesResult.data.map((lecture) => ({
      ...lecture,
      content_type: "lecture" as const,
    }));
    return {
      data: [...booksWithType, ...lecturesWithType],
      total: booksResult.total + lecturesResult.total,
    };
  }
}

/**
 * ì½˜í…ì¸  ë§ˆìŠ¤í„° ìƒì„¸ ì¡°íšŒ (í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated getMasterBookById ë˜ëŠ” getMasterLectureById ì‚¬ìš© ê¶Œì¥
 */
export async function getContentMasterById(
  masterId: string
): Promise<{ master: any | null; details: BookDetail[] }> {
  const supabase = await createSupabaseServerClient();

  // ë¨¼ì € êµì¬ì—ì„œ ì°¾ê¸°
  const bookResult = await getMasterBookById(masterId);
  if (bookResult.book) {
    return {
      master: bookResult.book,
      details: bookResult.details,
    };
  }

  // ê°•ì˜ì—ì„œ ì°¾ê¸°
  const { lecture, episodes } = await getMasterLectureById(masterId);
  if (lecture) {
    return {
      master: lecture,
      details: [], // ê°•ì˜ëŠ” ì„¸ë¶€ ì •ë³´ ì—†ìŒ (episodesëŠ” ë³„ë„)
    };
  }

  return { master: null, details: [] };
}

// ============================================
// í•™ìƒ ì½˜í…ì¸  ë³µì‚¬ í•¨ìˆ˜
// ============================================

/**
 * ë§ˆìŠ¤í„° êµì¬ë¥¼ í•™ìƒ êµì¬ë¡œ ë³µì‚¬
 * ì£¼ì˜: Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ RLS ì •ì±…ì„ ìš°íšŒí•©ë‹ˆë‹¤.
 */
export async function copyMasterBookToStudent(
  bookId: string,
  studentId: string,
  tenantId: string
): Promise<{ bookId: string }> {
  // Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error(
      "Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
    );
  }

  const { book } = await getMasterBookById(bookId);
  if (!book) {
    throw new Error("êµì¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  // ì¤‘ë³µ ì²´í¬: ê°™ì€ master_content_idë¥¼ ê°€ì§„ í•™ìƒ êµì¬ê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
  const { data: existingBook } = await supabase
    .from("books")
    .select("id")
    .eq("student_id", studentId)
    .eq("master_content_id", bookId)  // books í…Œì´ë¸”ì€ ì•„ì§ master_content_id ì‚¬ìš© (êµì¬ìš©)
    .maybeSingle();

  if (existingBook) {
    // ì´ë¯¸ ë³µì‚¬ëœ êµì¬ê°€ ìˆìœ¼ë©´ ê¸°ì¡´ ID ë°˜í™˜
    return { bookId: existingBook.id };
  }

  if (!supabase) throw new Error("Supabase client uninitialized");

  const { data: studentBook, error } = await supabase
    .from("books")
    .insert({
      tenant_id: tenantId,
      student_id: studentId,
      title: book.title,
      revision: book.revision,
      semester: null, // ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ semester í•„ë“œ ì œê±°ë¨
      subject_category: book.subject_category,
      subject: book.subject,
      publisher: book.publisher,
      difficulty_level: book.difficulty_level,
      total_pages: book.total_pages,
      notes: book.notes,
      master_content_id: bookId,  // books í…Œì´ë¸”ì€ ì•„ì§ master_content_id ì‚¬ìš© (êµì¬ìš©)
    })
    .select("id")
    .single();

  if (error) {
    console.error("[data/contentMasters] êµì¬ ë³µì‚¬ ì‹¤íŒ¨", {
      bookId,
      studentId,
      tenantId,
      error: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
    });
    throw new Error(
      error.code === "42501"
        ? "RLS ì •ì±… ìœ„ë°˜: êµì¬ ë³µì‚¬ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
        : error.message || "êµì¬ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
    );
  }

  // book_detailsë„ í•¨ê»˜ ë³µì‚¬
  const { details } = await getMasterBookById(bookId);
  if (details.length > 0) {
    const studentBookDetails = details.map((detail) => ({
      book_id: studentBook.id,
      major_unit: detail.major_unit,
      minor_unit: detail.minor_unit,
      page_number: detail.page_number,
      display_order: detail.display_order,
    }));

    if (!supabase) throw new Error("Supabase client uninitialized");
  
  const { error: detailsError } = await supabase
      .from("student_book_details")
      .insert(studentBookDetails);

    if (detailsError) {
      console.error("[data/contentMasters] êµì¬ ìƒì„¸ ì •ë³´ ë³µì‚¬ ì‹¤íŒ¨", {
        bookId: studentBook.id,
        error: detailsError.message,
        code: detailsError.code,
      });
      // ìƒì„¸ ì •ë³´ ë³µì‚¬ ì‹¤íŒ¨í•´ë„ êµì¬ëŠ” ë³µì‚¬ë¨
    }
  }

  return { bookId: studentBook.id };
}

/**
 * ë§ˆìŠ¤í„° ê°•ì˜ë¥¼ í•™ìƒ ê°•ì˜ë¡œ ë³µì‚¬
 * ì£¼ì˜: Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ RLS ì •ì±…ì„ ìš°íšŒí•©ë‹ˆë‹¤.
 */
export async function copyMasterLectureToStudent(
  lectureId: string,
  studentId: string,
  tenantId: string
): Promise<{ lectureId: string }> {
  // Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error(
      "Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
    );
  }

  const { lecture } = await getMasterLectureById(lectureId);
  if (!lecture) {
    throw new Error("ê°•ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  if (!supabase) throw new Error("Supabase client uninitialized");
  
  // ì¤‘ë³µ ì²´í¬: ê°™ì€ master_lecture_idë¥¼ ê°€ì§„ í•™ìƒ ê°•ì˜ê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
  const { data: existingLecture } = await supabase
    .from("lectures")
    .select("id")
    .eq("student_id", studentId)
    .eq("master_lecture_id", lectureId)  // ë³€ê²½: master_content_id â†’ master_lecture_id
    .maybeSingle();

  if (existingLecture) {
    // ì´ë¯¸ ë³µì‚¬ëœ ê°•ì˜ê°€ ìˆìœ¼ë©´ ê¸°ì¡´ ID ë°˜í™˜
    return { lectureId: existingLecture.id };
  }

  if (!supabase) throw new Error("Supabase client uninitialized");
  
  const { data: studentLecture, error } = await supabase
    .from("lectures")
    .insert({
      tenant_id: tenantId,
      student_id: studentId,
      title: lecture.title,
      revision: lecture.revision,
      semester: null, // ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ semester í•„ë“œ ì œê±°ë¨
      subject_category: lecture.subject_category,
      subject: lecture.subject,
      platform: lecture.platform_name,  // ë³€ê²½: platform â†’ platform_name
      difficulty_level: lecture.difficulty_level,
      total_episodes: lecture.total_episodes,  // ì¶”ê°€: ì´ íšŒì°¨
      notes: lecture.notes,
      master_lecture_id: lectureId,  // ë³€ê²½: master_content_id â†’ master_lecture_id
    })
    .select("id")
    .single();

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ë³µì‚¬ ì‹¤íŒ¨", {
      lectureId,
      studentId,
      tenantId,
      error: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
    });
    throw new Error(
      error.code === "42501"
        ? "RLS ì •ì±… ìœ„ë°˜: ê°•ì˜ ë³µì‚¬ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
        : error.message || "ê°•ì˜ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
    );
  }

  // episodesë„ í•¨ê»˜ ë³µì‚¬
  const { episodes } = await getMasterLectureById(lectureId);
  if (episodes.length > 0) {
    const studentEpisodes = episodes.map((episode) => ({
      lecture_id: studentLecture.id,
      episode_number: episode.episode_number,
      title: episode.title,  // ë³€ê²½: episode_title â†’ title
      duration: episode.duration,
      display_order: episode.display_order,
    }));

    const { error: episodesError } = await supabase
      .from("student_lecture_episodes")
      .insert(studentEpisodes);

    if (episodesError) {
      console.error("[data/contentMasters] ê°•ì˜ episode ë³µì‚¬ ì‹¤íŒ¨", {
        lectureId: studentLecture.id,
        error: episodesError.message,
        code: episodesError.code,
      });
      // episode ë³µì‚¬ ì‹¤íŒ¨í•´ë„ ê°•ì˜ëŠ” ë³µì‚¬ë¨
    }
  }

  return { lectureId: studentLecture.id };
}

// ============================================
// ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê´€ë ¨ í•¨ìˆ˜
// ============================================

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê²€ìƒ‰
 * @param filters ê²€ìƒ‰ í•„í„°
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì , ì „ë‹¬í•˜ì§€ ì•Šìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©)
 */
export async function searchMasterCustomContents(
  filters: MasterCustomContentFilters,
  supabase?: Awaited<ReturnType<typeof createSupabaseServerClient>>
): Promise<{ data: MasterCustomContent[]; total: number }> {
  const queryClient = supabase || await createSupabaseServerClient();

  let query = queryClient
    .from("master_custom_contents")
    .select("*", { count: "exact" });

  // í•„í„° ì ìš©
  if (filters.curriculum_revision_id) {
    query = query.eq("curriculum_revision_id", filters.curriculum_revision_id);
  }
  if (filters.subject_group_id) {
    query = query.eq("subject_group_id", filters.subject_group_id);
  }
  if (filters.subject_id) {
    query = query.eq("subject_id", filters.subject_id);
  }
  if (filters.content_type) {
    query = query.eq("content_type", filters.content_type);
  }
  if (filters.search) {
    query = query.ilike("title", `%${filters.search}%`);
  }
  if (filters.difficulty) {
    query = query.eq("difficulty_level", filters.difficulty);
  }
  if (filters.tenantId) {
    query = query.or(`tenant_id.is.null,tenant_id.eq.${filters.tenantId}`);
  } else {
    query = query.is("tenant_id", null); // ê¸°ë³¸ì ìœ¼ë¡œ ê³µê°œ ì½˜í…ì¸ ë§Œ
  }

  // ì •ë ¬
  const sortBy = filters.sort || "updated_at_desc";
  if (sortBy === "title_asc") {
    query = query.order("title", { ascending: true });
  } else if (sortBy === "title_desc") {
    query = query.order("title", { ascending: false });
  } else if (sortBy === "difficulty_level_asc") {
    query = query.order("difficulty_level", { ascending: true });
  } else if (sortBy === "difficulty_level_desc") {
    query = query.order("difficulty_level", { ascending: false });
  } else if (sortBy === "created_at_asc") {
    query = query.order("created_at", { ascending: true });
  } else if (sortBy === "created_at_desc") {
    query = query.order("created_at", { ascending: false });
  } else {
    // ê¸°ë³¸ê°’: updated_at_desc
    query = query.order("updated_at", { ascending: false });
  }

  // í˜ì´ì§€ë„¤ì´ì…˜
  if (filters.limit) {
    query = query.limit(filters.limit);
  }
  if (filters.offset) {
    query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);
  }

  const { data, error, count } = await query;

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê²€ìƒ‰ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  const result = {
    data: (data as MasterCustomContent[] | null) ?? [],
    total: count ?? 0,
  };

  return result;
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„¸ ì¡°íšŒ
 */
export async function getMasterCustomContentById(
  contentId: string
): Promise<{ content: MasterCustomContent | null }> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("master_custom_contents")
    .select("*")
    .eq("id", contentId)
    .maybeSingle<MasterCustomContent>();

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return {
    content: data,
  };
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„±
 */
export async function createMasterCustomContent(
  data: Omit<MasterCustomContent, "id" | "created_at" | "updated_at">
): Promise<MasterCustomContent> {
  const supabase = await createSupabaseServerClient();

  const { data: content, error } = await supabase
    .from("master_custom_contents")
    .insert(data)
    .select("*")
    .single<MasterCustomContent>();

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„± ì‹¤íŒ¨", error);
    throw new Error(error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return content;
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìˆ˜ì •
 */
export async function updateMasterCustomContent(
  contentId: string,
  updates: Partial<Omit<MasterCustomContent, "id" | "created_at" | "updated_at">>
): Promise<MasterCustomContent> {
  const supabase = await createSupabaseServerClient();

  const { data: content, error } = await supabase
    .from("master_custom_contents")
    .update(updates)
    .eq("id", contentId)
    .select("*")
    .single<MasterCustomContent>();

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return content;
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì‚­ì œ
 */
export async function deleteMasterCustomContent(contentId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("master_custom_contents")
    .delete()
    .eq("id", contentId);

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

/**
 * ë§ˆìŠ¤í„° ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ í•™ìƒ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¡œ ë³µì‚¬
 * ì£¼ì˜: Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ RLS ì •ì±…ì„ ìš°íšŒí•©ë‹ˆë‹¤.
 */
export async function copyMasterCustomContentToStudent(
  contentId: string,
  studentId: string,
  tenantId: string
): Promise<{ contentId: string }> {
  // Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabase = createSupabaseAdminClient();
  if (!supabase) {
    throw new Error(
      "Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
    );
  }

  const { content } = await getMasterCustomContentById(contentId);
  if (!content) {
    throw new Error("ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  // ì¤‘ë³µ ì²´í¬: ê°™ì€ master_content_idë¥¼ ê°€ì§„ í•™ìƒ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
  const { data: existingContent } = await supabase
    .from("student_custom_contents")
    .select("id")
    .eq("student_id", studentId)
    .eq("title", content.title) // ì œëª©ìœ¼ë¡œ ì¤‘ë³µ ì²´í¬ (master_content_idê°€ ì—†ì„ ìˆ˜ ìˆìŒ)
    .maybeSingle();

  if (existingContent) {
    // ì´ë¯¸ ë³µì‚¬ëœ ì½˜í…ì¸ ê°€ ìˆìœ¼ë©´ ê¸°ì¡´ ID ë°˜í™˜
    return { contentId: existingContent.id };
  }

  const { data: studentContent, error } = await supabase
    .from("student_custom_contents")
    .insert({
      tenant_id: tenantId,
      student_id: studentId,
      title: content.title,
      content_type: content.content_type,
      total_page_or_time: content.total_page_or_time,
      subject: content.subject,
    })
    .select("id")
    .single();

  if (error) {
    console.error("[data/contentMasters] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ë³µì‚¬ ì‹¤íŒ¨", {
      contentId,
      studentId,
      tenantId,
      error: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
    });
    throw new Error(
      error.code === "42501"
        ? "RLS ì •ì±… ìœ„ë°˜: ì»¤ìŠ¤í…€ ì½˜í…ì¸  ë³µì‚¬ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
        : error.message || "ì»¤ìŠ¤í…€ ì½˜í…ì¸  ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
    );
  }

  return { contentId: studentContent.id };
}

/**
 * ë§ˆìŠ¤í„° ì½˜í…ì¸ ë¥¼ í•™ìƒ ì½˜í…ì¸ ë¡œ ë³µì‚¬ (í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated copyMasterBookToStudent, copyMasterLectureToStudent, copyMasterCustomContentToStudent ì‚¬ìš© ê¶Œì¥
 */
export async function copyMasterToStudentContent(
  masterId: string,
  studentId: string,
  tenantId: string
): Promise<{ bookId?: string; lectureId?: string; contentId?: string }> {
  // ë¨¼ì € êµì¬ì—ì„œ ì°¾ê¸°
  try {
    const result = await copyMasterBookToStudent(masterId, studentId, tenantId);
    return { bookId: result.bookId };
  } catch (error) {
    // êµì¬ê°€ ì•„ë‹ˆë©´ ê°•ì˜ë¡œ ì‹œë„
    try {
      const result = await copyMasterLectureToStudent(masterId, studentId, tenantId);
      return { lectureId: result.lectureId };
    } catch (lectureError) {
      // ê°•ì˜ë„ ì•„ë‹ˆë©´ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¡œ ì‹œë„
      const result = await copyMasterCustomContentToStudent(masterId, studentId, tenantId);
      return { contentId: result.contentId };
    }
  }
}

// ============================================
// í•„í„° ì˜µì…˜ ì¡°íšŒ í•¨ìˆ˜
// ============================================

/**
 * ê°œì •êµìœ¡ê³¼ì • ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 */
export async function getCurriculumRevisions(): Promise<Array<{ id: string; name: string }>> {
  // Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ), ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
  const supabase = await getClientForRLSBypass();

  if (!supabase) {
    console.error("[data/contentMasters] Supabase client uninitialized");
    return [];
  }

  const { data, error } = await supabase
    .from("curriculum_revisions")
    .select("id, name")
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] ê°œì •êµìœ¡ê³¼ì • ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  console.log("[data/contentMasters] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ê²°ê³¼:", {
    count: data?.length || 0,
    data: data || [],
    hasAdminClient: !!supabase,
  });

  return (data as Array<{ id: string; name: string }> | null) ?? [];
}

/**
 * êµê³¼ ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­)
 */
export async function getSubjectGroupsForFilter(
  curriculumRevisionId?: string
): Promise<SubjectGroup[]> {
  return await getSubjectGroups(curriculumRevisionId);
}

/**
 * ê³¼ëª© ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 * @param subjectGroupId êµê³¼ ê·¸ë£¹ ID (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ ëª¨ë“  ê³¼ëª© ì¡°íšŒ)
 */
export async function getSubjectsForFilter(
  subjectGroupId?: string
): Promise<Subject[]> {
  if (!subjectGroupId) {
    // ëª¨ë“  ê³¼ëª© ì¡°íšŒ (ì„±ëŠ¥ ê³ ë ¤í•˜ì—¬ ì œí•œ)
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("subjects")
      .select("*")
      .order("name", { ascending: true })
      .limit(500); // ìµœëŒ€ 500ê°œ ì œí•œ

    if (error) {
      console.error("[data/contentMasters] ê³¼ëª© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
      return [];
    }

    return (data as Subject[] | null) ?? [];
  }

  return await getSubjectsByGroup(subjectGroupId);
}

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

/**
 * ê³¼ëª© ëª©ë¡ ì¡°íšŒ (êµì¬)
 */
export async function getBookSubjectList(): Promise<string[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("master_books")
    .select("subject")
    .not("subject", "is", null);

  if (error) {
    console.error("[data/contentMasters] êµì¬ ê³¼ëª© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  const subjects = Array.from(
    new Set((data || []).map((item) => item.subject).filter(Boolean))
  ).sort();

  return subjects as string[];
}

/**
 * ê³¼ëª© ëª©ë¡ ì¡°íšŒ (ê°•ì˜)
 */
export async function getLectureSubjectList(): Promise<string[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("master_lectures")
    .select("subject")
    .not("subject", "is", null);

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ê³¼ëª© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  const subjects = Array.from(
    new Set((data || []).map((item) => item.subject).filter(Boolean))
  ).sort();

  return subjects as string[];
}

/**
 * ê³¼ëª© ëª©ë¡ ì¡°íšŒ (í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated getBookSubjectList ë˜ëŠ” getLectureSubjectList ì‚¬ìš© ê¶Œì¥
 */
export async function getSubjectList(
  content_type?: "book" | "lecture"
): Promise<string[]> {
  if (content_type === "book") {
    return getBookSubjectList();
  } else if (content_type === "lecture") {
    return getLectureSubjectList();
  } else {
    // ë‘˜ ë‹¤ ì¡°íšŒ
    const [books, lectures] = await Promise.all([
      getBookSubjectList(),
      getLectureSubjectList(),
    ]);
    return Array.from(new Set([...books, ...lectures])).sort();
  }
}

/**
 * í•™ê¸° ëª©ë¡ ì¡°íšŒ
 * @deprecated í•™ë…„/í•™ê¸° í•„í„°ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */
/**
 * í•™ê¸° ëª©ë¡ ì¡°íšŒ (í•™ìƒ ì½˜í…ì¸ ìš©)
 * @deprecated ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ semester í•„ë“œê°€ ì œê±°ë¨ (2025-02-04)
 * í•™ìƒ ì½˜í…ì¸ (books, lectures)ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
 */
export async function getSemesterList(): Promise<string[]> {
  const supabase = await createSupabaseServerClient();

  // ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ semester í•„ë“œ ì œê±°ë¨
  // í•™ìƒ ì½˜í…ì¸ (books, lectures)ì—ì„œë§Œ ì¡°íšŒ
  const [booksResult, lecturesResult] = await Promise.all([
    supabase.from("books").select("semester").not("semester", "is", null),
    supabase.from("lectures").select("semester").not("semester", "is", null),
  ]);

  const allSemesters = [
    ...(booksResult.data || []).map((item: { semester: string }) => item.semester),
    ...(lecturesResult.data || []).map((item: { semester: string }) => item.semester),
  ];

  const semesters = Array.from(new Set(allSemesters.filter(Boolean))).sort();

  return semesters as string[];
}

/**
 * ì¶œíŒì‚¬ ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 * master_books í…Œì´ë¸”ì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš©ëœ publisher_idë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¡°íšŒ
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì„ íƒì , ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ)
 */
export async function getPublishersForFilter(
  tenantId?: string | null
): Promise<Array<{ id: string; name: string }>> {
  const supabase = await getClientForRLSBypass();
  if (!supabase) return [];

  // master_booksì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš©ëœ publisher_id ì¡°íšŒ
  let publisherQuery = supabase
    .from("master_books")
    .select("publisher_id")
    .not("publisher_id", "is", null);

  // tenantIdê°€ ìˆìœ¼ë©´ í•´ë‹¹ í…Œë„ŒíŠ¸ + ê³µê°œ ì½˜í…ì¸ ë§Œ, ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ
  if (tenantId) {
    publisherQuery = publisherQuery.or(`tenant_id.is.null,tenant_id.eq.${tenantId}`);
  } else {
    publisherQuery = publisherQuery.is("tenant_id", null);
  }

  const { data: booksData, error: booksError } = await publisherQuery;

  if (booksError) {
    console.error("[data/contentMasters] ì¶œíŒì‚¬ ID ì¡°íšŒ ì‹¤íŒ¨", booksError);
    return [];
  }

  // ì‚¬ìš©ëœ publisher_id ì¶”ì¶œ (ì¤‘ë³µ ì œê±°)
  const publisherIds = Array.from(
    new Set(
      (booksData || [])
        .map((book: { publisher_id: string | null }) => book.publisher_id)
        .filter((id): id is string => id !== null)
    )
  );

  if (publisherIds.length === 0) {
    return [];
  }

  // publishers í…Œì´ë¸”ì—ì„œ í•´ë‹¹ ì¶œíŒì‚¬ ì •ë³´ ì¡°íšŒ
  const { data, error } = await supabase
    .from("publishers")
    .select("id, name")
    .in("id", publisherIds)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] ì¶œíŒì‚¬ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Array<{ id: string; name: string }> | null) ?? [];
}

/**
 * í”Œë«í¼ ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 * master_lectures í…Œì´ë¸”ì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš©ëœ platform_idë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¡°íšŒ
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì„ íƒì , ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ)
 */
export async function getPlatformsForFilter(
  tenantId?: string | null
): Promise<Array<{ id: string; name: string }>> {
  const supabase = await getClientForRLSBypass();
  if (!supabase) return [];

  // master_lecturesì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš©ëœ platform_id ì¡°íšŒ
  
  let platformQuery = supabase
    .from("master_lectures")
    .select("platform_id")
    .not("platform_id", "is", null);

  // tenantIdê°€ ìˆìœ¼ë©´ í•´ë‹¹ í…Œë„ŒíŠ¸ + ê³µê°œ ì½˜í…ì¸ ë§Œ, ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ
  if (tenantId) {
    platformQuery = platformQuery.or(`tenant_id.is.null,tenant_id.eq.${tenantId}`);
  } else {
    platformQuery = platformQuery.is("tenant_id", null);
  }

  const { data: lecturesData, error: lecturesError } = await platformQuery;

  if (lecturesError) {
    console.error("[data/contentMasters] í”Œë«í¼ ID ì¡°íšŒ ì‹¤íŒ¨", lecturesError);
    return [];
  }

  // ì‚¬ìš©ëœ platform_id ì¶”ì¶œ (ì¤‘ë³µ ì œê±°)
  const platformIds = Array.from(
    new Set(
      (lecturesData || [])
        .map((lecture: { platform_id: string | null }) => lecture.platform_id)
        .filter((id): id is string => id !== null)
    )
  );

  if (platformIds.length === 0) {
    return [];
  }

  // platforms í…Œì´ë¸”ì—ì„œ í•´ë‹¹ í”Œë«í¼ ì •ë³´ ì¡°íšŒ
  const { data, error } = await supabase
    .from("platforms")
    .select("id, name")
    .in("id", platformIds)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] í”Œë«í¼ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Array<{ id: string; name: string }> | null) ?? [];
}

/**
 * ë§ˆìŠ¤í„° êµì¬ ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 */
export async function getDifficultiesForMasterBooks(
  tenantId?: string | null
): Promise<string[]> {
  const supabase = await getClientForRLSBypass();

  if (!supabase) return [];
  let query = supabase
    .from("master_books")
    .select("difficulty_level")
    .not("difficulty_level", "is", null);

  // tenantIdê°€ ìˆìœ¼ë©´ í•´ë‹¹ í…Œë„ŒíŠ¸ + ê³µê°œ ì½˜í…ì¸ ë§Œ, ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ
  if (tenantId) {
    query = query.or(`tenant_id.is.null,tenant_id.eq.${tenantId}`);
  } else {
    query = query.is("tenant_id", null);
  }

  const { data, error } = await query;

  if (error) {
    console.error("[data/contentMasters] ë§ˆìŠ¤í„° êµì¬ ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  const difficulties = new Set<string>();
  (data ?? []).forEach((item: { difficulty_level: string | null }) => {
    if (item.difficulty_level) {
      difficulties.add(item.difficulty_level);
    }
  });

  return Array.from(difficulties).sort();
}

/**
 * ë§ˆìŠ¤í„° ê°•ì˜ ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ (í•„í„° ì˜µì…˜ìš©)
 */
export async function getDifficultiesForMasterLectures(
  tenantId?: string | null
): Promise<string[]> {
  const supabase = await getClientForRLSBypass();

  if (!supabase) return [];
  let query = supabase
    .from("master_lectures")
    .select("difficulty_level")
    .not("difficulty_level", "is", null);

  // tenantIdê°€ ìˆìœ¼ë©´ í•´ë‹¹ í…Œë„ŒíŠ¸ + ê³µê°œ ì½˜í…ì¸ ë§Œ, ì—†ìœ¼ë©´ ê³µê°œ ì½˜í…ì¸ ë§Œ
  if (tenantId) {
    query = query.or(`tenant_id.is.null,tenant_id.eq.${tenantId}`);
  } else {
    query = query.is("tenant_id", null);
  }

  const { data, error } = await query;

  if (error) {
    console.error("[data/contentMasters] ë§ˆìŠ¤í„° ê°•ì˜ ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  const difficulties = new Set<string>();
  (data ?? []).forEach((item: { difficulty_level: string | null }) => {
    if (item.difficulty_level) {
      difficulties.add(item.difficulty_level);
    }
  });

  return Array.from(difficulties).sort();
}

// ============================================
// CRUD í•¨ìˆ˜
// ============================================

/**
 * êµì¬ ìƒì„±
 */
export async function createMasterBook(
  data: Omit<MasterBook, "id" | "created_at" | "updated_at">
): Promise<MasterBook> {
  const supabase = await createSupabaseServerClient();

  const { data: book, error } = await supabase
    .from("master_books")
    .insert({
      tenant_id: data.tenant_id,
      is_active: data.is_active,
      curriculum_revision_id: data.curriculum_revision_id,
      subject_id: data.subject_id,
      subject_group_id: data.subject_group_id,
      subject_category: data.subject_category,
      subject: data.subject,
      grade_min: data.grade_min,
      grade_max: data.grade_max,
      school_type: data.school_type,
      revision: data.revision,
      content_category: data.content_category,
      // semester í•„ë“œ ì œê±°ë¨ (2025-02-04)
      title: data.title,
      subtitle: data.subtitle,
      series_name: data.series_name,
      author: data.author,
      publisher_id: data.publisher_id,
      publisher_name: data.publisher_name,
      isbn_10: data.isbn_10,
      isbn_13: data.isbn_13,
      edition: data.edition,
      published_date: data.published_date,
      total_pages: data.total_pages,
      target_exam_type: data.target_exam_type,
      description: data.description,
      toc: data.toc,
      publisher_review: data.publisher_review,
      tags: data.tags,
      source: data.source,
      source_product_code: data.source_product_code,
      source_url: data.source_url,
      cover_image_url: data.cover_image_url,
      difficulty_level: data.difficulty_level,
      notes: data.notes,
      pdf_url: data.pdf_url,
      ocr_data: data.ocr_data,
      page_analysis: data.page_analysis,
      overall_difficulty: data.overall_difficulty,
    })
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìƒì„± ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return book as MasterBook;
}

/**
 * êµì¬ ìˆ˜ì •
 */
export async function updateMasterBook(
  bookId: string,
  data: Partial<Omit<MasterBook, "id" | "created_at" | "updated_at">>
): Promise<MasterBook> {
  const supabase = await createSupabaseServerClient();

  // undefined í•„ë“œëŠ” ì œì™¸í•˜ê³  ì‹¤ì œ ì¡´ì¬í•˜ëŠ” í•„ë“œë§Œ ì—…ë°ì´íŠ¸
  const updateFields: Record<string, any> = {};
  
  if (data.tenant_id !== undefined) updateFields.tenant_id = data.tenant_id;
  if (data.is_active !== undefined) updateFields.is_active = data.is_active;
  if (data.curriculum_revision_id !== undefined) updateFields.curriculum_revision_id = data.curriculum_revision_id;
  if (data.subject_id !== undefined) updateFields.subject_id = data.subject_id;
  if (data.subject_group_id !== undefined) updateFields.subject_group_id = data.subject_group_id;
  if (data.subject_category !== undefined) updateFields.subject_category = data.subject_category;
  if (data.subject !== undefined) updateFields.subject = data.subject;
  if (data.grade_min !== undefined) updateFields.grade_min = data.grade_min;
  if (data.grade_max !== undefined) updateFields.grade_max = data.grade_max;
  if (data.school_type !== undefined) updateFields.school_type = data.school_type;
  if (data.revision !== undefined) updateFields.revision = data.revision;
  if (data.content_category !== undefined) updateFields.content_category = data.content_category;
  // semester í•„ë“œ ì œê±°ë¨ (2025-02-04)
  if (data.title !== undefined) updateFields.title = data.title;
  if (data.subtitle !== undefined) updateFields.subtitle = data.subtitle;
  if (data.series_name !== undefined) updateFields.series_name = data.series_name;
  if (data.author !== undefined) updateFields.author = data.author;
  if (data.publisher_id !== undefined) updateFields.publisher_id = data.publisher_id;
  if (data.publisher_name !== undefined) updateFields.publisher_name = data.publisher_name;
  if (data.isbn_10 !== undefined) updateFields.isbn_10 = data.isbn_10;
  if (data.isbn_13 !== undefined) updateFields.isbn_13 = data.isbn_13;
  if (data.edition !== undefined) updateFields.edition = data.edition;
  if (data.published_date !== undefined) updateFields.published_date = data.published_date;
  if (data.total_pages !== undefined) updateFields.total_pages = data.total_pages;
  if (data.target_exam_type !== undefined) updateFields.target_exam_type = data.target_exam_type;
  if (data.description !== undefined) updateFields.description = data.description;
  if (data.toc !== undefined) updateFields.toc = data.toc;
  if (data.publisher_review !== undefined) updateFields.publisher_review = data.publisher_review;
  if (data.tags !== undefined) updateFields.tags = data.tags;
  if (data.source !== undefined) updateFields.source = data.source;
  if (data.source_product_code !== undefined) updateFields.source_product_code = data.source_product_code;
  if (data.source_url !== undefined) updateFields.source_url = data.source_url;
  if (data.cover_image_url !== undefined) updateFields.cover_image_url = data.cover_image_url;
  if (data.difficulty_level !== undefined) updateFields.difficulty_level = data.difficulty_level;
  if (data.notes !== undefined) updateFields.notes = data.notes;
  if (data.pdf_url !== undefined) updateFields.pdf_url = data.pdf_url;
  if (data.ocr_data !== undefined) updateFields.ocr_data = data.ocr_data;
  if (data.page_analysis !== undefined) updateFields.page_analysis = data.page_analysis;
  if (data.overall_difficulty !== undefined) updateFields.overall_difficulty = data.overall_difficulty;

  const { data: book, error } = await supabase
    .from("master_books")
    .update(updateFields)
    .eq("id", bookId)
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return book as MasterBook;
}

/**
 * êµì¬ ì‚­ì œ
 */
export async function deleteMasterBook(bookId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("master_books")
    .delete()
    .eq("id", bookId);

  if (error) {
    console.error("[data/contentMasters] êµì¬ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

/**
 * ê°•ì˜ ìƒì„±
 */
export async function createMasterLecture(
  data: Omit<MasterLecture, "id" | "created_at" | "updated_at">
): Promise<MasterLecture> {
  const supabase = await createSupabaseServerClient();

  const { data: lecture, error } = await supabase
    .from("master_lectures")
    .insert({
      tenant_id: data.tenant_id,
      revision: data.revision,
      content_category: data.content_category,
      // semester í•„ë“œ ì œê±°ë¨ (2025-02-04)
      subject_category: data.subject_category,
      subject: data.subject,
      title: data.title,
      platform: data.platform,
      total_episodes: data.total_episodes,
      total_duration: data.total_duration,
      difficulty_level: data.difficulty_level,
      notes: data.notes,
      linked_book_id: data.linked_book_id,
      video_url: data.video_url,
      transcript: data.transcript,
      episode_analysis: data.episode_analysis,
      overall_difficulty: data.overall_difficulty,
    })
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ìƒì„± ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return lecture as MasterLecture;
}

/**
 * ê°•ì˜ ìˆ˜ì •
 */
export async function updateMasterLecture(
  lectureId: string,
  data: Partial<Omit<MasterLecture, "id" | "created_at" | "updated_at">>
): Promise<MasterLecture> {
  const supabase = await createSupabaseServerClient();

  const { data: lecture, error } = await supabase
    .from("master_lectures")
    .update({
      revision: data.revision,
      content_category: data.content_category,
      // semester í•„ë“œ ì œê±°ë¨ (2025-02-04)
      subject_category: data.subject_category,
      subject: data.subject,
      title: data.title,
      platform: data.platform,
      total_episodes: data.total_episodes,
      total_duration: data.total_duration,
      difficulty_level: data.difficulty_level,
      notes: data.notes,
      linked_book_id: data.linked_book_id,
      video_url: data.video_url,
      transcript: data.transcript,
      episode_analysis: data.episode_analysis,
      overall_difficulty: data.overall_difficulty,
    })
    .eq("id", lectureId)
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return lecture as MasterLecture;
}

/**
 * ê°•ì˜ ì‚­ì œ
 */
export async function deleteMasterLecture(lectureId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("master_lectures")
    .delete()
    .eq("id", lectureId);

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

// ============================================
// êµì¬ ìƒì„¸ ì •ë³´ CRUD
// ============================================

/**
 * êµì¬ ìƒì„¸ ì •ë³´ ì¶”ê°€
 */
export async function createBookDetail(
  data: Omit<BookDetail, "id" | "created_at">
): Promise<BookDetail> {
  const supabase = await createSupabaseServerClient();

  const { data: detail, error } = await supabase
    .from("book_details")
    .insert({
      book_id: data.book_id,
      major_unit: data.major_unit,
      minor_unit: data.minor_unit,
      page_number: data.page_number,
      display_order: data.display_order,
    })
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìƒì„¸ ì •ë³´ ì¶”ê°€ ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìƒì„¸ ì •ë³´ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return detail as BookDetail;
}

/**
 * êµì¬ ìƒì„¸ ì •ë³´ ìˆ˜ì •
 */
export async function updateBookDetail(
  detailId: string,
  data: Partial<Omit<BookDetail, "id" | "created_at">>
): Promise<BookDetail> {
  const supabase = await createSupabaseServerClient();

  const { data: detail, error } = await supabase
    .from("book_details")
    .update({
      major_unit: data.major_unit,
      minor_unit: data.minor_unit,
      page_number: data.page_number,
      display_order: data.display_order,
    })
    .eq("id", detailId)
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìƒì„¸ ì •ë³´ ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìƒì„¸ ì •ë³´ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return detail as BookDetail;
}

/**
 * êµì¬ ìƒì„¸ ì •ë³´ ì‚­ì œ
 */
export async function deleteBookDetail(detailId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("book_details")
    .delete()
    .eq("id", detailId);

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìƒì„¸ ì •ë³´ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìƒì„¸ ì •ë³´ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

/**
 * êµì¬ì˜ ëª¨ë“  ìƒì„¸ ì •ë³´ ì‚­ì œ
 */
export async function deleteAllBookDetails(bookId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("book_details")
    .delete()
    .eq("book_id", bookId);

  if (error) {
    console.error("[data/contentMasters] êµì¬ ìƒì„¸ ì •ë³´ ì¼ê´„ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "êµì¬ ìƒì„¸ ì •ë³´ ì¼ê´„ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

// ============================================
// ê°•ì˜ Episode ê´€ë ¨ í•¨ìˆ˜
// ============================================

/**
 * ê°•ì˜ episode ìƒì„±
 */
export async function createLectureEpisode(
  data: Omit<LectureEpisode, "id" | "created_at">
): Promise<LectureEpisode> {
  const supabase = await createSupabaseServerClient();

  const { data: episode, error } = await supabase
    .from("lecture_episodes")
    .insert({
      lecture_id: data.lecture_id,
      episode_number: data.episode_number,
      title: data.title || null,  // ë³€ê²½: episode_title â†’ title
      duration: data.duration || null,
      display_order: data.display_order,
    })
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ episode ì¶”ê°€ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ episode ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return episode as LectureEpisode;
}

/**
 * ê°•ì˜ episode ìˆ˜ì •
 */
export async function updateLectureEpisode(
  episodeId: string,
  data: Partial<Omit<LectureEpisode, "id" | "created_at">>
): Promise<LectureEpisode> {
  const supabase = await createSupabaseServerClient();

  const { data: episode, error } = await supabase
    .from("lecture_episodes")
    .update({
      episode_number: data.episode_number,
      title: data.title,  // ë³€ê²½: episode_title â†’ title
      duration: data.duration,
      display_order: data.display_order,
    })
    .eq("id", episodeId)
    .select()
    .single();

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ episode ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ episode ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  return episode as LectureEpisode;
}

/**
 * ê°•ì˜ episode ì‚­ì œ
 */
export async function deleteLectureEpisode(episodeId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("lecture_episodes")
    .delete()
    .eq("id", episodeId);

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ episode ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ episode ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

/**
 * ê°•ì˜ episode ì¼ê´„ ì‚­ì œ
 */
export async function deleteAllLectureEpisodes(lectureId: string): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("lecture_episodes")
    .delete()
    .eq("lecture_id", lectureId);

  if (error) {
    console.error("[data/contentMasters] ê°•ì˜ episode ì¼ê´„ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(error.message || "ê°•ì˜ episode ì¼ê´„ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }
}

// ============================================
// í•™ìƒ ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ì¡°íšŒ
// ============================================

/**
 * í•™ìƒ êµì¬ì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ (student_book_details)
 */
export async function getStudentBookDetails(
  bookId: string,
  studentId: string
): Promise<Array<{ id: string; page_number: number; major_unit: string | null; minor_unit: string | null }>> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_book_details")
    .select("id, page_number, major_unit, minor_unit")
    .eq("book_id", bookId)
    .order("page_number", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] í•™ìƒ êµì¬ ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Array<{ id: string; page_number: number; major_unit: string | null; minor_unit: string | null }> | null) ?? [];
}

/**
 * í•™ìƒ ê°•ì˜ì˜ episode ì •ë³´ ì¡°íšŒ (student_lecture_episodes)
 */
export async function getStudentLectureEpisodes(
  lectureId: string,
  studentId: string
): Promise<Array<{ id: string; episode_number: number; title: string | null }>> {  // ë³€ê²½: episode_title â†’ title
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_lecture_episodes")
    .select("id, episode_number, title")  // ë³€ê²½: episode_title â†’ title
    .eq("lecture_id", lectureId)
    .order("episode_number", { ascending: true });

  if (error) {
    console.error("[data/contentMasters] í•™ìƒ ê°•ì˜ episode ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Array<{ id: string; episode_number: number; title: string | null }> | null) ?? [];  // ë³€ê²½: episode_title â†’ title
}

/**
 * ì—¬ëŸ¬ êµì¬ì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
 * @param bookIds ì¡°íšŒí•  êµì¬ ID ë°°ì—´
 * @param studentId í•™ìƒ ID
 * @returns Map<bookId, BookDetail[]> í˜•íƒœë¡œ ë°˜í™˜
 */
export async function getStudentBookDetailsBatch(
  bookIds: string[],
  studentId: string
): Promise<Map<string, Array<{ id: string; page_number: number; major_unit: string | null; minor_unit: string | null }>>> {
  if (bookIds.length === 0) {
    return new Map();
  }

  const supabase = await createSupabaseServerClient();

  // ì„±ëŠ¥ ì¸¡ì • ì‹œì‘
  const queryStart = performance.now();

  const { data, error } = await supabase
    .from("student_book_details")
    .select("id, book_id, page_number, major_unit, minor_unit")
    .in("book_id", bookIds)
    .order("book_id", { ascending: true })
    .order("page_number", { ascending: true });

  const queryTime = performance.now() - queryStart;

  if (error) {
    console.error("[data/contentMasters] í•™ìƒ êµì¬ ìƒì„¸ ì •ë³´ ë°°ì¹˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return new Map();
  }

  // ê²°ê³¼ë¥¼ bookIdë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ Mapìœ¼ë¡œ ë°˜í™˜ (ìµœì í™”: push() ì‚¬ìš©)
  const resultMap = new Map<string, Array<{ id: string; page_number: number; major_unit: string | null; minor_unit: string | null }>>();
  
  (data || []).forEach((detail: { id: string; book_id: string; page_number: number; major_unit: string | null; minor_unit: string | null }) => {
    if (!resultMap.has(detail.book_id)) {
      resultMap.set(detail.book_id, []);
    }
    resultMap.get(detail.book_id)!.push({
      id: detail.id,
      page_number: detail.page_number,
      major_unit: detail.major_unit,
      minor_unit: detail.minor_unit,
    });
  });

  // ì¡°íšŒ ê²°ê³¼ê°€ ì—†ëŠ” bookIdë“¤ë„ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”
  bookIds.forEach((bookId) => {
    if (!resultMap.has(bookId)) {
      resultMap.set(bookId, []);
    }
  });

  // ì„±ëŠ¥ ë¡œê¹… (ê°œë°œ í™˜ê²½ì—ì„œë§Œ) - resultMap ìƒì„± í›„ ì‹¤í–‰
  if (process.env.NODE_ENV === "development") {
    const resultCount = data?.length || 0;
    const emptyBookIds = bookIds.filter((bookId) => !resultMap.has(bookId) || resultMap.get(bookId)!.length === 0);
    
    console.log("[getStudentBookDetailsBatch] ì¿¼ë¦¬ ì„±ëŠ¥:", {
      bookCount: bookIds.length,
      resultCount,
      queryTime: `${queryTime.toFixed(2)}ms`,
      avgTimePerBook: bookIds.length > 0 ? `${(queryTime / bookIds.length).toFixed(2)}ms` : "N/A",
      emptyBookCount: emptyBookIds.length,
      emptyBookIds: emptyBookIds.length > 0 ? emptyBookIds : undefined,
    });
    
    // ëª©ì°¨ê°€ ì—†ëŠ” êµì¬ê°€ ìˆëŠ” ê²½ìš° ì¶”ê°€ ë¡œê¹…
    if (emptyBookIds.length > 0) {
      console.debug("[getStudentBookDetailsBatch] ëª©ì°¨ê°€ ì—†ëŠ” êµì¬:", {
        count: emptyBookIds.length,
        bookIds: emptyBookIds,
        reason: "student_book_details í…Œì´ë¸”ì— í•´ë‹¹ êµì¬ì˜ ëª©ì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.",
      });
    }
  }

  return resultMap;
}

/**
 * ì—¬ëŸ¬ ê°•ì˜ì˜ episode ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
 * @param lectureIds ì¡°íšŒí•  ê°•ì˜ ID ë°°ì—´
 * @param studentId í•™ìƒ ID
 * @returns Map<lectureId, Episode[]> í˜•íƒœë¡œ ë°˜í™˜
 */
export async function getStudentLectureEpisodesBatch(
  lectureIds: string[],
  studentId: string
): Promise<Map<string, Array<{ id: string; episode_number: number; title: string | null; duration: number | null }>>> {
  if (lectureIds.length === 0) {
    return new Map();
  }

  const supabase = await createSupabaseServerClient();

  // ì„±ëŠ¥ ì¸¡ì • ì‹œì‘
  const queryStart = performance.now();

  const { data, error } = await supabase
    .from("student_lecture_episodes")
    .select("id, lecture_id, episode_number, title, duration")
    .in("lecture_id", lectureIds)
    .order("lecture_id", { ascending: true })
    .order("episode_number", { ascending: true });

  const queryTime = performance.now() - queryStart;

  if (error) {
    console.error("[data/contentMasters] í•™ìƒ ê°•ì˜ episode ë°°ì¹˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return new Map();
  }

  // ê²°ê³¼ë¥¼ lectureIdë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ Mapìœ¼ë¡œ ë°˜í™˜ (ìµœì í™”: push() ì‚¬ìš©)
  const resultMap = new Map<string, Array<{ id: string; episode_number: number; title: string | null; duration: number | null }>>();
  
  (data || []).forEach((episode: { id: string; lecture_id: string; episode_number: number; title: string | null; duration: number | null }) => {
    if (!resultMap.has(episode.lecture_id)) {
      resultMap.set(episode.lecture_id, []);
    }
    resultMap.get(episode.lecture_id)!.push({
      id: episode.id,
      episode_number: episode.episode_number,
      title: episode.title,
      duration: episode.duration,
    });
  });

  // ì¡°íšŒ ê²°ê³¼ê°€ ì—†ëŠ” lectureIdë“¤ë„ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”
  lectureIds.forEach((lectureId) => {
    if (!resultMap.has(lectureId)) {
      resultMap.set(lectureId, []);
    }
  });

  // ì„±ëŠ¥ ë¡œê¹… (ê°œë°œ í™˜ê²½ì—ì„œë§Œ) - resultMap ìƒì„± í›„ ì‹¤í–‰
  if (process.env.NODE_ENV === "development") {
    const resultCount = data?.length || 0;
    const emptyLectureIds = lectureIds.filter((lectureId) => !resultMap.has(lectureId) || resultMap.get(lectureId)!.length === 0);
    
    console.log("[getStudentLectureEpisodesBatch] ì¿¼ë¦¬ ì„±ëŠ¥:", {
      lectureCount: lectureIds.length,
      resultCount,
      queryTime: `${queryTime.toFixed(2)}ms`,
      avgTimePerLecture: lectureIds.length > 0 ? `${(queryTime / lectureIds.length).toFixed(2)}ms` : "N/A",
      emptyLectureCount: emptyLectureIds.length,
      emptyLectureIds: emptyLectureIds.length > 0 ? emptyLectureIds : undefined,
    });
    
    // íšŒì°¨ê°€ ì—†ëŠ” ê°•ì˜ê°€ ìˆëŠ” ê²½ìš° ì¶”ê°€ ë¡œê¹…
    if (emptyLectureIds.length > 0) {
      console.debug("[getStudentLectureEpisodesBatch] íšŒì°¨ê°€ ì—†ëŠ” ê°•ì˜:", {
        count: emptyLectureIds.length,
        lectureIds: emptyLectureIds,
        reason: "student_lecture_episodes í…Œì´ë¸”ì— í•´ë‹¹ ê°•ì˜ì˜ íšŒì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.",
      });
    }
  }

  return resultMap;
}
</file>

<file path="contentMetadata.ts">
/**
 * ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° ì¡°íšŒ ìœ í‹¸ë¦¬í‹°
 * TODO ì£¼ì„ í•´ê²°: ë§ˆìŠ¤í„° ì½˜í…ì¸ ì˜ subject_categoryë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¡°íšŒ
 */

import { createSupabaseServerClient, createSupabasePublicClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { PlanGroupError, PlanGroupErrorCodes } from "@/lib/errors/planGroupErrors";

/**
 * ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° íƒ€ì…
 */
export type ContentMetadata = {
  title: string;
  subject_category: string;
  total_pages?: number; // êµì¬ì¸ ê²½ìš°
  total_episodes?: number; // ê°•ì˜ì¸ ê²½ìš°
  subject?: string | null;
  semester?: string | null;
  revision?: string | null;
  difficulty_level?: string | null;
  publisher?: string | null; // êµì¬ì¸ ê²½ìš°
  platform?: string | null; // ê°•ì˜ì¸ ê²½ìš°
};

/**
 * ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° ì¡°íšŒ (ì„œë²„ ì‚¬ì´ë“œ)
 * í•™ìƒ ì½˜í…ì¸  ë˜ëŠ” ë§ˆìŠ¤í„° ì½˜í…ì¸ ì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 */
export async function fetchContentMetadata(
  contentId: string,
  contentType: "book" | "lecture",
  studentId?: string
): Promise<ContentMetadata> {
  const supabase = await createSupabaseServerClient();

  try {
    // 1. í•™ìƒ ì½˜í…ì¸ ì¸ ê²½ìš° ë¨¼ì € ì¡°íšŒ
    if (studentId) {
      if (contentType === "book") {
        const { data: studentBook, error: studentError } = await supabase
          .from("books")
          .select("id, title, subject_category, master_content_id, subject, semester, revision, difficulty_level, publisher")
          .eq("id", contentId)
          .eq("student_id", studentId)
          .maybeSingle();

        if (studentError) {
          throw new PlanGroupError(
            `í•™ìƒ êµì¬ ì¡°íšŒ ì‹¤íŒ¨: ${studentError.message}`,
            PlanGroupErrorCodes.CONTENT_FETCH_FAILED,
            "ì½˜í…ì¸  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            true,
            { contentId, contentType, studentId }
          );
        }

        if (studentBook) {
          // master_content_idê°€ ìˆìœ¼ë©´ ì›ë³¸ ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ subject_category ì¡°íšŒ
          if (studentBook.master_content_id) {
            const { data: masterBook } = await supabase
              .from("master_books")
              .select("subject_category, total_pages")
              .eq("id", studentBook.master_content_id)
              .maybeSingle();

            return {
              title: studentBook.title || "ì œëª© ì—†ìŒ",
              subject_category: masterBook?.subject_category || studentBook.subject_category || "ê¸°íƒ€",
              total_pages: masterBook?.total_pages,
              subject: studentBook.subject,
              semester: studentBook.semester,
              revision: studentBook.revision,
              difficulty_level: studentBook.difficulty_level,
              publisher: studentBook.publisher,
            };
          }

          // master_content_idê°€ ì—†ìœ¼ë©´ í•™ìƒ ì½˜í…ì¸  ì •ë³´ ì‚¬ìš©
          return {
            title: studentBook.title || "ì œëª© ì—†ìŒ",
            subject_category: studentBook.subject_category || "ê¸°íƒ€",
            subject: studentBook.subject,
            semester: studentBook.semester,
            revision: studentBook.revision,
            difficulty_level: studentBook.difficulty_level,
            publisher: studentBook.publisher,
          };
        }
      } else {
        // lecture
        const { data: studentLecture, error: studentError } = await supabase
          .from("lectures")
          .select("id, title, subject_category, master_content_id, subject, semester, revision, difficulty_level, platform")
          .eq("id", contentId)
          .eq("student_id", studentId)
          .maybeSingle();

        if (studentError) {
          throw new PlanGroupError(
            `í•™ìƒ ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨: ${studentError.message}`,
            PlanGroupErrorCodes.CONTENT_FETCH_FAILED,
            "ì½˜í…ì¸  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            true,
            { contentId, contentType, studentId }
          );
        }

        if (studentLecture) {
          // master_content_idê°€ ìˆìœ¼ë©´ ì›ë³¸ ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ subject_category ì¡°íšŒ
          if (studentLecture.master_content_id) {
            const { data: masterLecture } = await supabase
              .from("master_lectures")
              .select("subject_category, total_episodes")
              .eq("id", studentLecture.master_content_id)
              .maybeSingle();

            return {
              title: studentLecture.title || "ì œëª© ì—†ìŒ",
              subject_category: masterLecture?.subject_category || studentLecture.subject_category || "ê¸°íƒ€",
              total_episodes: masterLecture?.total_episodes,
              subject: studentLecture.subject,
              semester: studentLecture.semester,
              revision: studentLecture.revision,
              difficulty_level: studentLecture.difficulty_level,
              platform: studentLecture.platform,
            };
          }

          // master_content_idê°€ ì—†ìœ¼ë©´ í•™ìƒ ì½˜í…ì¸  ì •ë³´ ì‚¬ìš©
          return {
            title: studentLecture.title || "ì œëª© ì—†ìŒ",
            subject_category: studentLecture.subject_category || "ê¸°íƒ€",
            subject: studentLecture.subject,
            semester: studentLecture.semester,
            revision: studentLecture.revision,
            difficulty_level: studentLecture.difficulty_level,
            platform: studentLecture.platform,
          };
        }
      }
    }

    // 2. ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ (í•™ìƒ ì½˜í…ì¸ ê°€ ì—†ê±°ë‚˜ studentIdê°€ ì—†ëŠ” ê²½ìš°)
    if (contentType === "book") {
      const { data: masterBook, error: masterError } = await supabase
        .from("master_books")
        .select("title, subject_category, total_pages, subject, semester, revision, difficulty_level, publisher")
        .eq("id", contentId)
        .maybeSingle();

      if (masterError) {
        throw new PlanGroupError(
          `ë§ˆìŠ¤í„° êµì¬ ì¡°íšŒ ì‹¤íŒ¨: ${masterError.message}`,
          PlanGroupErrorCodes.CONTENT_NOT_FOUND,
          "ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          false,
          { contentId, contentType }
        );
      }

      if (!masterBook) {
        throw new PlanGroupError(
          `ë§ˆìŠ¤í„° êµì¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${contentId}`,
          PlanGroupErrorCodes.CONTENT_NOT_FOUND,
          "ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          false,
          { contentId, contentType }
        );
      }

      return {
        title: masterBook.title || "ì œëª© ì—†ìŒ",
        subject_category: masterBook.subject_category || "ê¸°íƒ€",
        total_pages: masterBook.total_pages,
        subject: masterBook.subject,
        semester: masterBook.semester,
        revision: masterBook.revision,
        difficulty_level: masterBook.difficulty_level,
        publisher: masterBook.publisher,
      };
    } else {
      // lecture
      const { data: masterLecture, error: masterError } = await supabase
        .from("master_lectures")
        .select("title, subject_category, total_episodes, subject, semester, revision, difficulty_level, platform")
        .eq("id", contentId)
        .maybeSingle();

      if (masterError) {
        throw new PlanGroupError(
          `ë§ˆìŠ¤í„° ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨: ${masterError.message}`,
          PlanGroupErrorCodes.CONTENT_NOT_FOUND,
          "ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          false,
          { contentId, contentType }
        );
      }

      if (!masterLecture) {
        throw new PlanGroupError(
          `ë§ˆìŠ¤í„° ê°•ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${contentId}`,
          PlanGroupErrorCodes.CONTENT_NOT_FOUND,
          "ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          false,
          { contentId, contentType }
        );
      }

      return {
        title: masterLecture.title || "ì œëª© ì—†ìŒ",
        subject_category: masterLecture.subject_category || "ê¸°íƒ€",
        total_episodes: masterLecture.total_episodes,
        subject: masterLecture.subject,
        semester: masterLecture.semester,
        revision: masterLecture.revision,
        difficulty_level: masterLecture.difficulty_level,
        platform: masterLecture.platform,
      };
    }
  } catch (error) {
    if (error instanceof PlanGroupError) {
      throw error;
    }
    throw new PlanGroupError(
      `ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: ${error instanceof Error ? error.message : String(error)}`,
      PlanGroupErrorCodes.CONTENT_METADATA_FETCH_FAILED,
      "ì½˜í…ì¸  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      true,
      { contentId, contentType, studentId }
    );
  }
}

/**
 * ì—¬ëŸ¬ ì½˜í…ì¸ ì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ë°°ì¹˜ë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
 */
export async function fetchContentMetadataBatch(
  contents: Array<{
    content_id: string;
    content_type: "book" | "lecture";
  }>,
  studentId?: string
): Promise<Map<string, ContentMetadata>> {
  const results = new Map<string, ContentMetadata>();
  
  // ë³‘ë ¬ë¡œ ì¡°íšŒ (Promise.all ì‚¬ìš©)
  const promises = contents.map(async (content) => {
    try {
      const metadata = await fetchContentMetadata(
        content.content_id,
        content.content_type,
        studentId
      );
      return { contentId: content.content_id, metadata };
    } catch (error) {
      // ê°œë³„ ì‹¤íŒ¨ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
      console.error(
        `[fetchContentMetadataBatch] ì½˜í…ì¸  ${content.content_id} ì¡°íšŒ ì‹¤íŒ¨:`,
        error
      );
      return null;
    }
  });

  const resolved = await Promise.all(promises);
  
  resolved.forEach((result) => {
    if (result) {
      results.set(result.contentId, result.metadata);
    }
  });

  return results;
}

// ============================================
// Education Metadata Types
// ============================================

export type CurriculumRevision = {
  id: string;
  name: string;
  year?: number | null; // ê°œì •êµìœ¡ê³¼ì • ì—°ë„ (ì˜ˆ: 2015, 2022)
  display_order?: number; // í‘œì‹œ ìˆœì„œ
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};


export type SubjectCategory = {
  id: string;
  name: string;
  code?: string | null;
  display_order: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

export type Subject = {
  id: string;
  subject_category_id: string;
  name: string;
  code?: string | null;
  subject_type?: "common" | "elective" | "research" | "social" | null;
  display_order?: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

export type Platform = {
  id: string;
  name: string;
  display_order: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

export type Publisher = {
  id: string;
  name: string;
  display_order: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

// ============================================
// Curriculum Revisions CRUD
// ============================================

export async function getCurriculumRevisions(): Promise<CurriculumRevision[]> {
  try {
    // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
    const supabaseAdmin = createSupabaseAdminClient();
    const supabase = supabaseAdmin || await createSupabaseServerClient();
    
    const { data, error } = await supabase
      .from("curriculum_revisions")
      .select("*")
      .order("name", { ascending: true });

    if (error) {
      // ì—ëŸ¬ ê°ì²´ì˜ ëª¨ë“  ì†ì„±ì„ ìƒì„¸íˆ ë¡œê¹…
      console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨", {
        error,
        errorMessage: error.message,
        errorCode: error.code,
        errorDetails: error.details,
        errorHint: error.hint,
        errorStringified: JSON.stringify(error, null, 2),
      });
      
      // ì—ëŸ¬ ë©”ì‹œì§€ê°€ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì²˜ë¦¬
      const errorMessage = error.message || error.details || error.hint || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜";
      throw new Error(`ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨: ${errorMessage}`);
    }

    return (data as CurriculumRevision[]) ?? [];
  } catch (error) {
    // ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ ì²˜ë¦¬
    console.error("[contentMetadata] getCurriculumRevisions ì˜ˆì™¸ ë°œìƒ", {
      error,
      errorType: typeof error,
      errorConstructor: error?.constructor?.name,
      errorStringified: error instanceof Error 
        ? JSON.stringify({ message: error.message, stack: error.stack }, null, 2)
        : JSON.stringify(error, null, 2),
    });
    
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error(`ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨: ${String(error)}`);
  }
}

export async function createCurriculumRevision(
  name: string,
  displayOrder?: number
): Promise<CurriculumRevision> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("curriculum_revisions")
      .insert({ name, display_order: displayOrder })
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ìƒì„± ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("curriculum_revisions_name_key")) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê°œì •êµìœ¡ê³¼ì •ëª…ì…ë‹ˆë‹¤: "${name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`ê°œì •êµìœ¡ê³¼ì • ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }

    return data as CurriculumRevision;
  }

  const { data, error } = await supabaseAdmin
    .from("curriculum_revisions")
    .insert({ name, display_order: displayOrder })
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ìƒì„± ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("curriculum_revisions_name_key")) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê°œì •êµìœ¡ê³¼ì •ëª…ì…ë‹ˆë‹¤: "${name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`ê°œì •êµìœ¡ê³¼ì • ìƒì„± ì‹¤íŒ¨: ${error.message}`);
  }

  return data as CurriculumRevision;
}

export async function updateCurriculumRevision(
  id: string,
  updates: Partial<{ name: string; is_active: boolean }>
): Promise<CurriculumRevision> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("curriculum_revisions")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ìˆ˜ì • ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("curriculum_revisions_name_key") && updates.name) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê°œì •êµìœ¡ê³¼ì •ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`ê°œì •êµìœ¡ê³¼ì • ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
    }

    return data as CurriculumRevision;
  }

  const { data, error } = await supabaseAdmin
    .from("curriculum_revisions")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ìˆ˜ì • ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("curriculum_revisions_name_key") && updates.name) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê°œì •êµìœ¡ê³¼ì •ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`ê°œì •êµìœ¡ê³¼ì • ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
  }

  return data as CurriculumRevision;
}

export async function deleteCurriculumRevision(id: string): Promise<void> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { error } = await supabase
      .from("curriculum_revisions")
      .delete()
      .eq("id", id);

    if (error) {
      console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ì‚­ì œ ì‹¤íŒ¨", error);
      throw new Error(`ê°œì •êµìœ¡ê³¼ì • ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
    }
    return;
  }

  const { error } = await supabaseAdmin
    .from("curriculum_revisions")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("[contentMetadata] ê°œì •êµìœ¡ê³¼ì • ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(`ê°œì •êµìœ¡ê³¼ì • ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
  }
}


// ============================================
// Subject Categories CRUD
// ============================================

export async function getSubjectCategories(
  revisionId?: string
): Promise<SubjectCategory[]> {
  const supabase = await createSupabaseServerClient();
  let query = supabase
    .from("subject_categories")
    .select("*")
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  // Note: If revisionId filtering is needed, it would require a join or separate table
  // For now, we'll return all subject categories
  const { data, error } = await query;

  if (error) {
    console.error("[contentMetadata] êµê³¼ ì¡°íšŒ ì‹¤íŒ¨", error);
    throw new Error(`êµê³¼ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  return (data as SubjectCategory[]) ?? [];
}

export async function createSubjectCategory(
  revision_id: string,
  name: string,
  display_order: number
): Promise<SubjectCategory> {
  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("subject_categories")
    .insert({ name, display_order })
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] êµê³¼ ìƒì„± ì‹¤íŒ¨", error);
    throw new Error(`êµê³¼ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
  }

  return data as SubjectCategory;
}

export async function updateSubjectCategory(
  id: string,
  updates: Partial<{
    name: string;
    display_order: number;
    is_active: boolean;
  }>
): Promise<SubjectCategory> {
  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("subject_categories")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] êµê³¼ ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(`êµê³¼ ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
  }

  return data as SubjectCategory;
}

export async function deleteSubjectCategory(id: string): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const { error } = await supabase
    .from("subject_categories")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("[contentMetadata] êµê³¼ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(`êµê³¼ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
  }
}

// ============================================
// Subjects CRUD
// ============================================

export async function getSubjects(
  subjectCategoryId?: string
): Promise<Subject[]> {
  const supabase = await createSupabaseServerClient();
  let query = supabase
    .from("subjects")
    .select("*")
    .order("name", { ascending: true });

  if (subjectCategoryId) {
    query = query.eq("subject_category_id", subjectCategoryId);
  }

  const { data, error } = await query;

  if (error) {
    console.error("[contentMetadata] ê³¼ëª© ì¡°íšŒ ì‹¤íŒ¨", error);
    throw new Error(`ê³¼ëª© ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  return (data as Subject[]) ?? [];
}

export async function createSubject(
  subject_category_id: string,
  name: string,
  display_order?: number
): Promise<Subject> {
  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("subjects")
    .insert({ subject_category_id, name, display_order })
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ê³¼ëª© ìƒì„± ì‹¤íŒ¨", error);
    throw new Error(`ê³¼ëª© ìƒì„± ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Subject;
}

export async function updateSubject(
  id: string,
  updates: Partial<{
    name: string;
    is_active: boolean;
  }>
): Promise<Subject> {
  const supabase = await createSupabaseServerClient();
  const { data, error } = await supabase
    .from("subjects")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ê³¼ëª© ìˆ˜ì • ì‹¤íŒ¨", error);
    throw new Error(`ê³¼ëª© ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Subject;
}

export async function deleteSubject(id: string): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const { error } = await supabase.from("subjects").delete().eq("id", id);

  if (error) {
    console.error("[contentMetadata] ê³¼ëª© ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(`ê³¼ëª© ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
  }
}

// ============================================
// Platforms CRUD
// ============================================

export async function getPlatforms(): Promise<Platform[]> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();
  
  const { data, error } = await supabase
    .from("platforms")
    .select("*")
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[contentMetadata] í”Œë«í¼ ì¡°íšŒ ì‹¤íŒ¨", error);
    throw new Error(`í”Œë«í¼ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  return (data as Platform[]) ?? [];
}

export async function createPlatform(
  name: string,
  display_order: number
): Promise<Platform> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("platforms")
      .insert({ name, display_order })
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] í”Œë«í¼ ìƒì„± ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("platforms_name_key")) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í”Œë«í¼ëª…ì…ë‹ˆë‹¤: "${name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`í”Œë«í¼ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }

    return data as Platform;
  }

  const { data, error } = await supabaseAdmin
    .from("platforms")
    .insert({ name, display_order })
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] í”Œë«í¼ ìƒì„± ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("platforms_name_key")) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í”Œë«í¼ëª…ì…ë‹ˆë‹¤: "${name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`í”Œë«í¼ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Platform;
}

export async function updatePlatform(
  id: string,
  updates: Partial<{ name: string; display_order: number; is_active: boolean }>
): Promise<Platform> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("platforms")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] í”Œë«í¼ ìˆ˜ì • ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("platforms_name_key") && updates.name) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í”Œë«í¼ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`í”Œë«í¼ ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
    }

    return data as Platform;
  }

  const { data, error } = await supabaseAdmin
    .from("platforms")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] í”Œë«í¼ ìˆ˜ì • ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("platforms_name_key") && updates.name) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í”Œë«í¼ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`í”Œë«í¼ ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Platform;
}

export async function deletePlatform(id: string): Promise<void> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { error } = await supabase.from("platforms").delete().eq("id", id);

    if (error) {
      console.error("[contentMetadata] í”Œë«í¼ ì‚­ì œ ì‹¤íŒ¨", error);
      throw new Error(`í”Œë«í¼ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
    }
    return;
  }

  const { error } = await supabaseAdmin.from("platforms").delete().eq("id", id);

  if (error) {
    console.error("[contentMetadata] í”Œë«í¼ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(`í”Œë«í¼ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
  }
}

// ============================================
// Publishers CRUD
// ============================================

export async function getPublishers(): Promise<Publisher[]> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();
  
  const { data, error } = await supabase
    .from("publishers")
    .select("*")
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[contentMetadata] ì¶œíŒì‚¬ ì¡°íšŒ ì‹¤íŒ¨", error);
    throw new Error(`ì¶œíŒì‚¬ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  return (data as Publisher[]) ?? [];
}

export async function createPublisher(
  name: string,
  display_order: number
): Promise<Publisher> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("publishers")
      .insert({ name, display_order })
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] ì¶œíŒì‚¬ ìƒì„± ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("publishers_name_key")) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¶œíŒì‚¬ëª…ì…ë‹ˆë‹¤: "${name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`ì¶œíŒì‚¬ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }

    return data as Publisher;
  }

  const { data, error } = await supabaseAdmin
    .from("publishers")
    .insert({ name, display_order })
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ì¶œíŒì‚¬ ìƒì„± ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("publishers_name_key")) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¶œíŒì‚¬ëª…ì…ë‹ˆë‹¤: "${name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`ì¶œíŒì‚¬ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Publisher;
}

export async function updatePublisher(
  id: string,
  updates: Partial<{ name: string; display_order: number; is_active: boolean }>
): Promise<Publisher> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("publishers")
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq("id", id)
      .select()
      .single();

    if (error) {
      console.error("[contentMetadata] ì¶œíŒì‚¬ ìˆ˜ì • ì‹¤íŒ¨", error);
      
      // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        if (error.message.includes("publishers_name_key") && updates.name) {
          throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¶œíŒì‚¬ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
        }
        throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
      }
      
      throw new Error(`ì¶œíŒì‚¬ ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
    }

    return data as Publisher;
  }

  const { data, error } = await supabaseAdmin
    .from("publishers")
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("[contentMetadata] ì¶œíŒì‚¬ ìˆ˜ì • ì‹¤íŒ¨", error);
    
    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error.code === "23505") {
      if (error.message.includes("publishers_name_key") && updates.name) {
        throw new Error(`ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¶œíŒì‚¬ëª…ì…ë‹ˆë‹¤: "${updates.name}"`);
      }
      throw new Error("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…ë‹ˆë‹¤.");
    }
    
    throw new Error(`ì¶œíŒì‚¬ ìˆ˜ì • ì‹¤íŒ¨: ${error.message}`);
  }

  return data as Publisher;
}

export async function deletePublisher(id: string): Promise<void> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  if (!supabaseAdmin) {
    // Admin í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    const supabase = await createSupabaseServerClient();
    const { error } = await supabase.from("publishers").delete().eq("id", id);

    if (error) {
      console.error("[contentMetadata] ì¶œíŒì‚¬ ì‚­ì œ ì‹¤íŒ¨", error);
      throw new Error(`ì¶œíŒì‚¬ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
    }
    return;
  }

  const { error } = await supabaseAdmin.from("publishers").delete().eq("id", id);

  if (error) {
    console.error("[contentMetadata] ì¶œíŒì‚¬ ì‚­ì œ ì‹¤íŒ¨", error);
    throw new Error(`ì¶œíŒì‚¬ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
  }
}
</file>

<file path="parents.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

export type Parent = {
  id: string;
  tenant_id?: string | null;
  created_at?: string | null;
};

/**
 * Parent IDë¡œ Parent ì¡°íšŒ
 */
export async function getParentById(
  parentId: string,
  tenantId?: string | null
): Promise<Parent | null> {
  const supabase = await createSupabaseServerClient();

  const selectParent = () =>
    supabase
      .from("parent_users")
      .select("id,tenant_id,created_at")
      .eq("id", parentId);

  let query = selectParent();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<Parent>();

  if (error && error.code === "42703") {
    ({ data, error } = await selectParent().maybeSingle<Parent>());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[data/parents] Parent ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * Tenant IDë¡œ Parent ëª©ë¡ ì¡°íšŒ
 */
export async function listParentsByTenant(
  tenantId: string | null
): Promise<Parent[]> {
  const supabase = await createSupabaseServerClient();

  if (!tenantId) {
    return [];
  }

  const selectParents = () =>
    supabase
      .from("parent_users")
      .select("id,tenant_id,created_at")
      .eq("tenant_id", tenantId)
      .order("created_at", { ascending: false });

  let { data, error } = await selectParents();

  if (error && error.code === "42703") {
    ({ data, error } = await selectParents());
  }

  if (error) {
    console.error("[data/parents] Parent ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Parent[] | null) ?? [];
}
</file>

<file path="planContents.ts">
// í”Œëœ ì½˜í…ì¸  ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { PlanContent } from "@/lib/types/plan";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * ì½˜í…ì¸  ì•„ì´í…œ íƒ€ì…
 */
export type ContentItem = {
  id: string;
  title: string;
  subtitle?: string | null;
  master_content_id?: string | null;
};

/**
 * ì½˜í…ì¸  ìƒì„¸ ì •ë³´ íƒ€ì…
 */
export type ContentDetail = {
  content_type: "book" | "lecture" | "custom";
  content_id: string;
  start_range: number;
  end_range: number;
  title: string;
  subject_category?: string | null;
  isRecommended: boolean; // ì¶”ì²œ ì½˜í…ì¸  ì—¬ë¶€
  masterContentId?: string; // ì›ë³¸ ë§ˆìŠ¤í„° ì½˜í…ì¸  ID
  // ìë™ ì¶”ì²œ ê´€ë ¨ í•„ë“œ
  is_auto_recommended?: boolean;
  recommendation_source?: "auto" | "admin" | "template" | null;
  recommendation_reason?: string | null;
  recommendation_metadata?: {
    scoreDetails?: {
      schoolGrade?: number | null;
      schoolAverageGrade?: number | null;
      mockPercentile?: number | null;
      mockGrade?: number | null;
      riskScore?: number;
    };
    priority?: number;
  } | null;
};

/**
 * í•™ìƒì˜ ì±… ëª©ë¡ ì¡°íšŒ
 */
export async function fetchStudentBooks(
  studentId: string
): Promise<ContentItem[]> {
  const supabase = await createSupabaseServerClient();

  try {
    const { data, error } = await supabase
      .from("books")
      .select("id, title, subject, master_content_id")
      .eq("student_id", studentId)
      .order("created_at", { ascending: false });

    if (error) throw error;

    return (
      data?.map((book) => ({
        id: book.id,
        title: book.title || "ì œëª© ì—†ìŒ",
        subtitle: book.subject || null,
        master_content_id: book.master_content_id || null,
      })) || []
    );
  } catch (err) {
    console.error("[data/planContents] ì±… ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", {
      error: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : undefined,
      studentId,
    });
    return [];
  }
}

/**
 * í•™ìƒì˜ ê°•ì˜ ëª©ë¡ ì¡°íšŒ
 */
export async function fetchStudentLectures(
  studentId: string
): Promise<ContentItem[]> {
  const supabase = await createSupabaseServerClient();

  try {
    const { data, error } = await supabase
      .from("lectures")
      .select("id, title, subject, master_content_id")
      .eq("student_id", studentId)
      .order("created_at", { ascending: false });

    if (error) throw error;

    return (
      data?.map((lecture) => ({
        id: lecture.id,
        title: lecture.title || "ì œëª© ì—†ìŒ",
        subtitle: lecture.subject || null,
        master_content_id: lecture.master_content_id || null,
      })) || []
    );
  } catch (err) {
    console.error("[data/planContents] ê°•ì˜ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", {
      error: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : undefined,
      studentId,
    });
    return [];
  }
}

/**
 * í•™ìƒì˜ ì»¤ìŠ¤í…€ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ
 */
export async function fetchStudentCustomContents(
  studentId: string
): Promise<ContentItem[]> {
  const supabase = await createSupabaseServerClient();

  try {
    const { data, error } = await supabase
      .from("student_custom_contents")
      .select("id, title, content_type")
      .eq("student_id", studentId)
      .order("created_at", { ascending: false });

    if (error) throw error;

    return (
      data?.map((custom) => ({
        id: custom.id,
        title: custom.title || "ì»¤ìŠ¤í…€ ì½˜í…ì¸ ",
        subtitle: custom.content_type || null,
      })) || []
    );
  } catch (err) {
    console.error("[data/planContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", {
      error: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : undefined,
      studentId,
    });
    return [];
  }
}

/**
 * í•™ìƒì˜ ëª¨ë“  ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ (í†µí•©)
 */
export async function fetchAllStudentContents(studentId: string): Promise<{
  books: ContentItem[];
  lectures: ContentItem[];
  custom: ContentItem[];
}> {
  const [books, lectures, custom] = await Promise.all([
    fetchStudentBooks(studentId),
    fetchStudentLectures(studentId),
    fetchStudentCustomContents(studentId),
  ]);

  return { books, lectures, custom };
}

/**
 * í”Œëœ ì½˜í…ì¸ ë¥¼ í•™ìƒ/ì¶”ì²œìœ¼ë¡œ ë¶„ë¥˜í•˜ê³  ìƒì„¸ ì •ë³´ ì¡°íšŒ
 * N+1 ì¿¼ë¦¬ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë°°ì¹˜ ì¡°íšŒ ì‚¬ìš©
 * 
 * @param contents í”Œëœ ì½˜í…ì¸  ëª©ë¡
 * @param studentId í•™ìƒ ID
 * @param options ì„ íƒì  ì˜µì…˜ (ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ ê¶Œí•œ ê´€ë ¨)
 * @returns ë¶„ë¥˜ëœ ì½˜í…ì¸  ëª©ë¡
 */
export async function classifyPlanContents(
  contents: Array<{
    content_type: "book" | "lecture" | "custom";
    content_id: string;
    master_content_id?: string | null; // ë§ˆìŠ¤í„° ì½˜í…ì¸  ID (plan_contentsì—ì„œ ì¡°íšŒí•œ ê°’)
    start_range: number;
    end_range: number;
    // ìë™ ì¶”ì²œ ê´€ë ¨ í•„ë“œ (ì„ íƒ)
    is_auto_recommended?: boolean;
    recommendation_source?: "auto" | "admin" | "template" | null;
    recommendation_reason?: string | null;
    recommendation_metadata?: {
      scoreDetails?: {
        schoolGrade?: number | null;
        schoolAverageGrade?: number | null;
        mockPercentile?: number | null;
        mockGrade?: number | null;
        riskScore?: number;
      };
      priority?: number;
    } | null;
  }>,
  studentId: string,
  options?: {
    currentUserRole?: "student" | "admin" | "consultant" | "parent";
    currentUserId?: string;
  }
): Promise<{
  studentContents: Array<ContentDetail>;
  recommendedContents: Array<ContentDetail>;
}> {
  // ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ê°€ ë‹¤ë¥¸ í•™ìƒì˜ ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•  ë•ŒëŠ” Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  const isAdminOrConsultant = options?.currentUserRole === "admin" || options?.currentUserRole === "consultant";
  const isOtherStudent = isAdminOrConsultant && options?.currentUserId && studentId !== options.currentUserId;
  
  let supabase: SupabaseServerClient;
  let isUsingAdminClient = false;
  if (isOtherStudent) {
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      console.warn("[classifyPlanContents] Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ì–´ ì¼ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©", {
        studentId,
        currentUserId: options?.currentUserId,
        currentUserRole: options?.currentUserRole,
      });
      supabase = await createSupabaseServerClient();
    } else {
      supabase = adminClient as any; // Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ SupabaseServerClient íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©
      isUsingAdminClient = true;
      if (process.env.NODE_ENV === "development") {
        console.log("[classifyPlanContents] Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)", {
          studentId,
          currentUserId: options?.currentUserId,
          currentUserRole: options?.currentUserRole,
        });
      }
    }
  } else {
    supabase = await createSupabaseServerClient();
  }

  // ë””ë²„ê¹…: ì…ë ¥ ë°ì´í„° ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[classifyPlanContents] ì…ë ¥ ë°ì´í„°:", {
      contentsCount: contents.length,
      studentId,
      contents: contents.map((c) => ({
        content_type: c.content_type,
        content_id: c.content_id,
        start_range: c.start_range,
        end_range: c.end_range,
      })),
    });
  }

  // 1. ëª¨ë“  ì½˜í…ì¸  ID ë° ë§ˆìŠ¤í„° ì½˜í…ì¸  ID ìˆ˜ì§‘ (ë°°ì¹˜ ì¡°íšŒë¥¼ ìœ„í•´)
  const bookContentIds: string[] = [];
  const lectureContentIds: string[] = [];
  const customContentIds: string[] = [];
  const masterBookIds: string[] = [];
  const masterLectureIds: string[] = [];

  contents.forEach((content) => {
    if (content.content_type === "book") {
      bookContentIds.push(content.content_id);
      // plan_contentsì— ì €ì¥ëœ master_content_idê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDë¡œë„ ìˆ˜ì§‘
      if (content.master_content_id) {
        masterBookIds.push(content.master_content_id);
      }
      // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ëŒ€ìƒì— í¬í•¨
      // (ì¤‘ë³µ ì œê±°ëŠ” Setì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë°°ì—´ì— push í›„ ë‚˜ì¤‘ì— ì¡°íšŒ ì‹œ ì²˜ë¦¬)
      masterBookIds.push(content.content_id);
    } else if (content.content_type === "lecture") {
      lectureContentIds.push(content.content_id);
      // plan_contentsì— ì €ì¥ëœ master_content_idê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDë¡œë„ ìˆ˜ì§‘
      if (content.master_content_id) {
        masterLectureIds.push(content.master_content_id);
      }
      // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ëŒ€ìƒì— í¬í•¨
      masterLectureIds.push(content.content_id);
    } else if (content.content_type === "custom") {
      customContentIds.push(content.content_id);
    }
  });

  // ì¤‘ë³µ ì œê±°
  const uniqueMasterBookIds = [...new Set(masterBookIds)];
  const uniqueMasterLectureIds = [...new Set(masterLectureIds)];

  if (process.env.NODE_ENV === "development") {
    console.log("[classifyPlanContents] ì½˜í…ì¸  ID ë¶„ë¥˜:", {
      bookCount: bookContentIds.length,
      lectureCount: lectureContentIds.length,
      customCount: customContentIds.length,
      bookIds: bookContentIds,
      lectureIds: lectureContentIds,
      customIds: customContentIds,
    });
  }

  // 2. ë°°ì¹˜ ì¡°íšŒ (N+1 ë¬¸ì œ í•´ê²°)
  // plan_contents.master_content_idë¥¼ ìš°ì„  í™œìš©í•˜ì—¬ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ
  // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ëŒ€ìƒì— í¬í•¨
  const [
    masterBooksResult,
    masterLecturesResult,
    studentBooksResult,
    studentLecturesResult,
    customContentsResult,
  ] = await Promise.all([
    // ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ (plan_contents.master_content_id + content_id)
    uniqueMasterBookIds.length > 0
      ? supabase
          .from("master_books")
          .select("id, title, subject_category, subject")
          .in("id", uniqueMasterBookIds)
      : Promise.resolve({ data: [], error: null }),
    uniqueMasterLectureIds.length > 0
      ? supabase
          .from("master_lectures")
          .select("id, title, subject_category, subject")
          .in("id", uniqueMasterLectureIds)
      : Promise.resolve({ data: [], error: null }),
    // í•™ìƒ ì½˜í…ì¸  ì¡°íšŒ
    bookContentIds.length > 0
      ? supabase
          .from("books")
          .select("id, title, subject, master_content_id")
          .in("id", bookContentIds)
          .eq("student_id", studentId)
      : Promise.resolve({ data: [], error: null }),
    lectureContentIds.length > 0
      ? supabase
          .from("lectures")
          .select("id, title, subject, master_content_id")
          .in("id", lectureContentIds)
          .eq("student_id", studentId)
      : Promise.resolve({ data: [], error: null }),
    // ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ
    customContentIds.length > 0
      ? supabase
          .from("student_custom_contents")
          .select("id, title, content_type")
          .in("id", customContentIds)
          .eq("student_id", studentId)
      : Promise.resolve({ data: [], error: null }),
  ]);

  // ë””ë²„ê¹…: ì¡°íšŒ ê²°ê³¼ ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[classifyPlanContents] ì¡°íšŒ ê²°ê³¼:", {
      isUsingAdminClient,
      isAdminOrConsultant,
      isOtherStudent,
      masterBooks: {
        count: masterBooksResult.data?.length || 0,
        ids: masterBooksResult.data?.map((b) => b.id) || [],
        error: masterBooksResult.error?.message || null,
      },
      masterLectures: {
        count: masterLecturesResult.data?.length || 0,
        ids: masterLecturesResult.data?.map((l) => l.id) || [],
        error: masterLecturesResult.error?.message || null,
      },
      studentBooks: {
        count: studentBooksResult.data?.length || 0,
        ids: studentBooksResult.data?.map((b) => b.id) || [],
        masterContentIds: studentBooksResult.data?.map((b) => b.master_content_id).filter(Boolean) || [],
        error: studentBooksResult.error?.message || null,
        queryParams: {
          studentId,
          bookContentIds,
          searchedIds: bookContentIds,
        },
      },
      studentLectures: {
        count: studentLecturesResult.data?.length || 0,
        ids: studentLecturesResult.data?.map((l) => l.id) || [],
        masterContentIds: studentLecturesResult.data?.map((l) => l.master_content_id).filter(Boolean) || [],
        error: studentLecturesResult.error?.message || null,
      },
      customContents: {
        count: customContentsResult.data?.length || 0,
        ids: customContentsResult.data?.map((c) => c.id) || [],
        error: customContentsResult.error?.message || null,
      },
    });
  }

  // ê´€ë¦¬ì ëª¨ë“œì—ì„œ ì¡°íšŒ ì‹¤íŒ¨ ì‹œ ê²½ê³  ë¡œê·¸
  if (isAdminOrConsultant && isOtherStudent) {
    const hasErrors = 
      studentBooksResult.error || 
      studentLecturesResult.error || 
      customContentsResult.error;
    
    if (hasErrors) {
      console.warn("[classifyPlanContents] ê´€ë¦¬ì ëª¨ë“œì—ì„œ ì½˜í…ì¸  ì¡°íšŒ ì¤‘ ì—ëŸ¬ ë°œìƒ:", {
        studentId,
        currentUserId: options?.currentUserId,
        currentUserRole: options?.currentUserRole,
        isUsingAdminClient,
        errors: {
          studentBooks: studentBooksResult.error ? {
            message: studentBooksResult.error.message,
            code: studentBooksResult.error.code,
          } : null,
          studentLectures: studentLecturesResult.error ? {
            message: studentLecturesResult.error.message,
            code: studentLecturesResult.error.code,
          } : null,
          customContents: customContentsResult.error ? {
            message: customContentsResult.error.message,
            code: customContentsResult.error.code,
          } : null,
        },
      });
    }

    // ì¡°íšŒëœ ì½˜í…ì¸  ê°œìˆ˜ê°€ ì˜ˆìƒë³´ë‹¤ ì ì„ ë•Œ ê²½ê³ 
    const expectedBookCount = bookContentIds.length;
    const actualBookCount = studentBooksResult.data?.length || 0;
    const expectedLectureCount = lectureContentIds.length;
    const actualLectureCount = studentLecturesResult.data?.length || 0;
    const expectedCustomCount = customContentIds.length;
    const actualCustomCount = customContentsResult.data?.length || 0;

    if (
      (expectedBookCount > 0 && actualBookCount < expectedBookCount) ||
      (expectedLectureCount > 0 && actualLectureCount < expectedLectureCount) ||
      (expectedCustomCount > 0 && actualCustomCount < expectedCustomCount)
    ) {
      console.warn("[classifyPlanContents] ê´€ë¦¬ì ëª¨ë“œì—ì„œ ì¼ë¶€ ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:", {
        studentId,
        isUsingAdminClient,
        books: { expected: expectedBookCount, actual: actualBookCount },
        lectures: { expected: expectedLectureCount, actual: actualLectureCount },
        custom: { expected: expectedCustomCount, actual: actualCustomCount },
        searchedBookIds: bookContentIds,
        foundBookIds: studentBooksResult.data?.map((b) => b.id) || [],
        searchedLectureIds: lectureContentIds,
        foundLectureIds: studentLecturesResult.data?.map((l) => l.id) || [],
        searchedCustomIds: customContentIds,
        foundCustomIds: customContentsResult.data?.map((c) => c.id) || [],
      });
    }
  }

  // 3. Mapìœ¼ë¡œ ë³€í™˜ (ë¹ ë¥¸ ì¡°íšŒ)
  // ë§ˆìŠ¤í„° ì½˜í…ì¸  Map (plan_contents.master_content_idë¡œ ì¡°íšŒí•œ ê²°ê³¼)
  const masterBooksMap = new Map(
    (masterBooksResult.data || []).map((book) => [book.id, book])
  );
  const masterLecturesMap = new Map(
    (masterLecturesResult.data || []).map((lecture) => [lecture.id, lecture])
  );
  // í•™ìƒ ì½˜í…ì¸  Map
  const studentBooksMap = new Map(
    (studentBooksResult.data || []).map((book) => [book.id, book])
  );
  const studentLecturesMap = new Map(
    (studentLecturesResult.data || []).map((lecture) => [lecture.id, lecture])
  );
  const customContentsMap = new Map(
    (customContentsResult.data || []).map((custom) => [custom.id, custom])
  );
  
  // í•™ìƒ ì½˜í…ì¸ ì˜ master_content_idë„ ìˆ˜ì§‘ (ì¶”ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒìš©)
  const additionalMasterBookIds = new Set<string>();
  const additionalMasterLectureIds = new Set<string>();
  [...studentBooksMap.values()].forEach((book) => {
    if (book.master_content_id && !masterBookIds.includes(book.master_content_id)) {
      additionalMasterBookIds.add(book.master_content_id);
    }
  });
  [...studentLecturesMap.values()].forEach((lecture) => {
    if (lecture.master_content_id && !masterLectureIds.includes(lecture.master_content_id)) {
      additionalMasterLectureIds.add(lecture.master_content_id);
    }
  });
  
  // ì¶”ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ (í•™ìƒ ì½˜í…ì¸ ì˜ master_content_id)
  const [additionalMasterBooksResult, additionalMasterLecturesResult] =
    await Promise.all([
      additionalMasterBookIds.size > 0
        ? supabase
            .from("master_books")
            .select("id, title, subject_category, subject")
            .in("id", Array.from(additionalMasterBookIds))
        : Promise.resolve({ data: [], error: null }),
      additionalMasterLectureIds.size > 0
        ? supabase
            .from("master_lectures")
            .select("id, title, subject_category, subject")
            .in("id", Array.from(additionalMasterLectureIds))
        : Promise.resolve({ data: [], error: null }),
    ]);
  
  // ì¶”ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸ ë¥¼ ê¸°ì¡´ Mapì— ë³‘í•©
  (additionalMasterBooksResult.data || []).forEach((book) => {
    masterBooksMap.set(book.id, book);
  });
  (additionalMasterLecturesResult.data || []).forEach((lecture) => {
    masterLecturesMap.set(lecture.id, lecture);
  });

  // ë””ë²„ê¹…: Map ë‚´ìš© ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[classifyPlanContents] Map ë³€í™˜ ê²°ê³¼:", {
      masterBooksMapSize: masterBooksMap.size,
      masterLecturesMapSize: masterLecturesMap.size,
      studentBooksMapSize: studentBooksMap.size,
      studentLecturesMapSize: studentLecturesMap.size,
      customContentsMapSize: customContentsMap.size,
    });
  }

  // 4. ë§ˆìŠ¤í„° ì½˜í…ì¸  Mapì€ ì´ë¯¸ ìœ„ì—ì„œ ì¡°íšŒ ì™„ë£Œ (plan_contents.master_content_id + í•™ìƒ ì½˜í…ì¸ ì˜ master_content_id)

  // 6. ì½˜í…ì¸  ë¶„ë¥˜ ë° ìƒì„¸ ì •ë³´ ìƒì„±
  const studentContents: Array<ContentDetail> = [];
  let recommendedContents: Array<ContentDetail> = [];
  const missingContents: Array<{
    content_type: string;
    content_id: string;
    reason: string;
  }> = [];

  for (const content of contents) {
    let contentDetail: ContentDetail | null = null;
    let masterContentId: string | undefined = undefined;

    if (content.content_type === "book") {
      // 1. plan_contentsì— ì €ì¥ëœ master_content_idê°€ ìˆìœ¼ë©´ ìš°ì„  í™œìš©
      const masterBookFromPlan = content.master_content_id
        ? masterBooksMap.get(content.master_content_id)
        : null;

      // 2. content_idë¡œ í•™ìƒ ì½˜í…ì¸  ì¡°íšŒ
      const studentBook = studentBooksMap.get(content.content_id);

      if (studentBook) {
        // í•™ìƒ ì½˜í…ì¸ ë¥¼ ì°¾ì€ ê²½ìš°
        let title = studentBook.title || "ì œëª© ì—†ìŒ";
        let subjectCategory = studentBook.subject || null;

        // plan_contentsì˜ master_content_id ë˜ëŠ” í•™ìƒ ì½˜í…ì¸ ì˜ master_content_idë¡œ ë§ˆìŠ¤í„° ì •ë³´ ì¡°íšŒ
        const masterBook = masterBookFromPlan ||
          (studentBook.master_content_id
            ? masterBooksMap.get(studentBook.master_content_id)
            : null);

        if (masterBook) {
          // ë§ˆìŠ¤í„° ì½˜í…ì¸  ì •ë³´ ìš°ì„  ì‚¬ìš© (ë” ì •í™•í•œ ì •ë³´)
          title = masterBook.title || studentBook.title || "ì œëª© ì—†ìŒ";
          subjectCategory =
            masterBook.subject_category ||
            masterBook.subject ||
            studentBook.subject ||
            null;
          masterContentId = content.master_content_id || studentBook.master_content_id || undefined;
        } else {
          masterContentId = studentBook.master_content_id || undefined;
        }

        contentDetail = {
          content_type: "book",
          content_id: content.content_id,
          start_range: content.start_range,
          end_range: content.end_range,
          title,
          subject_category: subjectCategory,
          isRecommended: false,
          masterContentId,
        };
      } else if (masterBookFromPlan) {
        // í•™ìƒ ì½˜í…ì¸ ë¥¼ ì°¾ì§€ ëª»í–ˆì§€ë§Œ plan_contentsì— master_content_idê°€ ìˆëŠ” ê²½ìš°
        // â†’ ì¶”ì²œ ì½˜í…ì¸ ì´ê±°ë‚˜ í•™ìƒ ì½˜í…ì¸ ê°€ ì‚­ì œëœ ê²½ìš°
        // content_idê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ì§€ í™•ì¸
        const isMasterContentId = masterBooksMap.has(content.content_id);
        
        contentDetail = {
          content_type: "book",
          content_id: content.content_id,
          start_range: content.start_range,
          end_range: content.end_range,
          title: masterBookFromPlan.title || "ì œëª© ì—†ìŒ",
          subject_category: masterBookFromPlan.subject_category || masterBookFromPlan.subject || null,
          isRecommended: isMasterContentId, // content_idê°€ ë§ˆìŠ¤í„° IDë©´ ì¶”ì²œ ì½˜í…ì¸ 
          masterContentId: content.master_content_id ?? undefined,
          // ìë™ ì¶”ì²œ ì •ë³´ ì „ë‹¬
          is_auto_recommended: content.is_auto_recommended ?? false,
          recommendation_source: content.recommendation_source ?? null,
          recommendation_reason: content.recommendation_reason ?? null,
          recommendation_metadata: content.recommendation_metadata ?? null,
        };
      } else {
        // í•™ìƒ ì½˜í…ì¸ ë„ ì—†ê³  plan_contentsì˜ master_content_idë¡œë„ ì¡°íšŒ ì‹¤íŒ¨
        // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ì§€ í™•ì¸ (ì´ë¯¸ masterBooksMapì— ì¡°íšŒë¨)
        const masterBookByContentId = masterBooksMap.get(content.content_id);
        if (masterBookByContentId) {
          // content_idê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ ê²½ìš° â†’ ì¶”ì²œ ì½˜í…ì¸ 
          contentDetail = {
            content_type: "book",
            content_id: content.content_id,
            start_range: content.start_range,
            end_range: content.end_range,
            title: masterBookByContentId.title || "ì œëª© ì—†ìŒ",
            subject_category: masterBookByContentId.subject_category || masterBookByContentId.subject || null,
            isRecommended: true, // ë§ˆìŠ¤í„° ì½˜í…ì¸ ì´ë¯€ë¡œ ì¶”ì²œ ì½˜í…ì¸ 
            masterContentId: content.content_id, // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ID
            // ìë™ ì¶”ì²œ ì •ë³´ ì „ë‹¬
            is_auto_recommended: content.is_auto_recommended ?? false,
            recommendation_source: content.recommendation_source ?? null,
            recommendation_reason: content.recommendation_reason ?? null,
            recommendation_metadata: content.recommendation_metadata ?? null,
          };
        } else {
          // ì •ë§ë¡œ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš°
          missingContents.push({
            content_type: "book",
            content_id: content.content_id,
            reason: `í•™ìƒ(${studentId})ì˜ êµì¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. master_booksì—ë„ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`,
          });
        }
      }
    } else if (content.content_type === "lecture") {
      // 1. plan_contentsì— ì €ì¥ëœ master_content_idê°€ ìˆìœ¼ë©´ ìš°ì„  í™œìš©
      const masterLectureFromPlan = content.master_content_id
        ? masterLecturesMap.get(content.master_content_id)
        : null;

      // 2. content_idë¡œ í•™ìƒ ì½˜í…ì¸  ì¡°íšŒ
      const studentLecture = studentLecturesMap.get(content.content_id);

      if (studentLecture) {
        // í•™ìƒ ì½˜í…ì¸ ë¥¼ ì°¾ì€ ê²½ìš°
        let title = studentLecture.title || "ì œëª© ì—†ìŒ";
        let subjectCategory = studentLecture.subject || null;

        // plan_contentsì˜ master_content_id ë˜ëŠ” í•™ìƒ ì½˜í…ì¸ ì˜ master_content_idë¡œ ë§ˆìŠ¤í„° ì •ë³´ ì¡°íšŒ
        const masterLecture = masterLectureFromPlan ||
          (studentLecture.master_content_id
            ? masterLecturesMap.get(studentLecture.master_content_id)
            : null);

        if (masterLecture) {
          // ë§ˆìŠ¤í„° ì½˜í…ì¸  ì •ë³´ ìš°ì„  ì‚¬ìš© (ë” ì •í™•í•œ ì •ë³´)
          title = masterLecture.title || studentLecture.title || "ì œëª© ì—†ìŒ";
          subjectCategory =
            masterLecture.subject_category ||
            masterLecture.subject ||
            studentLecture.subject ||
            null;
          masterContentId = content.master_content_id || studentLecture.master_content_id || undefined;
        } else {
          masterContentId = studentLecture.master_content_id || undefined;
        }

        contentDetail = {
          content_type: "lecture",
          content_id: content.content_id,
          start_range: content.start_range,
          end_range: content.end_range,
          title,
          subject_category: subjectCategory,
          isRecommended: false,
          masterContentId,
        };
      } else if (masterLectureFromPlan) {
        // í•™ìƒ ì½˜í…ì¸ ë¥¼ ì°¾ì§€ ëª»í–ˆì§€ë§Œ plan_contentsì— master_content_idê°€ ìˆëŠ” ê²½ìš°
        // â†’ ì¶”ì²œ ì½˜í…ì¸ ì´ê±°ë‚˜ í•™ìƒ ì½˜í…ì¸ ê°€ ì‚­ì œëœ ê²½ìš°
        // content_idê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ì§€ í™•ì¸
        const isMasterContentId = masterLecturesMap.has(content.content_id);
        
        contentDetail = {
          content_type: "lecture",
          content_id: content.content_id,
          start_range: content.start_range,
          end_range: content.end_range,
          title: masterLectureFromPlan.title || "ì œëª© ì—†ìŒ",
          subject_category: masterLectureFromPlan.subject_category || masterLectureFromPlan.subject || null,
          isRecommended: isMasterContentId, // content_idê°€ ë§ˆìŠ¤í„° IDë©´ ì¶”ì²œ ì½˜í…ì¸ 
          masterContentId: content.master_content_id ?? undefined,
          // ìë™ ì¶”ì²œ ì •ë³´ ì „ë‹¬
          is_auto_recommended: content.is_auto_recommended ?? false,
          recommendation_source: content.recommendation_source ?? null,
          recommendation_reason: content.recommendation_reason ?? null,
          recommendation_metadata: content.recommendation_metadata ?? null,
        };
      } else {
        // í•™ìƒ ì½˜í…ì¸ ë„ ì—†ê³  plan_contentsì˜ master_content_idë¡œë„ ì¡°íšŒ ì‹¤íŒ¨
        // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ì§€ í™•ì¸ (ì´ë¯¸ masterLecturesMapì— ì¡°íšŒë¨)
        const masterLectureByContentId = masterLecturesMap.get(content.content_id);
        if (masterLectureByContentId) {
          // content_idê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸  IDì¸ ê²½ìš° â†’ ì¶”ì²œ ì½˜í…ì¸ 
          contentDetail = {
            content_type: "lecture",
            content_id: content.content_id,
            start_range: content.start_range,
            end_range: content.end_range,
            title: masterLectureByContentId.title || "ì œëª© ì—†ìŒ",
            subject_category: masterLectureByContentId.subject_category || masterLectureByContentId.subject || null,
            isRecommended: true, // ë§ˆìŠ¤í„° ì½˜í…ì¸ ì´ë¯€ë¡œ ì¶”ì²œ ì½˜í…ì¸ 
            masterContentId: content.content_id, // content_id ìì²´ê°€ ë§ˆìŠ¤í„° ID
            // ìë™ ì¶”ì²œ ì •ë³´ ì „ë‹¬
            is_auto_recommended: content.is_auto_recommended ?? false,
            recommendation_source: content.recommendation_source ?? null,
            recommendation_reason: content.recommendation_reason ?? null,
            recommendation_metadata: content.recommendation_metadata ?? null,
          };
        } else {
          // ì •ë§ë¡œ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš°
          missingContents.push({
            content_type: "lecture",
            content_id: content.content_id,
            reason: `í•™ìƒ(${studentId})ì˜ ê°•ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. master_lecturesì—ë„ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`,
          });
        }
      }
    } else if (content.content_type === "custom") {
      // ì»¤ìŠ¤í…€ ì½˜í…ì¸ ëŠ” í•­ìƒ í•™ìƒ ì½˜í…ì¸ 
      const customContent = customContentsMap.get(content.content_id);
      if (customContent) {
        contentDetail = {
          content_type: "custom",
          content_id: content.content_id,
          start_range: content.start_range,
          end_range: content.end_range,
          title: customContent.title || "ì»¤ìŠ¤í…€ ì½˜í…ì¸ ",
          subject_category: customContent.content_type || null,
          isRecommended: false,
        };
      } else {
        // ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°
        missingContents.push({
          content_type: "custom",
          content_id: content.content_id,
          reason: `í•™ìƒ(${studentId})ì˜ ì»¤ìŠ¤í…€ ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
        });
      }
    }

    if (contentDetail) {
      // isRecommendedëŠ” contentDetailì— ì´ë¯¸ ì„¤ì •ë˜ì–´ ìˆìŒ
      if (contentDetail.isRecommended) {
        recommendedContents.push(contentDetail);
      } else {
        studentContents.push(contentDetail);
      }
    } else {
      // contentDetailì´ nullì¸ ê²½ìš° ë¡œê·¸
      if (process.env.NODE_ENV === "development") {
        console.warn("[classifyPlanContents] contentDetailì´ null:", {
          content_type: content.content_type,
          content_id: content.content_id,
          studentId,
        });
      }
    }
  }

  // ë””ë²„ê¹…: ëˆ„ë½ëœ ì½˜í…ì¸  ë¡œê·¸
  if (missingContents.length > 0) {
    console.warn("[classifyPlanContents] ëˆ„ë½ëœ ì½˜í…ì¸ :", {
      count: missingContents.length,
      missingContents,
      studentId,
    });
  }

  // ìµœì¢… ê²€ì¦: custom íƒ€ì…ì´ recommendedì— í¬í•¨ë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
  const invalidRecommended = recommendedContents.filter(
    (c) => c.content_type === "custom"
  );

  if (invalidRecommended.length > 0) {
    console.warn(
      "[classifyPlanContents] custom íƒ€ì… ì½˜í…ì¸ ê°€ ì¶”ì²œ ì½˜í…ì¸ ë¡œ ë¶„ë¥˜ë¨:",
      invalidRecommended.map((c) => c.content_id)
    );
    // custom íƒ€ì…ì„ studentContentsë¡œ ì´ë™
    recommendedContents = recommendedContents.filter(
      (c) => c.content_type !== "custom"
    );
    studentContents.push(...invalidRecommended);
  }

  // ë””ë²„ê¹…: ìµœì¢… ê²°ê³¼ ë¡œê·¸
  if (process.env.NODE_ENV === "development") {
    console.log("[classifyPlanContents] ìµœì¢… ê²°ê³¼:", {
      studentContentsCount: studentContents.length,
      recommendedContentsCount: recommendedContents.length,
      missingContentsCount: missingContents.length,
      totalInputCount: contents.length,
      invalidRecommendedMoved: invalidRecommended.length,
    });
  }

  return { studentContents, recommendedContents };
}
</file>

<file path="planGroupItems.ts">
/**
 * ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´
 * @module lib/data/planGroupItems
 * @see docs/refactoring/03_phase_todo_list.md [P2-4]
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { PlanGroupItem, PlanGroupItemInput } from "@/lib/types/plan";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

// ============================================
// CRUD í•¨ìˆ˜
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ì˜ ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ëª©ë¡ ì¡°íšŒ
 */
export async function getPlanGroupItems(
  planGroupId: string,
  tenantId?: string | null
): Promise<PlanGroupItem[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("plan_group_items")
    .select(
      "id,tenant_id,plan_group_id,content_type,content_id,master_content_id,target_start_page_or_time,target_end_page_or_time,repeat_count,split_strategy,is_review,is_required,priority,display_order,metadata,created_at,updated_at"
    )
    .eq("plan_group_id", planGroupId)
    .order("display_order", { ascending: true });

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  const { data, error } = await query;

  if (error) {
    console.error("[data/planGroupItems] ì¡°íšŒ ì‹¤íŒ¨", {
      planGroupId,
      tenantId,
      error,
    });
    return [];
  }

  return (data as PlanGroupItem[]) ?? [];
}

/**
 * ë‹¨ì¼ ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ì¡°íšŒ
 */
export async function getPlanGroupItemById(
  itemId: string,
  tenantId?: string | null
): Promise<PlanGroupItem | null> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("plan_group_items")
    .select(
      "id,tenant_id,plan_group_id,content_type,content_id,master_content_id,target_start_page_or_time,target_end_page_or_time,repeat_count,split_strategy,is_review,is_required,priority,display_order,metadata,created_at,updated_at"
    )
    .eq("id", itemId);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  const { data, error } = await query.maybeSingle();

  if (error && error.code !== "PGRST116") {
    console.error("[data/planGroupItems] ë‹¨ì¼ ì¡°íšŒ ì‹¤íŒ¨", {
      itemId,
      tenantId,
      error,
    });
    return null;
  }

  return (data as PlanGroupItem | null) ?? null;
}

/**
 * ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ìƒì„±
 */
export async function createPlanGroupItem(
  planGroupId: string,
  tenantId: string,
  input: PlanGroupItemInput
): Promise<{ success: boolean; itemId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: tenantId,
    plan_group_id: planGroupId,
    content_type: input.content_type,
    content_id: input.content_id,
    master_content_id: input.master_content_id ?? null,
    target_start_page_or_time: input.target_start_page_or_time,
    target_end_page_or_time: input.target_end_page_or_time,
    repeat_count: input.repeat_count ?? 1,
    split_strategy: input.split_strategy ?? "equal",
    is_review: input.is_review ?? false,
    is_required: input.is_required ?? true,
    priority: input.priority ?? 0,
    display_order: input.display_order ?? 0,
    metadata: input.metadata ?? {},
  };

  const { data, error } = await supabase
    .from("plan_group_items")
    .insert(payload)
    .select("id")
    .single();

  if (error) {
    console.error("[data/planGroupItems] ìƒì„± ì‹¤íŒ¨", {
      planGroupId,
      tenantId,
      error,
    });
    return { success: false, error: error.message };
  }

  return { success: true, itemId: data?.id };
}

/**
 * ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ì¼ê´„ ìƒì„±
 */
export async function createPlanGroupItems(
  planGroupId: string,
  tenantId: string,
  inputs: PlanGroupItemInput[]
): Promise<{ success: boolean; itemIds?: string[]; error?: string }> {
  const supabase = await createSupabaseServerClient();

  if (inputs.length === 0) {
    return { success: true, itemIds: [] };
  }

  const payloads = inputs.map((input, index) => ({
    tenant_id: tenantId,
    plan_group_id: planGroupId,
    content_type: input.content_type,
    content_id: input.content_id,
    master_content_id: input.master_content_id ?? null,
    target_start_page_or_time: input.target_start_page_or_time,
    target_end_page_or_time: input.target_end_page_or_time,
    repeat_count: input.repeat_count ?? 1,
    split_strategy: input.split_strategy ?? "equal",
    is_review: input.is_review ?? false,
    is_required: input.is_required ?? true,
    priority: input.priority ?? 0,
    display_order: input.display_order ?? index,
    metadata: input.metadata ?? {},
  }));

  const { data, error } = await supabase
    .from("plan_group_items")
    .insert(payloads)
    .select("id");

  if (error) {
    console.error("[data/planGroupItems] ì¼ê´„ ìƒì„± ì‹¤íŒ¨", {
      planGroupId,
      tenantId,
      count: inputs.length,
      error,
    });
    return { success: false, error: error.message };
  }

  return { success: true, itemIds: data?.map((d) => d.id) ?? [] };
}

/**
 * ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ì—…ë°ì´íŠ¸
 */
export async function updatePlanGroupItem(
  itemId: string,
  updates: Partial<PlanGroupItemInput>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, unknown> = {};
  if (updates.content_type !== undefined)
    payload.content_type = updates.content_type;
  if (updates.content_id !== undefined) payload.content_id = updates.content_id;
  if (updates.master_content_id !== undefined)
    payload.master_content_id = updates.master_content_id;
  if (updates.target_start_page_or_time !== undefined)
    payload.target_start_page_or_time = updates.target_start_page_or_time;
  if (updates.target_end_page_or_time !== undefined)
    payload.target_end_page_or_time = updates.target_end_page_or_time;
  if (updates.repeat_count !== undefined)
    payload.repeat_count = updates.repeat_count;
  if (updates.split_strategy !== undefined)
    payload.split_strategy = updates.split_strategy;
  if (updates.is_review !== undefined) payload.is_review = updates.is_review;
  if (updates.is_required !== undefined)
    payload.is_required = updates.is_required;
  if (updates.priority !== undefined) payload.priority = updates.priority;
  if (updates.display_order !== undefined)
    payload.display_order = updates.display_order;
  if (updates.metadata !== undefined) payload.metadata = updates.metadata;

  if (Object.keys(payload).length === 0) {
    return { success: true }; // ì—…ë°ì´íŠ¸í•  ë‚´ìš© ì—†ìŒ
  }

  const { error } = await supabase
    .from("plan_group_items")
    .update(payload)
    .eq("id", itemId);

  if (error) {
    console.error("[data/planGroupItems] ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", {
      itemId,
      updates: Object.keys(payload),
      error,
    });
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ì‚­ì œ
 */
export async function deletePlanGroupItem(
  itemId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("plan_group_items")
    .delete()
    .eq("id", itemId);

  if (error) {
    console.error("[data/planGroupItems] ì‚­ì œ ì‹¤íŒ¨", {
      itemId,
      error,
    });
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ëª¨ë“  ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ì‚­ì œ
 */
export async function deletePlanGroupItemsByGroupId(
  planGroupId: string
): Promise<{ success: boolean; deletedCount?: number; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // ì‚­ì œ ì „ ì¹´ìš´íŠ¸ ì¡°íšŒ
  const { count } = await supabase
    .from("plan_group_items")
    .select("id", { count: "exact", head: true })
    .eq("plan_group_id", planGroupId);

  const { error } = await supabase
    .from("plan_group_items")
    .delete()
    .eq("plan_group_id", planGroupId);

  if (error) {
    console.error("[data/planGroupItems] ê·¸ë£¹ë³„ ì‚­ì œ ì‹¤íŒ¨", {
      planGroupId,
      error,
    });
    return { success: false, error: error.message };
  }

  return { success: true, deletedCount: count ?? 0 };
}

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

/**
 * plan_contentsë¥¼ plan_group_itemsë¡œ ë³€í™˜ (ë§ˆì´ê·¸ë ˆì´ì…˜ ìš©ë„)
 * ê¸°ì¡´ plan_contents ë°ì´í„°ë¥¼ plan_group_items í˜•ì‹ìœ¼ë¡œ ë³€í™˜
 */
export function convertPlanContentToGroupItem(
  planContent: {
    content_type: string;
    content_id: string;
    master_content_id?: string | null;
    start_range: number;
    end_range: number;
    display_order?: number;
  },
  options?: {
    repeat_count?: number;
    is_review?: boolean;
    priority?: number;
  }
): PlanGroupItemInput {
  return {
    content_type: planContent.content_type as "book" | "lecture" | "custom",
    content_id: planContent.content_id,
    master_content_id: planContent.master_content_id,
    target_start_page_or_time: planContent.start_range,
    target_end_page_or_time: planContent.end_range,
    repeat_count: options?.repeat_count ?? 1,
    split_strategy: "equal",
    is_review: options?.is_review ?? false,
    is_required: true,
    priority: options?.priority ?? 0,
    display_order: planContent.display_order ?? 0,
  };
}
</file>

<file path="planGroups.ts">
// í”Œëœ ê·¸ë£¹ ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { PostgrestError } from "@supabase/supabase-js";
import {
  PlanGroup,
  PlanContent,
  PlanExclusion,
  AcademySchedule,
  PlanGroupCreationData,
  PlanFilters,
  SchedulerOptions,
  SubjectConstraints,
  AdditionalPeriodReallocation,
  NonStudyTimeBlock,
  DailyScheduleInfo,
} from "@/lib/types/plan";
import { logError } from "@/lib/errors/handler";
import { checkColumnExists } from "@/lib/utils/migrationStatus";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * í”Œëœ ê·¸ë£¹ ìƒì„± ì‹œ ì‚¬ìš©í•˜ëŠ” payload íƒ€ì…
 */
type PlanGroupPayload = {
  tenant_id: string;
  student_id: string;
  name: string | null;
  plan_purpose: string | null;
  scheduler_type: string | null;
  scheduler_options?: SchedulerOptions | null;
  period_start: string;
  period_end: string;
  target_date: string | null;
  block_set_id: string | null;
  status: string;
  subject_constraints?: SubjectConstraints | null;
  additional_period_reallocation?: AdditionalPeriodReallocation | null;
  non_study_time_blocks?: NonStudyTimeBlock[] | null;
  daily_schedule?: DailyScheduleInfo[] | null;
  plan_type?: string | null;
  camp_template_id?: string | null;
  camp_invitation_id?: string | null;
};

/**
 * PostgrestError íƒ€ì… ê°€ë“œ í•¨ìˆ˜
 */
function isPostgrestError(error: unknown): error is PostgrestError {
  return (
    typeof error === "object" &&
    error !== null &&
    "message" in error &&
    "code" in error
  );
}

/**
 * ì—ëŸ¬ì—ì„œ detailsì™€ hintë¥¼ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
 */
function getErrorDetails(error: unknown): {
  details: unknown;
  hint: string | null;
} {
  if (isPostgrestError(error)) {
    return {
      details: error.details ?? null,
      hint: error.hint ?? null,
    };
  }
  return {
    details: null,
    hint: null,
  };
}

/**
 * í”Œëœ ê·¸ë£¹ í•„í„°
 */
export type PlanGroupFilters = {
  studentId: string;
  tenantId?: string | null;
  status?: string | string[];
  planPurpose?: string;
  dateRange?: {
    start: string;
    end: string;
  };
  includeDeleted?: boolean;
};

/**
 * í•™ìƒì˜ í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ
 */
export async function getPlanGroupsForStudent(
  filters: PlanGroupFilters
): Promise<PlanGroup[]> {
  const supabase = await createSupabaseServerClient();

  const selectGroups = () =>
    supabase
      .from("plan_groups")
      .select(
        "id,tenant_id,student_id,name,plan_purpose,scheduler_type,scheduler_options,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
      )
      .eq("student_id", filters.studentId);

  let query = selectGroups();

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.status) {
    if (Array.isArray(filters.status)) {
      query = query.in("status", filters.status);
    } else {
      query = query.eq("status", filters.status);
    }
  }

  if (filters.planPurpose) {
    query = query.eq("plan_purpose", filters.planPurpose);
  }

  if (filters.dateRange) {
    query = query
      .gte("period_start", filters.dateRange.start)
      .lte("period_end", filters.dateRange.end);
  }

  if (!filters.includeDeleted) {
    query = query.is("deleted_at", null);
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;
  let planGroupsData: PlanGroup[] | null = data as PlanGroup[] | null;

  if (error && error.code === "42703") {
    // ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒíƒœ í™•ì¸ (ìºì‹œ ì‚¬ìš©)
    const hasSchedulerOptions = await checkColumnExists(
      "plan_groups",
      "scheduler_options"
    );

    if (!hasSchedulerOptions) {
      // fallback: ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° (scheduler_options ì œì™¸)
      if (process.env.NODE_ENV === "development") {
        console.warn("[getPlanGroupsForStudent] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ fallback ì¿¼ë¦¬ ì‚¬ìš©", {
          studentId: filters.studentId,
          tenantId: filters.tenantId,
        });
      }

      const fallbackQuery = supabase
        .from("plan_groups")
        .select(
          "id,tenant_id,student_id,name,plan_purpose,scheduler_type,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
        )
        .eq("student_id", filters.studentId);

      if (filters.tenantId) {
        fallbackQuery.eq("tenant_id", filters.tenantId);
      }

      if (!filters.includeDeleted) {
        fallbackQuery.is("deleted_at", null);
      }

      const fallbackResult = await fallbackQuery.order("created_at", {
        ascending: false,
      });
      error = fallbackResult.error;

      // fallback ì„±ê³µ ì‹œ scheduler_optionsë¥¼ nullë¡œ ì„¤ì •
      if (fallbackResult.data && !error) {
        planGroupsData = fallbackResult.data.map((group: any) => ({
          ...group,
          scheduler_options: null,
        })) as PlanGroup[];
      } else {
        planGroupsData = (fallbackResult.data as PlanGroup[] | null) ?? null;
      }
    }
  }

  if (error) {
    logError(error, {
      function: "getPlanGroupsForStudent",
      filters,
    });
    return [];
  }

  return planGroupsData ?? [];
}

/**
 * í”Œëœ ê·¸ë£¹ IDë¡œ ì¡°íšŒ
 */
/**
 * í”Œëœ ê·¸ë£¹ì„ IDë¡œ ì¡°íšŒí•©ë‹ˆë‹¤.
 *
 * í•™ìƒ IDì™€ í…Œë„ŒíŠ¸ IDë¥¼ ì‚¬ìš©í•˜ì—¬ RLS(Row Level Security)ë¥¼ í†µí•´ ì ‘ê·¼ ê¶Œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
 * ì‚­ì œë˜ì§€ ì•Šì€ í”Œëœ ê·¸ë£¹ë§Œ ì¡°íšŒí•©ë‹ˆë‹¤.
 *
 * Fallback ì²˜ë¦¬:
 * - ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°(ì—ëŸ¬ ì½”ë“œ 42703) fallback ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * - scheduler_options ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° nullë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
 *
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 * @param studentId í•™ìƒ ID (RLS í™•ì¸ìš©)
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì„ íƒì‚¬í•­, RLS í™•ì¸ìš©)
 * @returns í”Œëœ ê·¸ë£¹ ê°ì²´ ë˜ëŠ” null (ì¡°íšŒ ì‹¤íŒ¨ ì‹œ)
 *
 * @example
 * ```typescript
 * const group = await getPlanGroupById(
 *   "group-123",
 *   "student-456",
 *   "tenant-789"
 * );
 * if (group) {
 *   console.log(group.name);
 * }
 * ```
 */
export async function getPlanGroupById(
  groupId: string,
  studentId: string,
  tenantId?: string | null
): Promise<PlanGroup | null> {
  const supabase = await createSupabaseServerClient();

  const selectGroup = () =>
    supabase
      .from("plan_groups")
      .select(
        "id,tenant_id,student_id,name,plan_purpose,scheduler_type,scheduler_options,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
      )
      .eq("id", groupId)
      .eq("student_id", studentId)
      .is("deleted_at", null);

  let query = selectGroup();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<PlanGroup>();

  // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback ì²˜ë¦¬
  // ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒíƒœë¥¼ ë¨¼ì € í™•ì¸í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì¬ì‹œë„ ë°©ì§€
  if (error && error.code === "42703") {
    // scheduler_options ì»¬ëŸ¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ìºì‹œ ì‚¬ìš©)
    const hasSchedulerOptions = await checkColumnExists(
      "plan_groups",
      "scheduler_options"
    );

    if (!hasSchedulerOptions) {
      // scheduler_options ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ fallback ì¿¼ë¦¬ ì‚¬ìš©
      if (process.env.NODE_ENV === "development") {
        console.warn("[getPlanGroupById] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ fallback ì¿¼ë¦¬ ì‚¬ìš©", {
          groupId,
          studentId,
          tenantId,
        });
      }
        supabase
          .from("plan_groups")
          .select(
            "id,tenant_id,student_id,name,plan_purpose,scheduler_type,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
          )
          .eq("id", groupId)
          .eq("student_id", studentId)
          .is("deleted_at", null);

      const fallbackSelect = () =>
        supabase
          .from("plan_groups")
          .select(
            "id,tenant_id,student_id,name,plan_purpose,scheduler_type,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
          );

      let fallbackQuery = fallbackSelect();
      if (tenantId) {
        fallbackQuery = fallbackQuery.eq("tenant_id", tenantId);
      }

      ({ data, error } = await fallbackQuery.maybeSingle<PlanGroup>());

      // fallback ì„±ê³µ ì‹œ scheduler_optionsë¥¼ nullë¡œ ì„¤ì •
      if (data && !error) {
        data = { ...data, scheduler_options: null } as PlanGroup;
      }
    } else {
      // scheduler_options ì»¬ëŸ¼ì€ ìˆì§€ë§Œ ë‹¤ë¥¸ ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
      // ì›ë˜ ì¿¼ë¦¬ë¥¼ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ì—ëŸ¬ ì²˜ë¦¬
      if (process.env.NODE_ENV === "development") {
        console.warn("[getPlanGroupById] ì»¬ëŸ¼ ì—ëŸ¬ ë°œìƒ (scheduler_optionsëŠ” ì¡´ì¬)", {
          groupId,
          studentId,
          tenantId,
        });
      }
    }
  }

  if (error && isPostgrestError(error) && error.code !== "PGRST116") {
    const { details, hint } = getErrorDetails(error);
    logError(error, {
      function: "getPlanGroupById",
      groupId,
      studentId,
      tenantId,
      details,
      hint,
    });
    return null;
  }

  return data ?? null;
}

/**
 * í”Œëœ ê·¸ë£¹ì„ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * í”Œëœ ê·¸ë£¹ì˜ ë©”íƒ€ë°ì´í„°ì™€ JSONB í•„ë“œë“¤ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•©ë‹ˆë‹¤.
 * ìƒì„± ì„±ê³µ ì‹œ í”Œëœ ê·¸ë£¹ IDë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 *
 * JSONB í•„ë“œ:
 * - scheduler_options: ìŠ¤ì¼€ì¤„ëŸ¬ ì˜µì…˜
 * - daily_schedule: ì¼ë³„ ìŠ¤ì¼€ì¤„ ì •ë³´
 * - subject_constraints: êµê³¼ ì œì•½ ì¡°ê±´
 * - additional_period_reallocation: ì¶”ê°€ ê¸°ê°„ ì¬ë°°ì¹˜ ì •ë³´
 * - non_study_time_blocks: í•™ìŠµ ì‹œê°„ ì œì™¸ í•­ëª©
 *
 * @param group í”Œëœ ê·¸ë£¹ ìƒì„± ë°ì´í„°
 * @param group.tenant_id í…Œë„ŒíŠ¸ ID (í•„ìˆ˜)
 * @param group.student_id í•™ìƒ ID (í•„ìˆ˜)
 * @param group.name í”Œëœ ê·¸ë£¹ ì´ë¦„ (ì„ íƒì‚¬í•­)
 * @param group.plan_purpose í”Œëœ ëª©ì  (ì„ íƒì‚¬í•­)
 * @param group.scheduler_type ìŠ¤ì¼€ì¤„ëŸ¬ ìœ í˜• (ì„ íƒì‚¬í•­)
 * @param group.scheduler_options ìŠ¤ì¼€ì¤„ëŸ¬ ì˜µì…˜ (JSONB, ì„ íƒì‚¬í•­)
 * @param group.period_start ê¸°ê°„ ì‹œì‘ì¼ (í•„ìˆ˜)
 * @param group.period_end ê¸°ê°„ ì¢…ë£Œì¼ (í•„ìˆ˜)
 * @param group.target_date ëª©í‘œì¼ (ì„ íƒì‚¬í•­)
 * @param group.block_set_id ë¸”ë¡ ì„¸íŠ¸ ID (ì„ íƒì‚¬í•­)
 * @param group.status í”Œëœ ìƒíƒœ (ì„ íƒì‚¬í•­, ê¸°ë³¸ê°’: "draft")
 * @param group.subject_constraints êµê³¼ ì œì•½ ì¡°ê±´ (JSONB, ì„ íƒì‚¬í•­)
 * @param group.additional_period_reallocation ì¶”ê°€ ê¸°ê°„ ì¬ë°°ì¹˜ ì •ë³´ (JSONB, ì„ íƒì‚¬í•­)
 * @param group.non_study_time_blocks í•™ìŠµ ì‹œê°„ ì œì™¸ í•­ëª© (JSONB, ì„ íƒì‚¬í•­)
 * @param group.daily_schedule ì¼ë³„ ìŠ¤ì¼€ì¤„ ì •ë³´ (JSONB, ì„ íƒì‚¬í•­)
 * @param group.plan_type í”Œëœ ìœ í˜• (ì„ íƒì‚¬í•­)
 * @param group.camp_template_id ìº í”„ í…œí”Œë¦¿ ID (ì„ íƒì‚¬í•­)
 * @param group.camp_invitation_id ìº í”„ ì´ˆëŒ€ ID (ì„ íƒì‚¬í•­)
 * @returns ìƒì„± ê²°ê³¼ ê°ì²´ (success, groupId, error í¬í•¨)
 *
 * @example
 * ```typescript
 * const result = await createPlanGroup({
 *   tenant_id: "tenant-123",
 *   student_id: "student-456",
 *   name: "2025ë…„ 1í•™ê¸° í•™ìŠµ ê³„íš",
 *   plan_purpose: "ë‚´ì‹ ëŒ€ë¹„",
 *   scheduler_type: "1730_timetable",
 *   period_start: "2025-01-01",
 *   period_end: "2025-06-30",
 *   scheduler_options: { study_days: 6, review_days: 1 },
 * });
 * if (result.success) {
 *   console.log("í”Œëœ ê·¸ë£¹ ìƒì„± ì„±ê³µ:", result.groupId);
 * }
 * ```
 */
export async function createPlanGroup(
  group: {
    tenant_id: string;
    student_id: string;
    name?: string | null;
    plan_purpose: string | null;
    scheduler_type: string | null;
    scheduler_options?: SchedulerOptions | null;
    period_start: string;
    period_end: string;
    target_date?: string | null;
    block_set_id?: string | null;
    status?: string;
    subject_constraints?: SubjectConstraints | null;
    additional_period_reallocation?: AdditionalPeriodReallocation | null;
    non_study_time_blocks?: NonStudyTimeBlock[] | null;
    daily_schedule?: DailyScheduleInfo[] | null; // JSONB: ì¼ë³„ ìŠ¤ì¼€ì¤„ ì •ë³´
    // ìº í”„ ê´€ë ¨ í•„ë“œ
    plan_type?: string | null;
    camp_template_id?: string | null;
    camp_invitation_id?: string | null;
  }
): Promise<{ success: boolean; groupId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: PlanGroupPayload = {
    tenant_id: group.tenant_id,
    student_id: group.student_id,
    name: group.name || null,
    plan_purpose: group.plan_purpose,
    scheduler_type: group.scheduler_type,
    period_start: group.period_start,
    period_end: group.period_end,
    target_date: group.target_date || null,
    block_set_id: group.block_set_id || null,
    status: group.status || "draft",
  };

  // scheduler_optionsê°€ ì‹¤ì œ ê°’ì´ ìˆìœ¼ë©´ ì¶”ê°€ (ë°ì´í„°ë² ì´ìŠ¤ì— ì»¬ëŸ¼ì´ ìˆì„ ê²½ìš°)
  // nullì´ë‚˜ undefinedê°€ ì•„ë‹ ë•Œë§Œ ì¶”ê°€
  if (group.scheduler_options !== undefined && group.scheduler_options !== null) {
    payload.scheduler_options = group.scheduler_options;
  }

  // 1730 Timetable ì¶”ê°€ í•„ë“œ
  if (group.subject_constraints !== undefined && group.subject_constraints !== null) {
    payload.subject_constraints = group.subject_constraints;
  }

  if (group.additional_period_reallocation !== undefined && group.additional_period_reallocation !== null) {
    payload.additional_period_reallocation = group.additional_period_reallocation;
  }

  if (group.non_study_time_blocks !== undefined && group.non_study_time_blocks !== null) {
    payload.non_study_time_blocks = group.non_study_time_blocks;
  }

  if (group.daily_schedule !== undefined && group.daily_schedule !== null) {
    payload.daily_schedule = group.daily_schedule;
  }

  // ìº í”„ ê´€ë ¨ í•„ë“œ
  if (group.plan_type !== undefined && group.plan_type !== null) {
    payload.plan_type = group.plan_type;
  }
  if (group.camp_template_id !== undefined && group.camp_template_id !== null) {
    payload.camp_template_id = group.camp_template_id;
  }
  if (group.camp_invitation_id !== undefined && group.camp_invitation_id !== null) {
    payload.camp_invitation_id = group.camp_invitation_id;
  }

  let { data, error } = await supabase
    .from("plan_groups")
    .insert(payload)
    .select("id")
    .single();

  // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback ì²˜ë¦¬
  if (error && error.code === "42703") {
    // scheduler_optionsê°€ í¬í•¨ëœ ê²½ìš° ì œì™¸í•˜ê³  ì¬ì‹œë„
    if (payload.scheduler_options !== undefined) {
      if (process.env.NODE_ENV === "development") {
        console.warn("[createPlanGroup] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ fallback ìƒì„± ì‚¬ìš©", {
          studentId: group.student_id,
          tenantId: group.tenant_id,
        });
      }
      
      const { scheduler_options: _schedulerOptions, ...fallbackPayload } = payload;
      ({ data, error } = await supabase
        .from("plan_groups")
        .insert(fallbackPayload)
        .select("id")
        .single());
      
      // fallback ì„±ê³µ ì‹œ ê²½ê³ ë§Œ ì¶œë ¥
      if (!error && process.env.NODE_ENV === "development") {
        console.warn("[createPlanGroup] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ í•´ë‹¹ í•„ë“œëŠ” ì €ì¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
      }
    } else {
      // ë‹¤ë¥¸ ì»¬ëŸ¼ ë¬¸ì œì¸ ê²½ìš° ì¼ë°˜ fallback
      const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
      ({ data, error } = await supabase
        .from("plan_groups")
        .insert(fallbackPayload)
        .select("id")
        .single());
    }
  }

  if (error) {
    logError(error, {
      function: "createPlanGroup",
      studentId: group.student_id,
      tenantId: group.tenant_id,
      payload: Object.keys(payload),
      errorString: JSON.stringify(error, Object.getOwnPropertyNames(error)),
    });
    return { success: false, error: error.message || String(error) };
  }

  return { success: true, groupId: data?.id };
}

/**
 * í”Œëœ ê·¸ë£¹ ì—…ë°ì´íŠ¸
 */
export async function updatePlanGroup(
  groupId: string,
  studentId: string,
  updates: {
    name?: string | null;
    plan_purpose?: string | null;
    scheduler_type?: string | null;
    scheduler_options?: any | null;
    period_start?: string;
    period_end?: string;
    target_date?: string | null;
    block_set_id?: string | null;
    status?: string;
    daily_schedule?: any | null; // JSONB: ì¼ë³„ ìŠ¤ì¼€ì¤„ ì •ë³´
    subject_constraints?: any | null; // JSONB: êµê³¼ ì œì•½ ì¡°ê±´
    additional_period_reallocation?: any | null; // JSONB: ì¶”ê°€ ê¸°ê°„ ì¬ë°°ì¹˜ ì •ë³´
    non_study_time_blocks?: any | null; // JSONB: í•™ìŠµ ì‹œê°„ ì œì™¸ í•­ëª©
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.name !== undefined) payload.name = updates.name;
  if (updates.plan_purpose !== undefined) payload.plan_purpose = updates.plan_purpose;
  if (updates.scheduler_type !== undefined) payload.scheduler_type = updates.scheduler_type;
  if (updates.scheduler_options !== undefined) payload.scheduler_options = updates.scheduler_options;
  if (updates.period_start !== undefined) payload.period_start = updates.period_start;
  if (updates.period_end !== undefined) payload.period_end = updates.period_end;
  if (updates.target_date !== undefined) payload.target_date = updates.target_date;
  if (updates.block_set_id !== undefined) payload.block_set_id = updates.block_set_id;
  if (updates.status !== undefined) payload.status = updates.status;
  if (updates.daily_schedule !== undefined) payload.daily_schedule = updates.daily_schedule;
  if (updates.subject_constraints !== undefined) payload.subject_constraints = updates.subject_constraints;
  if (updates.additional_period_reallocation !== undefined) payload.additional_period_reallocation = updates.additional_period_reallocation;
  if (updates.non_study_time_blocks !== undefined) payload.non_study_time_blocks = updates.non_study_time_blocks;

  let { error } = await supabase
    .from("plan_groups")
    .update(payload)
    .eq("id", groupId)
    .eq("student_id", studentId)
    .is("deleted_at", null);

  // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback ì²˜ë¦¬
  if (error && (error.code === "42703" || error.code === "PGRST204")) {
    // scheduler_optionsê°€ í¬í•¨ëœ ê²½ìš° ì œì™¸í•˜ê³  ì¬ì‹œë„
    if (payload.scheduler_options !== undefined) {
      if (process.env.NODE_ENV === "development") {
        console.warn("[updatePlanGroup] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ fallback ì—…ë°ì´íŠ¸ ì‚¬ìš©", {
          groupId,
          studentId,
        });
      }
      
      const { scheduler_options: _schedulerOptions, ...fallbackPayload } = payload;
      ({ error } = await supabase
        .from("plan_groups")
        .update(fallbackPayload)
        .eq("id", groupId)
        .eq("student_id", studentId)
        .is("deleted_at", null));
      
      // scheduler_optionsê°€ ì—†ì–´ë„ ë‹¤ë¥¸ í•„ë“œëŠ” ì—…ë°ì´íŠ¸ ì„±ê³µ
      if (!error) {
        if (process.env.NODE_ENV === "development") {
          console.warn("[updatePlanGroup] scheduler_options ì»¬ëŸ¼ì´ ì—†ì–´ í•´ë‹¹ í•„ë“œëŠ” ì €ì¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
        }
        return { success: true };
      }
    }
    
    // ë‹¤ë¥¸ ì»¬ëŸ¼ ë¬¸ì œì¸ ê²½ìš° ì¼ë°˜ fallback
    ({ error } = await supabase
      .from("plan_groups")
      .update(payload)
      .eq("id", groupId));
  }

  if (error) {
    logError(error, {
      function: "updatePlanGroup",
      groupId,
      studentId,
      payload: Object.keys(payload),
    });
    return { success: false, error: error.message || String(error) };
  }

  return { success: true };
}

/**
 * í”Œëœ ê·¸ë£¹ Soft Delete
 */
export async function deletePlanGroup(
  groupId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("plan_groups")
    .update({ deleted_at: new Date().toISOString() })
    .eq("id", groupId)
    .eq("student_id", studentId)
    .is("deleted_at", null);

  if (error) {
    logError(error, {
      function: "deletePlanGroup",
      groupId,
      studentId,
    });
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ìº í”„ ì´ˆëŒ€ IDë¡œ í”Œëœ ê·¸ë£¹ ì‚­ì œ (ê´€ë¦¬ììš©, Hard Delete)
 * ì´ˆëŒ€ ì‚­ì œ ì‹œ ê´€ë ¨ëœ í”Œëœ ê·¸ë£¹ë„ í•¨ê»˜ ì‚­ì œí•˜ê¸° ìœ„í•œ í•¨ìˆ˜
 */
export async function deletePlanGroupByInvitationId(
  invitationId: string
): Promise<{ success: boolean; error?: string; deletedGroupId?: string }> {
  const supabase = await createSupabaseServerClient();

  // 1. camp_invitation_idë¡œ í”Œëœ ê·¸ë£¹ ì¡°íšŒ
  const { data: planGroup, error: fetchError } = await supabase
    .from("plan_groups")
    .select("id, student_id")
    .eq("camp_invitation_id", invitationId)
    .is("deleted_at", null)
    .maybeSingle();

  if (fetchError) {
    logError(fetchError, {
      function: "deletePlanGroupByInvitationId",
      invitationId,
    });
    return { success: false, error: fetchError.message };
  }

  // í”Œëœ ê·¸ë£¹ì´ ì—†ìœ¼ë©´ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬ (ì‚­ì œí•  ê²ƒì´ ì—†ìŒ)
  if (!planGroup) {
    return { success: true };
  }

  const groupId = planGroup.id;
  const studentId = planGroup.student_id;

  // 2. ê´€ë ¨ student_plan ì‚­ì œ (hard delete)
  const { error: deletePlansError } = await supabase
    .from("student_plan")
    .delete()
    .eq("plan_group_id", groupId);

  if (deletePlansError) {
    logError(deletePlansError, {
      function: "deletePlanGroupByInvitationId",
      groupId,
      studentId,
    });
    return {
      success: false,
      error: `í”Œëœ ì‚­ì œ ì‹¤íŒ¨: ${deletePlansError.message}`,
    };
  }

  // 3. plan_contents ì‚­ì œ (ì•ˆì „ì„ ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œ)
  const { error: deleteContentsError } = await supabase
    .from("plan_contents")
    .delete()
    .eq("plan_group_id", groupId);

  if (deleteContentsError) {
    logError(deleteContentsError, {
      function: "deletePlanGroupByInvitationId",
      groupId,
      studentId,
      level: "warn",
    });
    // ì½˜í…ì¸  ì‚­ì œ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ (ì™¸ë˜í‚¤ ì œì•½ìœ¼ë¡œ ìë™ ì‚­ì œë  ìˆ˜ ìˆìŒ)
  }

  // 4. plan_exclusions ì‚­ì œ (ì•ˆì „ì„ ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œ)
  const { error: deleteExclusionsError } = await supabase
    .from("plan_exclusions")
    .delete()
    .eq("plan_group_id", groupId);

  if (deleteExclusionsError) {
    logError(deleteExclusionsError, {
      function: "deletePlanGroupByInvitationId",
      groupId,
      studentId,
      level: "warn",
    });
    // ì œì™¸ì¼ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ (ì™¸ë˜í‚¤ ì œì•½ìœ¼ë¡œ ìë™ ì‚­ì œë  ìˆ˜ ìˆìŒ)
  }

  // 5. academy_schedules ì‚­ì œëŠ” ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ
  // ì´ìœ :
  // - ìº í”„ ëª¨ë“œì—ì„œëŠ” academy_schedulesê°€ plan_group_id ì—†ì´ ì €ì¥ë¨ (í•™ìƒë³„ ì „ì—­ ê´€ë¦¬)
  // - submitCampParticipationì—ì„œ ê¸°ì¡´ í•™ì› ì¼ì •ì„ ëª¨ë‘ ì‚­ì œí•˜ê³  í…œí”Œë¦¿ ì¼ì •ìœ¼ë¡œ êµì²´
  // - ì´ˆëŒ€ ì·¨ì†Œ ì‹œ academy_schedulesë¥¼ ì‚­ì œí•˜ë©´ ë‹¤ë¥¸ í”Œëœ ê·¸ë£¹ì˜ í•™ì› ì¼ì •ê¹Œì§€ ì‚­ì œë  ìœ„í—˜ì´ ìˆìŒ
  // - ë”°ë¼ì„œ academy_schedulesëŠ” ì‚­ì œí•˜ì§€ ì•Šê³  ìœ ì§€ (ë‹¤ë¥¸ í”Œëœ ê·¸ë£¹ ë³´í˜¸)

  // 6. plan_groups ì‚­ì œ (hard delete)
  const { error: deleteGroupError } = await supabase
    .from("plan_groups")
    .delete()
    .eq("id", groupId);

  if (deleteGroupError) {
    logError(deleteGroupError, {
      function: "deletePlanGroupByInvitationId",
      groupId,
      studentId,
    });
    return {
      success: false,
      error: `í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨: ${deleteGroupError.message}`,
    };
  }

  return { success: true, deletedGroupId: groupId };
}

/**
 * ìº í”„ í…œí”Œë¦¿ IDë¡œ í”Œëœ ê·¸ë£¹ ì‚­ì œ (ê´€ë¦¬ììš©, Hard Delete)
 * í…œí”Œë¦¿ ì‚­ì œ ì‹œ ê´€ë ¨ëœ í”Œëœ ê·¸ë£¹ë„ í•¨ê»˜ ì‚­ì œí•˜ê¸° ìœ„í•œ í•¨ìˆ˜
 * ì—¬ëŸ¬ í”Œëœ ê·¸ë£¹ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª¨ë‘ ì‚­ì œ
 */
export async function deletePlanGroupsByTemplateId(
  templateId: string
): Promise<{ success: boolean; error?: string; deletedGroupIds?: string[] }> {
  const supabase = await createSupabaseServerClient();

  // 1. camp_template_idë¡œ í”Œëœ ê·¸ë£¹ ì¡°íšŒ (ì—¬ëŸ¬ ê°œì¼ ìˆ˜ ìˆìŒ)
  const { data: planGroups, error: fetchError } = await supabase
    .from("plan_groups")
    .select("id, student_id")
    .eq("camp_template_id", templateId)
    .is("deleted_at", null);

  if (fetchError) {
    logError(fetchError, {
      function: "deletePlanGroupsByTemplateId",
      templateId,
    });
    return { success: false, error: fetchError.message };
  }

  // í”Œëœ ê·¸ë£¹ì´ ì—†ìœ¼ë©´ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬ (ì‚­ì œí•  ê²ƒì´ ì—†ìŒ)
  if (!planGroups || planGroups.length === 0) {
    return { success: true, deletedGroupIds: [] };
  }

  const groupIds = planGroups.map((g) => g.id);
  const deletedGroupIds: string[] = [];

  // 2. ê° í”Œëœ ê·¸ë£¹ì— ëŒ€í•´ ê´€ë ¨ ë°ì´í„° ì‚­ì œ
  for (const groupId of groupIds) {
    // 2-1. ê´€ë ¨ student_plan ì‚­ì œ (hard delete)
    const { error: deletePlansError } = await supabase
      .from("student_plan")
      .delete()
      .eq("plan_group_id", groupId);

    if (deletePlansError) {
      logError(deletePlansError, {
        function: "deletePlanGroupsByTemplateId",
        groupId,
        level: "warn",
      });
      // ê°œë³„ í”Œëœ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }

    // 2-2. plan_contents ì‚­ì œ (ì•ˆì „ì„ ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œ)
    const { error: deleteContentsError } = await supabase
      .from("plan_contents")
      .delete()
      .eq("plan_group_id", groupId);

    if (deleteContentsError) {
      logError(deleteContentsError, {
        function: "deletePlanGroupsByTemplateId",
        groupId,
        level: "warn",
      });
      // ì½˜í…ì¸  ì‚­ì œ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }

    // 2-3. plan_exclusions ì‚­ì œ (ì•ˆì „ì„ ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œ)
    const { error: deleteExclusionsError } = await supabase
      .from("plan_exclusions")
      .delete()
      .eq("plan_group_id", groupId);

    if (deleteExclusionsError) {
      logError(deleteExclusionsError, {
        function: "deletePlanGroupsByTemplateId",
        groupId,
        level: "warn",
      });
      // ì œì™¸ì¼ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
    }

    // 2-4. plan_groups ì‚­ì œ (hard delete)
    const { error: deleteGroupError } = await supabase
      .from("plan_groups")
      .delete()
      .eq("id", groupId);

    if (deleteGroupError) {
      logError(deleteGroupError, {
        function: "deletePlanGroupsByTemplateId",
        groupId,
        level: "warn",
      });
      // ê°œë³„ í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨ëŠ” ê¸°ë¡ë§Œ í•˜ê³  ê³„ì† ì§„í–‰
    } else {
      deletedGroupIds.push(groupId);
    }
  }

  return { success: true, deletedGroupIds };
}

/**
 * í”Œëœ ê·¸ë£¹ ì½˜í…ì¸  ì¡°íšŒ
 */
export async function getPlanContents(
  groupId: string,
  tenantId?: string | null
): Promise<PlanContent[]> {
  const supabase = await createSupabaseServerClient();

  if (process.env.NODE_ENV === "development") {
    console.log("[getPlanContents] í”Œëœ ì½˜í…ì¸  ì¡°íšŒ ì‹œì‘", { groupId, tenantId });
  }

  const selectContents = () =>
    supabase
      .from("plan_contents")
      .select(
        "id,tenant_id,plan_group_id,content_type,content_id,master_content_id,start_range,end_range,start_detail_id,end_detail_id,display_order,is_auto_recommended,recommendation_source,recommendation_reason,recommendation_metadata,recommended_at,recommended_by,created_at,updated_at"
      )
      .eq("plan_group_id", groupId)
      .order("display_order", { ascending: true });

  let query = selectContents();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query;

  if (process.env.NODE_ENV === "development") {
    console.log("[getPlanContents] í”Œëœ ì½˜í…ì¸  ì¡°íšŒ ê²°ê³¼", {
      groupId,
      tenantId,
      dataCount: data?.length || 0,
      error: error ? { message: error.message, code: error.code } : null,
    });
  }

  if (error && error.code === "42703") {
    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback ì¿¼ë¦¬ ì‹œë„
    const fallbackSelect = () =>
      supabase
        .from("plan_contents")
        .select("id,tenant_id,plan_group_id,content_type,content_id,master_content_id,start_range,end_range,start_detail_id,end_detail_id,display_order,is_auto_recommended,recommendation_source,recommendation_reason,recommendation_metadata,recommended_at,recommended_by,created_at,updated_at")
        .eq("plan_group_id", groupId)
        .order("display_order", { ascending: true });
    
    let fallbackQuery = fallbackSelect();
    if (tenantId) {
      fallbackQuery = fallbackQuery.eq("tenant_id", tenantId);
    }
    
    ({ data, error } = await fallbackQuery);
  }

  if (error) {
    const { details, hint } = getErrorDetails(error);
    logError(error, {
      function: "getPlanContents",
      groupId,
      tenantId,
      details,
      hint,
    });
    
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ë¹ˆ ë°°ì—´ ë°˜í™˜ (í˜ì´ì§€ê°€ ê¹¨ì§€ì§€ ì•Šë„ë¡)
    return [];
  }

  return (data as PlanContent[] | null) ?? [];
}

/**
 * í”Œëœ ê·¸ë£¹ ì½˜í…ì¸  ì¼ê´„ ìƒì„±
 */
export async function createPlanContents(
  groupId: string,
  tenantId: string,
  contents: Array<{
    content_type: string;
    content_id: string;
    master_content_id?: string | null; // ë§ˆìŠ¤í„° ì½˜í…ì¸  ID (í•™ìƒ ì½˜í…ì¸ ê°€ ë§ˆìŠ¤í„° ì½˜í…ì¸ ì™€ ì—°ê³„ëœ ê²½ìš°)
    start_range: number;
    end_range: number;
    display_order?: number;
    // ìë™ ì¶”ì²œ ê´€ë ¨ í•„ë“œ (ì„ íƒ)
    is_auto_recommended?: boolean;
    recommendation_source?: "auto" | "admin" | "template" | null;
    recommendation_reason?: string | null;
    recommendation_metadata?: {
      scoreDetails?: {
        schoolGrade?: number | null;
        schoolAverageGrade?: number | null;
        mockPercentile?: number | null;
        mockGrade?: number | null;
        riskScore?: number;
      };
      priority?: number;
    } | null;
    recommended_at?: string | null;
    recommended_by?: string | null;
  }>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  if (contents.length === 0) {
    return { success: true };
  }

  const payload = contents.map((content, index) => ({
    tenant_id: tenantId,
    plan_group_id: groupId,
    content_type: content.content_type,
    content_id: content.content_id,
    master_content_id: content.master_content_id ?? null,
    start_range: content.start_range,
    end_range: content.end_range,
    start_detail_id: (content as any).start_detail_id ?? null,
    end_detail_id: (content as any).end_detail_id ?? null,
    display_order: content.display_order ?? index,
    // ìë™ ì¶”ì²œ ê´€ë ¨ í•„ë“œ
    is_auto_recommended: content.is_auto_recommended ?? false,
    recommendation_source: content.recommendation_source ?? null,
    recommendation_reason: content.recommendation_reason ?? null,
    recommendation_metadata: content.recommendation_metadata ?? null,
    recommended_at: content.recommended_at ?? null,
    recommended_by: content.recommended_by ?? null,
  }));

  let { error } = await supabase.from("plan_contents").insert(payload);

  if (error && error.code === "42703") {
    if (process.env.NODE_ENV === "development") {
      console.warn("[createPlanContents] ì»¬ëŸ¼ì´ ì—†ì–´ fallback ì¿¼ë¦¬ ì‚¬ìš©", {
        groupId,
        tenantId,
      });
    }
    // í•„ë“œê°€ ì—†ëŠ” ê²½ìš° fallback (í•˜ìœ„ í˜¸í™˜ì„±)
    const fallbackPayload = payload.map(({ 
      tenant_id: _tenantId, 
      master_content_id: _masterContentId,
      is_auto_recommended: _isAuto,
      recommendation_source: _source,
      recommendation_reason: _reason,
      recommendation_metadata: _metadata,
      recommended_at: _at,
      recommended_by: _by,
      ...rest 
    }) => rest);
    ({ error } = await supabase.from("plan_contents").insert(fallbackPayload));
  }

  if (error) {
    logError(error, {
      function: "createPlanContents",
      groupId,
      tenantId,
    });
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í”Œëœ ê·¸ë£¹ ì œì™¸ì¼ ì¡°íšŒ (í”Œëœ ê·¸ë£¹ë³„ ê´€ë¦¬)
 */
export async function getPlanExclusions(
  groupId: string,
  tenantId?: string | null
): Promise<PlanExclusion[]> {
  const supabase = await createSupabaseServerClient();

  const selectExclusions = () =>
    supabase
      .from("plan_exclusions")
      .select("id,tenant_id,student_id,plan_group_id,exclusion_date,exclusion_type,reason,created_at")
      .eq("plan_group_id", groupId)
      .order("exclusion_date", { ascending: true });

  let query = selectExclusions();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query;

  if (error && error.code === "42703") {
    ({ data, error } = await selectExclusions());
  }

  if (error) {
    logError(error, {
      function: "getPlanExclusions",
      groupId,
      tenantId,
    });
    return [];
  }

  return (data as PlanExclusion[] | null) ?? [];
}

/**
 * í•™ìƒë³„ ì œì™¸ì¼ ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 */
export async function getStudentExclusions(
  studentId: string,
  tenantId?: string | null
): Promise<PlanExclusion[]> {
  const supabase = await createSupabaseServerClient();

  const selectExclusions = () =>
    supabase
      .from("plan_exclusions")
      .select("id,tenant_id,student_id,exclusion_date,exclusion_type,reason,created_at")
      .eq("student_id", studentId)
      .order("exclusion_date", { ascending: true });

  let query = selectExclusions();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query;

  if (error && error.code === "42703") {
    ({ data, error } = await selectExclusions());
  }

  if (error) {
    logError(error, {
      function: "getStudentExclusions",
      studentId,
      tenantId,
    });
    return [];
  }

  return (data as PlanExclusion[] | null) ?? [];
}

/**
 * í”Œëœ ê·¸ë£¹ ì œì™¸ì¼ ì¼ê´„ ìƒì„± (í”Œëœ ê·¸ë£¹ë³„ ê´€ë¦¬)
 */
export async function createPlanExclusions(
  groupId: string,
  tenantId: string,
  exclusions: Array<{
    exclusion_date: string;
    exclusion_type: string;
    reason?: string | null;
  }>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  if (exclusions.length === 0) {
    return { success: true };
  }

  // í”Œëœ ê·¸ë£¹ì—ì„œ student_id ì¡°íšŒ
  const { data: group } = await supabase
    .from("plan_groups")
    .select("student_id")
    .eq("id", groupId)
    .maybeSingle();
  
  if (!group?.student_id) {
    return { success: false, error: "í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
  }

  // ì¤‘ë³µ ì²´í¬: í˜„ì¬ í”Œëœ ê·¸ë£¹ ë‚´ ì œì™¸ì¼ ì¡°íšŒ (ë‚ ì§œ+ìœ í˜• ì¡°í•©)
  const currentExclusionsQuery = supabase
    .from("plan_exclusions")
    .select("id, exclusion_date, exclusion_type")
    .eq("student_id", group.student_id)
    .eq("plan_group_id", groupId);
  
  if (tenantId) {
    currentExclusionsQuery.eq("tenant_id", tenantId);
  }
  
  const { data: currentExclusions, error: exclusionsError } = await currentExclusionsQuery;
  
  if (exclusionsError) {
    logError(exclusionsError, {
      function: "createPlanExclusions",
      groupId,
      tenantId,
      level: "warn",
    });
  }

  // í˜„ì¬ í”Œëœ ê·¸ë£¹ì— ì´ë¯¸ ìˆëŠ” ì œì™¸ì¼ (ë‚ ì§œ+ìœ í˜• ì¡°í•©)
  const existingKeys = new Set(
    (currentExclusions || []).map(
      (e) => `${e.exclusion_date}-${e.exclusion_type}`
    )
  );

  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ ì œì™¸ì¼ ì¡°íšŒ (plan_group_idê°€ NULLì´ê±°ë‚˜ ë‹¤ë¥¸ í”Œëœ ê·¸ë£¹)
  const timeManagementExclusionsQuery = supabase
    .from("plan_exclusions")
    .select("id, exclusion_date, exclusion_type, reason")
    .eq("student_id", group.student_id);
  
  if (tenantId) {
    timeManagementExclusionsQuery.eq("tenant_id", tenantId);
  }
  
  // plan_group_idê°€ NULLì´ê±°ë‚˜ í˜„ì¬ ê·¸ë£¹ì´ ì•„ë‹Œ ê²ƒ
  timeManagementExclusionsQuery.or(`plan_group_id.is.null,plan_group_id.neq.${groupId}`);
  
  const { data: timeManagementExclusions } = await timeManagementExclusionsQuery;
  
  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ ì œì™¸ì¼ì„ í‚¤ë¡œ ë§¤í•‘
  const timeManagementMap = new Map(
    (timeManagementExclusions || []).map((e) => [
      `${e.exclusion_date}-${e.exclusion_type}`,
      e,
    ])
  );

  // ì—…ë°ì´íŠ¸í•  í•­ëª©ê³¼ ìƒˆë¡œ ìƒì„±í•  í•­ëª© ë¶„ë¦¬
  const toUpdate: Array<{ id: string; exclusion: typeof exclusions[0] }> = [];
  const toInsert: typeof exclusions = [];

  for (const exclusion of exclusions) {
    const key = `${exclusion.exclusion_date}-${exclusion.exclusion_type}`;
    
    // í˜„ì¬ í”Œëœ ê·¸ë£¹ì— ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
    if (existingKeys.has(key)) {
      if (process.env.NODE_ENV === "development") {
        console.log("[createPlanExclusions] ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì œì™¸ì¼ ìŠ¤í‚µ", { key });
      }
      continue;
    }
    
    // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì— ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸
    const timeManagementExclusion = timeManagementMap.get(key);
    if (timeManagementExclusion) {
      toUpdate.push({
        id: timeManagementExclusion.id,
        exclusion,
      });
    } else {
      // ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
      toInsert.push(exclusion);
    }
  }

  if (process.env.NODE_ENV === "development") {
    console.log("[createPlanExclusions] ì²˜ë¦¬ ìš”ì•½", {
      updateCount: toUpdate.length,
      insertCount: toInsert.length,
      skipCount: exclusions.length - toUpdate.length - toInsert.length,
    });
  }

  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ ì œì™¸ì¼ì„ í˜„ì¬ í”Œëœ ê·¸ë£¹ìœ¼ë¡œ ì—…ë°ì´íŠ¸
  if (toUpdate.length > 0) {
    for (const { id, exclusion } of toUpdate) {
      const { error: updateError } = await supabase
        .from("plan_exclusions")
        .update({
          plan_group_id: groupId,
          reason: exclusion.reason || null,
        })
        .eq("id", id);

      if (updateError) {
        logError(updateError, {
          function: "createPlanExclusions",
          level: "warn",
          exclusionId: id,
          groupId,
        });
        // ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ ì‹œ ìƒˆë¡œ ìƒì„± ëª©ë¡ì— ì¶”ê°€
        toInsert.push(exclusion);
      } else if (process.env.NODE_ENV === "development") {
        console.log("[createPlanExclusions] ì œì™¸ì¼ ì¬í™œìš© ì„±ê³µ", {
          exclusionDate: exclusion.exclusion_date,
          exclusionType: exclusion.exclusion_type,
        });
      }
    }
  }

  // ìƒˆë¡œ ìƒì„±í•  ì œì™¸ì¼
  if (toInsert.length > 0) {
    const payload = toInsert.map((exclusion) => ({
      tenant_id: tenantId,
      student_id: group.student_id,
      plan_group_id: groupId,
      exclusion_date: exclusion.exclusion_date,
      exclusion_type: exclusion.exclusion_type,
      reason: exclusion.reason || null,
    }));

    let { error } = await supabase.from("plan_exclusions").insert(payload);

    if (error && error.code === "42703") {
      const fallbackPayload = payload.map(({ tenant_id: _tenantId, ...rest }) => rest);
      ({ error } = await supabase.from("plan_exclusions").insert(fallbackPayload));
    }

    // ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬ (ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ unique ì œì•½ì¡°ê±´)
    if (error && (error.code === "23505" || error.message?.includes("duplicate"))) {
      return {
        success: false,
        error: "ì´ë¯¸ ë“±ë¡ëœ ì œì™¸ì¼ì´ ìˆìŠµë‹ˆë‹¤.",
      };
    }

    if (error) {
      logError(error, {
        function: "createPlanExclusions",
        groupId,
        tenantId,
      });
      return { success: false, error: error.message };
    }

    if (process.env.NODE_ENV === "development") {
      console.log("[createPlanExclusions] ì œì™¸ì¼ ìƒì„± ì™„ë£Œ", { insertCount: toInsert.length });
    }
  }

  return { success: true };
}

/**
 * í•™ìƒë³„ ì œì™¸ì¼ ì¼ê´„ ìƒì„± (ì „ì—­ ê´€ë¦¬)
 */
export async function createStudentExclusions(
  studentId: string,
  tenantId: string,
  exclusions: Array<{
    exclusion_date: string;
    exclusion_type: string;
    reason?: string | null;
  }>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  if (exclusions.length === 0) {
    return { success: true };
  }

  // ì¤‘ë³µ ì²´í¬: ê°™ì€ ë‚ ì§œì˜ ì œì™¸ì¼ì´ ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
  const existingExclusions = await getStudentExclusions(studentId, tenantId);
  const existingDates = new Set(existingExclusions.map((e) => e.exclusion_date));

  const newExclusions = exclusions.filter(
    (e) => !existingDates.has(e.exclusion_date)
  );

  if (newExclusions.length === 0) {
    return { success: true }; // ëª¨ë“  ì œì™¸ì¼ì´ ì´ë¯¸ ì¡´ì¬
  }

  const payload = newExclusions.map((exclusion) => ({
    tenant_id: tenantId,
    student_id: studentId,
    exclusion_date: exclusion.exclusion_date,
    exclusion_type: exclusion.exclusion_type,
    reason: exclusion.reason || null,
  }));

  let { error } = await supabase.from("plan_exclusions").insert(payload);

  if (error && error.code === "42703") {
    const fallbackPayload = payload.map(({ tenant_id: _tenantId, ...rest }) => rest);
    ({ error } = await supabase.from("plan_exclusions").insert(fallbackPayload));
  }

  if (error) {
    logError(error, {
      function: "createStudentExclusions",
      studentId,
      tenantId,
    });
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í”Œëœ ê·¸ë£¹ë³„ í•™ì› ì¼ì • ì¡°íšŒ (Phase 2: plan_group_id ê¸°ë°˜)
 */
export async function getAcademySchedules(
  groupId: string,
  tenantId?: string | null
): Promise<AcademySchedule[]> {
  const supabase = await createSupabaseServerClient();
  
  // academiesì™€ ì¡°ì¸í•˜ì—¬ travel_time ê°€ì ¸ì˜¤ê¸°
  const selectSchedules = () =>
    supabase
      .from("academy_schedules")
      .select(
        "id,tenant_id,student_id,plan_group_id,academy_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at,academies(travel_time)"
      )
      .eq("plan_group_id", groupId) // plan_group_idë¡œ ì¡°íšŒ (í”Œëœ ê·¸ë£¹ë³„ ê´€ë¦¬)
      .order("day_of_week", { ascending: true })
      .order("start_time", { ascending: true });

  let query = selectSchedules();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query;
  let schedulesData: AcademySchedule[] | null = data as AcademySchedule[] | null;

  // tenant_id ì»¬ëŸ¼ ì—†ëŠ” ê²½ìš° ì¬ì‹œë„
  if (error && error.code === "42703") {
    if (process.env.NODE_ENV === "development") {
      console.warn("[getAcademySchedules] tenant_id ì»¬ëŸ¼ ì—†ìŒ, ì¬ì‹œë„", { groupId, tenantId });
    }
    const retryQuery = supabase
      .from("academy_schedules")
      .select(
        "id,student_id,plan_group_id,academy_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at,academies(travel_time)"
      )
      .eq("plan_group_id", groupId)
      .order("day_of_week", { ascending: true })
      .order("start_time", { ascending: true });

    const retryResult = await retryQuery;
    error = retryResult.error;
    
    // tenant_idë¥¼ nullë¡œ ì„¤ì •
    if (retryResult.data && !error) {
      schedulesData = retryResult.data.map((schedule: any) => ({
        ...schedule,
        tenant_id: null,
        academy_id: schedule.academy_id || "", 
      })) as AcademySchedule[];
    } else {
      schedulesData = (retryResult.data as AcademySchedule[] | null) ?? null;
    }
  }

  if (error) {
    logError(error, {
      function: "getAcademySchedules",
      groupId,
      tenantId,
    });
    return [];
  }

  // travel_time ì¶”ì¶œ ë° ë°˜í™˜
  type ScheduleWithAcademies = AcademySchedule & {
    academies?: { travel_time?: number } | Array<{ travel_time?: number }> | null;
  };
  
  return (
    schedulesData?.map((schedule) => {
      const scheduleWithAcademies = schedule as ScheduleWithAcademies;
      const travelTime = Array.isArray(scheduleWithAcademies.academies)
        ? scheduleWithAcademies.academies[0]?.travel_time ?? 60
        : (scheduleWithAcademies.academies as { travel_time?: number } | null)?.travel_time ?? 60;
      return {
        ...schedule,
        travel_time: travelTime,
      };
    }) || []
  );
}

/**
 * í•™ìƒë³„ í•™ì› ì¼ì • ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 */
export async function getStudentAcademySchedules(
  studentId: string,
  tenantId?: string | null
): Promise<AcademySchedule[]> {
  const supabase = await createSupabaseServerClient();

  // academiesì™€ ì¡°ì¸í•˜ì—¬ travel_time ê°€ì ¸ì˜¤ê¸°
  const selectSchedules = () =>
    supabase
      .from("academy_schedules")
      .select(
        "id,tenant_id,student_id,academy_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at,academies(travel_time)"
      )
      .eq("student_id", studentId)
      .order("day_of_week", { ascending: true })
      .order("start_time", { ascending: true });

  let query = selectSchedules();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query;
  let studentSchedulesData: AcademySchedule[] | null = (data as AcademySchedule[] | null) ?? null;

  if (error && isPostgrestError(error) && error.code === "42703") {
    // academy_idê°€ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ fallback
    const fallbackSelect = () =>
      supabase
        .from("academy_schedules")
        .select(
          "id,tenant_id,student_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at"
        )
        .eq("student_id", studentId)
        .order("day_of_week", { ascending: true })
        .order("start_time", { ascending: true });
    
    let fallbackQuery = fallbackSelect();
    if (tenantId) {
      fallbackQuery = fallbackQuery.eq("tenant_id", tenantId);
    }
    const fallbackResult = await fallbackQuery;
    error = fallbackResult.error;
    
    // academy_idë¥¼ ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì •
    if (fallbackResult.data && !error) {
      studentSchedulesData = fallbackResult.data.map((schedule: any) => ({
        ...schedule,
        academy_id: "", 
        tenant_id: "",
        academy_name: schedule.academy_name || null,
      })) as AcademySchedule[];
    } else {
      studentSchedulesData = (fallbackResult.data as AcademySchedule[] | null) ?? null;
    }
  }

  if (error) {
    logError(error, {
      function: "getStudentAcademySchedules",
      studentId,
      tenantId,
    });
    return [];
  }

  // ë°ì´í„° ë³€í™˜: academies ê´€ê³„ ë°ì´í„°ë¥¼ travel_timeìœ¼ë¡œ ë³€í™˜
  type ScheduleWithAcademies = AcademySchedule & {
    academies?: { travel_time?: number } | null;
  };
  
  const schedules = (studentSchedulesData ?? []) as ScheduleWithAcademies[];
  return schedules.map((schedule) => ({
    ...schedule,
    travel_time: schedule.academies?.travel_time ?? 60, // ê¸°ë³¸ê°’ 60ë¶„
    academies: undefined, // ê´€ê³„ ë°ì´í„° ì œê±°
  })) as AcademySchedule[];
}

/**
 * í”Œëœ ê·¸ë£¹ í•™ì› ì¼ì • ì¼ê´„ ìƒì„± (í•™ìƒë³„ ì „ì—­ ê´€ë¦¬)
 * @deprecated createStudentAcademySchedules ì‚¬ìš© ê¶Œì¥
 */
export async function createAcademySchedules(
  groupId: string,
  tenantId: string,
  schedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string | null;
    subject?: string | null;
  }>
): Promise<{ success: boolean; error?: string }> {
  // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ student_idë¥¼ ì¡°íšŒí•˜ì—¬ ì‚¬ìš©
  const supabase = await createSupabaseServerClient();
  
  // í”Œëœ ê·¸ë£¹ì—ì„œ student_id ì¡°íšŒ
  const { data: group } = await supabase
    .from("plan_groups")
    .select("student_id")
    .eq("id", groupId)
    .maybeSingle();
  
  if (!group?.student_id) {
    return { success: false, error: "í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
  }
  
  return createStudentAcademySchedules(group.student_id, tenantId, schedules);
}

/**
 * í”Œëœ ê·¸ë£¹ë³„ í•™ì› ì¼ì • ìƒì„±
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 * @param tenantId í…Œë„ŒíŠ¸ ID
 * @param schedules ìƒì„±í•  í•™ì› ì¼ì • ëª©ë¡
 * @param useAdminClient ê´€ë¦¬ì ëª¨ë“œì¼ ë•Œ trueë¡œ ì„¤ì • (RLS ìš°íšŒ)
 */
export async function createPlanAcademySchedules(
  groupId: string,
  tenantId: string,
  schedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string | null;
    subject?: string | null;
  }>,
  useAdminClient: boolean = false
): Promise<{ success: boolean; error?: string }> {
  // ê´€ë¦¬ì ëª¨ë“œì¼ ë•Œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  let supabase;
  if (useAdminClient) {
    const { createSupabaseAdminClient } = await import("@/lib/supabase/admin");
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      if (process.env.NODE_ENV === "development") {
        console.warn("[createPlanAcademySchedules] Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ì–´ ì¼ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©");
      }
      supabase = await createSupabaseServerClient();
    } else {
      supabase = adminClient;
    }
  } else {
    supabase = await createSupabaseServerClient();
  }

  if (schedules.length === 0) {
    if (process.env.NODE_ENV === "development") {
      console.log("[createPlanAcademySchedules] í•™ì› ì¼ì •ì´ ì—†ìŠµë‹ˆë‹¤.");
    }
    return { success: true };
  }

  // í”Œëœ ê·¸ë£¹ì—ì„œ student_id ì¡°íšŒ
  const { data: group } = await supabase
    .from("plan_groups")
    .select("student_id")
    .eq("id", groupId)
    .maybeSingle();
  
  if (!group?.student_id) {
    return { success: false, error: "í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
  }

  // ë””ë²„ê¹…: ì…ë ¥ëœ í•™ì› ì¼ì • í™•ì¸
  if (process.env.NODE_ENV === "development") {
    console.log("[createPlanAcademySchedules] ì…ë ¥ëœ í•™ì› ì¼ì •", {
      groupId,
      studentId: group.student_id,
      tenantId,
      schedulesCount: schedules.length,
    });
  }

  const studentId = group.student_id;

  // ì¤‘ë³µ ì²´í¬: í˜„ì¬ í”Œëœ ê·¸ë£¹ì˜ ê¸°ì¡´ í•™ì› ì¼ì • ì¡°íšŒ
  const existingSchedules = await getAcademySchedules(groupId, tenantId);
  const existingKeys = new Set(
    existingSchedules.map((s) => 
      `${s.day_of_week}:${s.start_time}:${s.end_time}:${s.academy_name || ""}:${s.subject || ""}`
    )
  );

  if (process.env.NODE_ENV === "development") {
    console.log("[createPlanAcademySchedules] ê¸°ì¡´ í•™ì› ì¼ì • (í˜„ì¬ í”Œëœ ê·¸ë£¹)", {
      existingSchedulesCount: existingSchedules.length,
    });
  }

  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ í•™ì› ì¼ì • ì¡°íšŒ (plan_group_idê°€ NULLì´ê±°ë‚˜ ë‹¤ë¥¸ í”Œëœ ê·¸ë£¹)
  const timeManagementSchedulesQuery = supabase
    .from("academy_schedules")
    .select("id, day_of_week, start_time, end_time, academy_name, subject, academy_id")
    .eq("student_id", studentId);
  
  if (tenantId) {
    timeManagementSchedulesQuery.eq("tenant_id", tenantId);
  }
  
  // plan_group_idê°€ NULLì´ê±°ë‚˜ í˜„ì¬ ê·¸ë£¹ì´ ì•„ë‹Œ ê²ƒ
  timeManagementSchedulesQuery.or(`plan_group_id.is.null,plan_group_id.neq.${groupId}`);
  
  const { data: timeManagementSchedules } = await timeManagementSchedulesQuery;
  
  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ í•™ì› ì¼ì •ì„ í‚¤ë¡œ ë§¤í•‘
  const timeManagementMap = new Map(
    (timeManagementSchedules || []).map((s) => [
      `${s.day_of_week}:${s.start_time}:${s.end_time}:${s.academy_name || ""}:${s.subject || ""}`,
      s,
    ])
  );

  // ì—…ë°ì´íŠ¸í•  í•­ëª©ê³¼ ìƒˆë¡œ ìƒì„±í•  í•­ëª© ë¶„ë¦¬
  const toUpdate: Array<{ id: string; schedule: typeof schedules[0] }> = [];
  const toInsert: typeof schedules = [];

  for (const schedule of schedules) {
    const key = `${schedule.day_of_week}:${schedule.start_time}:${schedule.end_time}:${schedule.academy_name || ""}:${schedule.subject || ""}`;
    
    // í˜„ì¬ í”Œëœ ê·¸ë£¹ì— ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
    if (existingKeys.has(key)) {
      if (process.env.NODE_ENV === "development") {
        console.log("[createPlanAcademySchedules] ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í•™ì› ì¼ì • ìŠ¤í‚µ", { key });
      }
      continue;
    }
    
    // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì— ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸
    const timeManagementSchedule = timeManagementMap.get(key);
    if (timeManagementSchedule) {
      toUpdate.push({
        id: timeManagementSchedule.id,
        schedule,
      });
    } else {
      // ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
      toInsert.push(schedule);
    }
  }

  if (process.env.NODE_ENV === "development") {
    console.log("[createPlanAcademySchedules] ì²˜ë¦¬ ìš”ì•½", {
      updateCount: toUpdate.length,
      insertCount: toInsert.length,
      skipCount: schedules.length - toUpdate.length - toInsert.length,
    });
  }

  // academy_nameë³„ë¡œ academyë¥¼ ì°¾ê±°ë‚˜ ìƒì„±í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
  const getOrCreateAcademy = async (academyName: string): Promise<string | null> => {
    const { data: existingAcademy } = await supabase
      .from("academies")
      .select("id")
      .eq("student_id", studentId)
      .eq("name", academyName)
      .maybeSingle();

    if (existingAcademy) {
      return existingAcademy.id;
    }

    // ìƒˆ academy ìƒì„±
    const { data: newAcademy, error: academyError } = await supabase
      .from("academies")
      .insert({
        student_id: studentId,
        tenant_id: tenantId,
        name: academyName,
        travel_time: 60,
      })
      .select("id")
      .single();

    if (academyError || !newAcademy) {
      logError(academyError || new Error("í•™ì› ìƒì„± ì‹¤íŒ¨"), {
        function: "createPlanAcademySchedules",
        level: "warn",
        academyName,
        studentId,
      });
      return null;
    }

    return newAcademy.id;
  };

  // ì‹œê°„ ê´€ë¦¬ ì˜ì—­ì˜ í•™ì› ì¼ì •ì„ í˜„ì¬ í”Œëœ ê·¸ë£¹ìœ¼ë¡œ ì—…ë°ì´íŠ¸
  if (toUpdate.length > 0) {
    for (const { id, schedule } of toUpdate) {
      // academy_nameìœ¼ë¡œ academy ì°¾ê¸° ë˜ëŠ” ìƒì„±
      const academyName = schedule.academy_name || "í•™ì›";
      const academyId = await getOrCreateAcademy(academyName);
      
      if (!academyId) {
        console.warn("[createPlanAcademySchedules] í•™ì› ID í™•ë³´ ì‹¤íŒ¨, ìƒˆë¡œ ìƒì„±ìœ¼ë¡œ í´ë°±", {
          academyName,
          scheduleId: id,
        });
        toInsert.push(schedule);
        continue;
      }

      const { error: updateError } = await supabase
        .from("academy_schedules")
        .update({
          plan_group_id: groupId,
          academy_id: academyId,
          academy_name: schedule.academy_name || null,
          subject: schedule.subject || null,
        })
        .eq("id", id);

      if (updateError) {
        logError(updateError, {
          function: "createPlanAcademySchedules",
          level: "warn",
          scheduleId: id,
        });
        toInsert.push(schedule);
      } else if (process.env.NODE_ENV === "development") {
        console.log("[createPlanAcademySchedules] í•™ì› ì¼ì • ì¬í™œìš© ì„±ê³µ", {
          dayOfWeek: schedule.day_of_week,
          startTime: schedule.start_time,
          endTime: schedule.end_time,
        });
      }
    }
  }

  // ìƒˆë¡œ ìƒì„±í•  í•™ì› ì¼ì •
  if (toInsert.length > 0) {
    // academy_nameë³„ë¡œ academyë¥¼ ì°¾ê±°ë‚˜ ìƒì„±
    const academyNameMap = new Map<string, string>();

    for (const schedule of toInsert) {
      const academyName = schedule.academy_name || "í•™ì›";
      
      if (!academyNameMap.has(academyName)) {
        const academyId = await getOrCreateAcademy(academyName);
        if (!academyId) {
          return { success: false, error: `í•™ì› ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${academyName}` };
        }
        academyNameMap.set(academyName, academyId);
      }
    }

    // academy_idì™€ plan_group_idë¥¼ í¬í•¨í•œ payload ìƒì„±
    const payload = toInsert.map((schedule) => {
      const academyName = schedule.academy_name || "í•™ì›";
      const academyId = academyNameMap.get(academyName);
      
      if (!academyId) {
        throw new Error(`í•™ì› IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${academyName}`);
      }

      return {
        tenant_id: tenantId,
        student_id: studentId,
        plan_group_id: groupId,
        academy_id: academyId,
        day_of_week: schedule.day_of_week,
        start_time: schedule.start_time,
        end_time: schedule.end_time,
        academy_name: schedule.academy_name || null,
        subject: schedule.subject || null,
      };
    });

    let { error } = await supabase.from("academy_schedules").insert(payload);

    if (error && error.code === "42703") {
      const fallbackPayload = payload.map(({ tenant_id: _tenantId, ...rest }) => rest);
      ({ error } = await supabase.from("academy_schedules").insert(fallbackPayload));
    }

    if (error) {
      logError(error, {
        function: "createPlanAcademySchedules",
        groupId,
        tenantId,
      });
      return { success: false, error: error.message };
    }

    if (process.env.NODE_ENV === "development") {
      console.log("[createPlanAcademySchedules] í•™ì› ì¼ì • ìƒì„± ì™„ë£Œ", { insertCount: toInsert.length });
    }
  }

  return { success: true };
}

/**
 * í•™ìƒë³„ í•™ì› ì¼ì • ì¼ê´„ ìƒì„± (ì „ì—­ ê´€ë¦¬)
 * @deprecated Phase 2 ì´í›„ createPlanAcademySchedules ì‚¬ìš© ê¶Œì¥
 * @param useAdminClient ê´€ë¦¬ì ëª¨ë“œì¼ ë•Œ trueë¡œ ì„¤ì • (RLS ìš°íšŒ)
 */
export async function createStudentAcademySchedules(
  studentId: string,
  tenantId: string,
  schedules: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string | null;
    subject?: string | null;
  }>,
  useAdminClient: boolean = false
): Promise<{ success: boolean; error?: string }> {
  // ê´€ë¦¬ì ëª¨ë“œì¼ ë•Œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
  let supabase;
  if (useAdminClient) {
    const { createSupabaseAdminClient } = await import("@/lib/supabase/admin");
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      if (process.env.NODE_ENV === "development") {
        console.warn("[createStudentAcademySchedules] Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ì–´ ì¼ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©");
      }
      supabase = await createSupabaseServerClient();
    } else {
      supabase = adminClient;
    }
  } else {
    supabase = await createSupabaseServerClient();
  }

  if (schedules.length === 0) {
    if (process.env.NODE_ENV === "development") {
      console.log("[createStudentAcademySchedules] í•™ì› ì¼ì •ì´ ì—†ìŠµë‹ˆë‹¤.");
    }
    return { success: true };
  }

  // ë””ë²„ê¹…: ì…ë ¥ëœ í•™ì› ì¼ì • í™•ì¸
  if (process.env.NODE_ENV === "development") {
    console.log("[createStudentAcademySchedules] ì…ë ¥ëœ í•™ì› ì¼ì •", {
      studentId,
      tenantId,
      schedulesCount: schedules.length,
    });
  }

  // ì¤‘ë³µ ì²´í¬: ê°™ì€ ìš”ì¼, ì‹œê°„ëŒ€ì˜ í•™ì› ì¼ì •ì´ ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
  const existingSchedules = await getStudentAcademySchedules(studentId, tenantId);
  const existingKeys = new Set(
    existingSchedules.map((s) => `${s.day_of_week}:${s.start_time}:${s.end_time}`)
  );

  // ë””ë²„ê¹…: ê¸°ì¡´ í•™ì› ì¼ì • í™•ì¸
  if (process.env.NODE_ENV === "development") {
    console.log("[createStudentAcademySchedules] ê¸°ì¡´ í•™ì› ì¼ì •", {
      existingSchedulesCount: existingSchedules.length,
    });
  }

  const newSchedules = schedules.filter(
    (s) => !existingKeys.has(`${s.day_of_week}:${s.start_time}:${s.end_time}`)
  );

  // ë””ë²„ê¹…: í•„í„°ë§ëœ ìƒˆ í•™ì› ì¼ì • í™•ì¸
  if (process.env.NODE_ENV === "development") {
    console.log("[createStudentAcademySchedules] í•„í„°ë§ëœ ìƒˆ í•™ì› ì¼ì •", {
      newSchedulesCount: newSchedules.length,
      skippedCount: schedules.length - newSchedules.length,
    });
  }

  if (newSchedules.length === 0) {
    if (process.env.NODE_ENV === "development") {
      console.log("[createStudentAcademySchedules] ëª¨ë“  í•™ì› ì¼ì •ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.");
    }
    return { success: true }; // ëª¨ë“  í•™ì› ì¼ì •ì´ ì´ë¯¸ ì¡´ì¬
  }

  // academy_nameë³„ë¡œ academyë¥¼ ì°¾ê±°ë‚˜ ìƒì„±
  const academyNameMap = new Map<string, string>(); // academy_name -> academy_id

  for (const schedule of newSchedules) {
    const academyName = schedule.academy_name || "í•™ì›";
    
    if (!academyNameMap.has(academyName)) {
      // ê¸°ì¡´ academy ì°¾ê¸°
      const { data: existingAcademy } = await supabase
        .from("academies")
        .select("id")
        .eq("student_id", studentId)
        .eq("name", academyName)
        .maybeSingle();

      let academyId: string;
      
      if (existingAcademy) {
        academyId = existingAcademy.id;
      } else {
        // ìƒˆ academy ìƒì„±
        const { data: newAcademy, error: academyError } = await supabase
          .from("academies")
          .insert({
            student_id: studentId,
            tenant_id: tenantId,
            name: academyName,
            travel_time: 60, // ê¸°ë³¸ê°’
          })
          .select("id")
          .single();

        if (academyError || !newAcademy) {
          logError(academyError || new Error("í•™ì› ìƒì„± ì‹¤íŒ¨"), {
            function: "createStudentAcademySchedules",
            studentId,
            tenantId,
            academyName,
            useAdminClient,
          });
          return { success: false, error: academyError?.message || "í•™ì› ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
        }

        academyId = newAcademy.id;
      }

      academyNameMap.set(academyName, academyId);
    }
  }

  // academy_idë¥¼ í¬í•¨í•œ payload ìƒì„±
  // ì£¼ì˜: ì´ í•¨ìˆ˜ëŠ” deprecatedë˜ì—ˆìœ¼ë©°, Phase 2 ì´í›„ plan_group_idê°€ í•„ìˆ˜ì…ë‹ˆë‹¤.
  // ì´ í•¨ìˆ˜ëŠ” ì‹œê°„ ê´€ë¦¬ ë©”ë‰´ì—ì„œë§Œ ì‚¬ìš©ë˜ë©°, ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ê¹Œì§€ë§Œ ìœ íš¨í•©ë‹ˆë‹¤.
  const payload = newSchedules.map((schedule) => {
    const academyName = schedule.academy_name || "í•™ì›";
    const academyId = academyNameMap.get(academyName);
    
    if (!academyId) {
      throw new Error(`í•™ì› IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${academyName}`);
    }

    return {
      tenant_id: tenantId,
      student_id: studentId,
      // plan_group_idëŠ” ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ NOT NULLì´ë¯€ë¡œ ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš© ë¶ˆê°€
      academy_id: academyId,
      day_of_week: schedule.day_of_week,
      start_time: schedule.start_time,
      end_time: schedule.end_time,
      academy_name: schedule.academy_name || null, // í•˜ìœ„ í˜¸í™˜ì„±
      subject: schedule.subject || null,
    };
  });

  let { error } = await supabase.from("academy_schedules").insert(payload);

  if (error && error.code === "42703") {
    const fallbackPayload = payload.map(({ tenant_id: _tenantId, ...rest }) => rest);
    ({ error } = await supabase.from("academy_schedules").insert(fallbackPayload));
  }

  if (error) {
    logError(error, {
      function: "createStudentAcademySchedules",
      studentId,
      tenantId,
    });
    return { success: false, error: error.message };
  }

  if (process.env.NODE_ENV === "development") {
    console.log("[createStudentAcademySchedules] í•™ì› ì¼ì • ì €ì¥ ì™„ë£Œ", { savedCount: payload.length });
  }

  return { success: true };
}

/**
 * ê´€ë¦¬ììš© í”Œëœ ê·¸ë£¹ ì¡°íšŒ (student_id ì—†ì´ ì¡°íšŒ)
 */
export async function getPlanGroupByIdForAdmin(
  groupId: string,
  tenantId: string
): Promise<PlanGroup | null> {
  const supabase = await createSupabaseServerClient();

  const selectGroup = () =>
    supabase
      .from("plan_groups")
      .select(
        "id,tenant_id,student_id,name,plan_purpose,scheduler_type,scheduler_options,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
      )
      .eq("id", groupId)
      .eq("tenant_id", tenantId)
      .is("deleted_at", null);

  let { data, error } = await selectGroup().maybeSingle<PlanGroup>();

  if (error && error.code === "42703") {
    // ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback
    const fallbackSelect = () =>
      supabase
        .from("plan_groups")
        .select(
          "id,tenant_id,student_id,name,plan_purpose,scheduler_type,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
        )
        .eq("id", groupId)
        .eq("tenant_id", tenantId)
        .is("deleted_at", null);

    ({ data, error } = await fallbackSelect().maybeSingle<PlanGroup>());

    if (data && !error) {
      data = { ...data, scheduler_options: null } as PlanGroup;
    }
  }

  if (error && error.code !== "PGRST116") {
    logError(error, {
      function: "getPlanGroupByIdForAdmin",
      groupId,
      tenantId,
    });
    return null;
  }

  return data ?? null;
}

/**
 * í”Œëœ ê·¸ë£¹ ì „ì²´ ì¡°íšŒ (ê´€ë ¨ ë°ì´í„° í¬í•¨)
 */
export async function getPlanGroupWithDetails(
  groupId: string,
  studentId: string,
  tenantId?: string | null
): Promise<{
  group: PlanGroup | null;
  contents: PlanContent[];
  exclusions: PlanExclusion[];
  academySchedules: AcademySchedule[];
}> {
  // í”Œëœ ê·¸ë£¹ë³„ ì œì™¸ì¼ê³¼ í•™ì› ì¼ì • ì¡°íšŒ
  // ê° ì¡°íšŒê°€ ì‹¤íŒ¨í•´ë„ ë‹¤ë¥¸ ë°ì´í„°ëŠ” ì •ìƒì ìœ¼ë¡œ ë°˜í™˜ë˜ë„ë¡ Promise.allSettled ì‚¬ìš©
  const [groupResult, contentsResult, exclusionsResult, academySchedulesResult] = await Promise.allSettled([
    getPlanGroupById(groupId, studentId, tenantId),
    getPlanContents(groupId, tenantId),
    getPlanExclusions(groupId, tenantId), // í”Œëœ ê·¸ë£¹ë³„ ì œì™¸ì¼
    getStudentAcademySchedules(studentId, tenantId), // í•™ì› ì¼ì •ì€ ì—¬ì „íˆ ì „ì—­ ê´€ë¦¬
  ]);

  // ê²°ê³¼ ì¶”ì¶œ (ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©)
  const group = groupResult.status === "fulfilled" ? groupResult.value : null;
  const contents = contentsResult.status === "fulfilled" ? contentsResult.value : [];
  const exclusions = exclusionsResult.status === "fulfilled" ? exclusionsResult.value : [];
  const academySchedules = academySchedulesResult.status === "fulfilled" ? academySchedulesResult.value : [];

  // ì‹¤íŒ¨í•œ ì¡°íšŒê°€ ìˆìœ¼ë©´ ë¡œê¹…
  if (contentsResult.status === "rejected") {
    logError(contentsResult.reason, {
      function: "getPlanGroupWithDetails",
      groupId,
      tenantId,
      level: "warn",
    });
  }
  if (exclusionsResult.status === "rejected") {
    logError(exclusionsResult.reason, {
      function: "getPlanGroupWithDetails",
      groupId,
      tenantId,
      level: "warn",
    });
  }
  if (academySchedulesResult.status === "rejected") {
    logError(academySchedulesResult.reason, {
      function: "getPlanGroupWithDetails",
      studentId,
      tenantId,
      level: "warn",
    });
  }

  return {
    group,
    contents,
    exclusions,
    academySchedules,
  };
}

/**
 * ê´€ë¦¬ììš© í”Œëœ ê·¸ë£¹ ì „ì²´ ì¡°íšŒ (ê´€ë ¨ ë°ì´í„° í¬í•¨)
 */
export async function getPlanGroupWithDetailsForAdmin(
  groupId: string,
  tenantId: string
): Promise<{
  group: PlanGroup | null;
  contents: PlanContent[];
  exclusions: PlanExclusion[];
  academySchedules: AcademySchedule[];
}> {
  const group = await getPlanGroupByIdForAdmin(groupId, tenantId);
  
  if (!group) {
    return {
      group: null,
      contents: [],
      exclusions: [],
      academySchedules: [],
    };
  }

  // ê´€ë¦¬ììš© í•™ì› ì¼ì • ì¡°íšŒ (RLS ìš°íšŒë¥¼ ìœ„í•´ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©)
  const getAcademySchedulesForAdmin = async (): Promise<AcademySchedule[]> => {
    let adminSchedulesData: AcademySchedule[] | null = null; // Declare adminSchedulesData here
    
    // 1. Service Role Keyë¡œ ì‹œë„ (RLS ìš°íšŒ)
    const { createSupabaseAdminClient } = await import("@/lib/supabase/admin");
    const adminClient = createSupabaseAdminClient();
    
    if (!adminClient) {
      // Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìœ¼ë©´ ì¼ë°˜ í•¨ìˆ˜ ì‚¬ìš© (fallback)
      if (process.env.NODE_ENV === "development") {
        console.warn("[getPlanGroupWithDetailsForAdmin] Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ì–´ ì¼ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©");
      }
      return getStudentAcademySchedules(group.student_id, tenantId);
    }

    // academiesì™€ ì¡°ì¸í•˜ì—¬ travel_time ê°€ì ¸ì˜¤ê¸°
    const selectSchedules = () =>
      adminClient
        .from("academy_schedules")
        .select(
          "id,tenant_id,student_id,academy_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at,academies(travel_time)"
        )
        .eq("student_id", group.student_id)
        .eq("tenant_id", tenantId)
        .order("day_of_week", { ascending: true })
        .order("start_time", { ascending: true });

    let { data, error } = await selectSchedules();
    adminSchedulesData = data as AcademySchedule[] | null;

    if (error && error.code === "42703") {
      // academy_idê°€ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ fallback
      const fallbackSelect = () =>
        adminClient
          .from("academy_schedules")
          .select(
            "id,tenant_id,student_id,day_of_week,start_time,end_time,academy_name,subject,created_at,updated_at"
          )
          .eq("student_id", group.student_id)
          .eq("tenant_id", tenantId)
          .order("day_of_week", { ascending: true })
          .order("start_time", { ascending: true });

      const fallbackResult = await fallbackSelect();
      error = fallbackResult.error;
      
      // academy_idë¥¼ nullë¡œ ì„¤ì •
      if (fallbackResult.data && !error) {
        adminSchedulesData = fallbackResult.data.map((schedule: any) => ({
            ...schedule,
            academy_id: schedule.academy_id || "", // Ensure string
            tenant_id: schedule.tenant_id || "", 
            academy_name: schedule.academy_name || null,
          })) as AcademySchedule[];
      }
    }

    if (error) {
      logError(error, {
        function: "getPlanGroupWithDetailsForAdmin",
        groupId,
        studentId: group.student_id,
        tenantId,
      });
      // ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ ë°˜í™˜
      return [];
    }

    // ë°ì´í„° ë³€í™˜: academies ê´€ê³„ ë°ì´í„°ë¥¼ travel_timeìœ¼ë¡œ ë³€í™˜
    type ScheduleWithAcademies = AcademySchedule & {
      academies?: { travel_time?: number } | null;
    };
    
    const schedules = (adminSchedulesData ?? []) as ScheduleWithAcademies[];
    const academySchedules = schedules.map((schedule) => ({
      ...schedule,
      travel_time: schedule.academies?.travel_time ?? 60, // ê¸°ë³¸ê°’ 60ë¶„
      academies: undefined, // ê´€ê³„ ë°ì´í„° ì œê±°
    })) as AcademySchedule[];

    if (process.env.NODE_ENV === "development") {
      console.log("[getPlanGroupWithDetailsForAdmin] ê´€ë¦¬ììš© í•™ì› ì¼ì • ì¡°íšŒ ì„±ê³µ", {
        groupId,
        studentId: group.student_id,
        tenantId,
        academySchedulesCount: academySchedules.length,
      });
    }

    return academySchedules;
  };

  // í”Œëœ ê·¸ë£¹ë³„ ì œì™¸ì¼ê³¼ í•™ì› ì¼ì • ì¡°íšŒ
  const [contents, exclusions, academySchedules] = await Promise.all([
    getPlanContents(groupId, tenantId),
    getPlanExclusions(groupId, tenantId),
    getAcademySchedulesForAdmin(),
  ]);

  return {
    group,
    contents,
    exclusions,
    academySchedules,
  };
}

/**
 * í”Œëœ ê·¸ë£¹ í†µê³„ ì •ë³´ íƒ€ì…
 */
export type PlanGroupStats = {
  planCount: number;
  completedCount: number;
  totalCount: number;
  isCompleted: boolean; // ì‹¤ì œ ì™„ë£Œ ìƒíƒœ
};

/**
 * í”Œëœ ê·¸ë£¹ê³¼ í†µê³„ ì •ë³´ë¥¼ í•¨ê»˜ ì¡°íšŒ
 */
export async function getPlanGroupsWithStats(
  filters: PlanGroupFilters
): Promise<Array<PlanGroup & PlanGroupStats>> {
  const supabase = await createSupabaseServerClient();
  
  // 1. í”Œëœ ê·¸ë£¹ ì¡°íšŒ
  const groups = await getPlanGroupsForStudent(filters);
  
  if (groups.length === 0) {
    return [];
  }

  const groupIds = groups.map((g) => g.id);
  const studentId = filters.studentId;

  // 2. í”Œëœ ê°œìˆ˜ ë° ì™„ë£Œ ìƒíƒœ ì¡°íšŒ (ë°°ì¹˜)
  const [planCountsResult, planCompletionResult] = await Promise.all([
    // í”Œëœ ê°œìˆ˜ ì¡°íšŒ
    supabase
      .from("student_plan")
      .select("plan_group_id")
      .eq("student_id", studentId)
      .in("plan_group_id", groupIds),
    // í”Œëœ ì™„ë£Œ ìƒíƒœ ì¡°íšŒ
    supabase
      .from("student_plan")
      .select(
        "plan_group_id, planned_end_page_or_time, completed_amount"
      )
      .eq("student_id", studentId)
      .in("plan_group_id", groupIds)
      .not("plan_group_id", "is", null),
  ]);

  // 3. í†µê³„ ê³„ì‚°
  const planCountsMap = new Map<string, number>();
  (planCountsResult.data || []).forEach((plan) => {
    if (plan.plan_group_id) {
      planCountsMap.set(
        plan.plan_group_id,
        (planCountsMap.get(plan.plan_group_id) || 0) + 1
      );
    }
  });

  const completionMap = new Map<
    string,
    { completedCount: number; totalCount: number; isCompleted: boolean }
  >();

  // plan_group_idë³„ë¡œ ê·¸ë£¹í™”
  const plansByGroup = new Map<
    string,
    Array<{ planned_end: number | null; completed: number | null }>
  >();

  (planCompletionResult.data || []).forEach((plan) => {
    if (plan.plan_group_id) {
      const groupPlans = plansByGroup.get(plan.plan_group_id) || [];
      groupPlans.push({
        planned_end: plan.planned_end_page_or_time ?? null,
        completed: plan.completed_amount ?? null,
      });
      plansByGroup.set(plan.plan_group_id, groupPlans);
    }
  });

  // ì™„ë£Œ ìƒíƒœ ê³„ì‚°
  plansByGroup.forEach((groupPlans, groupId) => {
    const totalCount = groupPlans.length;
    let completedCount = 0;

    groupPlans.forEach((plan) => {
      if (
        plan.planned_end !== null &&
        plan.completed !== null &&
        plan.completed >= plan.planned_end
      ) {
        completedCount++;
      }
    });

    const isCompleted =
      totalCount > 0 &&
      completedCount === totalCount &&
      groupPlans.every((plan) => {
        if (plan.planned_end === null) return false;
        return plan.completed !== null && plan.completed >= plan.planned_end;
      });

    completionMap.set(groupId, {
      completedCount,
      totalCount,
      isCompleted,
    });
  });

  // 4. ê²°ê³¼ ë³‘í•©
  return groups.map((group) => {
    const planCount = planCountsMap.get(group.id) || 0;
    const completion = completionMap.get(group.id) || {
      completedCount: 0,
      totalCount: planCount,
      isCompleted: false,
    };

    // ì™„ë£Œ ìƒíƒœ í‘œì‹œ (ì‹¤ì œ ì™„ë£Œë˜ì—ˆê³  í˜„ì¬ ìƒíƒœê°€ completedê°€ ì•„ë‹ˆë©´ í‘œì‹œìš©ìœ¼ë¡œ completed)
    let displayStatus = group.status;
    if (
      completion.isCompleted &&
      group.status !== "completed" &&
      group.status !== "cancelled"
    ) {
      displayStatus = "completed";
    }

    return {
      ...group,
      status: displayStatus as typeof group.status,
      planCount,
      completedCount: completion.completedCount,
      totalCount: completion.totalCount,
      isCompleted: completion.isCompleted,
    };
  });
}
</file>

<file path="schedulerSettings.ts">
/**
 * ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ë°ì´í„° ì¡°íšŒ í•¨ìˆ˜
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type {
  TenantSchedulerSettings,
  PartialSchedulerSettings,
  SchedulerSettings,
} from "@/lib/types/schedulerSettings";
import {
  mergeSchedulerSettings,
  dbToPartialSettings,
  planGroupOptionsToPartialSettings,
} from "@/lib/utils/schedulerSettingsMerge";

/**
 * ê¸°ê´€ë³„ ì „ì—­ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ì¡°íšŒ
 */
export async function getTenantSchedulerSettings(
  tenantId: string
): Promise<TenantSchedulerSettings | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("tenant_scheduler_settings")
    .select("*")
    .eq("tenant_id", tenantId)
    .maybeSingle();

  if (error) {
    console.error("Error fetching tenant scheduler settings:", error);
    return null;
  }

  return data;
}

/**
 * í…œí”Œë¦¿ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ì¡°íšŒ
 * camp_templates.template_data.scheduler_settingsì—ì„œ ì¶”ì¶œ
 */
export async function getTemplateSchedulerSettings(
  templateId: string
): Promise<PartialSchedulerSettings | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("camp_templates")
    .select("template_data")
    .eq("id", templateId)
    .maybeSingle();

  if (error) {
    console.error("Error fetching template scheduler settings:", error);
    return null;
  }

  if (!data?.template_data) {
    return null;
  }

  const templateData = data.template_data as {
    scheduler_settings?: PartialSchedulerSettings;
  };

  return templateData.scheduler_settings || null;
}

/**
 * ë³‘í•©ëœ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ì¡°íšŒ
 * ì „ì—­ â†’ í…œí”Œë¦¿ â†’ í”Œëœê·¸ë£¹ ìˆœìœ¼ë¡œ ë³‘í•©
 */
export async function getMergedSchedulerSettings(
  tenantId: string,
  templateId?: string | null,
  groupSettings?: Record<string, unknown> | null
): Promise<SchedulerSettings> {
  // 1. ì „ì—­ ì„¤ì • ì¡°íšŒ
  const tenantSettings = await getTenantSchedulerSettings(tenantId);
  const globalPartial = dbToPartialSettings(tenantSettings);

  // 2. í…œí”Œë¦¿ ì„¤ì • ì¡°íšŒ
  let templatePartial: PartialSchedulerSettings | null = null;
  if (templateId) {
    templatePartial = await getTemplateSchedulerSettings(templateId);
  }

  // 3. í”Œëœê·¸ë£¹ ì„¤ì • ë³€í™˜
  const groupPartial = planGroupOptionsToPartialSettings(
    groupSettings as {
      study_days?: number;
      review_days?: number;
      weak_subject_focus?: string | boolean;
      review_scope?: string;
      lunch_time?: { start: string; end: string };
      camp_study_hours?: { start: string; end: string };
      self_study_hours?: { start: string; end: string };
    } | null
  );

  // 4. ë³‘í•©
  return mergeSchedulerSettings(globalPartial, templatePartial, groupPartial);
}

/**
 * í”Œëœ ê·¸ë£¹ IDë¡œ ë³‘í•©ëœ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ì¡°íšŒ
 */
export async function getMergedSchedulerSettingsByGroupId(
  groupId: string
): Promise<SchedulerSettings | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("plan_groups")
    .select("tenant_id, camp_template_id, scheduler_options")
    .eq("id", groupId)
    .single();

  if (error) {
    console.error("Error fetching plan group for scheduler settings:", error);
    return null;
  }

  return getMergedSchedulerSettings(
    data.tenant_id,
    data.camp_template_id,
    data.scheduler_options as Record<string, unknown>
  );
}

/**
 * ì „ì—­ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸
 */
export async function upsertTenantSchedulerSettings(
  tenantId: string,
  settings: Partial<Omit<TenantSchedulerSettings, "id" | "tenant_id" | "created_at" | "updated_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("tenant_scheduler_settings")
    .upsert(
      {
        tenant_id: tenantId,
        ...settings,
        updated_at: new Date().toISOString(),
      },
      {
        onConflict: "tenant_id",
      }
    );

  if (error) {
    console.error("Error upserting tenant scheduler settings:", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í…œí”Œë¦¿ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ì—…ë°ì´íŠ¸
 */
export async function updateTemplateSchedulerSettings(
  templateId: string,
  schedulerSettings: PartialSchedulerSettings
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // ê¸°ì¡´ template_data ê°€ì ¸ì˜¤ê¸°
  const { data: existingData, error: fetchError } = await supabase
    .from("camp_templates")
    .select("template_data")
    .eq("id", templateId)
    .single();

  if (fetchError) {
    return { success: false, error: fetchError.message };
  }

  const templateData = (existingData.template_data || {}) as Record<
    string,
    unknown
  >;

  // scheduler_settings ì—…ë°ì´íŠ¸
  templateData.scheduler_settings = schedulerSettings;

  const { error: updateError } = await supabase
    .from("camp_templates")
    .update({ template_data: templateData })
    .eq("id", templateId);

  if (updateError) {
    return { success: false, error: updateError.message };
  }

  return { success: true };
}
</file>

<file path="schools.ts">
/**
 * í•™êµ ë°ì´í„° ì¡°íšŒ í•¨ìˆ˜
 *
 * ìƒˆ í…Œì´ë¸” êµ¬ì¡°:
 * - school_info: ì¤‘Â·ê³ ë“±í•™êµ
 * - universities: ëŒ€í•™êµ
 * - university_campuses: ëŒ€í•™êµ ìº í¼ìŠ¤
 * - all_schools_view: í†µí•© ì¡°íšŒ VIEW
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type {
  SchoolType,
  SchoolTypeKor,
  SchoolInfo,
  University,
  UniversityCampus,
  UniversityWithCampus,
  AllSchoolsView,
  SchoolSimple,
  SearchSchoolsOptions,
  GetSchoolsOptions,
  Region,
  SCHOOL_TYPE_MAP,
  SCHOOL_TYPE_REVERSE_MAP,
  parseSchoolId,
} from "@/lib/domains/school/types";

// Re-export types for convenience
export type {
  SchoolType,
  SchoolTypeKor,
  SchoolInfo,
  University,
  UniversityCampus,
  UniversityWithCampus,
  AllSchoolsView,
  SchoolSimple,
  Region,
};

// ============================================
// í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ íƒ€ì… (Deprecated)
// ============================================

/**
 * @deprecated ìƒˆ íƒ€ì… AllSchoolsView ë˜ëŠ” SchoolSimple ì‚¬ìš©
 */
export type School = {
  id: string;
  name: string;
  type: SchoolTypeKor;
  region: string | null;
  region_id?: string | null;
  address?: string | null;
  postal_code?: string | null;
  address_detail?: string | null;
  city?: string | null;
  district?: string | null;
  phone?: string | null;
  category?: string | null;
  university_type?: string | null;
  university_ownership?: string | null;
  campus_name?: string | null;
  display_order?: number;
  is_active?: boolean;
  created_at?: string;
  updated_at?: string;
};

// ============================================
// Region ì¡°íšŒ í•¨ìˆ˜
// ============================================

/**
 * ì§€ì—­ ëª©ë¡ ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 */
export async function getRegions(): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/schools] ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Region[] | null) ?? [];
}

/**
 * ìƒìœ„ ì§€ì—­ë³„ í•˜ìœ„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByParent(parentId: string): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("parent_id", parentId)
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/schools] í•˜ìœ„ ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Region[] | null) ?? [];
}

/**
 * ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByLevel(level: 1 | 2 | 3): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("level", level)
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/schools] ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Region[] | null) ?? [];
}

// ============================================
// í†µí•© í•™êµ ì¡°íšŒ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ)
// ============================================

/**
 * í†µí•© í•™êµ ëª©ë¡ ì¡°íšŒ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ í›„ í•©ì¹˜ê¸°)
 */
export async function getAllSchools(options?: GetSchoolsOptions): Promise<AllSchoolsView[]> {
  const supabase = await createSupabaseServerClient();
  const results: AllSchoolsView[] = [];

  try {
    // ì¤‘í•™êµ/ê³ ë“±í•™êµ ì¡°íšŒ
    if (!options?.schoolType || options.schoolType === "MIDDLE" || options.schoolType === "HIGH") {
      let schoolInfoQuery = supabase
        .from("school_info")
        .select("*")
        .eq("closed_flag", "N");

      if (options?.schoolType === "MIDDLE") {
        schoolInfoQuery = schoolInfoQuery.eq("school_level", "ì¤‘");
      } else if (options?.schoolType === "HIGH") {
        schoolInfoQuery = schoolInfoQuery.eq("school_level", "ê³ ");
      }

      if (options?.region) {
        schoolInfoQuery = schoolInfoQuery.ilike("region", `%${options.region}%`);
      }

      const limit = options?.limit ? Math.floor(options.limit / 2) : 500;
      const { data: schoolInfoData, error: schoolInfoError } = await schoolInfoQuery
        .limit(limit)
        .order("school_name", { ascending: true });

      if (!schoolInfoError && schoolInfoData) {
        for (const si of schoolInfoData) {
          results.push({
            id: `SCHOOL_${si.id}`,
            school_type: si.school_level === "ì¤‘" ? "MIDDLE" : "HIGH",
            name: si.school_name,
            code: si.school_code,
            region: si.region,
            address: si.address_full,
            postal_code: si.postal_code,
            phone: si.phone_number,
            website: si.homepage_url,
            establishment_type: si.establishment_type,
            campus_name: null,
            university_type: null,
            source_table: "school_info",
            source_id: si.id,
            latitude: si.latitude,
            longitude: si.longitude,
            created_at: si.created_at,
          });
        }
      }
    }

    // ëŒ€í•™êµ ì¡°íšŒ
    if (!options?.schoolType || options.schoolType === "UNIVERSITY") {
      let campusQuery = supabase
        .from("university_campuses")
        .select(`
          *,
          university:universities(*)
        `)
        .eq("campus_status", "ê¸°ì¡´");

      if (options?.region) {
        campusQuery = campusQuery.ilike("region", `%${options.region}%`);
      }

      const limit = options?.limit ? Math.floor(options.limit / 2) : 500;
      const { data: campusData, error: campusError } = await campusQuery
        .limit(limit)
        .order("campus_name", { ascending: true });

      if (!campusError && campusData) {
        for (const uc of campusData) {
          const university = uc.university as any;
          const campusName = uc.campus_name;
          const universityName = university?.name_kor || campusName;
          
          results.push({
            id: `UNIV_${uc.id}`,
            school_type: "UNIVERSITY",
            name: campusName === universityName 
              ? universityName 
              : `${universityName} (${uc.campus_type || ""})`,
            code: university?.university_code || null,
            region: uc.region,
            address: uc.address_kor,
            postal_code: uc.postal_code,
            phone: uc.phone_number,
            website: university?.homepage_url || null,
            establishment_type: university?.establishment_type || null,
            campus_name: campusName,
            university_type: university?.university_type || null,
            source_table: "university_campuses",
            source_id: uc.id,
            latitude: null,
            longitude: null,
            created_at: uc.created_at,
          });
        }
      }
    }

    // ì´ë¦„ìˆœ ì •ë ¬
    results.sort((a, b) => a.name.localeCompare(b.name, "ko"));

    // limit ì ìš©
    if (options?.limit) {
      return results.slice(0, options.limit);
    }

    return results;
  } catch (error) {
    console.error("[data/schools] í†µí•© í•™êµ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

/**
 * í†µí•© í•™êµ ê²€ìƒ‰
 */
export async function searchAllSchools(options: SearchSchoolsOptions): Promise<SchoolSimple[]> {
  const supabase = await createSupabaseServerClient();
  const results: SchoolSimple[] = [];

  try {
    const query = options.query?.trim() || "";

    // ì¤‘í•™êµ/ê³ ë“±í•™êµ ê²€ìƒ‰
    if (!options.schoolType || options.schoolType === "MIDDLE" || options.schoolType === "HIGH") {
      let schoolInfoQuery = supabase
        .from("school_info")
        .select("id, school_name, school_level, region, school_code")
        .eq("closed_flag", "N");

      if (options.schoolType === "MIDDLE") {
        schoolInfoQuery = schoolInfoQuery.eq("school_level", "ì¤‘");
      } else if (options.schoolType === "HIGH") {
        schoolInfoQuery = schoolInfoQuery.eq("school_level", "ê³ ");
      }

      if (query) {
        schoolInfoQuery = schoolInfoQuery.ilike("school_name", `%${query}%`);
      }

      if (options.region) {
        schoolInfoQuery = schoolInfoQuery.ilike("region", `%${options.region}%`);
      }

      const limit = options.limit ? Math.floor(options.limit / 2) : 25;
      const { data: schoolInfoData, error: schoolInfoError } = await schoolInfoQuery
        .limit(limit)
        .order("school_name", { ascending: true });

      if (!schoolInfoError && schoolInfoData) {
        for (const si of schoolInfoData) {
          results.push({
            id: `SCHOOL_${si.id}`,
            name: si.school_name,
            schoolType: si.school_level === "ì¤‘" ? "MIDDLE" : "HIGH",
            region: si.region,
            sourceTable: "school_info",
            sourceId: si.id,
          });
        }
      }
    }

    // ëŒ€í•™êµ ê²€ìƒ‰
    if (!options.schoolType || options.schoolType === "UNIVERSITY") {
      const limit = options.limit ? Math.floor(options.limit / 2) : 25;
      
      if (query) {
        // ê²€ìƒ‰ì–´ê°€ ìˆì„ ë•Œ: ë‘ ê°œì˜ ì¿¼ë¦¬ë¡œ ë‚˜ëˆ„ì–´ ê²€ìƒ‰
        // 1. ìº í¼ìŠ¤ëª…ìœ¼ë¡œ ê²€ìƒ‰
        let campusNameQuery = supabase
          .from("university_campuses")
          .select(`
            id,
            campus_name,
            region,
            campus_type,
            university:universities!inner(university_code, name_kor)
          `)
          .eq("campus_status", "ê¸°ì¡´")
          .ilike("campus_name", `%${query}%`);

        if (options.region) {
          campusNameQuery = campusNameQuery.ilike("region", `%${options.region}%`);
        }

        const { data: campusNameData, error: campusNameError } = await campusNameQuery
          .limit(limit)
          .order("campus_name", { ascending: true });

        // 2. ëŒ€í•™ëª…ìœ¼ë¡œ ê²€ìƒ‰: universities í…Œì´ë¸”ì—ì„œ ë¨¼ì € ê²€ìƒ‰ í›„ university_campuses ì¡°íšŒ
        const { data: universitiesData, error: universitiesError } = await supabase
          .from("universities")
          .select("id")
          .ilike("name_kor", `%${query}%`)
          .limit(limit);

        let universityNameData: any[] = [];
        if (!universitiesError && universitiesData && universitiesData.length > 0) {
          const universityIds = universitiesData.map(u => u.id);
          
          let universityCampusQuery = supabase
            .from("university_campuses")
            .select(`
              id,
              campus_name,
              region,
              campus_type,
              university:universities!inner(university_code, name_kor)
            `)
            .eq("campus_status", "ê¸°ì¡´")
            .in("university_id", universityIds);

          if (options.region) {
            universityCampusQuery = universityCampusQuery.ilike("region", `%${options.region}%`);
          }

          const { data: campusData, error: campusError } = await universityCampusQuery
            .limit(limit)
            .order("campus_name", { ascending: true });

          if (!campusError && campusData) {
            universityNameData = campusData;
          }
        }

        // ê²°ê³¼ í•©ì¹˜ê¸° (ì¤‘ë³µ ì œê±°)
        const allCampusData: any[] = [];
        const seenIds = new Set<number>();

        if (!campusNameError && campusNameData) {
          for (const uc of campusNameData) {
            if (!seenIds.has(uc.id)) {
              seenIds.add(uc.id);
              allCampusData.push(uc);
            }
          }
        }

        for (const uc of universityNameData) {
          if (!seenIds.has(uc.id)) {
            seenIds.add(uc.id);
            allCampusData.push(uc);
          }
        }

        // ê²°ê³¼ ë³€í™˜
        for (const uc of allCampusData.slice(0, limit)) {
          const university = uc.university as any;
          const campusName = uc.campus_name;
          const universityName = university?.name_kor || campusName;
          
          // ìº í¼ìŠ¤ëª…ì´ ëŒ€í•™ëª…ê³¼ ê°™ìœ¼ë©´ ëŒ€í•™ëª…ë§Œ, ë‹¤ë¥´ë©´ "ëŒ€í•™ëª… (ìº í¼ìŠ¤ëª…)" í˜•ì‹
          const displayName = campusName === universityName
            ? universityName
            : `${universityName} (${uc.campus_type || ""})`;
          
          results.push({
            id: `UNIV_${uc.id}`,
            name: displayName,
            schoolType: "UNIVERSITY",
            region: uc.region,
            sourceTable: "university_campuses",
            sourceId: uc.id,
          });
        }
      } else {
        // ê²€ìƒ‰ì–´ê°€ ì—†ì„ ë•Œ: ì „ì²´ ì¡°íšŒ
        let campusQuery = supabase
          .from("university_campuses")
          .select(`
            id,
            campus_name,
            region,
            campus_type,
            university:universities!inner(university_code, name_kor)
          `)
          .eq("campus_status", "ê¸°ì¡´");

        if (options.region) {
          campusQuery = campusQuery.ilike("region", `%${options.region}%`);
        }

        const { data: campusData, error: campusError } = await campusQuery
          .limit(limit)
          .order("campus_name", { ascending: true });

        if (!campusError && campusData) {
          for (const uc of campusData) {
            const university = uc.university as any;
            const campusName = uc.campus_name;
            const universityName = university?.name_kor || campusName;
            
            // ìº í¼ìŠ¤ëª…ì´ ëŒ€í•™ëª…ê³¼ ê°™ìœ¼ë©´ ëŒ€í•™ëª…ë§Œ, ë‹¤ë¥´ë©´ "ëŒ€í•™ëª… (ìº í¼ìŠ¤ëª…)" í˜•ì‹
            const displayName = campusName === universityName
              ? universityName
              : `${universityName} (${uc.campus_type || ""})`;
            
            results.push({
              id: `UNIV_${uc.id}`,
              name: displayName,
              schoolType: "UNIVERSITY",
              region: uc.region,
              sourceTable: "university_campuses",
              sourceId: uc.id,
            });
          }
        }
      }
    }

    // ì´ë¦„ìˆœ ì •ë ¬
    results.sort((a, b) => a.name.localeCompare(b.name, "ko"));

    // limit ì ìš©
    if (options.limit) {
      return results.slice(0, options.limit);
    }

    return results;
  } catch (error) {
    console.error("[data/schools] í•™êµ ê²€ìƒ‰ ì‹¤íŒ¨", error);
    return [];
  }
}

/**
 * í†µí•© í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function getSchoolByUnifiedId(unifiedId: string): Promise<AllSchoolsView | null> {
  const supabase = await createSupabaseServerClient();

  try {
    // ID í˜•ì‹ íŒŒì‹±
    if (unifiedId.startsWith("SCHOOL_")) {
      const sourceId = parseInt(unifiedId.replace("SCHOOL_", ""), 10);
      if (isNaN(sourceId)) return null;

      const { data, error } = await supabase
        .from("school_info")
        .select("*")
        .eq("id", sourceId)
        .maybeSingle();

      if (error || !data) return null;

      return {
        id: `SCHOOL_${data.id}`,
        school_type: data.school_level === "ì¤‘" ? "MIDDLE" : "HIGH",
        name: data.school_name,
        code: data.school_code,
        region: data.region,
        address: data.address_full,
        postal_code: data.postal_code,
        phone: data.phone_number,
        website: data.homepage_url,
        establishment_type: data.establishment_type,
        campus_name: null,
        university_type: null,
        source_table: "school_info",
        source_id: data.id,
        latitude: data.latitude,
        longitude: data.longitude,
        created_at: data.created_at,
      };
    } else if (unifiedId.startsWith("UNIV_")) {
      const sourceId = parseInt(unifiedId.replace("UNIV_", ""), 10);
      if (isNaN(sourceId)) return null;

      const { data, error } = await supabase
        .from("university_campuses")
        .select(`
          *,
          university:universities(*)
        `)
        .eq("id", sourceId)
        .maybeSingle();

      if (error || !data) return null;

      const university = data.university as any;
      const campusName = data.campus_name;
      const universityName = university?.name_kor || campusName;

      return {
        id: `UNIV_${data.id}`,
        school_type: "UNIVERSITY",
        name: campusName === universityName
          ? universityName
          : `${universityName} (${data.campus_type || ""})`,
        code: university?.university_code || null,
        region: data.region,
        address: data.address_kor,
        postal_code: data.postal_code,
        phone: data.phone_number,
        website: university?.homepage_url || null,
        establishment_type: university?.establishment_type || null,
        campus_name: campusName,
        university_type: university?.university_type || null,
        source_table: "university_campuses",
        source_id: data.id,
        latitude: null,
        longitude: null,
        created_at: data.created_at,
      };
    }

    return null;
  } catch (error) {
    console.error("[data/schools] í†µí•© í•™êµ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

// ============================================
// ì¤‘Â·ê³ ë“±í•™êµ ì¡°íšŒ (school_info)
// ============================================

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getSchoolInfoList(options?: {
  schoolLevel?: "ì¤‘" | "ê³ ";
  region?: string;
  limit?: number;
}): Promise<SchoolInfo[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("school_info")
    .select("*")
    .eq("closed_flag", "N");

  if (options?.schoolLevel) {
    query = query.eq("school_level", options.schoolLevel);
  }

  if (options?.region) {
    query = query.ilike("region", `%${options.region}%`);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("school_name", { ascending: true });

  if (error) {
    console.error("[data/schools] ì¤‘Â·ê³ ë“±í•™êµ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as SchoolInfo[]) ?? [];
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function getSchoolInfoById(id: number): Promise<SchoolInfo | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("school_info")
    .select("*")
    .eq("id", id)
    .maybeSingle();

  if (error) {
    console.error("[data/schools] ì¤‘Â·ê³ ë“±í•™êµ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data as SchoolInfo | null;
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ê²€ìƒ‰
 */
export async function searchSchoolInfo(
  query: string,
  schoolLevel?: "ì¤‘" | "ê³ ",
  limit = 50
): Promise<SchoolInfo[]> {
  const supabase = await createSupabaseServerClient();

  let dbQuery = supabase
    .from("school_info")
    .select("*")
    .eq("closed_flag", "N")
    .ilike("school_name", `%${query}%`);

  if (schoolLevel) {
    dbQuery = dbQuery.eq("school_level", schoolLevel);
  }

  const { data, error } = await dbQuery
    .limit(limit)
    .order("school_name", { ascending: true });

  if (error) {
    console.error("[data/schools] ì¤‘Â·ê³ ë“±í•™êµ ê²€ìƒ‰ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as SchoolInfo[]) ?? [];
}

// ============================================
// ëŒ€í•™êµ ì¡°íšŒ (universities, university_campuses)
// ============================================

/**
 * ëŒ€í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getUniversities(options?: {
  establishmentType?: string;
  universityType?: string;
  limit?: number;
}): Promise<University[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase.from("universities").select("*");

  if (options?.establishmentType) {
    query = query.eq("establishment_type", options.establishmentType);
  }

  if (options?.universityType) {
    query = query.eq("university_type", options.universityType);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("name_kor", { ascending: true });

  if (error) {
    console.error("[data/schools] ëŒ€í•™êµ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as University[]) ?? [];
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ ëª©ë¡ ì¡°íšŒ
 */
export async function getUniversityCampuses(options?: {
  universityId?: number;
  region?: string;
  limit?: number;
}): Promise<UniversityWithCampus[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities(*)
    `)
    .eq("campus_status", "ê¸°ì¡´");

  if (options?.universityId) {
    query = query.eq("university_id", options.universityId);
  }

  if (options?.region) {
    query = query.ilike("region", `%${options.region}%`);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("campus_name", { ascending: true });

  if (error) {
    console.error("[data/schools] ëŒ€í•™êµ ìº í¼ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as UniversityWithCampus[]) ?? [];
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ IDë¡œ ì¡°íšŒ
 */
export async function getUniversityCampusById(id: number): Promise<UniversityWithCampus | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities(*)
    `)
    .eq("id", id)
    .maybeSingle();

  if (error) {
    console.error("[data/schools] ëŒ€í•™êµ ìº í¼ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data as UniversityWithCampus | null;
}

/**
 * ëŒ€í•™êµ/ìº í¼ìŠ¤ ê²€ìƒ‰
 */
export async function searchUniversityCampuses(
  query: string,
  limit = 50
): Promise<UniversityWithCampus[]> {
  const supabase = await createSupabaseServerClient();

  // 1. ìº í¼ìŠ¤ëª…ìœ¼ë¡œ ê²€ìƒ‰
  const { data: campusNameData, error: campusNameError } = await supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities!inner(*)
    `)
    .eq("campus_status", "ê¸°ì¡´")
    .ilike("campus_name", `%${query}%`)
    .limit(limit)
    .order("campus_name", { ascending: true });

  // 2. ëŒ€í•™ëª…ìœ¼ë¡œ ê²€ìƒ‰: universities í…Œì´ë¸”ì—ì„œ ë¨¼ì € ê²€ìƒ‰ í›„ university_campuses ì¡°íšŒ
  const { data: universitiesData, error: universitiesError } = await supabase
    .from("universities")
    .select("id")
    .ilike("name_kor", `%${query}%`)
    .limit(limit);

  let universityNameData: any[] = [];
  if (!universitiesError && universitiesData && universitiesData.length > 0) {
    const universityIds = universitiesData.map(u => u.id);
    
    const { data: campusData, error: campusError } = await supabase
      .from("university_campuses")
      .select(`
        *,
        university:universities!inner(*)
      `)
      .eq("campus_status", "ê¸°ì¡´")
      .in("university_id", universityIds)
      .limit(limit)
      .order("campus_name", { ascending: true });

    if (!campusError && campusData) {
      universityNameData = campusData;
    }
  }

  // ê²°ê³¼ í•©ì¹˜ê¸° (ì¤‘ë³µ ì œê±°)
  const allCampusData: any[] = [];
  const seenIds = new Set<number>();

  if (!campusNameError && campusNameData) {
    for (const uc of campusNameData) {
      if (!seenIds.has(uc.id)) {
        seenIds.add(uc.id);
        allCampusData.push(uc);
      }
    }
  }

  for (const uc of universityNameData) {
    if (!seenIds.has(uc.id)) {
      seenIds.add(uc.id);
      allCampusData.push(uc);
    }
  }

  return (allCampusData.slice(0, limit) as UniversityWithCampus[]) ?? [];
}

// ============================================
// í•˜ìœ„ í˜¸í™˜ì„± í•¨ìˆ˜ (Deprecated)
// ============================================

const SCHOOL_TYPE_MAP_INTERNAL: Record<SchoolType, SchoolTypeKor> = {
  MIDDLE: "ì¤‘í•™êµ",
  HIGH: "ê³ ë“±í•™êµ",
  UNIVERSITY: "ëŒ€í•™êµ",
};

const SCHOOL_TYPE_REVERSE_MAP_INTERNAL: Record<SchoolTypeKor, SchoolType> = {
  "ì¤‘í•™êµ": "MIDDLE",
  "ê³ ë“±í•™êµ": "HIGH",
  "ëŒ€í•™êµ": "UNIVERSITY",
};

/**
 * @deprecated ìƒˆ í•¨ìˆ˜ getAllSchools ì‚¬ìš©
 * ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•œ í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getSchools(options?: {
  regionId?: string;
  type?: SchoolTypeKor;
  includeInactive?: boolean;
}): Promise<School[]> {
  const schoolType = options?.type ? SCHOOL_TYPE_REVERSE_MAP_INTERNAL[options.type] : undefined;
  
  const allSchools = await getAllSchools({
    schoolType,
    limit: 1000,
  });

  return allSchools.map((s) => ({
    id: s.id,
    name: s.name,
    type: SCHOOL_TYPE_MAP_INTERNAL[s.school_type],
    region: s.region,
    region_id: null,
    address: s.address,
    postal_code: s.postal_code,
    phone: s.phone,
    campus_name: s.campus_name,
    university_type: s.university_type,
    display_order: 0,
    is_active: true,
    created_at: s.created_at,
  }));
}

/**
 * @deprecated ìƒˆ í•¨ìˆ˜ getSchoolByUnifiedId ì‚¬ìš©
 * ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•œ í•™êµ ìƒì„¸ ì¡°íšŒ
 */
export async function getSchoolById(schoolId: string): Promise<School | null> {
  const school = await getSchoolByUnifiedId(schoolId);
  
  if (!school) return null;

  return {
    id: school.id,
    name: school.name,
    type: SCHOOL_TYPE_MAP_INTERNAL[school.school_type],
    region: school.region,
    address: school.address,
    postal_code: school.postal_code,
    phone: school.phone,
    campus_name: school.campus_name,
    university_type: school.university_type,
  };
}

/**
 * @deprecated ìƒˆ í•¨ìˆ˜ searchAllSchools ì‚¬ìš©
 * ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•œ í•™êµëª… ì¡°íšŒ
 */
export async function getSchoolByName(
  name: string,
  type?: SchoolTypeKor
): Promise<School | null> {
  const schoolType = type ? SCHOOL_TYPE_REVERSE_MAP_INTERNAL[type] : undefined;
  
  const results = await searchAllSchools({
    query: name,
    schoolType,
    limit: 1,
  });

  if (results.length === 0) return null;

  const school = await getSchoolByUnifiedId(results[0].id);
  if (!school) return null;

  return {
    id: school.id,
    name: school.name,
    type: SCHOOL_TYPE_MAP_INTERNAL[school.school_type],
    region: school.region,
    address: school.address,
    postal_code: school.postal_code,
    phone: school.phone,
    campus_name: school.campus_name,
    university_type: school.university_type,
  };
}

/**
 * @deprecated í†µí•© í…Œì´ë¸”ì—ì„œëŠ” ì¤‘ë³µ í™•ì¸ì´ ë¶ˆí•„ìš”
 * ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„ ìœ„í•œ í•™êµ ì¤‘ë³µ í™•ì¸
 */
export async function checkSchoolDuplicate(
  name: string,
  type: SchoolTypeKor,
  regionId?: string | null,
  campusName?: string | null,
  excludeId?: string
): Promise<School | null> {
  // ìƒˆ í…Œì´ë¸” êµ¬ì¡°ì—ì„œëŠ” ì½ê¸° ì „ìš©ì´ë¯€ë¡œ í•­ìƒ null ë°˜í™˜
  console.warn("[data/schools] checkSchoolDuplicateëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
  return null;
}
</file>

<file path="scoreDetails.ts">
/**
 * ì„±ì  ìƒì„¸ ë°ì´í„° í˜ì¹­ í•¨ìˆ˜
 * 
 * ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì˜ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { Tables } from "@/lib/supabase/database.types";
import { handleQueryError } from "@/lib/data/core/errorHandler";

type InternalScore = Tables<"student_internal_scores">;
type MockScore = Tables<"student_mock_scores">;

/**
 * í•™ê¸°ë³„ ë‚´ì‹  ì„±ì  ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param grade - í•™ë…„ (ì„ íƒì‚¬í•­)
 * @param semester - í•™ê¸° (ì„ íƒì‚¬í•­)
 * @returns ë‚´ì‹  ì„±ì  ë°°ì—´
 */
export async function getInternalScoresByTerm(
  studentId: string,
  tenantId: string,
  grade?: number,
  semester?: number
): Promise<(InternalScore & {
  subject_group?: { name: string } | null;
  subject?: { name: string } | null;
  subject_type?: { name: string } | null;
})[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_internal_scores")
    .select(`
      *,
      subject_group:subject_groups(name),
      subject:subjects(name),
      subject_type:subject_types(name)
    `)
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId);

  if (grade !== undefined) {
    query = query.eq("grade", grade);
  }

  if (semester !== undefined) {
    query = query.eq("semester", semester);
  }

  const { data, error } = await query.order("grade", { ascending: true })
    .order("semester", { ascending: true })
    .order("created_at", { ascending: true });

  if (handleQueryError(error, {
    context: "[data/scoreDetails] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨",
    logError: true,
  })) {
    // ì—ëŸ¬ ìƒì„¸ ì •ë³´ ì¶”ê°€ ë¡œê¹…
    if (error) {
      const errorDetails: Record<string, unknown> = {
        studentId,
        tenantId,
        grade,
        semester,
      };
      
      // ì—ëŸ¬ ì •ë³´ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
      if (error.message) errorDetails.errorMessage = error.message;
      if (error.code) errorDetails.errorCode = error.code;
      if ("details" in error && error.details) errorDetails.errorDetails = error.details;
      if ("hint" in error && error.hint) errorDetails.errorHint = error.hint;
      if ("statusCode" in error) {
        errorDetails.errorStatusCode = (error as { statusCode?: unknown }).statusCode;
      }
      
      // JSON ì§ë ¬í™” ì‹œë„
      try {
        errorDetails.errorString = JSON.stringify(error, Object.getOwnPropertyNames(error));
      } catch (e) {
        errorDetails.errorString = String(error);
      }
      
      console.error("[data/scoreDetails] ë‚´ì‹  ì„±ì  ì¡°íšŒ ìƒì„¸ ì •ë³´", errorDetails);
    }
    return [];
  }

  return (data as any[]) || [];
}

/**
 * ê¸°ê°„ë³„ ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param startDate - ì‹œì‘ì¼ (YYYY-MM-DD, ì„ íƒì‚¬í•­)
 * @param endDate - ì¢…ë£Œì¼ (YYYY-MM-DD, ì„ íƒì‚¬í•­)
 * @param grade - í•™ë…„ (ì„ íƒì‚¬í•­)
 * @returns ëª¨ì˜ê³ ì‚¬ ì„±ì  ë°°ì—´
 */
export async function getMockScoresByPeriod(
  studentId: string,
  tenantId: string,
  startDate?: string,
  endDate?: string,
  grade?: number
): Promise<(MockScore & {
  subject_group?: { name: string } | null;
  subject?: { name: string } | null;
})[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_mock_scores")
    .select(`
      *,
      subject_group:subject_groups(name),
      subject:subjects(name)
    `)
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId);

  if (startDate) {
    query = query.gte("exam_date", startDate);
  }

  if (endDate) {
    query = query.lte("exam_date", endDate);
  }

  if (grade !== undefined) {
    query = query.eq("grade", grade);
  }

  const { data, error } = await query.order("exam_date", { ascending: false })
    .order("created_at", { ascending: false });

  if (handleQueryError(error, {
    context: "[data/scoreDetails] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨",
    logError: true,
  })) {
    // ì—ëŸ¬ ìƒì„¸ ì •ë³´ ì¶”ê°€ ë¡œê¹…
    if (error) {
      const errorDetails: Record<string, unknown> = {
        studentId,
        tenantId,
        startDate,
        endDate,
        grade,
      };
      
      // ì—ëŸ¬ ì •ë³´ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
      if (error.message) errorDetails.errorMessage = error.message;
      if (error.code) errorDetails.errorCode = error.code;
      if ("details" in error && error.details) errorDetails.errorDetails = error.details;
      if ("hint" in error && error.hint) errorDetails.errorHint = error.hint;
      if ("statusCode" in error) {
        errorDetails.errorStatusCode = (error as { statusCode?: unknown }).statusCode;
      }
      
      // JSON ì§ë ¬í™” ì‹œë„
      try {
        errorDetails.errorString = JSON.stringify(error, Object.getOwnPropertyNames(error));
      } catch (e) {
        errorDetails.errorString = String(error);
      }
      
      console.error("[data/scoreDetails] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ìƒì„¸ ì •ë³´", errorDetails);
    }
    return [];
  }

  return (data as any[]) || [];
}

/**
 * ìµœê·¼ Nê°œì˜ ëª¨ì˜ê³ ì‚¬ ì‹œí—˜ ëª©ë¡ ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param limit - ì¡°íšŒí•  ì‹œí—˜ ê°œìˆ˜ (ê¸°ë³¸ê°’: 3)
 * @returns ì‹œí—˜ ëª©ë¡ (ì‹œí—˜ì¼, ì‹œí—˜ëª…, í•™ë…„)
 */
export async function getRecentMockExams(
  studentId: string,
  tenantId: string,
  limit: number = 3
): Promise<Array<{
  exam_date: string;
  exam_title: string;
  grade: number;
}>> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_mock_scores")
    .select("exam_date, exam_title, grade")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId)
    .order("exam_date", { ascending: false })
    .limit(limit);

  if (handleQueryError(error, {
    context: "[data/scoreDetails] ìµœê·¼ ëª¨ì˜ê³ ì‚¬ ì‹œí—˜ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨",
    logError: true,
  })) {
    return [];
  }

  // ì¤‘ë³µ ì œê±° (ê°™ì€ ì‹œí—˜ì¼, ì‹œí—˜ëª…, í•™ë…„)
  const uniqueExams = Array.from(
    new Map(
      (data || []).map((exam) => [
        `${exam.exam_date}-${exam.exam_title}-${exam.grade}`,
        exam,
      ])
    ).values()
  );

  return uniqueExams;
}

/**
 * íŠ¹ì • ì‹œí—˜ì˜ ê³¼ëª©ë³„ ì„±ì  ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param examDate - ì‹œí—˜ì¼
 * @param examTitle - ì‹œí—˜ëª…
 * @returns ê³¼ëª©ë³„ ì„±ì  ë°°ì—´
 */
export async function getMockScoresByExam(
  studentId: string,
  tenantId: string,
  examDate: string,
  examTitle: string
): Promise<(MockScore & {
  subject_group?: { name: string } | null;
  subject?: { name: string } | null;
})[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_mock_scores")
    .select(`
      *,
      subject_group:subject_groups(name),
      subject:subjects(name)
    `)
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId)
    .eq("exam_date", examDate)
    .eq("exam_title", examTitle)
    .order("subject_group_id", { ascending: true });

  if (handleQueryError(error, {
    context: "[data/scoreDetails] íŠ¹ì • ì‹œí—˜ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨",
    logError: true,
  })) {
    return [];
  }

  return (data as any[]) || [];
}

/**
 * êµê³¼êµ°ë³„ ë‚´ì‹  ì„±ì  í‰ê·  ê³„ì‚°
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param grade - í•™ë…„ (ì„ íƒì‚¬í•­)
 * @param semester - í•™ê¸° (ì„ íƒì‚¬í•­)
 * @returns êµê³¼êµ°ë³„ í‰ê·  ë“±ê¸‰
 */
export async function getInternalAverageBySubjectGroup(
  studentId: string,
  tenantId: string,
  grade?: number,
  semester?: number
): Promise<Array<{
  subject_group_id: string;
  subject_group_name: string;
  average_grade: number;
  count: number;
}>> {
  const scores = await getInternalScoresByTerm(studentId, tenantId, grade, semester);

  // êµê³¼êµ°ë³„ë¡œ ê·¸ë£¹í™”
  const grouped = scores.reduce((acc, score) => {
    const groupId = score.subject_group_id;
    const groupName = (score.subject_group as any)?.name || "ê¸°íƒ€";

    if (!acc[groupId]) {
      acc[groupId] = {
        subject_group_id: groupId,
        subject_group_name: groupName,
        grades: [],
      };
    }

    if (score.rank_grade) {
      acc[groupId].grades.push(score.rank_grade);
    }

    return acc;
  }, {} as Record<string, { subject_group_id: string; subject_group_name: string; grades: number[] }>);

  // í‰ê·  ê³„ì‚°
  return Object.values(grouped).map((group) => ({
    subject_group_id: group.subject_group_id,
    subject_group_name: group.subject_group_name,
    average_grade: group.grades.reduce((sum, g) => sum + g, 0) / group.grades.length,
    count: group.grades.length,
  }));
}

/**
 * ê³¼ëª©ë³„ ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¶”ì´
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param subjectId - ê³¼ëª© ID
 * @param limit - ì¡°íšŒí•  ìµœê·¼ ì‹œí—˜ ê°œìˆ˜ (ê¸°ë³¸ê°’: 5)
 * @returns ì‹œí—˜ë³„ ì„±ì  ë°°ì—´
 */
export async function getMockTrendBySubject(
  studentId: string,
  tenantId: string,
  subjectId: string,
  limit: number = 5
): Promise<Array<{
  exam_date: string;
  exam_title: string;
  grade_score: number | null;
  standard_score: number | null;
  percentile: number | null;
}>> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_mock_scores")
    .select("exam_date, exam_title, grade_score, standard_score, percentile")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId)
    .eq("subject_id", subjectId)
    .order("exam_date", { ascending: false })
    .limit(limit);

  if (handleQueryError(error, {
    context: "[data/scoreDetails] ê³¼ëª©ë³„ ëª¨ì˜ê³ ì‚¬ ì¶”ì´ ì¡°íšŒ ì‹¤íŒ¨",
    logError: true,
  })) {
    return [];
  }

  return (data || []).reverse(); // ì‹œê°„ìˆœ ì •ë ¬
}
</file>

<file path="scoreQueries.ts">
/**
 * ì„±ì  ì¡°íšŒ ì¿¼ë¦¬ ì˜ˆì‹œ
 * 
 * í•œ í•™ê¸°ì˜ ë‚´ì‹  + ëª¨ì˜ê³ ì‚¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” ì˜ˆì‹œ ì¿¼ë¦¬ì…ë‹ˆë‹¤.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { Tables } from "@/lib/supabase/database.types";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * í•œ í•™ê¸°ì˜ ë‚´ì‹  + ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ
 * 
 * student_termsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•´ë‹¹ í•™ê¸°ì˜ ë‚´ì‹  ì„±ì ê³¼ ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ í•¨ê»˜ ì¡°íšŒí•©ë‹ˆë‹¤.
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @param schoolYear - í•™ë…„ë„ (ì˜ˆ: 2024)
 * @param grade - í•™ë…„ (1~3)
 * @param semester - í•™ê¸° (1~2)
 * @returns ë‚´ì‹  ì„±ì ê³¼ ëª¨ì˜ê³ ì‚¬ ì„±ì  ë¦¬ìŠ¤íŠ¸
 */
export async function getTermScores(
  studentId: string,
  tenantId: string,
  schoolYear: number,
  grade: number,
  semester: number
): Promise<{
  term: Tables<"student_terms"> | null;
  internalScores: Array<Tables<"student_internal_scores"> & {
    subject: Tables<"subjects"> | null;
    subject_group: Tables<"subject_groups"> | null;
  }>;
  mockScores: Array<Tables<"student_mock_scores"> & {
    subject: Tables<"subjects"> | null;
    subject_group: Tables<"subject_groups"> | null;
  }>;
}> {
  const supabase = await createSupabaseServerClient();

  // 1. student_term ì¡°íšŒ
  const { data: term, error: termError } = await supabase
    .from("student_terms")
    .select("*")
    .eq("tenant_id", tenantId)
    .eq("student_id", studentId)
    .eq("school_year", schoolYear)
    .eq("grade", grade)
    .eq("semester", semester)
    .maybeSingle();

  if (termError) {
    console.error("[data/scoreQueries] student_term ì¡°íšŒ ì‹¤íŒ¨", termError);
  }

  // 2. ë‚´ì‹  ì„±ì  ì¡°íšŒ (student_term_idë¡œ ì—°ê²°)
  const { data: internalScores, error: internalError } = await supabase
    .from("student_internal_scores")
    .select(`
      *,
      subject:subjects(*),
      subject_group:subject_groups(*)
    `)
    .eq("tenant_id", tenantId)
    .eq("student_id", studentId)
    .eq("grade", grade)
    .eq("semester", semester)
    .order("created_at", { ascending: false });

  if (internalError) {
    console.error("[data/scoreQueries] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", internalError);
  }

  // 3. ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ (student_term_idë¡œ ì—°ê²°, ë˜ëŠ” gradeë§Œìœ¼ë¡œ í•„í„°ë§)
  const { data: mockScores, error: mockError } = await supabase
    .from("student_mock_scores")
    .select(`
      *,
      subject:subjects(*),
      subject_group:subject_groups(*)
    `)
    .eq("tenant_id", tenantId)
    .eq("student_id", studentId)
    .eq("grade", grade)
    .order("exam_date", { ascending: false });

  if (mockError) {
    console.error("[data/scoreQueries] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", mockError);
  }

  return {
    term: term as Tables<"student_terms"> | null,
    internalScores: (internalScores as any[]) ?? [],
    mockScores: (mockScores as any[]) ?? [],
  };
}

/**
 * í•™ìƒì˜ ëª¨ë“  í•™ê¸° ì„±ì  ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @returns í•™ê¸°ë³„ ì„±ì  ë¦¬ìŠ¤íŠ¸
 */
export async function getAllTermScores(
  studentId: string,
  tenantId: string
): Promise<Array<{
  term: Tables<"student_terms">;
  internalScores: Array<Tables<"student_internal_scores">>;
  mockScores: Array<Tables<"student_mock_scores">>;
}>> {
  const supabase = await createSupabaseServerClient();

  // 1. ëª¨ë“  student_terms ì¡°íšŒ
  const { data: terms, error: termsError } = await supabase
    .from("student_terms")
    .select("*")
    .eq("tenant_id", tenantId)
    .eq("student_id", studentId)
    .order("school_year", { ascending: false })
    .order("grade", { ascending: true })
    .order("semester", { ascending: true });

  if (termsError) {
    console.error("[data/scoreQueries] student_terms ì¡°íšŒ ì‹¤íŒ¨", termsError);
    return [];
  }

  if (!terms || terms.length === 0) {
    return [];
  }

  // 2. ê° í•™ê¸°ë³„ë¡œ ë‚´ì‹  ì„±ì ê³¼ ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ
  const results = await Promise.all(
    terms.map(async (term) => {
      // ë‚´ì‹  ì„±ì  ì¡°íšŒ
      const { data: internalScores } = await supabase
        .from("student_internal_scores")
        .select("*")
        .eq("student_term_id", term.id)
        .order("created_at", { ascending: false });

      // ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ (student_term_idê°€ ìˆëŠ” ê²½ìš°ë§Œ)
      const { data: mockScores } = await supabase
        .from("student_mock_scores")
        .select("*")
        .eq("student_term_id", term.id)
        .order("exam_date", { ascending: false });

      return {
        term: term as Tables<"student_terms">,
        internalScores: (internalScores as Tables<"student_internal_scores">[]) ?? [],
        mockScores: (mockScores as Tables<"student_mock_scores">[]) ?? [],
      };
    })
  );

  return results;
}
</file>

<file path="studentCareerFieldPreferences.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type CareerField = 
  | "ì¸ë¬¸ê³„ì—´"
  | "ì‚¬íšŒê³„ì—´"
  | "ìì—°ê³„ì—´"
  | "ê³µí•™ê³„ì—´"
  | "ì˜ì•½ê³„ì—´"
  | "ì˜ˆì²´ëŠ¥ê³„ì—´"
  | "êµìœ¡ê³„ì—´"
  | "ë†ì—…ê³„ì—´"
  | "í•´ì–‘ê³„ì—´"
  | "ê¸°íƒ€";

export type StudentCareerFieldPreference = {
  id: string;
  student_id: string;
  career_field: CareerField;
  priority: number;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * í•™ìƒ IDë¡œ ì§„ë¡œ ê³„ì—´ ì„ í˜¸ë„ ëª©ë¡ ì¡°íšŒ (ìš°ì„ ìˆœìœ„ ìˆœ)
 */
export async function getStudentCareerFieldPreferences(
  studentId: string
): Promise<StudentCareerFieldPreference[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_career_field_preferences")
    .select("*")
    .eq("student_id", studentId)
    .order("priority", { ascending: true });

  if (error) {
    console.error("[data/studentCareerFieldPreferences] ì§„ë¡œ ê³„ì—´ ì„ í˜¸ë„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as StudentCareerFieldPreference[]) ?? [];
}

/**
 * í•™ìƒì˜ ì§„ë¡œ ê³„ì—´ ì„ í˜¸ë„ ì „ì²´ êµì²´
 */
export async function replaceStudentCareerFieldPreferences(
  studentId: string,
  preferences: { career_field: CareerField; priority: number }[]
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // íŠ¸ëœì­ì…˜: ê¸°ì¡´ ë°ì´í„° ì‚­ì œ í›„ ìƒˆë¡œ ì‚½ì…
  const { error: deleteError } = await supabase
    .from("student_career_field_preferences")
    .delete()
    .eq("student_id", studentId);

  if (deleteError) {
    console.error("[data/studentCareerFieldPreferences] ê¸°ì¡´ ì„ í˜¸ë„ ì‚­ì œ ì‹¤íŒ¨", deleteError);
    return { success: false, error: deleteError.message };
  }

  if (preferences.length === 0) {
    return { success: true };
  }

  const payload = preferences.map((pref) => ({
    student_id: studentId,
    career_field: pref.career_field,
    priority: pref.priority,
  }));

  const { error: insertError } = await supabase
    .from("student_career_field_preferences")
    .insert(payload);

  if (insertError) {
    console.error("[data/studentCareerFieldPreferences] ì„ í˜¸ë„ ì €ì¥ ì‹¤íŒ¨", insertError);
    return { success: false, error: insertError.message };
  }

  return { success: true };
}

/**
 * í•™ìƒì˜ ì§„ë¡œ ê³„ì—´ ì„ í˜¸ë„ ì¶”ê°€
 */
export async function addStudentCareerFieldPreference(
  studentId: string,
  careerField: CareerField
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ìµœëŒ€ ìš°ì„ ìˆœìœ„ í™•ì¸
  const { data: existing } = await supabase
    .from("student_career_field_preferences")
    .select("priority")
    .eq("student_id", studentId)
    .order("priority", { ascending: false })
    .limit(1)
    .maybeSingle();

  const nextPriority = existing ? existing.priority + 1 : 1;

  const { error } = await supabase
    .from("student_career_field_preferences")
    .insert({
      student_id: studentId,
      career_field: careerField,
      priority: nextPriority,
    });

  if (error) {
    console.error("[data/studentCareerFieldPreferences] ì„ í˜¸ë„ ì¶”ê°€ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í•™ìƒì˜ ì§„ë¡œ ê³„ì—´ ì„ í˜¸ë„ ì‚­ì œ
 */
export async function removeStudentCareerFieldPreference(
  studentId: string,
  careerField: CareerField
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_career_field_preferences")
    .delete()
    .eq("student_id", studentId)
    .eq("career_field", careerField);

  if (error) {
    console.error("[data/studentCareerFieldPreferences] ì„ í˜¸ë„ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="studentCareerGoals.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type StudentCareerGoal = {
  id: string;
  student_id: string;
  tenant_id?: string | null;
  exam_year?: number | null;
  curriculum_revision?: "2009 ê°œì •" | "2015 ê°œì •" | "2022 ê°œì •" | null;
  desired_university_ids?: string[] | null; // í¬ë§ ëŒ€í•™êµ í†µí•© ID ë°°ì—´ (ìµœëŒ€ 3ê°œ, í˜•ì‹: UNIV_14, SCHOOL_123 ë“±)
  desired_career_field?: string | null;
  target_major?: string | null;
  target_major_2?: string | null;
  target_score?: Record<string, number> | null;
  target_university_type?: string | null;
  notes?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * í•™ìƒ IDë¡œ ì§„ë¡œ ëª©í‘œ ì •ë³´ ì¡°íšŒ
 */
export async function getStudentCareerGoalById(
  studentId: string
): Promise<StudentCareerGoal | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_career_goals")
    .select("*")
    .eq("student_id", studentId)
    .maybeSingle<StudentCareerGoal>();

  if (error && error.code !== "PGRST116") {
    console.error("[data/studentCareerGoals] ì§„ë¡œ ëª©í‘œ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * ì§„ë¡œ ëª©í‘œ ì •ë³´ ìƒì„±/ì—…ë°ì´íŠ¸
 */
export async function upsertStudentCareerGoal(
  goal: {
    student_id: string;
    tenant_id?: string | null;
    exam_year?: number | null;
    curriculum_revision?: "2009 ê°œì •" | "2015 ê°œì •" | "2022 ê°œì •" | null;
    desired_university_ids?: string[] | null; // í¬ë§ ëŒ€í•™êµ í†µí•© ID ë°°ì—´ (ìµœëŒ€ 3ê°œ, í˜•ì‹: UNIV_14, SCHOOL_123 ë“±)
    desired_career_field?: string | null;
    target_major?: string | null;
    target_major_2?: string | null;
    target_score?: Record<string, number> | null;
    target_university_type?: string | null;
    notes?: string | null;
  }
): Promise<{ success: boolean; error?: string; id?: string }> {
  const supabase = await createSupabaseServerClient();

  // ê¸°ì¡´ ë ˆì½”ë“œ í™•ì¸
  const { data: existing } = await supabase
    .from("student_career_goals")
    .select("id")
    .eq("student_id", goal.student_id)
    .maybeSingle();

  // desired_university_ids ë°°ì—´ ê²€ì¦ (ìµœëŒ€ 3ê°œ)
  let universityIds = goal.desired_university_ids ?? null;
  if (universityIds && universityIds.length > 3) {
    return {
      success: false,
      error: "í¬ë§ ëŒ€í•™êµëŠ” ìµœëŒ€ 3ê°œê¹Œì§€ë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
    };
  }

  // nullì´ë‚˜ ë¹ˆ ë°°ì—´ì„ ë¹ˆ ë°°ì—´ë¡œ ì •ê·œí™”
  if (universityIds === null || universityIds.length === 0) {
    universityIds = [];
  }

  // desired_university_idsëŠ” í†µí•© ID í˜•ì‹ (UNIV_14, SCHOOL_123 ë“±)ì„ ê·¸ëŒ€ë¡œ ì €ì¥
  // í†µí•© ID í˜•ì‹ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ë³€í™˜ ì‹œë„
  let resolvedUniversityIds: string[] = [];
  if (universityIds.length > 0) {
    // í†µí•© ID í˜•ì‹ì¸ì§€ í™•ì¸ (UNIV_14, SCHOOL_123 ë“±)
    const unifiedIdRegex = /^(UNIV_|SCHOOL_)\d+$/;
    const isAllUnifiedIds = universityIds.every((id) => unifiedIdRegex.test(id));

    if (isAllUnifiedIds) {
      // ì´ë¯¸ í†µí•© ID í˜•ì‹ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      resolvedUniversityIds = universityIds;
    } else {
      // UUID í˜•ì‹ì¸ì§€ í™•ì¸ (8-4-4-4-12 í˜•ì‹)
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      const isAllUuids = universityIds.every((id) => uuidRegex.test(id));

      if (isAllUuids) {
        // UUIDê°€ ì „ë‹¬ëœ ê²½ìš°, ê²½ê³  ë¡œê·¸ ì¶œë ¥ (í–¥í›„ í†µí•© IDë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”)
        console.warn(
          "[data/studentCareerGoals] UUID í˜•ì‹ì˜ desired_university_idsê°€ ì „ë‹¬ë˜ì—ˆìŠµë‹ˆë‹¤. í†µí•© ID í˜•ì‹ (UNIV_*, SCHOOL_*)ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”."
        );
        resolvedUniversityIds = universityIds;
      } else {
        // ì•Œ ìˆ˜ ì—†ëŠ” í˜•ì‹
        console.error(
          "[data/studentCareerGoals] ì•Œ ìˆ˜ ì—†ëŠ” desired_university_ids í˜•ì‹:",
          universityIds
        );
        return {
          success: false,
          error: "í•™êµ ID í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. í†µí•© ID í˜•ì‹ (UNIV_*, SCHOOL_*)ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.",
        };
      }
    }
  }

  const payload = {
    student_id: goal.student_id,
    tenant_id: goal.tenant_id ?? null,
    exam_year: goal.exam_year ?? null,
    curriculum_revision: goal.curriculum_revision ?? null,
    desired_university_ids: resolvedUniversityIds,
    desired_career_field: goal.desired_career_field ?? null,
    target_major: goal.target_major ?? null,
    target_major_2: goal.target_major_2 ?? null,
    target_score: goal.target_score ?? null,
    target_university_type: goal.target_university_type ?? null,
    notes: goal.notes ?? null,
  };

  let result;
  if (existing) {
    // ì—…ë°ì´íŠ¸
    result = await supabase
      .from("student_career_goals")
      .update(payload)
      .eq("student_id", goal.student_id)
      .select("id")
      .single();
  } else {
    // ìƒì„±
    result = await supabase
      .from("student_career_goals")
      .insert(payload)
      .select("id")
      .single();
  }

  if (result.error) {
    console.error("[data/studentCareerGoals] ì§„ë¡œ ëª©í‘œ ì €ì¥ ì‹¤íŒ¨", result.error);
    return { success: false, error: result.error.message };
  }

  return { success: true, id: result.data?.id };
}
</file>

<file path="studentContents.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

// ì±… íƒ€ì…
export type Book = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  title: string;
  revision?: string | null;
  semester?: string | null;
  subject_category?: string | null;
  subject?: string | null;
  publisher?: string | null;
  difficulty_level?: string | null;
  total_pages?: number | null;
  notes?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

// ê°•ì˜ íƒ€ì…
export type Lecture = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  title: string;
  revision?: string | null;
  semester?: string | null;
  subject_category?: string | null;
  subject?: string | null;
  platform?: string | null;
  difficulty_level?: string | null;
  duration?: number | null; // ë¶„ ë‹¨ìœ„
  notes?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

// ì»¤ìŠ¤í…€ ì½˜í…ì¸  íƒ€ì…
export type CustomContent = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  title: string;
  content_type?: string | null;
  total_page_or_time?: number | null;
  subject?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type ContentFilters = {
  studentId: string;
  tenantId?: string | null;
  contentType?: "book" | "lecture" | "custom";
  subject?: string;
};

/**
 * ì±… ëª©ë¡ ì¡°íšŒ
 */
export async function getBooks(
  studentId: string,
  tenantId?: string | null,
  filters?: { subject?: string }
): Promise<Book[]> {
  const supabase = await createSupabaseServerClient();

  const selectBooks = () =>
    supabase
      .from("books")
      .select("id,tenant_id,student_id,title,revision,semester,subject_category,subject,publisher,difficulty_level,total_pages,notes,created_at,updated_at")
      .eq("student_id", studentId);

  let query = selectBooks();

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.subject) {
    query = query.eq("subject", filters.subject);
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase.from("books").select("*");

    if (filters?.subject) {
      fallbackQuery.eq("subject", filters.subject);
    }

    ({ data, error } = await fallbackQuery.order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentContents] ì±… ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Book[] | null) ?? [];
}

/**
 * ê°•ì˜ ëª©ë¡ ì¡°íšŒ
 */
export async function getLectures(
  studentId: string,
  tenantId?: string | null,
  filters?: { subject?: string }
): Promise<Lecture[]> {
  const supabase = await createSupabaseServerClient();

  const selectLectures = () =>
    supabase
      .from("lectures")
      .select("id,tenant_id,student_id,title,revision,semester,subject_category,subject,platform,difficulty_level,duration,notes,created_at,updated_at")
      .eq("student_id", studentId);

  let query = selectLectures();

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.subject) {
    query = query.eq("subject", filters.subject);
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase.from("lectures").select("*");

    if (filters?.subject) {
      fallbackQuery.eq("subject", filters.subject);
    }

    ({ data, error } = await fallbackQuery.order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentContents] ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Lecture[] | null) ?? [];
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ
 */
export async function getCustomContents(
  studentId: string,
  tenantId?: string | null,
  filters?: { subject?: string }
): Promise<CustomContent[]> {
  const supabase = await createSupabaseServerClient();

  const selectCustom = () =>
    supabase
      .from("student_custom_contents")
      .select("id,tenant_id,student_id,title,content_type,total_page_or_time,subject,created_at,updated_at")
      .eq("student_id", studentId);

  let query = selectCustom();

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.subject) {
    query = query.eq("subject", filters.subject);
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase.from("student_custom_contents").select("*");

    if (filters?.subject) {
      fallbackQuery.eq("subject", filters.subject);
    }

    ({ data, error } = await fallbackQuery.order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as CustomContent[] | null) ?? [];
}

/**
 * ì±… ìƒì„±
 */
export async function createBook(
  book: {
    tenant_id?: string | null;
    student_id: string;
    title: string;
    revision?: string | null;
    semester?: string | null;
    subject_category?: string | null;
    subject?: string | null;
    publisher?: string | null;
    difficulty_level?: string | null;
    total_pages?: number | null;
    notes?: string | null;
  }
): Promise<{ success: boolean; bookId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: book.tenant_id || null,
    student_id: book.student_id,
    title: book.title,
    revision: book.revision || null,
    semester: book.semester || null,
    subject_category: book.subject_category || null,
    subject: book.subject || null,
    publisher: book.publisher || null,
    difficulty_level: book.difficulty_level || null,
    total_pages: book.total_pages || null,
    notes: book.notes || null,
  };

  let { data, error } = await supabase
    .from("books")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ data, error } = await supabase
      .from("books")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentContents] ì±… ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, bookId: data?.id };
}

/**
 * ê°•ì˜ ìƒì„±
 */
export async function createLecture(
  lecture: {
    tenant_id?: string | null;
    student_id: string;
    title: string;
    revision?: string | null;
    semester?: string | null;
    subject_category?: string | null;
    subject?: string | null;
    platform?: string | null;
    difficulty_level?: string | null;
    duration?: number | null;
    notes?: string | null;
  }
): Promise<{ success: boolean; lectureId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: lecture.tenant_id || null,
    student_id: lecture.student_id,
    title: lecture.title,
    revision: lecture.revision || null,
    semester: lecture.semester || null,
    subject_category: lecture.subject_category || null,
    subject: lecture.subject || null,
    platform: lecture.platform || null,
    difficulty_level: lecture.difficulty_level || null,
    duration: lecture.duration || null,
    notes: lecture.notes || null,
  };

  let { data, error } = await supabase
    .from("lectures")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ data, error } = await supabase
      .from("lectures")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentContents] ê°•ì˜ ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, lectureId: data?.id };
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„±
 */
export async function createCustomContent(
  content: {
    tenant_id?: string | null;
    student_id: string;
    title: string;
    content_type?: string | null;
    total_page_or_time?: number | null;
    subject?: string | null;
  }
): Promise<{ success: boolean; contentId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: content.tenant_id || null,
    student_id: content.student_id,
    title: content.title,
    content_type: content.content_type || null,
    total_page_or_time: content.total_page_or_time || null,
    subject: content.subject || null,
  };

  let { data, error } = await supabase
    .from("student_custom_contents")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ data, error } = await supabase
      .from("student_custom_contents")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, contentId: data?.id };
}

/**
 * ì±… ì—…ë°ì´íŠ¸
 */
export async function updateBook(
  bookId: string,
  studentId: string,
  updates: Partial<Omit<Book, "id" | "student_id" | "created_at" | "updated_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.title !== undefined) payload.title = updates.title;
  if (updates.revision !== undefined) payload.revision = updates.revision;
  if (updates.semester !== undefined) payload.semester = updates.semester;
  if (updates.subject_category !== undefined) payload.subject_category = updates.subject_category;
  if (updates.subject !== undefined) payload.subject = updates.subject;
  if (updates.publisher !== undefined) payload.publisher = updates.publisher;
  if (updates.difficulty_level !== undefined) payload.difficulty_level = updates.difficulty_level;
  if (updates.total_pages !== undefined) payload.total_pages = updates.total_pages;
  if (updates.notes !== undefined) payload.notes = updates.notes;

  let { error } = await supabase
    .from("books")
    .update(payload)
    .eq("id", bookId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("books").update(payload).eq("id", bookId));
  }

  if (error) {
    console.error("[data/studentContents] ì±… ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ê°•ì˜ ì—…ë°ì´íŠ¸
 */
export async function updateLecture(
  lectureId: string,
  studentId: string,
  updates: Partial<Omit<Lecture, "id" | "student_id" | "created_at" | "updated_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.title !== undefined) payload.title = updates.title;
  if (updates.revision !== undefined) payload.revision = updates.revision;
  if (updates.semester !== undefined) payload.semester = updates.semester;
  if (updates.subject_category !== undefined) payload.subject_category = updates.subject_category;
  if (updates.subject !== undefined) payload.subject = updates.subject;
  if (updates.platform !== undefined) payload.platform = updates.platform;
  if (updates.difficulty_level !== undefined) payload.difficulty_level = updates.difficulty_level;
  if (updates.duration !== undefined) payload.duration = updates.duration;
  if ((updates as any).total_episodes !== undefined) payload.total_episodes = (updates as any).total_episodes;
  if ((updates as any).linked_book_id !== undefined) payload.linked_book_id = (updates as any).linked_book_id;
  if (updates.notes !== undefined) payload.notes = updates.notes;

  let { error } = await supabase
    .from("lectures")
    .update(payload)
    .eq("id", lectureId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("lectures").update(payload).eq("id", lectureId));
  }

  if (error) {
    console.error("[data/studentContents] ê°•ì˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì—…ë°ì´íŠ¸
 */
export async function updateCustomContent(
  contentId: string,
  studentId: string,
  updates: Partial<Omit<CustomContent, "id" | "student_id" | "created_at" | "updated_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.title !== undefined) payload.title = updates.title;
  if (updates.content_type !== undefined) payload.content_type = updates.content_type;
  if (updates.total_page_or_time !== undefined) payload.total_page_or_time = updates.total_page_or_time;
  if (updates.subject !== undefined) payload.subject = updates.subject;

  let { error } = await supabase
    .from("student_custom_contents")
    .update(payload)
    .eq("id", contentId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_custom_contents")
      .update(payload)
      .eq("id", contentId));
  }

  if (error) {
    console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ì±… ì‚­ì œ
 */
export async function deleteBook(
  bookId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("books")
    .delete()
    .eq("id", bookId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("books").delete().eq("id", bookId));
  }

  if (error) {
    console.error("[data/studentContents] ì±… ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ê°•ì˜ ì‚­ì œ
 */
export async function deleteLecture(
  lectureId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("lectures")
    .delete()
    .eq("id", lectureId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("lectures").delete().eq("id", lectureId));
  }

  if (error) {
    console.error("[data/studentContents] ê°•ì˜ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì‚­ì œ
 */
export async function deleteCustomContent(
  contentId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_custom_contents")
    .delete()
    .eq("id", contentId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_custom_contents")
      .delete()
      .eq("id", contentId));
  }

  if (error) {
    console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ID ë°°ì—´ë¡œ ì½˜í…ì¸ ë¥¼ ë³‘ë ¬ ì¡°íšŒ (ê³µí†µ í•¨ìˆ˜)
 * @param bookIds ì±… ID ë°°ì—´
 * @param lectureIds ê°•ì˜ ID ë°°ì—´
 * @param customIds ì»¤ìŠ¤í…€ ì½˜í…ì¸  ID ë°°ì—´
 * @param studentId í•™ìƒ ID
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì„ íƒ)
 * @returns ì¡°íšŒëœ ì½˜í…ì¸  ê°ì²´
 */
export async function getContentsByIds(
  bookIds: string[],
  lectureIds: string[],
  customIds: string[],
  studentId: string,
  tenantId?: string | null
): Promise<{
  books: Book[];
  lectures: Lecture[];
  customContents: CustomContent[];
}> {
  const supabase = await createSupabaseServerClient();
  
  // Defensive: Limit IN clause size to prevent extremely large queries
  const MAX_IN_CLAUSE_SIZE = 500;
  const safeBookIds = bookIds.slice(0, MAX_IN_CLAUSE_SIZE);
  const safeLectureIds = lectureIds.slice(0, MAX_IN_CLAUSE_SIZE);
  const safeCustomIds = customIds.slice(0, MAX_IN_CLAUSE_SIZE);

  if (bookIds.length > MAX_IN_CLAUSE_SIZE) {
    console.warn(`[data/studentContents] bookIds truncated from ${bookIds.length} to ${MAX_IN_CLAUSE_SIZE}`);
  }
  if (lectureIds.length > MAX_IN_CLAUSE_SIZE) {
    console.warn(`[data/studentContents] lectureIds truncated from ${lectureIds.length} to ${MAX_IN_CLAUSE_SIZE}`);
  }
  if (customIds.length > MAX_IN_CLAUSE_SIZE) {
    console.warn(`[data/studentContents] customIds truncated from ${customIds.length} to ${MAX_IN_CLAUSE_SIZE}`);
  }

  // ë³‘ë ¬ ì¡°íšŒ
  const [booksResult, lecturesResult, customContentsResult] = await Promise.all([
    safeBookIds.length > 0
      ? (async () => {
          try {
            let query = supabase
              .from("books")
              .select("id,tenant_id,student_id,title,revision,semester,subject_category,subject,publisher,difficulty_level,total_pages,notes,created_at,updated_at")
              .eq("student_id", studentId)
              .in("id", safeBookIds);
            
            if (tenantId) {
              query = query.eq("tenant_id", tenantId);
            }
            
            const { data, error } = await query;
            if (error) {
              console.error("[data/studentContents] ì±… ì¡°íšŒ ì‹¤íŒ¨", error);
              return [];
            }
            return (data as Book[]) ?? [];
          } catch (err) {
            console.error("[data/studentContents] ì±… ì¡°íšŒ ì˜ˆì™¸", err);
            return [];
          }
        })()
      : Promise.resolve([]),
    safeLectureIds.length > 0
      ? (async () => {
          try {
            let query = supabase
              .from("lectures")
              .select("id,tenant_id,student_id,title,revision,semester,subject_category,subject,platform,difficulty_level,duration,notes,created_at,updated_at")
              .eq("student_id", studentId)
              .in("id", safeLectureIds);
            
            if (tenantId) {
              query = query.eq("tenant_id", tenantId);
            }
            
            const { data, error } = await query;
            if (error) {
              console.error("[data/studentContents] ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨", error);
              return [];
            }
            return (data as Lecture[]) ?? [];
          } catch (err) {
            console.error("[data/studentContents] ê°•ì˜ ì¡°íšŒ ì˜ˆì™¸", err);
            return [];
          }
        })()
      : Promise.resolve([]),
    safeCustomIds.length > 0
      ? (async () => {
          try {
            let query = supabase
              .from("student_custom_contents")
              .select("id,tenant_id,student_id,title,content_type,total_page_or_time,subject,created_at,updated_at")
              .eq("student_id", studentId)
              .in("id", safeCustomIds);
            
            if (tenantId) {
              query = query.eq("tenant_id", tenantId);
            }
            
            const { data, error } = await query;
            if (error) {
              console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ ì‹¤íŒ¨", error);
              return [];
            }
            return (data as CustomContent[]) ?? [];
          } catch (err) {
            console.error("[data/studentContents] ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ ì˜ˆì™¸", err);
            return [];
          }
        })()
      : Promise.resolve([]),
  ]);

  return {
    books: booksResult,
    lectures: lecturesResult,
    customContents: customContentsResult,
  };
}
</file>

<file path="studentGoals.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type Goal = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  goal_type: "range" | "exam" | "weekly" | "monthly";
  title: string;
  description?: string | null;
  subject?: string | null;
  content_id?: string | null;
  start_date: string;
  end_date: string;
  expected_amount?: number | null;
  target_score?: number | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type GoalProgress = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  goal_id: string;
  plan_id?: string | null;
  session_id?: string | null;
  progress_amount: number;
  created_at?: string | null;
};

export type GoalFilters = {
  studentId: string;
  tenantId?: string | null;
  goalType?: "range" | "exam" | "weekly" | "monthly";
  dateRange?: {
    start: string;
    end: string;
  };
  isActive?: boolean; // í˜„ì¬ ë‚ ì§œê°€ start_dateì™€ end_date ì‚¬ì´ì— ìˆëŠ” ëª©í‘œ
};

/**
 * í•™ìƒì˜ ëª©í‘œ ëª©ë¡ ì¡°íšŒ
 */
export async function getGoalsForStudent(
  filters: GoalFilters
): Promise<Goal[]> {
  const supabase = await createSupabaseServerClient();

  const selectGoals = () =>
    supabase
      .from("student_goals")
      .select(
        "id,tenant_id,student_id,goal_type,title,description,subject,content_id,start_date,end_date,expected_amount,target_score,created_at,updated_at"
      )
      .eq("student_id", filters.studentId);

  let query = selectGoals();

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.goalType) {
    query = query.eq("goal_type", filters.goalType);
  }

  if (filters.dateRange) {
    query = query
      .gte("start_date", filters.dateRange.start)
      .lte("end_date", filters.dateRange.end);
  }

  if (filters.isActive !== undefined) {
    const today = new Date().toISOString().slice(0, 10);
    if (filters.isActive) {
      query = query.lte("start_date", today).gte("end_date", today);
    } else {
      query = query.or(`start_date.gt.${today},end_date.lt.${today}`);
    }
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase
      .from("student_goals")
      .select("*")
      .eq("student_id", filters.studentId);

    if (filters.goalType) {
      fallbackQuery.eq("goal_type", filters.goalType);
    }

    if (filters.dateRange) {
      fallbackQuery
        .gte("start_date", filters.dateRange.start)
        .lte("end_date", filters.dateRange.end);
    }

    ({ data, error } = await fallbackQuery.order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Goal[] | null) ?? [];
}

/**
 * ëª©í‘œ IDë¡œ ëª©í‘œ ì¡°íšŒ
 */
export async function getGoalById(
  goalId: string,
  studentId: string,
  tenantId?: string | null
): Promise<Goal | null> {
  const supabase = await createSupabaseServerClient();

  const selectGoal = () =>
    supabase
      .from("student_goals")
      .select(
        "id,tenant_id,student_id,goal_type,title,description,subject,content_id,start_date,end_date,expected_amount,target_score,created_at,updated_at"
      )
      .eq("id", goalId)
      .eq("student_id", studentId);

  let query = selectGoal();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<Goal>();

  if (error && error.code === "42703") {
    ({ data, error } = await selectGoal().maybeSingle<Goal>());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[data/studentGoals] ëª©í‘œ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * ëª©í‘œ ìƒì„±
 */
export async function createGoal(
  goal: {
    tenant_id?: string | null;
    student_id: string;
    goal_type: "range" | "exam" | "weekly" | "monthly";
    title: string;
    description?: string | null;
    subject?: string | null;
    content_id?: string | null;
    start_date: string;
    end_date: string;
    expected_amount?: number | null;
    target_score?: number | null;
  }
): Promise<{ success: boolean; goalId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: goal.tenant_id || null,
    student_id: goal.student_id,
    goal_type: goal.goal_type,
    title: goal.title,
    description: goal.description || null,
    subject: goal.subject || null,
    content_id: goal.content_id || null,
    start_date: goal.start_date,
    end_date: goal.end_date,
    expected_amount: goal.expected_amount || null,
    target_score: goal.target_score || null,
  };

  let { data, error } = await supabase
    .from("student_goals")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ data, error } = await supabase
      .from("student_goals")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, goalId: data?.id };
}

/**
 * ëª©í‘œ ì—…ë°ì´íŠ¸
 */
export async function updateGoal(
  goalId: string,
  studentId: string,
  updates: {
    goal_type?: "range" | "exam" | "weekly" | "monthly";
    title?: string;
    description?: string | null;
    subject?: string | null;
    content_id?: string | null;
    start_date?: string;
    end_date?: string;
    expected_amount?: number | null;
    target_score?: number | null;
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.goal_type !== undefined) payload.goal_type = updates.goal_type;
  if (updates.title !== undefined) payload.title = updates.title;
  if (updates.description !== undefined) payload.description = updates.description;
  if (updates.subject !== undefined) payload.subject = updates.subject;
  if (updates.content_id !== undefined) payload.content_id = updates.content_id;
  if (updates.start_date !== undefined) payload.start_date = updates.start_date;
  if (updates.end_date !== undefined) payload.end_date = updates.end_date;
  if (updates.expected_amount !== undefined) payload.expected_amount = updates.expected_amount;
  if (updates.target_score !== undefined) payload.target_score = updates.target_score;

  let { error } = await supabase
    .from("student_goals")
    .update(payload)
    .eq("id", goalId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("student_goals").update(payload).eq("id", goalId));
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ëª©í‘œ ì‚­ì œ
 */
export async function deleteGoal(
  goalId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_goals")
    .delete()
    .eq("id", goalId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("student_goals").delete().eq("id", goalId));
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ëª©í‘œ ì§„í–‰ë¥  ê¸°ë¡
 */
export async function recordGoalProgress(
  progress: {
    tenant_id?: string | null;
    student_id: string;
    goal_id: string;
    plan_id?: string | null;
    session_id?: string | null;
    progress_amount: number;
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: progress.tenant_id || null,
    student_id: progress.student_id,
    goal_id: progress.goal_id,
    plan_id: progress.plan_id || null,
    session_id: progress.session_id || null,
    progress_amount: progress.progress_amount,
  };

  let { error } = await supabase
    .from("student_goal_progress")
    .insert(payload)
    .eq("student_id", progress.student_id);

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ error } = await supabase
      .from("student_goal_progress")
      .insert(fallbackPayload));
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ì§„í–‰ë¥  ê¸°ë¡ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ëª©í‘œì˜ ì§„í–‰ë¥  ëª©ë¡ ì¡°íšŒ
 */
export async function getGoalProgressList(
  goalId: string,
  studentId: string,
  tenantId?: string | null
): Promise<GoalProgress[]> {
  const supabase = await createSupabaseServerClient();

  const selectProgress = () =>
    supabase
      .from("student_goal_progress")
      .select(
        "id,tenant_id,student_id,goal_id,plan_id,session_id,progress_amount,created_at"
      )
      .eq("goal_id", goalId)
      .eq("student_id", studentId);

  let query = selectProgress();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  query = query.order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    ({ data, error } = await selectProgress()
      .order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentGoals] ëª©í‘œ ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as GoalProgress[] | null) ?? [];
}
</file>

<file path="studentPlans.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

// ============================================
// í”Œëœ ì—…ë°ì´íŠ¸ ì œí•œ ì •ì±… (Phase 2)
// ============================================

/**
 * student_planì—ì„œ í—ˆìš©ë˜ëŠ” ì—…ë°ì´íŠ¸ í•„ë“œ
 * - ì‹¤í–‰ ê´€ë ¨: íƒ€ì´ë¨¸, ì§„í–‰ë¥ , ì™„ë£ŒëŸ‰
 * - ì¼ì • ì¡°ì •: ë‚ ì§œ ë³€ê²½ (ë¯¸ë£¨ê¸°)
 * - ë²”ìœ„ ì¡°ì •: í˜ì´ì§€/ì‹œê°„ ë¯¸ì„¸ ì¡°ì •
 * - ë©”íƒ€ë°ì´í„°: ë©”ëª¨
 */
export type AllowedPlanUpdates = {
  // ì¼ì • ì¡°ì •
  plan_date?: string;
  block_index?: number; // ë¯¸ë£¨ê¸° ì‹œ í•¨ê»˜ ë³€ê²½ ê°€ëŠ¥
  // ë²”ìœ„ ë¯¸ì„¸ ì¡°ì •
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
  // ì‹¤í–‰ ê´€ë ¨
  completed_amount?: number | null;
  progress?: number | null;
  actual_start_time?: string | null;
  actual_end_time?: string | null;
  total_duration_seconds?: number | null;
  paused_duration_seconds?: number | null;
  pause_count?: number | null;
  // ë©”íƒ€ë°ì´í„°
  memo?: string | null;
  is_reschedulable?: boolean;
  chapter?: string | null; // ì±•í„° ì •ë³´ ì—…ë°ì´íŠ¸ í—ˆìš©
};

/**
 * student_planì—ì„œ ê¸ˆì§€ë˜ëŠ” ì—…ë°ì´íŠ¸ í•„ë“œ
 * êµ¬ì¡°ì  ë³€ê²½ì€ í”Œëœê·¸ë£¹ ë ˆë²¨ì—ì„œ ì²˜ë¦¬í•´ì•¼ í•¨
 */
export type ForbiddenPlanUpdateFields =
  | "content_type"
  | "content_id"
  | "plan_group_id"
  | "student_id"
  | "tenant_id"
  | "origin_plan_item_id"
  | "plan_number";

/**
 * ê¸ˆì§€ëœ í•„ë“œ ëª©ë¡
 */
const FORBIDDEN_UPDATE_FIELDS: ForbiddenPlanUpdateFields[] = [
  "content_type",
  "content_id",
  "plan_group_id",
  "student_id",
  "tenant_id",
  "origin_plan_item_id",
  "plan_number",
];

// ============================================
// ì‚­ì œ ì •ì±… (Phase 2 - P2-9)
// ============================================

/**
 * student_plan ì‚­ì œ ì •ì±…
 *
 * 1. **ê°œë³„ í”Œëœ ì‚­ì œ (deletePlan)**
 *    - í•™ìƒì´ ì§ì ‘ ì‚­ì œ ê°€ëŠ¥
 *    - ê´€ë ¨ study_sessionsëŠ” plan_idê°€ NULLë¡œ ì„¤ì •ë¨ (ON DELETE SET NULL)
 *
 * 2. **í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹œ (plan_groups DELETE)**
 *    - DB: student_plan.plan_group_idëŠ” ON DELETE SET NULL
 *    - ì•± ë ˆë²¨: deletePlanGroupByInvitationIdì—ì„œ ëª…ì‹œì ìœ¼ë¡œ student_plan ë¨¼ì € ì‚­ì œ
 *
 * 3. **ë…¼ë¦¬ í”Œëœ ì‚­ì œ ì‹œ (plan_group_items DELETE)**
 *    - DB: student_plan.origin_plan_item_idëŠ” ON DELETE SET NULL
 *    - ì—°ê²°ë§Œ ëŠê¸°ê³  ì‹¤í–‰ ë°ì´í„°ëŠ” ë³´ì¡´
 *
 * 4. **ì™„ë£Œëœ í”Œëœ ë³´í˜¸**
 *    - actual_end_timeì´ ì„¤ì •ëœ í”Œëœì€ ì‚­ì œ ì „ í™•ì¸ í•„ìš”
 *    - í†µê³„ ë°ì´í„° ë³´ì¡´ì„ ìœ„í•´ soft delete ê¶Œì¥ (í–¥í›„ êµ¬í˜„)
 *
 * @see docs/refactoring/03_phase_todo_list.md [P2-9]
 */
export const PLAN_DELETE_POLICY = {
  /** ì™„ë£Œëœ í”Œëœ ì‚­ì œ í—ˆìš© ì—¬ë¶€ (í˜„ì¬: í—ˆìš©) */
  allowDeleteCompleted: true,
  /** íƒ€ì´ë¨¸ ì§„í–‰ ì¤‘ í”Œëœ ì‚­ì œ í—ˆìš© ì—¬ë¶€ (í˜„ì¬: í—ˆìš©) */
  allowDeleteInProgress: true,
  /** soft delete ì‚¬ìš© ì—¬ë¶€ (í˜„ì¬: hard delete) */
  useSoftDelete: false,
} as const;

export type Plan = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  plan_date: string;
  block_index: number;
  content_type: "book" | "lecture" | "custom";
  content_id: string;
  chapter?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
  completed_amount?: number | null;
  progress?: number | null;
  is_reschedulable: boolean;
  plan_group_id?: string | null;
  start_time?: string | null; // HH:mm í˜•ì‹ - í”Œëœ ìƒì„± ì‹œ ê³„ì‚°ëœ ì‹œì‘ ì‹œê°„
  end_time?: string | null; // HH:mm í˜•ì‹ - í”Œëœ ìƒì„± ì‹œ ê³„ì‚°ëœ ì¢…ë£Œ ì‹œê°„
  actual_start_time?: string | null;
  actual_end_time?: string | null;
  total_duration_seconds?: number | null;
  paused_duration_seconds?: number | null;
  pause_count?: number | null;
  // í”Œëœ ë©”íƒ€ë°ì´í„° í•„ë“œ
  plan_number?: number | null;
  sequence?: number | null; // í”Œëœ ê·¸ë£¹ ë‚´ì—ì„œ ê°™ì€ ì½˜í…ì¸ ì˜ íšŒì°¨ ë²ˆí˜¸
  memo?: string | null; // í”Œëœ ë©”ëª¨ (ê°™ì€ plan_numberë¥¼ ê°€ì§„ í”Œëœë“¤ì€ ê³µìœ )
  day_type?: string | null;
  week?: number | null;
  day?: number | null;
  is_partial?: boolean | null;
  is_continued?: boolean | null;
  // Denormalized í•„ë“œ (ì¡°íšŒ ì„±ëŠ¥ í–¥ìƒ)
  content_title?: string | null;
  content_subject?: string | null;
  content_subject_category?: string | null;
  content_category?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type PlanFilters = {
  studentId: string;
  tenantId?: string | null;
  dateRange?: {
    start: string;
    end: string;
  };
  planDate?: string;
  contentType?: "book" | "lecture" | "custom";
  planGroupIds?: string[]; // í”Œëœ ê·¸ë£¹ ID ëª©ë¡ìœ¼ë¡œ í•„í„°ë§
};

/**
 * í•™ìƒì˜ í”Œëœ ëª©ë¡ ì¡°íšŒ
 */
export async function getPlansForStudent(
  filters: PlanFilters
): Promise<Plan[]> {
  const supabase = await createSupabaseServerClient();

  const selectPlans = () =>
    supabase
      .from("student_plan")
      .select(
        "id,tenant_id,student_id,plan_date,block_index,content_type,content_id,chapter,planned_start_page_or_time,planned_end_page_or_time,completed_amount,progress,is_reschedulable,plan_group_id,start_time,end_time,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count,plan_number,sequence,day_type,week,day,is_partial,is_continued,content_title,content_subject,content_subject_category,content_category,memo,created_at,updated_at"
      )
      .eq("student_id", filters.studentId);

  let query = selectPlans();

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.planDate) {
    // planDateë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ (YYYY-MM-DD í˜•ì‹)
    const planDateStr =
      typeof filters.planDate === "string"
        ? filters.planDate.slice(0, 10)
        : String(filters.planDate).slice(0, 10);
    query = query.eq("plan_date", planDateStr);
  } else if (filters.dateRange) {
    // dateRangeì˜ startì™€ endë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ (YYYY-MM-DD í˜•ì‹)
    const startStr =
      typeof filters.dateRange.start === "string"
        ? filters.dateRange.start.slice(0, 10)
        : String(filters.dateRange.start).slice(0, 10);

    const endStr =
      typeof filters.dateRange.end === "string"
        ? filters.dateRange.end.slice(0, 10)
        : String(filters.dateRange.end).slice(0, 10);

    query = query.gte("plan_date", startStr).lte("plan_date", endStr);
  }

  if (filters.contentType) {
    query = query.eq("content_type", filters.contentType);
  }

  if (filters.planGroupIds && filters.planGroupIds.length > 0) {
    // plan_group_idê°€ NULLì´ ì•„ë‹Œ ê°’ë§Œ í•„í„°ë§
    // .in() ë©”ì„œë“œëŠ” ë°°ì—´ì˜ ê°’ë“¤ ì¤‘ í•˜ë‚˜ì™€ ì¼ì¹˜í•˜ëŠ” í–‰ì„ ë°˜í™˜
    try {
      // planGroupIdsê°€ ìœ íš¨í•œ UUID ë°°ì—´ì¸ì§€ í™•ì¸
      const validGroupIds = filters.planGroupIds.filter(
        (id) => id && typeof id === "string" && id.trim().length > 0
      );

      if (validGroupIds.length > 0) {
        query = query.in("plan_group_id", validGroupIds);
      } else {
        console.warn(
          "[data/studentPlans] ìœ íš¨í•œ planGroupIdsê°€ ì—†ìŠµë‹ˆë‹¤:",
          filters.planGroupIds
        );
        return []; // ìœ íš¨í•œ IDê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
      }
    } catch (filterError) {
      console.error(
        "[data/studentPlans] planGroupIds í•„í„°ë§ ì¤‘ ì˜¤ë¥˜:",
        filterError
      );
      // í•„í„°ë§ ì‹¤íŒ¨ ì‹œ ì „ì²´ ì¡°íšŒë¡œ í´ë°±
    }
  }

  query = query
    .order("plan_date", { ascending: true })
    .order("block_index", { ascending: true });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    let fallbackQuery = supabase
      .from("student_plan")
      .select("*")
      .eq("student_id", filters.studentId);

    if (filters.tenantId) {
      fallbackQuery = fallbackQuery.eq("tenant_id", filters.tenantId);
    }

    if (filters.planDate) {
      // planDateë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ (YYYY-MM-DD í˜•ì‹)
      const planDateStr =
        typeof filters.planDate === "string"
          ? filters.planDate.slice(0, 10)
          : String(filters.planDate).slice(0, 10);
      fallbackQuery = fallbackQuery.eq("plan_date", planDateStr);
    } else if (filters.dateRange) {
      // dateRangeì˜ startì™€ endë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ (YYYY-MM-DD í˜•ì‹)
      const startStr =
        typeof filters.dateRange.start === "string"
          ? filters.dateRange.start.slice(0, 10)
          : String(filters.dateRange.start).slice(0, 10);

      const endStr =
        typeof filters.dateRange.end === "string"
          ? filters.dateRange.end.slice(0, 10)
          : String(filters.dateRange.end).slice(0, 10);

      fallbackQuery = fallbackQuery
        .gte("plan_date", startStr)
        .lte("plan_date", endStr);
    }

    if (filters.contentType) {
      fallbackQuery = fallbackQuery.eq("content_type", filters.contentType);
    }

    if (filters.planGroupIds && filters.planGroupIds.length > 0) {
      // fallback ì¿¼ë¦¬ì—ì„œë„ ìœ íš¨í•œ IDë§Œ ì‚¬ìš©
      const validGroupIds = filters.planGroupIds.filter(
        (id) => id && typeof id === "string" && id.trim().length > 0
      );
      if (validGroupIds.length > 0) {
        fallbackQuery = fallbackQuery.in("plan_group_id", validGroupIds);
      }
    }

    ({ data, error } = await fallbackQuery
      .order("plan_date", { ascending: true })
      .order("block_index", { ascending: true }));
  }

  if (error) {
    const supabaseError = error as any;
    const errorMessage = supabaseError?.message || String(error);

    // HTML ì‘ë‹µì´ ë°˜í™˜ëœ ê²½ìš° (500 ì—ëŸ¬ ë“±) ê°ì§€
    const isHtmlError =
      typeof errorMessage === "string" &&
      errorMessage.includes("<!DOCTYPE html>");
    const isServerError =
      isHtmlError ||
      supabaseError?.code === "500" ||
      supabaseError?.statusCode === 500;

    // ì„œë²„ ì—ëŸ¬ì¸ ê²½ìš° ì¬ì‹œë„ ë¡œì§
    if (isServerError) {
      console.warn("[data/studentPlans] ì„œë²„ ì—ëŸ¬ ë°œìƒ, ì¬ì‹œë„ ì¤‘...", {
        errorCode: supabaseError?.code,
        statusCode: supabaseError?.statusCode,
        isHtmlError,
      });

      // ìµœëŒ€ 2ë²ˆ ì¬ì‹œë„ (ì´ 3ë²ˆ ì‹œë„)
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          // ì¬ì‹œë„ ì „ ëŒ€ê¸° (ì§€ìˆ˜ ë°±ì˜¤í”„: 1ì´ˆ, 2ì´ˆ)
          await new Promise((resolve) => setTimeout(resolve, attempt * 1000));

          // ê°„ë‹¨í•œ ì¿¼ë¦¬ë¡œ ì¬ì‹œë„
          const retryQuery = supabase
            .from("student_plan")
            .select("*")
            .eq("student_id", filters.studentId)
            .limit(1000); // ì œí•œì„ ë‘ì–´ ë³µì¡í•œ ì¿¼ë¦¬ ë°©ì§€

          if (filters.tenantId) {
            retryQuery.eq("tenant_id", filters.tenantId);
          }

          if (filters.planDate) {
            const planDateStr =
              typeof filters.planDate === "string"
                ? filters.planDate.slice(0, 10)
                : String(filters.planDate).slice(0, 10);
            retryQuery.eq("plan_date", planDateStr);
          } else if (filters.dateRange) {
            const startStr =
              typeof filters.dateRange.start === "string"
                ? filters.dateRange.start.slice(0, 10)
                : String(filters.dateRange.start).slice(0, 10);
            const endStr =
              typeof filters.dateRange.end === "string"
                ? filters.dateRange.end.slice(0, 10)
                : String(filters.dateRange.end).slice(0, 10);
            retryQuery.gte("plan_date", startStr).lte("plan_date", endStr);
          }

          const { data: retryData, error: retryError } = await retryQuery
            .order("plan_date", { ascending: true })
            .order("block_index", { ascending: true });

          if (!retryError && retryData) {
            // ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ì¶”ê°€ í•„í„°ë§
            let filtered = retryData as Plan[];

            if (filters.contentType) {
              filtered = filtered.filter(
                (plan) => plan.content_type === filters.contentType
              );
            }

            if (filters.planGroupIds && filters.planGroupIds.length > 0) {
              const activeGroupIdsSet = new Set(filters.planGroupIds);
              filtered = filtered.filter(
                (plan) =>
                  plan.plan_group_id &&
                  activeGroupIdsSet.has(plan.plan_group_id)
              );
            }

            return filtered;
          }
        } catch (retryError) {
          console.warn(
            `[data/studentPlans] ì¬ì‹œë„ ${attempt}ë²ˆì§¸ ì‹¤íŒ¨:`,
            retryError
          );
        }
      }

      console.error("[data/studentPlans] ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨, ë¹ˆ ë°°ì—´ ë°˜í™˜");
      return [];
    }

    // ì¼ë°˜ ì—ëŸ¬ ì²˜ë¦¬
    console.error("[data/studentPlans] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", {
      errorCode: supabaseError?.code,
      errorMessage: isHtmlError
        ? "ì„œë²„ ì—ëŸ¬ (HTML ì‘ë‹µ)"
        : errorMessage.substring(0, 200),
      filters: {
        studentId: filters.studentId,
        dateRange: filters.dateRange,
        planDate: filters.planDate,
        contentType: filters.contentType,
        planGroupIdsCount: filters.planGroupIds?.length || 0,
      },
    });

    // planGroupIds í•„í„°ë§ì´ ë¬¸ì œì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ í´ë°± ì‹œë„
    if (filters.planGroupIds && filters.planGroupIds.length > 0) {
      console.warn(
        "[data/studentPlans] planGroupIds í•„í„°ë§ ì‹¤íŒ¨, ì „ì²´ ì¡°íšŒë¡œ í´ë°±"
      );

      // planGroupIds ì—†ì´ ë‹¤ì‹œ ì‹œë„
      const fallbackFilters: PlanFilters = {
        studentId: filters.studentId,
        tenantId: filters.tenantId,
        planDate: filters.planDate
          ? typeof filters.planDate === "string"
            ? filters.planDate.slice(0, 10)
            : String(filters.planDate).slice(0, 10)
          : undefined,
        dateRange: filters.dateRange
          ? {
              start:
                typeof filters.dateRange.start === "string"
                  ? filters.dateRange.start.slice(0, 10)
                  : String(filters.dateRange.start).slice(0, 10),
              end:
                typeof filters.dateRange.end === "string"
                  ? filters.dateRange.end.slice(0, 10)
                  : String(filters.dateRange.end).slice(0, 10),
            }
          : undefined,
        contentType: filters.contentType,
        // planGroupIdsëŠ” ì œì™¸
      };

      try {
        const fallbackData = await getPlansForStudent(fallbackFilters);
        // ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ í•„í„°ë§
        const activeGroupIdsSet = new Set(filters.planGroupIds);
        const filtered = fallbackData.filter(
          (plan) =>
            plan.plan_group_id && activeGroupIdsSet.has(plan.plan_group_id)
        );
        return filtered;
      } catch (fallbackError) {
        console.error("[data/studentPlans] í´ë°± ì¡°íšŒë„ ì‹¤íŒ¨:", fallbackError);
      }
    }

    return [];
  }

  return (data as Plan[] | null) ?? [];
}

/**
 * í”Œëœ IDë¡œ í”Œëœ ì¡°íšŒ
 */
export async function getPlanById(
  planId: string,
  studentId: string,
  tenantId?: string | null
): Promise<Plan | null> {
  const supabase = await createSupabaseServerClient();

  const selectPlan = () =>
    supabase
      .from("student_plan")
      .select(
        "id,tenant_id,student_id,plan_date,block_index,content_type,content_id,chapter,planned_start_page_or_time,planned_end_page_or_time,completed_amount,progress,is_reschedulable,plan_group_id,start_time,end_time,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count,plan_number,sequence,day_type,week,day,is_partial,is_continued,content_title,content_subject,content_subject_category,content_category,memo,created_at,updated_at"
      )
      .eq("id", planId)
      .eq("student_id", studentId);

  let query = selectPlan();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<Plan>();

  if (error && error.code === "42703") {
    ({ data, error } = await selectPlan().maybeSingle<Plan>());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[data/studentPlans] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * í”Œëœ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type CreatePlanInput = {
  tenant_id: string | null;
  student_id: string;
  plan_date: string;
  block_index: number;
  content_type: "book" | "lecture" | "custom";
  content_id: string;
  chapter?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
  is_reschedulable: boolean;
  /** ë…¼ë¦¬ í”Œëœ ì•„ì´í…œ ID (plan_group_items í…Œì´ë¸” ì°¸ì¡°) */
  origin_plan_item_id?: string | null;
  /** í”Œëœ ê·¸ë£¹ ID */
  plan_group_id?: string | null;
  /** ì‹œì‘ ì‹œê°„ (HH:mm) */
  start_time?: string | null;
  /** ì¢…ë£Œ ì‹œê°„ (HH:mm) */
  end_time?: string | null;
};

/**
 * í”Œëœ ìƒì„±
 *
 * @param plan - í”Œëœ ìƒì„± ì •ë³´
 * @returns ìƒì„± ê²°ê³¼
 *
 * @see docs/refactoring/plan_flow_documentation.md
 */
export async function createPlan(
  plan: CreatePlanInput
): Promise<{ success: boolean; planId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, unknown> = {
    tenant_id: plan.tenant_id,
    student_id: plan.student_id,
    plan_date: plan.plan_date,
    block_index: plan.block_index,
    content_type: plan.content_type,
    content_id: plan.content_id,
    chapter: plan.chapter || null,
    planned_start_page_or_time: plan.planned_start_page_or_time || null,
    planned_end_page_or_time: plan.planned_end_page_or_time || null,
    is_reschedulable: plan.is_reschedulable,
  };

  // origin_plan_item_idê°€ ìˆìœ¼ë©´ ì¶”ê°€ (ë…¼ë¦¬ í”Œëœ ì—°ê²°)
  if (plan.origin_plan_item_id) {
    payload.origin_plan_item_id = plan.origin_plan_item_id;
  }

  // plan_group_idê°€ ìˆìœ¼ë©´ ì¶”ê°€
  if (plan.plan_group_id) {
    payload.plan_group_id = plan.plan_group_id;
  }

  // ì‹œê°„ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€ (Time ëª¨ë“œ)
  if (plan.start_time) {
    payload.start_time = plan.start_time;
  }
  if (plan.end_time) {
    payload.end_time = plan.end_time;
  }

  let { data, error } = await supabase
    .from("student_plan")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const {
      tenant_id: _tenantId,
      student_id: _studentId,
      ...fallbackPayload
    } = payload;
    ({ data, error } = await supabase
      .from("student_plan")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentPlans] í”Œëœ ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, planId: data?.id };
}

/**
 * í”Œëœ ì—…ë°ì´íŠ¸ (ì•ˆì „ ë²„ì „)
 * - í—ˆìš©ëœ í•„ë“œë§Œ ì—…ë°ì´íŠ¸ ê°€ëŠ¥
 * - êµ¬ì¡°ì  ë³€ê²½(content_type, content_id ë“±)ì€ ê¸ˆì§€
 * @see docs/refactoring/03_phase_todo_list.md [P2-8]
 */
export async function updatePlanSafe(
  planId: string,
  studentId: string,
  updates: AllowedPlanUpdates
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, unknown> = {};
  if (updates.plan_date !== undefined) payload.plan_date = updates.plan_date;
  if (updates.block_index !== undefined)
    payload.block_index = updates.block_index;
  if (updates.planned_start_page_or_time !== undefined)
    payload.planned_start_page_or_time = updates.planned_start_page_or_time;
  if (updates.planned_end_page_or_time !== undefined)
    payload.planned_end_page_or_time = updates.planned_end_page_or_time;
  if (updates.completed_amount !== undefined)
    payload.completed_amount = updates.completed_amount;
  if (updates.progress !== undefined) payload.progress = updates.progress;
  if (updates.actual_start_time !== undefined)
    payload.actual_start_time = updates.actual_start_time;
  if (updates.actual_end_time !== undefined)
    payload.actual_end_time = updates.actual_end_time;
  if (updates.total_duration_seconds !== undefined)
    payload.total_duration_seconds = updates.total_duration_seconds;
  if (updates.paused_duration_seconds !== undefined)
    payload.paused_duration_seconds = updates.paused_duration_seconds;
  if (updates.pause_count !== undefined)
    payload.pause_count = updates.pause_count;
  if (updates.memo !== undefined) payload.memo = updates.memo;
  if (updates.is_reschedulable !== undefined)
    payload.is_reschedulable = updates.is_reschedulable;
  if (updates.chapter !== undefined) payload.chapter = updates.chapter;

  if (Object.keys(payload).length === 0) {
    return { success: true }; // ì—…ë°ì´íŠ¸í•  ë‚´ìš© ì—†ìŒ
  }

  let { error } = await supabase
    .from("student_plan")
    .update(payload)
    .eq("id", planId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_plan")
      .update(payload)
      .eq("id", planId));
  }

  if (error) {
    console.error("[data/studentPlans] í”Œëœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (safe)", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í”Œëœ ì—…ë°ì´íŠ¸ (ë ˆê±°ì‹œ - í•˜ìœ„ í˜¸í™˜ì„±ìš©)
 * @deprecated updatePlanSafe ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤
 */
export async function updatePlan(
  planId: string,
  studentId: string,
  updates: {
    plan_date?: string;
    block_index?: number;
    content_type?: "book" | "lecture" | "custom";
    content_id?: string;
    chapter?: string | null;
    planned_start_page_or_time?: number | null;
    planned_end_page_or_time?: number | null;
    completed_amount?: number | null;
    progress?: number | null;
    is_reschedulable?: boolean;
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // ê¸ˆì§€ëœ í•„ë“œ ì‚¬ìš© ê²½ê³ 
  const forbiddenUsed = Object.keys(updates).filter((key) =>
    FORBIDDEN_UPDATE_FIELDS.includes(key as ForbiddenPlanUpdateFields)
  );
  if (forbiddenUsed.length > 0) {
    console.warn(
      `[data/studentPlans] êµ¬ì¡°ì  í•„ë“œ ì—…ë°ì´íŠ¸ ì‹œë„: ${forbiddenUsed.join(
        ", "
      )}. ` +
        `ì´ í•„ë“œë“¤ì€ í”Œëœê·¸ë£¹ ë ˆë²¨ì—ì„œ ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤. updatePlanSafe() ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.`
    );
  }

  const payload: Record<string, unknown> = {};
  if (updates.plan_date !== undefined) payload.plan_date = updates.plan_date;
  if (updates.block_index !== undefined)
    payload.block_index = updates.block_index;
  if (updates.content_type !== undefined)
    payload.content_type = updates.content_type;
  if (updates.content_id !== undefined) payload.content_id = updates.content_id;
  if (updates.chapter !== undefined) payload.chapter = updates.chapter;
  if (updates.planned_start_page_or_time !== undefined)
    payload.planned_start_page_or_time = updates.planned_start_page_or_time;
  if (updates.planned_end_page_or_time !== undefined)
    payload.planned_end_page_or_time = updates.planned_end_page_or_time;
  if (updates.completed_amount !== undefined)
    payload.completed_amount = updates.completed_amount;
  if (updates.progress !== undefined) payload.progress = updates.progress;
  if (updates.is_reschedulable !== undefined)
    payload.is_reschedulable = updates.is_reschedulable;

  let { error } = await supabase
    .from("student_plan")
    .update(payload)
    .eq("id", planId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_plan")
      .update(payload)
      .eq("id", planId));
  }

  if (error) {
    console.error("[data/studentPlans] í”Œëœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í”Œëœ ì‚­ì œ
 */
export async function deletePlan(
  planId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_plan")
    .delete()
    .eq("id", planId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("student_plan").delete().eq("id", planId));
  }

  if (error) {
    console.error("[data/studentPlans] í”Œëœ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ì—¬ëŸ¬ í”Œëœ ì¼ê´„ ì‚­ì œ
 */
export async function deletePlans(
  planIds: string[],
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  if (planIds.length === 0) {
    return { success: true };
  }

  // SupabaseëŠ” í•œ ë²ˆì— ìµœëŒ€ 100ê°œê¹Œì§€ ì‚­ì œ ê°€ëŠ¥
  const batchSize = 100;
  for (let i = 0; i < planIds.length; i += batchSize) {
    const batch = planIds.slice(i, i + batchSize);

    let { error } = await supabase
      .from("student_plan")
      .delete()
      .in("id", batch)
      .eq("student_id", studentId);

    if (error && error.code === "42703") {
      ({ error } = await supabase
        .from("student_plan")
        .delete()
        .in("id", batch));
    }

    if (error) {
      console.error("[data/studentPlans] í”Œëœ ì¼ê´„ ì‚­ì œ ì‹¤íŒ¨", error);
      return { success: false, error: error.message };
    }
  }

  return { success: true };
}
</file>

<file path="studentProfiles.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type StudentProfile = {
  id: string;
  tenant_id?: string | null;
  gender?: "ë‚¨" | "ì—¬" | null;
  phone?: string | null;
  profile_image_url?: string | null;
  mother_phone?: string | null;
  father_phone?: string | null;
  address?: string | null;
  address_detail?: string | null;
  postal_code?: string | null;
  emergency_contact?: string | null;
  emergency_contact_phone?: string | null;
  medical_info?: string | null;
  bio?: string | null;
  interests?: string[] | null;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * í•™ìƒ IDë¡œ í”„ë¡œí•„ ì •ë³´ ì¡°íšŒ
 */
export async function getStudentProfileById(
  studentId: string
): Promise<StudentProfile | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_profiles")
    .select("*")
    .eq("id", studentId)
    .maybeSingle<StudentProfile>();

  if (error && error.code !== "PGRST116") {
    console.error("[data/studentProfiles] í”„ë¡œí•„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * í”„ë¡œí•„ ì •ë³´ ìƒì„±/ì—…ë°ì´íŠ¸
 */
export async function upsertStudentProfile(
  profile: {
    id: string;
    tenant_id?: string | null;
    gender?: "ë‚¨" | "ì—¬" | null;
    phone?: string | null;
    profile_image_url?: string | null;
    mother_phone?: string | null;
    father_phone?: string | null;
    address?: string | null;
    address_detail?: string | null;
    postal_code?: string | null;
    emergency_contact?: string | null;
    emergency_contact_phone?: string | null;
    medical_info?: string | null;
    bio?: string | null;
    interests?: string[] | null;
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    id: profile.id,
    tenant_id: profile.tenant_id ?? null,
    gender: profile.gender ?? null,
    phone: profile.phone ?? null,
    profile_image_url: profile.profile_image_url ?? null,
    mother_phone: profile.mother_phone ?? null,
    father_phone: profile.father_phone ?? null,
    address: profile.address ?? null,
    address_detail: profile.address_detail ?? null,
    postal_code: profile.postal_code ?? null,
    emergency_contact: profile.emergency_contact ?? null,
    emergency_contact_phone: profile.emergency_contact_phone ?? null,
    medical_info: profile.medical_info ?? null,
    bio: profile.bio ?? null,
    interests: profile.interests ?? null,
  };

  const { error } = await supabase
    .from("student_profiles")
    .upsert(payload, { onConflict: "id" });

  if (error) {
    console.error("[data/studentProfiles] í”„ë¡œí•„ ì €ì¥ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="students.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { executeQuery, executeSingleQuery } from "./core/queryBuilder";
import type { SupabaseServerClient } from "./core/types";

export type Student = {
  id: string;
  tenant_id?: string | null;
  name?: string | null;
  grade?: string | null;
  class?: string | null;
  birth_date?: string | null;
  school_id?: string | null; // í†µí•© ID (SCHOOL_123 ë˜ëŠ” UNIV_456)
  school_type?: "MIDDLE" | "HIGH" | "UNIVERSITY" | null;
  student_number?: string | null;
  enrolled_at?: string | null;
  status?: "enrolled" | "on_leave" | "graduated" | "transferred" | null;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * í•™ìƒ IDë¡œ í•™ìƒ ì •ë³´ ì¡°íšŒ
 */
export async function getStudentById(
  studentId: string,
  tenantId?: string | null
): Promise<Student | null> {
  const supabase = await createSupabaseServerClient();

  // ê¸°ë³¸ í•™ì  ì •ë³´ë§Œ ì¡°íšŒ (í”„ë¡œí•„/ì§„ë¡œ ì •ë³´ëŠ” ë³„ë„ í…Œì´ë¸”ì—ì„œ ì¡°íšŒ)
  // name í•„ë“œë„ í¬í•¨í•˜ì—¬ ì¡°íšŒ
  // school_type ì»¬ëŸ¼ì€ ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ì¶”ê°€ë˜ë¯€ë¡œ, ì—ëŸ¬ ë°œìƒ ì‹œ ì¬ì‹œë„
  let { data, error } = await supabase
    .from("students")
    .select("id,tenant_id,name,grade,class,birth_date,school_id,school_type,student_number,enrolled_at,status,created_at,updated_at")
    .eq("id", studentId)
    .maybeSingle<Student>();
  
  // school_type ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ (42703 ì—ëŸ¬) school_type ì—†ì´ ì¬ì‹œë„
  if (error && error.code === "42703" && error.message?.includes("school_type")) {
    const retryResult = await supabase
      .from("students")
      .select("id,tenant_id,name,grade,class,birth_date,school_id,student_number,enrolled_at,status,created_at,updated_at")
      .eq("id", studentId)
      .maybeSingle<Student>();
    
    data = retryResult.data;
    error = retryResult.error;
    
    // school_typeì´ ì—†ìœ¼ë©´ nullë¡œ ì„¤ì •
    if (data) {
      data = { ...data, school_type: null };
    }
  }

  if (error) {
    // PGRST116ì€ ë ˆì½”ë“œê°€ ì—†ëŠ” ê²½ìš°ì´ë¯€ë¡œ null ë°˜í™˜
    if (error.code === "PGRST116") {
      return null;
    }
    console.error("[data/students] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", {
      studentId,
      error: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
    });
    return null;
  }

  return data ?? null;
}

/**
 * Tenant IDë¡œ í•™ìƒ ëª©ë¡ ì¡°íšŒ
 * @deprecated tenant_idëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëª¨ë“  í•™ìƒì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
export async function listStudentsByTenant(
  tenantId: string | null
): Promise<Student[]> {
  const supabase = await createSupabaseServerClient();

  // ê¸°ë³¸ í•™ì  ì •ë³´ë§Œ ì¡°íšŒ
  const result = await executeQuery<Student[]>(
    async () => {
      const queryResult = await supabase
        .from("students")
        .select("id,tenant_id,grade,class,birth_date,school_id,student_number,enrolled_at,status,created_at,updated_at")
        .order("created_at", { ascending: false });
      return queryResult;
    },
    {
      context: "[data/students]",
      defaultValue: [],
    }
  );

  return result ?? [];
}

/**
 * í•™ìƒ ê¸°ë³¸ ì •ë³´ ìƒì„±/ì—…ë°ì´íŠ¸
 */
/**
 * school_idì—ì„œ school_type ì¶”ì¶œ
 */
function extractSchoolType(schoolId: string | null | undefined): "MIDDLE" | "HIGH" | "UNIVERSITY" | null {
  if (!schoolId) return null;
  
  if (schoolId.startsWith("SCHOOL_")) {
    // school_info í…Œì´ë¸”ì˜ ê²½ìš°, ì‹¤ì œ ì¡°íšŒí•´ì„œ school_level í™•ì¸ í•„ìš”
    // í•˜ì§€ë§Œ ì—¬ê¸°ì„œëŠ” ì¼ë‹¨ null ë°˜í™˜ (ë‚˜ì¤‘ì— ì¡°íšŒí•´ì„œ ì„¤ì •)
    return null;
  } else if (schoolId.startsWith("UNIV_")) {
    return "UNIVERSITY";
  }
  
  return null;
}

export async function upsertStudent(
  student: {
    id: string;
    tenant_id: string | null;
    name?: string | null;
    grade: string;
    class: string;
    birth_date: string;
    school_id?: string | null;
    school_type?: "MIDDLE" | "HIGH" | "UNIVERSITY" | null;
    student_number?: string | null;
    enrolled_at?: string | null;
    status?: "enrolled" | "on_leave" | "graduated" | "transferred" | null;
  }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // tenant_idê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ tenant ì¡°íšŒ
  let tenantId = student.tenant_id;
  if (!tenantId) {
    const { data: defaultTenant, error: tenantError } = await supabase
      .from("tenants")
      .select("id")
      .eq("name", "Default Tenant")
      .maybeSingle();

    if (tenantError) {
      console.error("[data/students] Default Tenant ì¡°íšŒ ì‹¤íŒ¨", tenantError);
      return {
        success: false,
        error: "ê¸°ë³¸ ê¸°ê´€ ì •ë³´ë¥¼ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    if (!defaultTenant) {
      console.error("[data/students] Default Tenantê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      return {
        success: false,
        error:
          "ê¸°ë³¸ ê¸°ê´€ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.",
      };
    }

    tenantId = defaultTenant.id;
  }

  // ê¸°ì¡´ í•™ìƒ ì •ë³´ ì¡°íšŒ (nameì´ ì—†ì„ ê²½ìš° ê¸°ì¡´ ê°’ ìœ ì§€)
  let nameValue = student.name;
  if (!nameValue) {
    const { data: existingStudent } = await supabase
      .from("students")
      .select("name")
      .eq("id", student.id)
      .maybeSingle();
    
    if (existingStudent?.name) {
      nameValue = existingStudent.name;
    }
  }

  // school_type ìë™ ì¶”ì¶œ (school_idì—ì„œ)
  let schoolType = student.school_type;
  if (!schoolType && student.school_id) {
    schoolType = extractSchoolType(student.school_id);
    
    // SCHOOL_ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš° ì‹¤ì œ ì¡°íšŒí•´ì„œ school_level í™•ì¸
    if (!schoolType && student.school_id.startsWith("SCHOOL_")) {
      try {
        const { getSchoolByUnifiedId } = await import("@/lib/data/schools");
        const school = await getSchoolByUnifiedId(student.school_id);
        if (school) {
          schoolType = school.school_type;
        }
      } catch (error) {
        console.error("[data/students] school_type ì¡°íšŒ ì‹¤íŒ¨:", error);
      }
    }
  }

  const payload: Record<string, any> = {
    id: student.id,
    tenant_id: tenantId,
    grade: student.grade,
    class: student.class,
    birth_date: student.birth_date,
    school_id: student.school_id ?? null,
    student_number: student.student_number ?? null,
    enrolled_at: student.enrolled_at ?? null,
    status: student.status ?? "enrolled",
  };
  
  // nameì´ ìˆìœ¼ë©´ payloadì— ì¶”ê°€
  if (nameValue !== undefined) {
    payload.name = nameValue;
  }
  
  // school_typeì´ ìˆìœ¼ë©´ ì¶”ê°€ (ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ì»¬ëŸ¼ì´ ìˆì„ ë•Œë§Œ)
  if (schoolType) {
    payload.school_type = schoolType;
  }

  const { error } = await supabase
    .from("students")
    .upsert(payload, { onConflict: "id" });

  // school_type ì»¬ëŸ¼ì´ ì—†ì–´ì„œ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ school_type ì œê±°í•˜ê³  ì¬ì‹œë„
  if (error && error.code === "42703" && error.message?.includes("school_type")) {
    delete payload.school_type;
    const retryResult = await supabase
      .from("students")
      .upsert(payload, { onConflict: "id" });
    
    if (retryResult.error) {
      console.error("[data/students] í•™ìƒ ì •ë³´ ì €ì¥ ì‹¤íŒ¨", retryResult.error);
      return { success: false, error: retryResult.error.message };
    }
    
    console.warn("[data/students] school_type ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.");
  } else if (error) {
    console.error("[data/students] í•™ìƒ ì •ë³´ ì €ì¥ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="studentScores.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  getOrCreateStudentTerm,
  calculateSchoolYear,
} from "@/lib/data/studentTerms";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

// í†µí•© ì„±ì  íƒ€ì… (student_scores í…Œì´ë¸”)
export type StudentScore = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  subject_type: string;
  semester?: string | null;
  course: string;
  course_detail: string;
  raw_score: number;
  grade: number;
  score_type_detail?: string | null;
  test_date?: string | null;
  created_at?: string | null;
};

// ë‚´ì‹  ì„±ì  íƒ€ì… (ì •ê·œí™” ë²„ì „)
export type InternalScore = {
  id: string;
  tenant_id: string;
  student_id: string;
  curriculum_revision_id: string;
  subject_group_id: string;
  subject_type_id: string;
  subject_id: string;
  grade: number;
  semester: number;
  credit_hours: number;
  raw_score: number | null;
  avg_score: number | null;
  std_dev: number | null;
  rank_grade: number | null;
  total_students: number | null;
  created_at: string;
  updated_at: string;
};

// ë‚´ì‹  ì„±ì  íƒ€ì… (ë ˆê±°ì‹œ - í•˜ìœ„ í˜¸í™˜ì„±)
/** @deprecated InternalScoreë¥¼ ì‚¬ìš©í•˜ì„¸ìš” */
export type SchoolScore = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  grade: number;
  semester: number;
  // FK í•„ë“œ (ìƒˆë¡œìš´ ë°©ì‹)
  subject_group_id?: string | null;
  subject_id?: string | null;
  subject_type_id?: string | null;
  // Deprecated: í…ìŠ¤íŠ¸ í•„ë“œ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
  /** @deprecated subject_group_idë¥¼ ì‚¬ìš©í•˜ì„¸ìš” */
  subject_group?: string | null;
  /** @deprecated subject_type_idë¥¼ ì‚¬ìš©í•˜ì„¸ìš” */
  subject_type?: string | null;
  /** @deprecated subject_idë¥¼ ì‚¬ìš©í•˜ì„¸ìš” */
  subject_name?: string | null;
  credit_hours?: number | null;
  raw_score?: number | null;
  subject_average?: number | null;
  standard_deviation?: number | null;
  grade_score?: number | null;
  total_students?: number | null;
  rank_grade?: number | null;
  class_rank?: number | null;
  created_at?: string | null;
};

// ëª¨ì˜ê³ ì‚¬ ì„±ì  íƒ€ì… (ì •ê·œí™” ë²„ì „)
export type MockScore = {
  id: string;
  tenant_id: string;
  student_id: string;
  exam_date: string; // date í˜•ì‹: YYYY-MM-DD
  exam_title: string;
  grade: number;
  subject_id: string;
  subject_group_id: string;
  standard_score: number | null;
  percentile: number | null;
  grade_score: number | null;
  raw_score: number | null;
  created_at: string;
  updated_at: string;
};

/**
 * í†µí•© ì„±ì  ëª©ë¡ ì¡°íšŒ (student_scores)
 */
export async function getStudentScores(
  studentId: string,
  tenantId?: string | null,
  filters?: {
    subjectType?: string;
    semester?: string;
    course?: string;
  }
): Promise<StudentScore[]> {
  const supabase = await createSupabaseServerClient();

  const selectScores = () =>
    supabase.from("student_scores").select("*").eq("student_id", studentId);

  let query = selectScores();

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.subjectType) {
    query = query.eq("subject_type", filters.subjectType);
  }

  if (filters?.semester) {
    query = query.eq("semester", filters.semester);
  }

  if (filters?.course) {
    query = query.eq("course", filters.course);
  }

  query = query
    .order("test_date", { ascending: false })
    .order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase.from("student_scores").select("*");

    if (filters?.subjectType) {
      fallbackQuery.eq("subject_type", filters.subjectType);
    }

    if (filters?.semester) {
      fallbackQuery.eq("semester", filters.semester);
    }

    if (filters?.course) {
      fallbackQuery.eq("course", filters.course);
    }

    ({ data, error } = await fallbackQuery
      .order("test_date", { ascending: false })
      .order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentScores] í†µí•© ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as StudentScore[] | null) ?? [];
}

/**
 * í†µí•© ì„±ì  ìƒì„±
 */
export async function createStudentScore(score: {
  tenant_id?: string | null;
  student_id: string;
  subject_type: string;
  semester?: string | null;
  course: string;
  course_detail: string;
  raw_score: number;
  grade: number;
  score_type_detail?: string | null;
  test_date?: string | null;
}): Promise<{ success: boolean; scoreId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: score.tenant_id || null,
    student_id: score.student_id,
    subject_type: score.subject_type,
    semester: score.semester || null,
    course: score.course,
    course_detail: score.course_detail,
    raw_score: score.raw_score,
    grade: score.grade,
    score_type_detail: score.score_type_detail || null,
    test_date: score.test_date || null,
  };

  let { data, error } = await supabase
    .from("student_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const {
      tenant_id: _tenantId,
      student_id: _studentId,
      ...fallbackPayload
    } = payload;
    ({ data, error } = await supabase
      .from("student_scores")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentScores] í†µí•© ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, scoreId: data?.id };
}

/**
 * í†µí•© ì„±ì  ì—…ë°ì´íŠ¸
 */
export async function updateStudentScore(
  scoreId: string,
  studentId: string,
  updates: Partial<Omit<StudentScore, "id" | "student_id" | "created_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.subject_type !== undefined)
    payload.subject_type = updates.subject_type;
  if (updates.semester !== undefined) payload.semester = updates.semester;
  if (updates.course !== undefined) payload.course = updates.course;
  if (updates.course_detail !== undefined)
    payload.course_detail = updates.course_detail;
  if (updates.raw_score !== undefined) payload.raw_score = updates.raw_score;
  if (updates.grade !== undefined) payload.grade = updates.grade;
  if (updates.score_type_detail !== undefined)
    payload.score_type_detail = updates.score_type_detail;
  if (updates.test_date !== undefined) payload.test_date = updates.test_date;

  let { error } = await supabase
    .from("student_scores")
    .update(payload)
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_scores")
      .update(payload)
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] í†µí•© ì„±ì  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * í†µí•© ì„±ì  ì‚­ì œ
 */
export async function deleteStudentScore(
  scoreId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_scores")
    .delete()
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_scores")
      .delete()
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] í†µí•© ì„±ì  ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ (ì •ê·œí™” ë²„ì „)
 */
export async function getInternalScores(
  studentId: string,
  tenantId: string,
  filters?: {
    grade?: number;
    semester?: number;
    subjectGroupId?: string;
  }
): Promise<InternalScore[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_internal_scores")
    .select("*")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId);

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.semester) {
    query = query.eq("semester", filters.semester);
  }

  if (filters?.subjectGroupId) {
    query = query.eq("subject_group_id", filters.subjectGroupId);
  }

  const { data, error } = await query
    .order("grade", { ascending: true })
    .order("semester", { ascending: true })
    .order("created_at", { ascending: false });

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as InternalScore[] | null) ?? [];
}

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ (ë ˆê±°ì‹œ)
 *
 * âš ï¸ ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” student_school_scores í…Œì´ë¸”ì„ ì°¸ì¡°í•©ë‹ˆë‹¤.
 *
 * @deprecated getInternalScoresë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜, í†µí•© ëŒ€ì‹œë³´ë“œì˜ ê²½ìš° fetchScoreDashboard APIë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
 */
export async function getSchoolScores(
  studentId: string,
  tenantId?: string | null,
  filters?: {
    grade?: number;
    semester?: number;
    subjectGroup?: string;
  }
): Promise<SchoolScore[]> {
  console.warn(
    "[DEPRECATED] getSchoolScoresëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. getInternalScores ë˜ëŠ” fetchScoreDashboard APIë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
  );

  const supabase = await createSupabaseServerClient();

  const selectScores = () =>
    supabase
      .from("student_internal_scores") // student_school_scores -> student_internal_scores
      .select("*")
      .eq("student_id", studentId);

  let query = selectScores();

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.semester) {
    query = query.eq("semester", filters.semester);
  }

  if (filters?.subjectGroup) {
    query = query.eq("subject_group", filters.subjectGroup);
  }

  query = query
    .order("grade", { ascending: true })
    .order("semester", { ascending: true })
    .order("created_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    // âš ï¸ student_school_scoresëŠ” student_internal_scoresë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.
    const fallbackQuery = supabase.from("student_internal_scores").select("*");

    if (filters?.grade) {
      fallbackQuery.eq("grade", filters.grade);
    }

    if (filters?.semester) {
      fallbackQuery.eq("semester", filters.semester);
    }

    if (filters?.subjectGroup) {
      fallbackQuery.eq("subject_group", filters.subjectGroup);
    }

    ({ data, error } = await fallbackQuery
      .order("grade", { ascending: true })
      .order("semester", { ascending: true })
      .order("created_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as SchoolScore[] | null) ?? [];
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ëª©ë¡ ì¡°íšŒ (ì •ê·œí™” ë²„ì „)
 */
export async function getMockScores(
  studentId: string,
  tenantId: string,
  filters?: {
    grade?: number;
    examTitle?: string;
    examDate?: string;
    subjectGroupId?: string;
  }
): Promise<MockScore[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_mock_scores")
    .select("*")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId);

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.examTitle) {
    query = query.eq("exam_title", filters.examTitle);
  }

  if (filters?.examDate) {
    query = query.eq("exam_date", filters.examDate);
  }

  if (filters?.subjectGroupId) {
    query = query.eq("subject_group_id", filters.subjectGroupId);
  }

  const { data, error } = await query
    .order("exam_date", { ascending: false })
    .order("created_at", { ascending: false });

  if (error) {
    console.error("[data/studentScores] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as MockScore[] | null) ?? [];
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± (ì •ê·œí™” ë²„ì „)
 *
 * student_termsë¥¼ ì¡°íšŒ/ìƒì„±í•˜ì—¬ student_term_idë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.
 */
export async function createInternalScore(score: {
  tenant_id: string;
  student_id: string;
  curriculum_revision_id: string;
  subject_group_id: string;
  subject_type_id: string;
  subject_id: string;
  grade: number;
  semester: number;
  credit_hours: number;
  raw_score?: number | null;
  avg_score?: number | null;
  std_dev?: number | null;
  rank_grade?: number | null;
  total_students?: number | null;
  school_year?: number; // í•™ë…„ë„ (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ í˜„ì¬ ë‚ ì§œ ê¸°ì¤€ ê³„ì‚°)
}): Promise<{ success: boolean; scoreId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // school_year ê³„ì‚° (ì—†ìœ¼ë©´ í˜„ì¬ ë‚ ì§œ ê¸°ì¤€)
  const school_year = score.school_year ?? calculateSchoolYear();

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„±
  let student_term_id: string;
  try {
    student_term_id = await getOrCreateStudentTerm({
      tenant_id: score.tenant_id,
      student_id: score.student_id,
      school_year,
      grade: score.grade,
      semester: score.semester,
      curriculum_revision_id: score.curriculum_revision_id,
    });
  } catch (error) {
    console.error("[data/studentScores] student_term ì¡°íšŒ/ìƒì„± ì‹¤íŒ¨", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "student_term ì¡°íšŒ/ìƒì„± ì‹¤íŒ¨",
    };
  }

  const payload = {
    tenant_id: score.tenant_id,
    student_id: score.student_id,
    student_term_id, // student_term_id ì¶”ê°€
    curriculum_revision_id: score.curriculum_revision_id,
    subject_group_id: score.subject_group_id,
    subject_type_id: score.subject_type_id,
    subject_id: score.subject_id,
    grade: score.grade,
    semester: score.semester,
    credit_hours: score.credit_hours,
    raw_score: score.raw_score ?? null,
    avg_score: score.avg_score ?? null,
    std_dev: score.std_dev ?? null,
    rank_grade: score.rank_grade ?? null,
    total_students: score.total_students ?? null,
  };

  const { data, error } = await supabase
    .from("student_internal_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, scoreId: data?.id };
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± (ë ˆê±°ì‹œ)
 * @deprecated createInternalScoreë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export async function createSchoolScore(score: {
  tenant_id?: string | null;
  student_id: string;
  grade: number;
  semester: number;
  // FK í•„ë“œ (ìš°ì„  ì‚¬ìš©)
  subject_group_id?: string | null;
  subject_id?: string | null;
  subject_type_id?: string | null;
  // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ í•„ë“œ (deprecated)
  subject_group?: string | null;
  subject_type?: string | null;
  subject_name?: string | null;
  credit_hours?: number | null;
  raw_score?: number | null;
  subject_average?: number | null;
  standard_deviation?: number | null;
  grade_score?: number | null;
  total_students?: number | null;
  rank_grade?: number | null;
}): Promise<{ success: boolean; scoreId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {
    tenant_id: score.tenant_id || null,
    student_id: score.student_id,
    grade: score.grade,
    semester: score.semester,
    // FK í•„ë“œ (ìš°ì„  ì‚¬ìš©)
    subject_group_id: score.subject_group_id || null,
    subject_id: score.subject_id || null,
    subject_type_id: score.subject_type_id || null,
    // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ í•„ë“œ (deprecated)
    subject_group: score.subject_group || null,
    subject_type: score.subject_type || null,
    subject_name: score.subject_name || null,
    credit_hours: score.credit_hours || null,
    raw_score: score.raw_score || null,
    subject_average: score.subject_average || null,
    standard_deviation: score.standard_deviation || null,
    grade_score: score.grade_score || null,
    total_students: score.total_students || null,
    rank_grade: score.rank_grade || null,
  };

  let { data, error } = await supabase
    .from("student_school_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const {
      tenant_id: _tenantId,
      student_id: _studentId,
      ...fallbackPayload
    } = payload;
    ({ data, error } = await supabase
      .from("student_school_scores")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, scoreId: data?.id };
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± (ì •ê·œí™” ë²„ì „)
 *
 * student_termsë¥¼ ì¡°íšŒ/ìƒì„±í•˜ì—¬ student_term_idë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.
 * exam_dateë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•™ë…„ë„ì™€ í•™ê¸°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
 */
export async function createMockScore(score: {
  tenant_id: string;
  student_id: string;
  exam_date: string; // date í˜•ì‹: YYYY-MM-DD
  exam_title: string;
  grade: number;
  subject_id: string;
  subject_group_id: string;
  curriculum_revision_id: string; // student_term ìƒì„±ì— í•„ìš”
  raw_score?: number | null;
  standard_score?: number | null;
  percentile?: number | null;
  grade_score?: number | null;
  semester?: number; // í•™ê¸° (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ exam_date ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •)
}): Promise<{ success: boolean; scoreId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // exam_dateë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•™ë…„ë„ ê³„ì‚°
  const examDate = new Date(score.exam_date);
  const school_year = calculateSchoolYear(examDate);

  // í•™ê¸° ê³„ì‚° (ì—†ìœ¼ë©´ exam_date ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •: 3~8ì›” = 1í•™ê¸°, 9~2ì›” = 2í•™ê¸°)
  const semester =
    score.semester ??
    (examDate.getMonth() + 1 >= 3 && examDate.getMonth() + 1 <= 8 ? 1 : 2);

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„± (ì‹¤íŒ¨ ì‹œ NULL í—ˆìš©)
  let student_term_id: string | null = null;
  try {
    student_term_id = await getOrCreateStudentTerm({
      tenant_id: score.tenant_id,
      student_id: score.student_id,
      school_year,
      grade: score.grade,
      semester,
      curriculum_revision_id: score.curriculum_revision_id,
    });
  } catch (error) {
    // ëª¨ì˜ê³ ì‚¬ ì„±ì ì˜ ê²½ìš° student_term_idê°€ ì—†ì–´ë„ ì €ì¥ ê°€ëŠ¥
    console.warn(
      "[data/studentScores] student_term ì¡°íšŒ/ìƒì„± ì‹¤íŒ¨ (NULLë¡œ ì €ì¥)",
      error
    );
    // student_term_idëŠ” nullë¡œ ìœ ì§€
  }

  const payload = {
    tenant_id: score.tenant_id,
    student_id: score.student_id,
    student_term_id: student_term_id ?? null, // student_term_id (nullable)
    exam_date: score.exam_date,
    exam_title: score.exam_title,
    grade: score.grade,
    subject_id: score.subject_id,
    subject_group_id: score.subject_group_id,
    raw_score: score.raw_score ?? null,
    standard_score: score.standard_score ?? null,
    percentile: score.percentile ?? null,
    grade_score: score.grade_score ?? null,
  };

  const { data, error } = await supabase
    .from("student_mock_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error) {
    console.error("[data/studentScores] ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, scoreId: data?.id };
}

/**
 * ë‚´ì‹  ì„±ì  ì—…ë°ì´íŠ¸
 */
export async function updateSchoolScore(
  scoreId: string,
  studentId: string,
  updates: Partial<Omit<SchoolScore, "id" | "student_id" | "created_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.grade !== undefined) payload.grade = updates.grade;
  if (updates.semester !== undefined) payload.semester = updates.semester;
  // FK í•„ë“œ (ìš°ì„  ì‚¬ìš©)
  if (updates.subject_group_id !== undefined)
    payload.subject_group_id = updates.subject_group_id;
  if (updates.subject_id !== undefined) payload.subject_id = updates.subject_id;
  if (updates.subject_type_id !== undefined)
    payload.subject_type_id = updates.subject_type_id;
  // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ í•„ë“œ (deprecated)
  if (updates.subject_group !== undefined)
    payload.subject_group = updates.subject_group;
  if (updates.subject_type !== undefined)
    payload.subject_type = updates.subject_type;
  if (updates.subject_name !== undefined)
    payload.subject_name = updates.subject_name;
  if (updates.credit_hours !== undefined)
    payload.credit_hours = updates.credit_hours;
  if (updates.raw_score !== undefined) payload.raw_score = updates.raw_score;
  if (updates.subject_average !== undefined)
    payload.subject_average = updates.subject_average;
  if (updates.standard_deviation !== undefined)
    payload.standard_deviation = updates.standard_deviation;
  if (updates.grade_score !== undefined)
    payload.grade_score = updates.grade_score;
  if (updates.total_students !== undefined)
    payload.total_students = updates.total_students;
  if (updates.rank_grade !== undefined) payload.rank_grade = updates.rank_grade;

  let { error } = await supabase
    .from("student_school_scores")
    .update(payload)
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_school_scores")
      .update(payload)
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì—…ë°ì´íŠ¸
 */
export async function updateMockScore(
  scoreId: string,
  studentId: string,
  updates: Partial<Omit<MockScore, "id" | "student_id" | "created_at">>
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.grade !== undefined) payload.grade = updates.grade;
  // FK í•„ë“œ (ìš°ì„  ì‚¬ìš©)
  if (updates.subject_group_id !== undefined)
    payload.subject_group_id = updates.subject_group_id;
  if (updates.subject_id !== undefined) payload.subject_id = updates.subject_id;
  // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ í•„ë“œ (deprecated) - ì œê±°ë¨
  if (updates.raw_score !== undefined) payload.raw_score = updates.raw_score;
  if (updates.standard_score !== undefined)
    payload.standard_score = updates.standard_score;
  if (updates.percentile !== undefined) payload.percentile = updates.percentile;
  if (updates.grade_score !== undefined)
    payload.grade_score = updates.grade_score;

  let { error } = await supabase
    .from("student_mock_scores")
    .update(payload)
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_mock_scores")
      .update(payload)
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ë‚´ì‹  ì„±ì  ì‚­ì œ
 */
export async function deleteSchoolScore(
  scoreId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_school_scores")
    .delete()
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_school_scores")
      .delete()
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] ë‚´ì‹  ì„±ì  ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ
 */
export async function deleteMockScore(
  scoreId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_mock_scores")
    .delete()
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_mock_scores")
      .delete()
      .eq("id", scoreId));
  }

  if (error) {
    console.error("[data/studentScores] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="studentSessions.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

export type StudySession = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  plan_id?: string | null;
  content_type?: string | null;
  content_id?: string | null;
  started_at: string;
  ended_at?: string | null;
  duration_seconds?: number | null;
  paused_at?: string | null;
  resumed_at?: string | null;
  paused_duration_seconds?: number | null;
  created_at?: string | null;
  updated_at?: string | null;
};

export type SessionFilters = {
  studentId: string;
  tenantId?: string | null;
  dateRange?: {
    start: string;
    end: string;
  };
  planId?: string;
  isActive?: boolean; // ended_atì´ nullì¸ ì„¸ì…˜ë§Œ
};

/**
 * í•™ìŠµ ì„¸ì…˜ ëª©ë¡ ì¡°íšŒ
 */
export async function getSessionsInRange(
  filters: SessionFilters
): Promise<StudySession[]> {
  const supabase = await createSupabaseServerClient();

  const selectSessions = () =>
    supabase
      .from("student_study_sessions")
      .select(
        "id,tenant_id,student_id,plan_id,content_type,content_id,started_at,ended_at,duration_seconds,paused_at,resumed_at,paused_duration_seconds,created_at"
      )
      .eq("student_id", filters.studentId);

  let query = selectSessions();

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.planId) {
    query = query.eq("plan_id", filters.planId);
  }

  if (filters.isActive !== undefined) {
    if (filters.isActive) {
      query = query.is("ended_at", null);
    } else {
      query = query.not("ended_at", "is", null);
    }
  }

  if (filters.dateRange) {
    query = query
      .gte("started_at", filters.dateRange.start)
      .lte("started_at", filters.dateRange.end);
  }

  query = query.order("started_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase
      .from("student_study_sessions")
      .select("*")
      .eq("student_id", filters.studentId);

    if (filters.planId) {
      fallbackQuery.eq("plan_id", filters.planId);
    }

    if (filters.isActive !== undefined) {
      if (filters.isActive) {
        fallbackQuery.is("ended_at", null);
      } else {
        fallbackQuery.not("ended_at", "is", null);
      }
    }

    if (filters.dateRange) {
      fallbackQuery
        .gte("started_at", filters.dateRange.start)
        .lte("started_at", filters.dateRange.end);
    }

    ({ data, error } = await fallbackQuery.order("started_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentSessions] ì„¸ì…˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as StudySession[] | null) ?? [];
}

/**
 * í™œì„± ì„¸ì…˜ ì¡°íšŒ (ended_atì´ nullì¸ ì„¸ì…˜)
 */
export async function getActiveSession(
  studentId: string,
  tenantId?: string | null
): Promise<StudySession | null> {
  const sessions = await getSessionsInRange({
    studentId,
    tenantId,
    isActive: true,
  });

  return sessions.length > 0 ? sessions[0] : null;
}

/**
 * í”Œëœ ID ë°°ì—´ë¡œ í™œì„± ì„¸ì…˜ë§Œ ì¡°íšŒ (ìµœì í™”ëœ í•¨ìˆ˜)
 * @param planIds í”Œëœ ID ë°°ì—´
 * @param studentId í•™ìƒ ID
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì„ íƒ)
 * @returns í™œì„± ì„¸ì…˜ ë°°ì—´
 */
export async function getActiveSessionsForPlans(
  planIds: string[],
  studentId: string,
  tenantId?: string | null
): Promise<StudySession[]> {
  if (planIds.length === 0) {
    return [];
  }

  const supabase = await createSupabaseServerClient();

  // Defensive: Limit IN clause size
  const MAX_IN_CLAUSE_SIZE = 500;
  const safePlanIds = planIds.slice(0, MAX_IN_CLAUSE_SIZE);

  if (planIds.length > MAX_IN_CLAUSE_SIZE) {
    console.warn(`[data/studentSessions] planIds truncated from ${planIds.length} to ${MAX_IN_CLAUSE_SIZE}`);
  }

  let query = supabase
    .from("student_study_sessions")
    .select(
      "id,tenant_id,student_id,plan_id,content_type,content_id,started_at,ended_at,duration_seconds,paused_at,resumed_at,paused_duration_seconds,created_at"
    )
    .eq("student_id", studentId)
    .in("plan_id", safePlanIds)
    .is("ended_at", null); // í™œì„± ì„¸ì…˜ë§Œ

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  query = query.order("started_at", { ascending: false });

  let { data, error } = await query;

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const fallbackQuery = supabase
      .from("student_study_sessions")
      .select("*")
      .in("plan_id", safePlanIds)
      .is("ended_at", null);

    ({ data, error } = await fallbackQuery.order("started_at", { ascending: false }));
  }

  if (error) {
    console.error("[data/studentSessions] í™œì„± ì„¸ì…˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as StudySession[] | null) ?? [];
}

/**
 * ì„¸ì…˜ IDë¡œ ì„¸ì…˜ ì¡°íšŒ
 */
export async function getSessionById(
  sessionId: string,
  studentId: string,
  tenantId?: string | null
): Promise<StudySession | null> {
  const supabase = await createSupabaseServerClient();

  const selectSession = () =>
    supabase
      .from("student_study_sessions")
      .select(
        "id,tenant_id,student_id,plan_id,content_type,content_id,started_at,ended_at,duration_seconds,paused_at,resumed_at,paused_duration_seconds,created_at"
      )
      .eq("id", sessionId)
      .eq("student_id", studentId);

  let query = selectSession();
  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  let { data, error } = await query.maybeSingle<StudySession>();

  if (error && error.code === "42703") {
    ({ data, error } = await selectSession().maybeSingle<StudySession>());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[data/studentSessions] ì„¸ì…˜ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * í•™ìŠµ ì„¸ì…˜ ìƒì„±
 */
export async function createSession(
  session: {
    tenant_id?: string | null;
    student_id: string;
    plan_id?: string | null;
    content_type?: string | null;
    content_id?: string | null;
    started_at?: string; // ì—†ìœ¼ë©´ í˜„ì¬ ì‹œê°„ ì‚¬ìš©
  }
): Promise<{ success: boolean; sessionId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: session.tenant_id || null,
    student_id: session.student_id,
    plan_id: session.plan_id || null,
    content_type: session.content_type || null,
    content_id: session.content_id || null,
    started_at: session.started_at || new Date().toISOString(),
  };

  let { data, error } = await supabase
    .from("student_study_sessions")
    .insert(payload)
    .select("id")
    .single();

  if (error && error.code === "42703") {
    // fallback: tenant_id, student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš°
    const { tenant_id: _tenantId, student_id: _studentId, ...fallbackPayload } = payload;
    ({ data, error } = await supabase
      .from("student_study_sessions")
      .insert(fallbackPayload)
      .select("id")
      .single());
  }

  if (error) {
    console.error("[data/studentSessions] ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, sessionId: data?.id };
}

/**
 * í•™ìŠµ ì„¸ì…˜ ì¢…ë£Œ
 */
export async function endSession(
  sessionId: string,
  studentId: string,
  endedAt?: string, // ì—†ìœ¼ë©´ í˜„ì¬ ì‹œê°„ ì‚¬ìš©
  pausedDurationSeconds?: number // ì¼ì‹œì •ì§€ëœ ì´ ì‹œê°„ (ì´ˆ ë‹¨ìœ„)
): Promise<{ success: boolean; durationSeconds?: number; error?: string }> {
  const supabase = await createSupabaseServerClient();

  // ì„¸ì…˜ ì¡°íšŒ
  const session = await getSessionById(sessionId, studentId);
  if (!session) {
    return { success: false, error: "ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
  }

  if (session.ended_at) {
    return { success: false, error: "ì´ë¯¸ ì¢…ë£Œëœ ì„¸ì…˜ì…ë‹ˆë‹¤." };
  }

  const endedAtTime = endedAt || new Date().toISOString();
  const startedAt = new Date(session.started_at);
  const endedAtDate = new Date(endedAtTime);
  const totalDurationSeconds = Math.floor((endedAtDate.getTime() - startedAt.getTime()) / 1000);
  
  // ì¼ì‹œì •ì§€ ì‹œê°„ì´ ì „ë‹¬ëœ ê²½ìš° ì‚¬ìš©, ì—†ìœ¼ë©´ ì„¸ì…˜ì˜ paused_duration_seconds ì‚¬ìš©
  const finalPausedDuration = pausedDurationSeconds ?? session.paused_duration_seconds ?? 0;
  
  // ìˆœìˆ˜ í•™ìŠµ ì‹œê°„ = ì´ ì‹œê°„ - ì¼ì‹œì •ì§€ ì‹œê°„
  const actualDurationSeconds = Math.max(0, totalDurationSeconds - finalPausedDuration);

  const payload = {
    ended_at: endedAtTime,
    duration_seconds: actualDurationSeconds,
    paused_duration_seconds: finalPausedDuration,
  };

  let { error } = await supabase
    .from("student_study_sessions")
    .update(payload)
    .eq("id", sessionId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase
      .from("student_study_sessions")
      .update(payload)
      .eq("id", sessionId));
  }

  if (error) {
    console.error("[data/studentSessions] ì„¸ì…˜ ì¢…ë£Œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, durationSeconds: actualDurationSeconds };
}

/**
 * í•™ìŠµ ì„¸ì…˜ ì‚­ì œ (ì·¨ì†Œ)
 */
export async function deleteSession(
  sessionId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  let { error } = await supabase
    .from("student_study_sessions")
    .delete()
    .eq("id", sessionId)
    .eq("student_id", studentId);

  if (error && error.code === "42703") {
    ({ error } = await supabase.from("student_study_sessions").delete().eq("id", sessionId));
  }

  if (error) {
    console.error("[data/studentSessions] ì„¸ì…˜ ì‚­ì œ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}
</file>

<file path="studentStats.ts">
/**
 * í•™ìƒ í†µê³„ ë°°ì¹˜ ì¡°íšŒ (N+1 ë¬¸ì œ í•´ê²°)
 */

import type { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type StudentStats = {
  studentId: string;
  studyTimeMinutes: number;
  planCompletionRate: number;
  lastActivity: string | null;
  hasScore: boolean;
};

/**
 * ì—¬ëŸ¬ í•™ìƒì˜ ì£¼ê°„ í•™ìŠµ ì‹œê°„ì„ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function getStudentsWeeklyStudyTime(
  supabase: SupabaseServerClient,
  studentIds: string[],
  weekStart: Date,
  weekEnd: Date
): Promise<Map<string, number>> {
  if (studentIds.length === 0) {
    return new Map();
  }

  const weekStartStr = weekStart.toISOString().slice(0, 10);
  const weekEndStr = weekEnd.toISOString().slice(0, 10);

  const { data: sessions, error } = await supabase
    .from("student_study_sessions")
    .select("student_id, duration_seconds")
    .in("student_id", studentIds)
    .gte("started_at", weekStartStr)
    .lte("started_at", weekEndStr);

  if (error && error.code !== "PGRST116") {
    console.error("[studentStats] í•™ìŠµ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return new Map();
  }

  const timeMap = new Map<string, number>();
  (sessions ?? []).forEach((s: { student_id?: string; duration_seconds?: number | null }) => {
    if (!s.student_id || !s.duration_seconds) return;
    const current = timeMap.get(s.student_id) ?? 0;
    timeMap.set(s.student_id, current + s.duration_seconds);
  });

  // ì´ˆë¥¼ ë¶„ìœ¼ë¡œ ë³€í™˜
  const minutesMap = new Map<string, number>();
  timeMap.forEach((seconds, studentId) => {
    minutesMap.set(studentId, Math.floor(seconds / 60));
  });

  return minutesMap;
}

/**
 * ì—¬ëŸ¬ í•™ìƒì˜ ì£¼ê°„ í”Œëœ ì™„ë£Œìœ¨ì„ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function getStudentsWeeklyPlanCompletion(
  supabase: SupabaseServerClient,
  studentIds: string[],
  weekStart: Date,
  weekEnd: Date
): Promise<Map<string, number>> {
  if (studentIds.length === 0) {
    return new Map();
  }

  const weekStartStr = weekStart.toISOString().slice(0, 10);
  const weekEndStr = weekEnd.toISOString().slice(0, 10);

  const { data: plans, error } = await supabase
    .from("student_plan")
    .select("student_id, completed_amount")
    .in("student_id", studentIds)
    .gte("plan_date", weekStartStr)
    .lte("plan_date", weekEndStr);

  if (error && error.code !== "PGRST116") {
    console.error("[studentStats] í”Œëœ ì™„ë£Œìœ¨ ì¡°íšŒ ì‹¤íŒ¨", error);
    return new Map();
  }

  // í•™ìƒë³„ ì§‘ê³„
  const studentPlanMap = new Map<string, { total: number; completed: number }>();
  (plans ?? []).forEach(
    (p: { student_id?: string; completed_amount?: number | null }) => {
      if (!p.student_id) return;
      const current = studentPlanMap.get(p.student_id) ?? { total: 0, completed: 0 };
      current.total++;
      if (p.completed_amount !== null && p.completed_amount !== undefined && p.completed_amount > 0) {
        current.completed++;
      }
      studentPlanMap.set(p.student_id, current);
    }
  );

  // ì™„ë£Œìœ¨ ê³„ì‚°
  const completionMap = new Map<string, number>();
  studentPlanMap.forEach((data, studentId) => {
    const rate = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;
    completionMap.set(studentId, rate);
  });

  return completionMap;
}

/**
 * ì—¬ëŸ¬ í•™ìƒì˜ ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ì„ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function getStudentsLastActivity(
  supabase: SupabaseServerClient,
  studentIds: string[]
): Promise<Map<string, string | null>> {
  if (studentIds.length === 0) {
    return new Map();
  }

  // í•™ìŠµ ì„¸ì…˜ì—ì„œ ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ ì¡°íšŒ
  const { data: sessions, error } = await supabase
    .from("student_study_sessions")
    .select("student_id, started_at")
    .in("student_id", studentIds)
    .order("started_at", { ascending: false });

  if (error && error.code !== "PGRST116") {
    console.error("[studentStats] ë§ˆì§€ë§‰ í™œë™ ì¡°íšŒ ì‹¤íŒ¨", error);
    return new Map();
  }

  const activityMap = new Map<string, string | null>();
  
  // ê° í•™ìƒì˜ ê°€ì¥ ìµœê·¼ í™œë™ ì‹œê°„ë§Œ ì €ì¥
  (sessions ?? []).forEach((s: { student_id?: string; started_at?: string | null }) => {
    if (!s.student_id || !s.started_at) return;
    if (!activityMap.has(s.student_id)) {
      activityMap.set(s.student_id, s.started_at);
    }
  });

  // í™œë™ ê¸°ë¡ì´ ì—†ëŠ” í•™ìƒì€ nullë¡œ ì„¤ì •
  studentIds.forEach((id) => {
    if (!activityMap.has(id)) {
      activityMap.set(id, null);
    }
  });

  return activityMap;
}

/**
 * ì—¬ëŸ¬ í•™ìƒì˜ ì„±ì  ì…ë ¥ ì—¬ë¶€ë¥¼ í•œ ë²ˆì— ì¡°íšŒ
 */
export async function getStudentsHasScore(
  supabase: SupabaseServerClient,
  studentIds: string[]
): Promise<Set<string>> {
  if (studentIds.length === 0) {
    return new Set();
  }

  const [schoolScores, mockScores] = await Promise.all([
    supabase
      .from("student_internal_scores") // student_school_scores â†’ student_internal_scores
      .select("student_id")
      .in("student_id", studentIds)
      .limit(10000), // ì¶©ë¶„íˆ í° ì œí•œ
    supabase
      .from("student_mock_scores")
      .select("student_id")
      .in("student_id", studentIds)
      .limit(10000),
  ]);

  const hasScoreSet = new Set<string>();
  
  (schoolScores.data ?? []).forEach((s: { student_id?: string }) => {
    if (s.student_id) hasScoreSet.add(s.student_id);
  });
  
  (mockScores.data ?? []).forEach((s: { student_id?: string }) => {
    if (s.student_id) hasScoreSet.add(s.student_id);
  });

  return hasScoreSet;
}

/**
 * ì—¬ëŸ¬ í•™ìƒì˜ í†µê³„ë¥¼ í•œ ë²ˆì— ì¡°íšŒ (ë°°ì¹˜ ì²˜ë¦¬)
 */
export async function getStudentsStatsBatch(
  supabase: SupabaseServerClient,
  studentIds: string[],
  weekStart: Date,
  weekEnd: Date
): Promise<Map<string, StudentStats>> {
  if (studentIds.length === 0) {
    return new Map();
  }

  // ëª¨ë“  í†µê³„ë¥¼ ë³‘ë ¬ë¡œ ì¡°íšŒ
  const [studyTimeMap, completionMap, activityMap, hasScoreSet] = await Promise.all([
    getStudentsWeeklyStudyTime(supabase, studentIds, weekStart, weekEnd),
    getStudentsWeeklyPlanCompletion(supabase, studentIds, weekStart, weekEnd),
    getStudentsLastActivity(supabase, studentIds),
    getStudentsHasScore(supabase, studentIds),
  ]);

  // ê²°ê³¼ í†µí•©
  const statsMap = new Map<string, StudentStats>();
  
  studentIds.forEach((studentId) => {
    statsMap.set(studentId, {
      studentId,
      studyTimeMinutes: studyTimeMap.get(studentId) ?? 0,
      planCompletionRate: completionMap.get(studentId) ?? 0,
      lastActivity: activityMap.get(studentId) ?? null,
      hasScore: hasScoreSet.has(studentId),
    });
  });

  return statsMap;
}
</file>

<file path="studentTerms.ts">
/**
 * Student Terms ë°ì´í„° ì ‘ê·¼ í•¨ìˆ˜
 * 
 * student_terms í…Œì´ë¸”ì„ ê´€ë¦¬í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ì…ë‹ˆë‹¤.
 * í•™ìƒì˜ í•™ë…„ë„ë³„ í•™ê¸° ì •ë³´ë¥¼ ì¡°íšŒ/ìƒì„±í•©ë‹ˆë‹¤.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { Tables, TablesInsert } from "@/lib/supabase/database.types";

type SupabaseServerClient = Awaited<ReturnType<typeof createSupabaseServerClient>>;

/**
 * StudentTerm íƒ€ì… (student_terms í…Œì´ë¸”)
 */
export type StudentTerm = Tables<"student_terms">;

/**
 * StudentTerm ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type StudentTermInsert = TablesInsert<"student_terms">;

/**
 * student_terms ì¡°íšŒ ë˜ëŠ” ìƒì„±
 * 
 * ì£¼ì–´ì§„ ì¡°ê±´ì— ë§ëŠ” student_termì´ ìˆìœ¼ë©´ ë°˜í™˜í•˜ê³ ,
 * ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @param params - ì¡°íšŒ/ìƒì„± ì¡°ê±´
 * @returns student_term_id
 */
export async function getOrCreateStudentTerm(params: {
  tenant_id: string;
  student_id: string;
  school_year: number; // í•™ë…„ë„ (ì˜ˆ: 2024)
  grade: number; // í•™ë…„ (1~3)
  semester: number; // í•™ê¸° (1~2)
  curriculum_revision_id: string;
  class_name?: string | null; // ë°˜ ì´ë¦„ (ì„ íƒì‚¬í•­)
  homeroom_teacher?: string | null; // ë‹´ì„êµì‚¬ ì´ë¦„ (ì„ íƒì‚¬í•­)
  notes?: string | null; // ë¹„ê³  (ì„ íƒì‚¬í•­)
}): Promise<string> {
  const supabase = await createSupabaseServerClient();

  // ê¸°ì¡´ student_term ì¡°íšŒ
  const { data: existing, error: selectError } = await supabase
    .from("student_terms")
    .select("id")
    .eq("tenant_id", params.tenant_id)
    .eq("student_id", params.student_id)
    .eq("school_year", params.school_year)
    .eq("grade", params.grade)
    .eq("semester", params.semester)
    .maybeSingle();

  if (selectError) {
    console.error("[data/studentTerms] student_term ì¡°íšŒ ì‹¤íŒ¨", selectError);
    throw selectError;
  }

  // ê¸°ì¡´ student_termì´ ìˆìœ¼ë©´ ë°˜í™˜
  if (existing) {
    return existing.id;
  }

  // ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
  const insertPayload: StudentTermInsert = {
    tenant_id: params.tenant_id,
    student_id: params.student_id,
    school_year: params.school_year,
    grade: params.grade,
    semester: params.semester,
    curriculum_revision_id: params.curriculum_revision_id,
    class_name: params.class_name ?? null,
    homeroom_teacher: params.homeroom_teacher ?? null,
    notes: params.notes ?? null,
  };

  const { data: created, error: insertError } = await supabase
    .from("student_terms")
    .insert(insertPayload)
    .select("id")
    .single();

  if (insertError) {
    console.error("[data/studentTerms] student_term ìƒì„± ì‹¤íŒ¨", insertError);
    throw insertError;
  }

  return created.id;
}

/**
 * student_terms ì¡°íšŒ
 * 
 * @param params - ì¡°íšŒ ì¡°ê±´
 * @returns student_term ë˜ëŠ” null
 */
export async function getStudentTerm(params: {
  tenant_id: string;
  student_id: string;
  school_year: number;
  grade: number;
  semester: number;
}): Promise<StudentTerm | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_terms")
    .select("*")
    .eq("tenant_id", params.tenant_id)
    .eq("student_id", params.student_id)
    .eq("school_year", params.school_year)
    .eq("grade", params.grade)
    .eq("semester", params.semester)
    .maybeSingle();

  if (error) {
    console.error("[data/studentTerms] student_term ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data as StudentTerm | null;
}

/**
 * í•™ìƒì˜ ëª¨ë“  student_terms ì¡°íšŒ
 * 
 * @param studentId - í•™ìƒ ID
 * @param tenantId - í…Œë„ŒíŠ¸ ID
 * @returns student_term ë°°ì—´
 */
export async function getStudentTerms(
  studentId: string,
  tenantId: string
): Promise<StudentTerm[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_terms")
    .select("*")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId)
    .order("school_year", { ascending: false })
    .order("grade", { ascending: true })
    .order("semester", { ascending: true });

  if (error) {
    console.error("[data/studentTerms] student_terms ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as StudentTerm[]) ?? [];
}

// calculateSchoolYearëŠ” lib/utils/schoolYear.tsë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.
// í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ë¶„ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.
export { calculateSchoolYear } from "@/lib/utils/schoolYear";
</file>

<file path="subjects.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";

export type SubjectGroup = {
  id: string;
  curriculum_revision_id: string;
  name: string;
  display_order?: number;
  created_at?: string;
  updated_at?: string;
};

export type SubjectType = {
  id: string;
  curriculum_revision_id: string;
  name: string; // ê³¼ëª©êµ¬ë¶„ëª… (ì˜ˆ: ê³µí†µ, ì¼ë°˜ì„ íƒ, ì§„ë¡œì„ íƒ)
  display_order?: number;
  is_active: boolean;
  created_at?: string;
  updated_at?: string;
};

export type Subject = {
  id: string;
  subject_group_id: string;
  name: string;
  display_order?: number;
  subject_type_id?: string | null; // ê³¼ëª©êµ¬ë¶„ ID (FK â†’ subject_types)
  subject_type?: string | null; // ê³¼ëª©êµ¬ë¶„ëª… (JOIN ê²°ê³¼, í•˜ìœ„ í˜¸í™˜ì„±)
  created_at?: string;
  updated_at?: string;
};

/**
 * êµê³¼ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ ëª¨ë“  ê°œì •êµìœ¡ê³¼ì •ì˜ êµê³¼ ê·¸ë£¹ ì¡°íšŒ)
 */
export async function getSubjectGroups(
  curriculumRevisionId?: string
): Promise<SubjectGroup[]> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  let query = supabase
    .from("subject_groups")
    .select("*");

  if (curriculumRevisionId) {
    query = query.eq("curriculum_revision_id", curriculumRevisionId);
  }

  const { data, error } = await query
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/subjects] êµê³¼ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as SubjectGroup[] | null) ?? [];
}

/**
 * ê³¼ëª©êµ¬ë¶„ ëª©ë¡ ì¡°íšŒ (ê°œì •êµìœ¡ê³¼ì •ë³„)
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ ëª¨ë“  ê°œì •êµìœ¡ê³¼ì •ì˜ ê³¼ëª©êµ¬ë¶„ ì¡°íšŒ)
 */
export async function getSubjectTypes(
  curriculumRevisionId?: string
): Promise<SubjectType[]> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  let query = supabase
    .from("subject_types")
    .select("*")
    .eq("is_active", true);

  if (curriculumRevisionId) {
    query = query.eq("curriculum_revision_id", curriculumRevisionId);
  }

  const { data, error } = await query
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/subjects] ê³¼ëª©êµ¬ë¶„ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as SubjectType[] | null) ?? [];
}

/**
 * íŠ¹ì • êµê³¼ ê·¸ë£¹ì— ì†í•œ ê³¼ëª© ëª©ë¡ ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 * ê³¼ëª©êµ¬ë¶„ ì •ë³´ë„ í•¨ê»˜ ì¡°íšŒ
 */
export async function getSubjectsByGroup(
  subjectGroupId: string
): Promise<Subject[]> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("subjects")
    .select(`
      *,
      subject_types:subject_type_id (
        id,
        name
      )
    `)
    .eq("subject_group_id", subjectGroupId)
    .order("name", { ascending: true });

  if (error) {
    console.error("[data/subjects] ê³¼ëª© ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  // JOIN ê²°ê³¼ë¥¼ í‰íƒ„í™”
  return ((data as any[]) ?? []).map((subject) => ({
    ...subject,
    subject_type: subject.subject_types?.name || null,
  })) as Subject[];
}

/**
 * êµê³¼ ê·¸ë£¹ ì´ë¦„ìœ¼ë¡œ ê³¼ëª© ëª©ë¡ ì¡°íšŒ (ì „ì—­ ê´€ë¦¬)
 * @param subjectGroupName êµê³¼ ê·¸ë£¹ ì´ë¦„
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ë¡œ ì°¾ì€ êµê³¼ ê·¸ë£¹ ì‚¬ìš©)
 */
export async function getSubjectsByGroupName(
  subjectGroupName: string,
  curriculumRevisionId?: string
): Promise<Subject[]> {
  const supabase = await createSupabaseServerClient();

  // ë¨¼ì € êµê³¼ ê·¸ë£¹ ID ì¡°íšŒ
  let query = supabase
    .from("subject_groups")
    .select("id")
    .eq("name", subjectGroupName);

  if (curriculumRevisionId) {
    query = query.eq("curriculum_revision_id", curriculumRevisionId);
  }

  const { data: groupData, error: groupError } = await query
    .maybeSingle();

  if (groupError || !groupData) {
    console.error("[data/subjects] êµê³¼ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨", groupError);
    return [];
  }

  return getSubjectsByGroup(groupData.id);
}

/**
 * ëª¨ë“  êµê³¼ì™€ ê³¼ëª©ì„ í•¨ê»˜ ì¡°íšŒ (ê³„ì¸µ êµ¬ì¡°, ì „ì—­ ê´€ë¦¬)
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­)
 */
export async function getSubjectGroupsWithSubjects(
  curriculumRevisionId?: string
): Promise<(SubjectGroup & { subjects: Subject[] })[]> {
  const groups = await getSubjectGroups(curriculumRevisionId);

  const groupsWithSubjects = await Promise.all(
    groups.map(async (group) => {
      const subjects = await getSubjectsByGroup(group.id);
      return { ...group, subjects };
    })
  );

  return groupsWithSubjects;
}

/**
 * ê°œì •êµìœ¡ê³¼ì •ë³„ ì „ì²´ ê³„ì¸µ êµ¬ì¡° ì¡°íšŒ
 * ê°œì •êµìœ¡ê³¼ì • â†’ êµê³¼ â†’ ê³¼ëª© â†’ ê³¼ëª©êµ¬ë¶„
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (ì„ íƒì‚¬í•­)
 */
export async function getFullSubjectHierarchy(
  curriculumRevisionId?: string
): Promise<{
  curriculumRevision: { id: string; name: string; year?: number | null };
  subjectGroups: (SubjectGroup & {
    subjects: (Subject & { subjectType?: SubjectType | null })[];
  })[];
  subjectTypes: SubjectType[];
}> {
  const supabase = await createSupabaseServerClient();

  // ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ
  let revisionQuery = supabase.from("curriculum_revisions").select("*");
  if (curriculumRevisionId) {
    revisionQuery = revisionQuery.eq("id", curriculumRevisionId);
  } else {
    revisionQuery = revisionQuery.eq("is_active", true).order("name", { ascending: true }).limit(1);
  }

  const { data: revisionData, error: revisionError } = await revisionQuery.maybeSingle();

  if (revisionError || !revisionData) {
    console.error("[data/subjects] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨", revisionError);
    throw new Error("ê°œì •êµìœ¡ê³¼ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  const revisionId = revisionData.id;

  // êµê³¼ ê·¸ë£¹ ì¡°íšŒ
  const groups = await getSubjectGroups(revisionId);

  // ê³¼ëª©êµ¬ë¶„ ì¡°íšŒ
  const subjectTypes = await getSubjectTypes(revisionId);

  // ê³¼ëª© ì¡°íšŒ (ê³¼ëª©êµ¬ë¶„ ì •ë³´ í¬í•¨)
  const groupsWithSubjects = await Promise.all(
    groups.map(async (group) => {
      const subjects = await getSubjectsByGroup(group.id);
      const subjectsWithType = subjects.map((subject) => ({
        ...subject,
        subjectType: subject.subject_type_id
          ? subjectTypes.find((st) => st.id === subject.subject_type_id) || null
          : null,
      }));
      return { ...group, subjects: subjectsWithType };
    })
  );

  return {
    curriculumRevision: {
      id: revisionData.id,
      name: revisionData.name,
      year: revisionData.year,
    },
    subjectGroups: groupsWithSubjects,
    subjectTypes,
  };
}

/**
 * ê°œì •êµìœ¡ê³¼ì •ë³„ ì „ì²´ êµ¬ì¡°ë¥¼ ë‹¨ì¼ ì¿¼ë¦¬ë¡œ ì¡°íšŒ (ìµœì í™” ë²„ì „)
 * Supabase JOINì„ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ
 * @param curriculumRevisionId ê°œì •êµìœ¡ê³¼ì • ID (í•„ìˆ˜)
 */
export async function getSubjectHierarchyOptimized(
  curriculumRevisionId: string
): Promise<{
  curriculumRevision: { id: string; name: string; year?: number | null };
  subjectGroups: (SubjectGroup & {
    subjects: (Subject & { subjectType: SubjectType | null })[];
  })[];
  subjectTypes: SubjectType[];
}> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  // 1. ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ
  const { data: revisionData, error: revisionError } = await supabase
    .from("curriculum_revisions")
    .select("*")
    .eq("id", curriculumRevisionId)
    .single();

  if (revisionError || !revisionData) {
    console.error("[data/subjects] ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨", revisionError);
    throw new Error("ê°œì •êµìœ¡ê³¼ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  // 2. êµê³¼ + ê³¼ëª© + ê³¼ëª©êµ¬ë¶„ í•œ ë²ˆì— ì¡°íšŒ (JOIN)
  const { data: groupsData, error: groupsError } = await supabase
    .from("subject_groups")
    .select(`
      *,
      subjects:subjects (
        *,
        subject_types:subject_type_id (
          id,
          name,
          is_active
        )
      )
    `)
    .eq("curriculum_revision_id", curriculumRevisionId)
    .order("name", { ascending: true });

  if (groupsError) {
    console.error("[data/subjects] êµê³¼ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨", groupsError);
    throw new Error("êµê³¼ ê·¸ë£¹ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  // 3. ê³¼ëª©êµ¬ë¶„ ëª©ë¡ ì¡°íšŒ
  const { data: subjectTypesData, error: typesError } = await supabase
    .from("subject_types")
    .select("*")
    .eq("curriculum_revision_id", curriculumRevisionId)
    .eq("is_active", true)
    .order("name", { ascending: true });

  if (typesError) {
    console.error("[data/subjects] ê³¼ëª©êµ¬ë¶„ ì¡°íšŒ ì‹¤íŒ¨", typesError);
    throw new Error("ê³¼ëª©êµ¬ë¶„ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
  }

  // ë°ì´í„° ë³€í™˜
  const groupsWithSubjects = ((groupsData || []) as any[]).map((group) => ({
    ...group,
    subjects: ((group.subjects || []) as any[]).map((subject) => ({
      ...subject,
      subject_type: subject.subject_types?.name || null,
      subjectType: subject.subject_types || null,
    })),
  }));

  return {
    curriculumRevision: {
      id: revisionData.id,
      name: revisionData.name,
      year: revisionData.year,
    },
    subjectGroups: groupsWithSubjects as (SubjectGroup & {
      subjects: (Subject & { subjectType: SubjectType | null })[];
    })[],
    subjectTypes: (subjectTypesData || []) as SubjectType[],
  };
}

/**
 * í™œì„±í™”ëœ ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ (ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©)
 * @returns í™œì„±í™”ëœ ì²« ë²ˆì§¸ ê°œì •êµìœ¡ê³¼ì •
 */
export async function getActiveCurriculumRevision(): Promise<{
  id: string;
  name: string;
  year?: number | null;
} | null> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("curriculum_revisions")
    .select("id, name, year")
    .eq("is_active", true)
    .order("name", { ascending: true })
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error("[data/subjects] í™œì„± ê°œì •êµìœ¡ê³¼ì • ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data;
}

/**
 * íŠ¹ì • ê³¼ëª© IDë¡œ ê³¼ëª© ì •ë³´ ì¡°íšŒ (ê³¼ëª©êµ¬ë¶„ í¬í•¨)
 * @param subjectId ê³¼ëª© ID
 */
export async function getSubjectById(subjectId: string): Promise<
  | (Subject & {
      subjectGroup: SubjectGroup;
      subjectType?: SubjectType | null;
    })
  | null
> {
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("subjects")
    .select(`
      *,
      subject_groups:subject_group_id (
        id,
        curriculum_revision_id,
        name
      ),
      subject_types:subject_type_id (
        id,
        curriculum_revision_id,
        name,
        is_active
      )
    `)
    .eq("id", subjectId)
    .maybeSingle();

  if (error) {
    console.error("[data/subjects] ê³¼ëª© ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  if (!data) {
    return null;
  }

  return {
    ...data,
    subjectGroup: (data as any).subject_groups,
    subjectType: (data as any).subject_types || null,
    subject_type: (data as any).subject_types?.name || null,
  } as Subject & {
    subjectGroup: SubjectGroup;
    subjectType?: SubjectType | null;
  };
}

/**
 * íŠ¹ì • êµê³¼ ê·¸ë£¹ IDë¡œ êµê³¼ ê·¸ë£¹ ì •ë³´ ì¡°íšŒ
 * @param subjectGroupId êµê³¼ ê·¸ë£¹ ID
 */
export async function getSubjectGroupById(
  subjectGroupId: string
): Promise<SubjectGroup | null> {
  // ê´€ë¦¬ì ì‘ì—…ì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const supabaseAdmin = createSupabaseAdminClient();
  const supabase = supabaseAdmin || await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("subject_groups")
    .select("*")
    .eq("id", subjectGroupId)
    .maybeSingle();

  if (error) {
    console.error("[data/subjects] êµê³¼ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return (data as SubjectGroup | null) ?? null;
}
</file>

<file path="superadminDashboard.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";

export type TenantStatistics = {
  total: number;
  active: number;
  inactive: number;
  suspended: number;
};

export type UserStatistics = {
  students: number;
  parents: number;
  admins: number;
  consultants: number;
  superadmins: number;
  total: number;
};

export type RecentTenant = {
  id: string;
  name: string;
  type: string;
  created_at: string;
};

/**
 * ê¸°ê´€ í†µê³„ ì¡°íšŒ
 */
export async function getTenantStatistics(): Promise<TenantStatistics> {
  // Admin Clientë¥¼ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒ)
  const adminClient = createSupabaseAdminClient();
  const supabase = adminClient || (await createSupabaseServerClient());

  // ì „ì²´ ê¸°ê´€ ìˆ˜
  const { count: total } = await supabase
    .from("tenants")
    .select("*", { count: "exact", head: true });

  // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸
  let hasStatusColumn = false;
  try {
    const { error: testError } = await supabase
      .from("tenants")
      .select("status")
      .limit(1);
    
    if (!testError) {
      hasStatusColumn = true;
    }
  } catch (e) {
    // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
  }

  let active = 0;
  let inactive = 0;
  let suspended = 0;

  if (hasStatusColumn) {
    // í™œì„± ê¸°ê´€ ìˆ˜ (statusê°€ 'active'ì´ê±°ë‚˜ nullì¸ ê²½ìš°)
    const { count: activeCount, error: activeError } = await supabase
      .from("tenants")
      .select("*", { count: "exact", head: true })
      .or("status.eq.active,status.is.null");

    if (activeError) {
      console.error("[superadminDashboard] í™œì„± ê¸°ê´€ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", activeError);
    } else {
      active = activeCount || 0;
    }

    // ë¹„í™œì„± ê¸°ê´€ ìˆ˜
    const { count: inactiveCount, error: inactiveError } = await supabase
      .from("tenants")
      .select("*", { count: "exact", head: true })
      .eq("status", "inactive");

    if (inactiveError) {
      console.error("[superadminDashboard] ë¹„í™œì„± ê¸°ê´€ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", inactiveError);
    } else {
      inactive = inactiveCount || 0;
    }

    // ì •ì§€ëœ ê¸°ê´€ ìˆ˜
    const { count: suspendedCount, error: suspendedError } = await supabase
      .from("tenants")
      .select("*", { count: "exact", head: true })
      .eq("status", "suspended");

    if (suspendedError) {
      console.error("[superadminDashboard] ì •ì§€ëœ ê¸°ê´€ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", suspendedError);
    } else {
      suspended = suspendedCount || 0;
    }
  } else {
    // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ë¥¼ í™œì„±ìœ¼ë¡œ ê°„ì£¼
    active = total || 0;
  }

  return {
    total: total || 0,
    active: active || 0,
    inactive: inactive || 0,
    suspended: suspended || 0,
  };
}

/**
 * ì‚¬ìš©ì í†µê³„ ì¡°íšŒ
 * Super Adminì€ ëª¨ë“  í…Œë„ŒíŠ¸ì˜ ì‚¬ìš©ìë¥¼ ë³¼ ìˆ˜ ìˆì–´ì•¼ í•˜ë¯€ë¡œ Admin Client ì‚¬ìš©
 */
export async function getUserStatistics(): Promise<UserStatistics> {
  // Admin Clientë¥¼ ìš°ì„  ì‚¬ìš© (RLS ìš°íšŒí•˜ì—¬ ëª¨ë“  í…Œë„ŒíŠ¸ì˜ ë°ì´í„° ì¡°íšŒ)
  const adminClient = createSupabaseAdminClient();
  const supabase = adminClient || (await createSupabaseServerClient());

  if (!adminClient) {
    console.warn(
      "[superadminDashboard] Admin Clientë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ ì„œë²„ í´ë¼ì´ì–¸íŠ¸ë¡œ ì¡°íšŒí•©ë‹ˆë‹¤. RLS ì •ì±…ìœ¼ë¡œ ì¸í•´ ì¼ë¶€ ë°ì´í„°ê°€ ëˆ„ë½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    );
  }

  try {
    // í•™ìƒ ìˆ˜ (ëª¨ë“  í…Œë„ŒíŠ¸ì˜ í•™ìƒ)
    const { count: students, error: studentsError } = await supabase
      .from("students")
      .select("*", { count: "exact", head: true });

    if (studentsError) {
      console.error("[superadminDashboard] í•™ìƒ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", studentsError);
    }

    // í•™ë¶€ëª¨ ìˆ˜ (ëª¨ë“  í…Œë„ŒíŠ¸ì˜ í•™ë¶€ëª¨)
    const { count: parents, error: parentsError } = await supabase
      .from("parent_users")
      .select("*", { count: "exact", head: true });

    if (parentsError) {
      console.error("[superadminDashboard] í•™ë¶€ëª¨ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", parentsError);
    }

    // ê´€ë¦¬ì ìˆ˜ (admin)
    const { count: admins, error: adminsError } = await supabase
      .from("admin_users")
      .select("*", { count: "exact", head: true })
      .eq("role", "admin");

    if (adminsError) {
      console.error("[superadminDashboard] ê´€ë¦¬ì ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", adminsError);
    }

    // ì»¨ì„¤í„´íŠ¸ ìˆ˜
    const { count: consultants, error: consultantsError } = await supabase
      .from("admin_users")
      .select("*", { count: "exact", head: true })
      .eq("role", "consultant");

    if (consultantsError) {
      console.error("[superadminDashboard] ì»¨ì„¤í„´íŠ¸ ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", consultantsError);
    }

    // Super Admin ìˆ˜
    const { count: superadmins, error: superadminsError } = await supabase
      .from("admin_users")
      .select("*", { count: "exact", head: true })
      .eq("role", "superadmin");

    if (superadminsError) {
      console.error("[superadminDashboard] Super Admin ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨:", superadminsError);
    }

    return {
      students: students || 0,
      parents: parents || 0,
      admins: admins || 0,
      consultants: consultants || 0,
      superadmins: superadmins || 0,
      total: (students || 0) + (parents || 0) + (admins || 0) + (consultants || 0) + (superadmins || 0),
    };
  } catch (error) {
    console.error("[superadminDashboard] ì‚¬ìš©ì í†µê³„ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜:", error);
    return {
      students: 0,
      parents: 0,
      admins: 0,
      consultants: 0,
      superadmins: 0,
      total: 0,
    };
  }
}

/**
 * ìµœê·¼ ìƒì„±ëœ ê¸°ê´€ ëª©ë¡ ì¡°íšŒ
 */
export async function getRecentTenants(limit: number = 10): Promise<RecentTenant[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("tenants")
    .select("id, name, type, created_at")
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("[superadminDashboard] ìµœê·¼ ê¸°ê´€ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }

  return data || [];
}
</file>

<file path="tenants.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

export type Tenant = {
  id: string;
  name: string;
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * Tenant IDë¡œ Tenant ì¡°íšŒ
 */
export async function getTenantById(tenantId: string): Promise<Tenant | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("tenants")
    .select("id,name,created_at,updated_at")
    .eq("id", tenantId)
    .maybeSingle<Tenant>();

  if (error && error.code !== "PGRST116") {
    console.error("[data/tenants] Tenant ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }

  return data ?? null;
}

/**
 * ëª¨ë“  Tenant ëª©ë¡ ì¡°íšŒ (Super Adminìš©)
 */
export async function listAllTenants(): Promise<Tenant[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("tenants")
    .select("id,name,created_at,updated_at")
    .order("created_at", { ascending: false });

  if (error) {
    console.error("[data/tenants] Tenant ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }

  return (data as Tenant[] | null) ?? [];
}

/**
 * Tenant ìƒì„±
 */
export async function createTenant(
  tenant: { name: string }
): Promise<{ success: boolean; tenantId?: string; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("tenants")
    .insert({ name: tenant.name })
    .select("id")
    .single();

  if (error) {
    console.error("[data/tenants] Tenant ìƒì„± ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true, tenantId: data?.id };
}

/**
 * Tenant ì—…ë°ì´íŠ¸
 */
export async function updateTenant(
  tenantId: string,
  updates: { name?: string }
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, any> = {};
  if (updates.name !== undefined) payload.name = updates.name;

  const { error } = await supabase
    .from("tenants")
    .update(payload)
    .eq("id", tenantId);

  if (error) {
    console.error("[data/tenants] Tenant ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    return { success: false, error: error.message };
  }

  return { success: true };
}

/**
 * ê¸°ë³¸ Tenant ì¡°íšŒ
 * íšŒì›ê°€ì… ì‹œ tenant_idê°€ ì—†ì„ ê²½ìš° ì‚¬ìš©
 */
export async function getDefaultTenant(): Promise<{ id: string } | null> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data: defaultTenant, error: tenantError } = await supabase
      .from("tenants")
      .select("id")
      .eq("name", "Default Tenant")
      .maybeSingle<{ id: string }>();

    if (tenantError) {
      // PGRST116ì€ ë ˆì½”ë“œê°€ ì—†ëŠ” ê²½ìš°ì´ë¯€ë¡œ null ë°˜í™˜
      if (tenantError.code === "PGRST116") {
        console.warn("[data/tenants] Default Tenantê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return null;
      }
      console.error("[data/tenants] Default Tenant ì¡°íšŒ ì‹¤íŒ¨", {
        error: tenantError.message,
        code: tenantError.code,
      });
      return null;
    }

    return defaultTenant ?? null;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[data/tenants] getDefaultTenant ì‹¤íŒ¨", {
      message: errorMessage,
      error,
    });
    return null;
  }
}
</file>

<file path="termsContents.ts">
import { createSupabaseServerClient } from '@/lib/supabase/server';
import type { TermsContent, TermsContentType, TermsContentRow } from '@/lib/types/terms';

/**
 * í™œì„±í™”ëœ ì•½ê´€ ë‚´ìš© ì¡°íšŒ (ê³µê°œ ì¡°íšŒìš©)
 * 
 * RLS ì •ì±…ì— ë”°ë¼ í™œì„± ë²„ì „ë§Œ ì¡°íšŒ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 * ëª¨ë“  ì‚¬ìš©ì(ì¸ì¦ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)ê°€ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * 
 * @param contentType ì•½ê´€ ìœ í˜•
 * @returns í™œì„±í™”ëœ ì•½ê´€ ë‚´ìš© ë˜ëŠ” null
 */
export async function getActiveTermsContent(
  contentType: TermsContentType
): Promise<TermsContent | null> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('terms_contents')
      .select('*')
      .eq('content_type', contentType)
      .eq('is_active', true)
      .single();

    if (error) {
      // PGRST116: No rows returned
      if (error.code === 'PGRST116') {
        return null;
      }
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === 'PGRST205') {
        console.error('[termsContents] ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
        return null;
      }
      console.error('[termsContents] í™œì„± ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨:', {
        contentType,
        error: error.message,
        code: error.code,
      });
      return null;
    }

    return data as TermsContent;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('[termsContents] í™œì„± ì•½ê´€ ì¡°íšŒ ì˜ˆì™¸:', {
      contentType,
      error: errorMessage,
    });
    return null;
  }
}

/**
 * ì•½ê´€ ë²„ì „ íˆìŠ¤í† ë¦¬ ì¡°íšŒ (ê³µê°œ ì¡°íšŒìš©)
 * 
 * RLS ì •ì±…ì— ë”°ë¼ í™œì„± ë²„ì „ë§Œ ì¡°íšŒ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 * ëª¨ë“  ì‚¬ìš©ì(ì¸ì¦ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)ê°€ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * 
 * @param contentType ì•½ê´€ ìœ í˜•
 * @returns í™œì„±í™”ëœ ì•½ê´€ ëª©ë¡ (ë²„ì „ ë‚´ë¦¼ì°¨ìˆœ)
 */
export async function getTermsContentHistory(
  contentType: TermsContentType
): Promise<TermsContent[]> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('terms_contents')
      .select('*')
      .eq('content_type', contentType)
      .order('version', { ascending: false });

    if (error) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === 'PGRST205') {
        console.error('[termsContents] ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
        return [];
      }
      console.error('[termsContents] ì•½ê´€ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨:', {
        contentType,
        error: error.message,
        code: error.code,
      });
      return [];
    }

    return (data as TermsContentRow[]) as TermsContent[];
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('[termsContents] ì•½ê´€ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì˜ˆì™¸:', {
      contentType,
      error: errorMessage,
    });
    return [];
  }
}

/**
 * IDë¡œ ì•½ê´€ ë‚´ìš© ì¡°íšŒ (ê³µê°œ ì¡°íšŒìš©)
 * 
 * RLS ì •ì±…ì— ë”°ë¼ í™œì„± ë²„ì „ë§Œ ì¡°íšŒ ê°€ëŠ¥í•©ë‹ˆë‹¤.
 * ëª¨ë“  ì‚¬ìš©ì(ì¸ì¦ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)ê°€ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * 
 * @param id ì•½ê´€ ID
 * @returns ì•½ê´€ ë‚´ìš© ë˜ëŠ” null
 */
export async function getTermsContentById(id: string): Promise<TermsContent | null> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from('terms_contents')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      // PGRST116: No rows returned
      if (error.code === 'PGRST116') {
        return null;
      }
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === 'PGRST205') {
        console.error('[termsContents] ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
        return null;
      }
      console.error('[termsContents] ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨:', {
        id,
        error: error.message,
        code: error.code,
      });
      return null;
    }

    return data as TermsContent;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('[termsContents] ì•½ê´€ ì¡°íšŒ ì˜ˆì™¸:', {
      id,
      error: errorMessage,
    });
    return null;
  }
}
</file>

<file path="todayPlans.ts">
import { getPlansForStudent } from "@/lib/data/studentPlans";
import type { Book, Lecture, CustomContent } from "@/lib/data/studentContents";
import { getContentsByIds } from "@/lib/data/studentContents";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { PlanWithContent } from "@/app/(student)/today/_utils/planGroupUtils";
import { getPlanGroupsForStudent } from "@/lib/data/planGroups";
import type { TodayProgress } from "@/lib/metrics/todayProgress";
import { getSessionsInRange, getActiveSessionsForPlans } from "@/lib/data/studentSessions";
import {
  calculatePlanStudySeconds,
  buildActiveSessionMap,
} from "@/lib/metrics/studyTime";
import { perfTime } from "@/lib/utils/perfLog";

const ISO_DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

function normalizeIsoDate(value: string | null): string | null {
  if (!value || !ISO_DATE_REGEX.test(value)) {
    return null;
  }
  const date = new Date(value + "T00:00:00Z");
  return Number.isNaN(date.getTime()) ? null : value;
}

export type TodayPlansResponse = {
  plans: PlanWithContent[];
  sessions: Record<string, {
    isPaused: boolean;
    startedAt?: string | null;
    pausedAt?: string | null;
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }>;
  planDate: string;
  isToday: boolean;
  serverNow: number;
  /**
   * Today progress summary (same as /api/today/progress).
   * Included to avoid separate API call on Today/Camp Today pages.
   * Can be null if calculation fails (non-blocking).
   */
  todayProgress?: TodayProgress | null;
};

export type GetTodayPlansOptions = {
  studentId: string;
  tenantId: string | null;
  date?: string | null;
  camp?: boolean;
  /**
   * If true, includes todayProgress in the response.
   * Default: true
   */
  includeProgress?: boolean;
  /**
   * If true, narrows progress and session queries to only the plans in the result set.
   * This optimization reduces query time when the student has many progress records or active sessions.
   */
  narrowQueries?: boolean;
  /**
   * If true, uses cache for todayPlans results.
   * Default: true
   */
  useCache?: boolean;
  /**
   * Cache TTL in seconds.
   * Default: 120 (2 minutes)
   */
  cacheTtlSeconds?: number;
};

/**
 * ì„œë²„ ì‚¬ì´ë“œì—ì„œ ì˜¤ëŠ˜ì˜ í”Œëœ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
 * 
 * /api/today/plans API ë¼ìš°íŠ¸ì™€ ë™ì¼í•œ ë¡œì§ì„ ì‚¬ìš©í•˜ì§€ë§Œ,
 * ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì§ì ‘ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë¨.
 * 
 * @param options ì¡°íšŒ ì˜µì…˜
 * @returns ì˜¤ëŠ˜ì˜ í”Œëœ ë°ì´í„°
 */
export async function getTodayPlans(
  options: GetTodayPlansOptions
): Promise<TodayPlansResponse> {
  const { 
    studentId, 
    tenantId, 
    date, 
    camp = false, 
    includeProgress = true, 
    narrowQueries = false,
    useCache = true,
    cacheTtlSeconds = 120
  } = options;
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);
  
  const requestedDateParam = normalizeIsoDate(date ?? null);
  const targetDate = requestedDateParam ?? todayDate;

  // Supabase í´ë¼ì´ì–¸íŠ¸ë¥¼ í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ í•œ ë²ˆë§Œ ìƒì„±í•˜ì—¬ ì¬ì‚¬ìš©
  // ëª¨ë“  ë¸”ë¡(ìºì‹œ ì¡°íšŒ, ì§„í–‰ë¥  ì¡°íšŒ, ìºì‹œ ì €ì¥)ì—ì„œ ë™ì¼í•œ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
  const supabase = await createSupabaseServerClient();

  // Cache lookup (if enabled) - ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ
  if (useCache) {
    const lookupTimer = perfTime("[todayPlans] cache - lookup");
    try {
      
      // Build cache query with tenant_id handling (NULL-safe)
      // Use partial index: one for NULL tenant_id, one for non-NULL
      let cacheQuery = supabase
        .from("today_plans_cache")
        .select("payload, expires_at")
        .eq("student_id", studentId)
        .eq("plan_date", targetDate)
        .eq("is_camp_mode", !!camp)
        .gt("expires_at", new Date().toISOString()); // Only valid (non-expired) cache
      
      // Handle tenant_id (NULL or value)
      if (tenantId) {
        cacheQuery = cacheQuery.eq("tenant_id", tenantId);
      } else {
        cacheQuery = cacheQuery.is("tenant_id", null);
      }
      
      const { data: cacheRow, error: cacheError } = await cacheQuery.maybeSingle();
      
      if (!cacheError && cacheRow) {
        lookupTimer.end();
        // Return cached result
        return cacheRow.payload as TodayPlansResponse;
      }
      
      if (cacheError && cacheError.code !== "PGRST116") {
        // PGRST116 = no rows found (expected for cache miss)
        console.warn("[todayPlans] cache lookup error (non-blocking):", cacheError);
      }
    } catch (error) {
      console.warn("[todayPlans] cache lookup failed (non-blocking):", error);
      // Continue with normal execution on cache error
    }
    lookupTimer.end();
  }

  // Wave 1: Independent queries that can run in parallel
  // - planGroups (needed to filter plans)
  const allActivePlanGroups = await getPlanGroupsForStudent({
    studentId,
    tenantId,
    status: "active",
  });

  // Filter plan groups based on camp mode
  let planGroupIds: string[] | undefined = undefined;
  if (camp) {
    // ìº í”„ ëª¨ë“œ: ìº í”„ í™œì„± í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§
    const campPlanGroups = allActivePlanGroups.filter(
      (group) =>
        group.plan_type === "camp" ||
        group.camp_template_id !== null ||
        group.camp_invitation_id !== null
    );
    planGroupIds = campPlanGroups.map((g) => g.id);
  } else {
    // ì¼ë°˜ ëª¨ë“œ: ì¼ë°˜ í™œì„± í”Œëœ ê·¸ë£¹ë§Œ í•„í„°ë§
    const nonCampPlanGroups = allActivePlanGroups.filter(
      (group) =>
        group.plan_type !== "camp" &&
        group.camp_template_id === null &&
        group.camp_invitation_id === null
    );
    planGroupIds = nonCampPlanGroups.map((g) => g.id);
  }

  // ì„ íƒí•œ ë‚ ì§œ í”Œëœ ì¡°íšŒ
  let plans = await getPlansForStudent({
    studentId,
    tenantId,
    planDate: targetDate,
    planGroupIds: planGroupIds.length > 0 ? planGroupIds : undefined,
  });

  let displayDate = targetDate;
  let isToday = targetDate === todayDate;

  // ì˜¤ëŠ˜ í”Œëœì´ ì—†ìœ¼ë©´ ê°€ì¥ ê°€ê¹Œìš´ ë¯¸ë˜ ë‚ ì§œì˜ í”Œëœ ì°¾ê¸°
  if (!requestedDateParam && plans.length === 0) {
    const shortRangeEndDate = new Date(today);
    shortRangeEndDate.setDate(shortRangeEndDate.getDate() + 30);
    const shortRangeEndDateStr = shortRangeEndDate.toISOString().slice(0, 10);

    let futurePlans = await getPlansForStudent({
      studentId,
      tenantId,
      dateRange: {
        start: todayDate,
        end: shortRangeEndDateStr,
      },
      planGroupIds: planGroupIds.length > 0 ? planGroupIds : undefined,
    });

    if (futurePlans.length === 0) {
      const longRangeEndDate = new Date(today);
      longRangeEndDate.setDate(longRangeEndDate.getDate() + 180);
      const longRangeEndDateStr = longRangeEndDate.toISOString().slice(0, 10);

      futurePlans = await getPlansForStudent({
        studentId,
        tenantId,
        dateRange: {
          start: todayDate,
          end: longRangeEndDateStr,
        },
        planGroupIds: planGroupIds.length > 0 ? planGroupIds : undefined,
      });
    }

    if (futurePlans.length > 0) {
      const sortedPlans = futurePlans.sort((a, b) => {
        if (!a.plan_date || !b.plan_date) return 0;
        return a.plan_date.localeCompare(b.plan_date);
      });

      const nearestDate = sortedPlans[0].plan_date;
      if (nearestDate) {
        displayDate = nearestDate;
        isToday = false;
        plans = futurePlans.filter((p) => p.plan_date === nearestDate);
      }
    }
  }

  // Calculate todayProgress from already loaded data (no additional DB queries)
  // This replaces the ~600ms calculateTodayProgress call with in-memory computation
  let todayProgress: TodayProgress | null = null;
  if (includeProgress) {
    try {
      // Use already loaded plans (no need to re-query)
      const planTotalCount = plans.length;
      const planCompletedCount = plans.filter((plan) => !!plan.actual_end_time).length;

      // We'll compute todayStudyMinutes and achievementScore after fullDaySessions are loaded
      // Store intermediate values for later computation
      todayProgress = {
        todayStudyMinutes: 0, // Will be computed after sessions are loaded
        planCompletedCount,
        planTotalCount,
        achievementScore: 0, // Will be computed after todayStudyMinutes is known
      };
    } catch (error) {
      console.error("[data/todayPlans] ì˜¤ëŠ˜ ì§„í–‰ë¥  ê³„ì‚° ì‹¤íŒ¨ (ë¹„ì°¨ë‹¨)", error);
      // Non-blocking: continue without progress data
      todayProgress = null;
    }
  }

  if (plans.length === 0) {
    // If no plans, we still need to finalize todayProgress if includeProgress is true
    if (includeProgress && todayProgress) {
      // For empty plans, todayProgress is already computed (all zeros)
      todayProgress.todayStudyMinutes = 0;
      todayProgress.achievementScore = 0;
    }
    return {
      plans: [],
      sessions: {},
      planDate: displayDate,
      isToday,
      serverNow: Date.now(),
      todayProgress: todayProgress ?? undefined,
    };
  }

  // ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ (ìµœì í™”: í•„ìš”í•œ IDë§Œ ì¡°íšŒ)
  // Note: First run can be slow (~59s) due to cold start, connection pooling, or index warmup.
  // Subsequent runs should be ~190ms. This code is hardened to prevent large IN clauses and malformed queries.
  
  // Extract and deduplicate content IDs (defensive: filter out null/undefined/empty)
  const bookIds = [...new Set(
    plans
      .filter((p) => p.content_type === "book" && p.content_id && typeof p.content_id === "string")
      .map((p) => p.content_id as string)
  )];
  const lectureIds = [...new Set(
    plans
      .filter((p) => p.content_type === "lecture" && p.content_id && typeof p.content_id === "string")
      .map((p) => p.content_id as string)
  )];
  const customIds = [...new Set(
    plans
      .filter((p) => p.content_type === "custom" && p.content_id && typeof p.content_id === "string")
      .map((p) => p.content_id as string)
  )];

  // ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©í•˜ì—¬ ì½˜í…ì¸  ì¡°íšŒ
  const { books, lectures, customContents } = await getContentsByIds(
    bookIds,
    lectureIds,
    customIds,
    studentId,
    tenantId
  );

  // ë°ì´í„° enrich ì‹œì‘ (ë©”ëª¨ë¦¬ ì—°ì‚°ë§Œ ì¸¡ì •, DB ì¿¼ë¦¬ëŠ” ë³„ë„ ì¸¡ì •)
  // Step 1: Build maps (O(n) where n = content count)
  const contentMap = new Map<string, unknown>();
  books.forEach((book) => contentMap.set(`book:${book.id}`, book));
  lectures.forEach((lecture) => contentMap.set(`lecture:${lecture.id}`, lecture));
  customContents.forEach((custom) => contentMap.set(`custom:${custom.id}`, custom));

  // ì§„í–‰ë¥  ì¡°íšŒ (ìµœì í™”: í•„ìš”í•œ ì½˜í…ì¸ ë§Œ ì¡°íšŒ)
  // í•„ìš”í•œ ì½˜í…ì¸ ì˜ (content_type, content_id) ìŒë§Œ ì¡°íšŒ
  const contentKeys = new Set<string>();
  plans.forEach((plan) => {
    if (plan.content_type && plan.content_id) {
      contentKeys.add(`${plan.content_type}:${plan.content_id}`);
    }
  });

  let progressData: Array<{ content_type: string; content_id: string; progress: number | null }> = [];
  
  if (contentKeys.size > 0) {
    // ê° content_typeë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ ì¿¼ë¦¬
    const bookProgressIds: string[] = [];
    const lectureProgressIds: string[] = [];
    const customProgressIds: string[] = [];

    contentKeys.forEach((key) => {
      const [type, id] = key.split(":");
      if (type === "book") bookProgressIds.push(id);
      else if (type === "lecture") lectureProgressIds.push(id);
      else if (type === "custom") customProgressIds.push(id);
    });

    const progressQueries = [];
    if (bookProgressIds.length > 0) {
      progressQueries.push(
        supabase
          .from("student_content_progress")
          .select("content_type,content_id,progress")
          .eq("student_id", studentId)
          .eq("content_type", "book")
          .in("content_id", bookProgressIds)
      );
    }
    if (lectureProgressIds.length > 0) {
      progressQueries.push(
        supabase
          .from("student_content_progress")
          .select("content_type,content_id,progress")
          .eq("student_id", studentId)
          .eq("content_type", "lecture")
          .in("content_id", lectureProgressIds)
      );
    }
    if (customProgressIds.length > 0) {
      progressQueries.push(
        supabase
          .from("student_content_progress")
          .select("content_type,content_id,progress")
          .eq("student_id", studentId)
          .eq("content_type", "custom")
          .in("content_id", customProgressIds)
      );
    }

    if (progressQueries.length > 0) {
      const results = await Promise.all(progressQueries);
      results.forEach((result) => {
        if (result.data) {
          progressData.push(...result.data);
        }
      });
    }
  }

  // Step 2: Build progress map (O(n) where n = progress records)
  const progressMap = new Map<string, number | null>();
  progressData.forEach((row) => {
    if (row.content_type && row.content_id) {
      const key = `${row.content_type}:${row.content_id}`;
      progressMap.set(key, row.progress ?? null);
    }
  });

  // Wave 2: Queries that depend on plans (can run in parallel after plans are loaded)
  // - contents (books/lectures/custom) - already parallelized above
  // - progress (narrowed) - already parallelized above
  // - activeSessions (narrowed) - for plan execution state
  // - fullDaySessions (only if includeProgress) - for todayStudyMinutes calculation
  const planIds = plans.map((p) => p.id);
  const [activeSessionsResult, fullDaySessionsResult] = await Promise.all([
    // Query 1: Active sessions for plan execution state (narrowed to plan IDs) - ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©
    (async () => {
      if (planIds.length === 0) {
        return [];
      }
      const activeSessions = await getActiveSessionsForPlans(planIds, studentId, tenantId);
      // ê¸°ì¡´ í˜•ì‹ì— ë§ê²Œ ë³€í™˜
      return activeSessions.map((session) => ({
        plan_id: session.plan_id,
        started_at: session.started_at,
        paused_at: session.paused_at,
        resumed_at: session.resumed_at,
        paused_duration_seconds: session.paused_duration_seconds,
      }));
    })(),
    // Query 2: Full-day sessions for todayProgress calculation (only if includeProgress)
    includeProgress && plans.length > 0
      ? (async () => {
          const target = new Date(targetDate + "T00:00:00");
          const targetEnd = new Date(target);
          targetEnd.setHours(23, 59, 59, 999);
          const sessions = await getSessionsInRange({
            studentId,
            tenantId,
            dateRange: {
              start: target.toISOString(),
              end: targetEnd.toISOString(),
            },
          });
          return sessions;
        })()
      : Promise.resolve([]),
  ]);
  const activeSessions = activeSessionsResult;
  const fullDaySessions = fullDaySessionsResult;

  // Complete todayProgress calculation now that we have fullDaySessions
  if (includeProgress && todayProgress && fullDaySessions.length >= 0) {
    try {
      const activeSessionMap = buildActiveSessionMap(fullDaySessions);
      const nowMs = Date.now();
      const todayStudySeconds = plans.reduce((total, plan) => {
        return (
          total +
          calculatePlanStudySeconds(
            {
              actual_start_time: plan.actual_start_time,
              actual_end_time: plan.actual_end_time,
              total_duration_seconds: plan.total_duration_seconds,
              paused_duration_seconds: plan.paused_duration_seconds,
            },
            nowMs,
            plan.actual_end_time ? undefined : activeSessionMap.get(plan.id)
          )
        );
      }, 0);

      const todayStudyMinutes = Math.floor(todayStudySeconds / 60);

      // Calculate achievement score
      // (ì˜¤ëŠ˜ ì‹¤í–‰ë¥  * 0.7) + (ì§‘ì¤‘ íƒ€ì´ë¨¸ ëˆ„ì /ì˜ˆìƒ * 0.3)
      const executionRate =
        todayProgress.planTotalCount > 0
          ? (todayProgress.planCompletedCount / todayProgress.planTotalCount) * 100
          : 0;

      const expectedMinutes = todayProgress.planTotalCount * 60;
      const focusTimerRate =
        expectedMinutes > 0
          ? Math.min((todayStudyMinutes / expectedMinutes) * 100, 100)
          : 0;

      const achievementScore = Math.round(
        executionRate * 0.7 + focusTimerRate * 0.3
      );

      todayProgress.todayStudyMinutes = todayStudyMinutes;
      todayProgress.achievementScore = achievementScore;
    } catch (error) {
      console.error("[data/todayPlans] ì˜¤ëŠ˜ ì§„í–‰ë¥  ìµœì¢… ê³„ì‚° ì‹¤íŒ¨ (ë¹„ì°¨ë‹¨)", error);
      // Keep partial progress data
    }
  }

  // Step 3: Build session map (O(n) where n = active sessions)
  const sessionMap = new Map<string, { 
    isPaused: boolean; 
    startedAt?: string | null;
    pausedAt?: string | null; 
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }>();
  activeSessions?.forEach((session) => {
    if (session.plan_id) {
      const isPaused = !!session.paused_at && !session.resumed_at;
      sessionMap.set(session.plan_id, {
        isPaused,
        startedAt: session.started_at,
        pausedAt: session.paused_at,
        resumedAt: session.resumed_at,
        pausedDurationSeconds: session.paused_duration_seconds,
      });
    }
  });

  // Step 4: Attach content/progress/session to plans (O(n) where n = plans)
  // Optimized: Remove destructuring and spread operations for better performance
  
  // Helper function to exclude denormalized fields (more efficient than destructuring)
  const excludeFields = <T extends Record<string, any>>(
    obj: T,
    fieldsToExclude: Set<string>
  ): Omit<T, keyof T & string> => {
    const result: any = {};
    for (const key in obj) {
      if (!fieldsToExclude.has(key)) {
        result[key] = obj[key];
      }
    }
    return result;
  };

  const denormalizedFields = new Set([
    'content_title',
    'content_subject',
    'content_subject_category',
    'content_category'
  ]);

  const plansWithContent: PlanWithContent[] = plans.map((plan) => {
    // Pre-compute content key once per plan
    const contentKey = plan.content_type && plan.content_id 
      ? `${plan.content_type}:${plan.content_id}` 
      : null;
    
    // Direct Map lookups (O(1) each)
    const content = contentKey ? contentMap.get(contentKey) : undefined;
    const progress = contentKey ? (progressMap.get(contentKey) ?? null) : null;
    const session = sessionMap.get(plan.id);

    // Optimized: Use helper function for field exclusion (more efficient than destructuring)
    const planWithoutDenormalized = excludeFields(plan, denormalizedFields);

    // Optimized: Reuse session object from sessionMap (no need to recreate)
    // sessionMap already contains the properly formatted object
    // Optimized: Use Object.assign for better performance than spread
    const result = Object.assign({}, planWithoutDenormalized, {
      content: content as Book | Lecture | CustomContent | undefined,
      progress: progress ?? plan.progress ?? null,
      session: session,
    }) as PlanWithContent;

    return result;
  });

  // Step 5: Convert session map to object (O(n) where n = active sessions)
  const sessionsObj: Record<string, { 
    isPaused: boolean; 
    startedAt?: string | null;
    pausedAt?: string | null; 
    resumedAt?: string | null;
    pausedDurationSeconds?: number | null;
  }> = {};
  sessionMap.forEach((value, key) => {
    sessionsObj[key] = value;
  });

  const result: TodayPlansResponse = {
    plans: plansWithContent,
    sessions: sessionsObj,
    planDate: displayDate,
    isToday,
    serverNow: Date.now(),
    todayProgress: todayProgress ?? undefined,
  };

  // Cache store (if enabled and result is valid) - ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ
  if (useCache && result) {
    const storeTimer = perfTime("[todayPlans] cache - store");
    try {
      const now = new Date();
      const expiresAt = new Date(now.getTime() + (cacheTtlSeconds * 1000));
      
      // Use upsert with single UNIQUE constraint
      // Constraint: today_plans_cache_unique_key (tenant_id, student_id, plan_date, is_camp_mode)
      // Always use all 4 columns for onConflict, regardless of tenant_id being NULL or not
      const { error: cacheError } = await supabase
        .from("today_plans_cache")
        .upsert({
          tenant_id: tenantId ?? null,
          student_id: studentId,
          plan_date: targetDate,
          is_camp_mode: !!camp,
          payload: result,
          computed_at: now.toISOString(),
          expires_at: expiresAt.toISOString(),
          updated_at: now.toISOString(),
        }, {
          onConflict: "tenant_id,student_id,plan_date,is_camp_mode",
        });

      if (cacheError) {
        console.warn("[todayPlans] cache store error (non-blocking):", cacheError);
      }
    } catch (error) {
      console.warn("[todayPlans] cache store failed (non-blocking):", error);
      // Continue without caching - result is still valid
    }
    storeTimer.end();
  }

  return result;
}
</file>

<file path="userConsents.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { ConsentData, ConsentMetadata, ConsentType } from "@/lib/types/auth";

/**
 * ì‚¬ìš©ì ì•½ê´€ ë™ì˜ ì •ë³´ ì €ì¥
 * @param userId ì‚¬ìš©ì ID
 * @param consents ì•½ê´€ ë™ì˜ ë°ì´í„°
 * @param metadata ì„ íƒì  ë©”íƒ€ë°ì´í„° (IP ì£¼ì†Œ, User Agent)
 */
export async function saveUserConsents(
  userId: string,
  consents: ConsentData,
  metadata?: ConsentMetadata
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    // ì•½ê´€ ë™ì˜ ë°ì´í„°ë¥¼ ë°°ì—´ë¡œ ë³€í™˜
    const consentRecords: Array<{
      user_id: string;
      consent_type: ConsentType;
      consented: boolean;
      ip_address?: string | null;
      user_agent?: string | null;
    }> = [
      {
        user_id: userId,
        consent_type: "terms",
        consented: consents.terms,
        ip_address: metadata?.ip_address || null,
        user_agent: metadata?.user_agent || null,
      },
      {
        user_id: userId,
        consent_type: "privacy",
        consented: consents.privacy,
        ip_address: metadata?.ip_address || null,
        user_agent: metadata?.user_agent || null,
      },
      {
        user_id: userId,
        consent_type: "marketing",
        consented: consents.marketing,
        ip_address: metadata?.ip_address || null,
        user_agent: metadata?.user_agent || null,
      },
    ];

    // ì•½ê´€ ë™ì˜ ì •ë³´ ì €ì¥ (UPSERT ì‚¬ìš©í•˜ì—¬ ì¤‘ë³µ ì‹œ ì—…ë°ì´íŠ¸)
    const { error } = await supabase.from("user_consents").upsert(consentRecords, {
      onConflict: "user_id,consent_type",
    });

    if (error) {
      console.error("[userConsents] ì•½ê´€ ë™ì˜ ì €ì¥ ì‹¤íŒ¨:", {
        userId,
        error: error.message,
        code: error.code,
      });
      return {
        success: false,
        error: error.message || "ì•½ê´€ ë™ì˜ ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    console.log("[userConsents] ì•½ê´€ ë™ì˜ ì €ì¥ ì„±ê³µ:", { userId });
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[userConsents] ì•½ê´€ ë™ì˜ ì €ì¥ ì˜ˆì™¸:", {
      userId,
      error: errorMessage,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * ì‚¬ìš©ìì˜ ì•½ê´€ ë™ì˜ ì •ë³´ ì¡°íšŒ
 * @param userId ì‚¬ìš©ì ID
 */
export async function getUserConsents(userId: string): Promise<{
  terms: boolean;
  privacy: boolean;
  marketing: boolean;
} | null> {
  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("user_consents")
      .select("consent_type, consented")
      .eq("user_id", userId);

    if (error) {
      console.error("[userConsents] ì•½ê´€ ë™ì˜ ì¡°íšŒ ì‹¤íŒ¨:", {
        userId,
        error: error.message,
        code: error.code,
      });
      return null;
    }

    // ë°ì´í„°ë¥¼ ê°ì²´ë¡œ ë³€í™˜
    const consents = {
      terms: false,
      privacy: false,
      marketing: false,
    };

    data?.forEach((record) => {
      if (record.consent_type === "terms") {
        consents.terms = record.consented;
      } else if (record.consent_type === "privacy") {
        consents.privacy = record.consented;
      } else if (record.consent_type === "marketing") {
        consents.marketing = record.consented;
      }
    });

    return consents;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[userConsents] ì•½ê´€ ë™ì˜ ì¡°íšŒ ì˜ˆì™¸:", {
      userId,
      error: errorMessage,
    });
    return null;
  }
}
</file>

<file path="config/configManager.ts">
/**
 * ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì • ê´€ë¦¬ì
 * DBì—ì„œ ì„¤ì •ì„ ì¡°íšŒ/ì €ì¥í•˜ê³ , ê¸°ë³¸ê°’ í´ë°± ë¡œì§ì„ ì œê³µ
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { SupabaseServerClient } from "@/lib/data/core/types";
import {
  RangeRecommendationConfig,
  type RecommendationConfig,
} from "./types";
import {
  defaultRangeRecommendationConfig,
  defaultRecommendationConfig,
} from "./defaultConfig";

/**
 * ì„¤ì • íƒ€ì…ë³„ ìƒìˆ˜
 */
const SETTING_TYPES = {
  RANGE_RECOMMENDATION: "range_recommendation",
} as const;

const SETTING_KEYS = {
  RANGE_RECOMMENDATION_CONFIG: "config",
} as const;

/**
 * ë²”ìœ„ ì¶”ì²œ ì„¤ì • ì¡°íšŒ
 * ìš°ì„ ìˆœìœ„: í…Œë„ŒíŠ¸ë³„ ì„¤ì • â†’ ì „ì—­ ì„¤ì • â†’ ê¸°ë³¸ê°’
 *
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì—†ìœ¼ë©´ ì „ì—­ ì„¤ì •ë§Œ ì¡°íšŒ)
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì , ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±)
 * @returns ë²”ìœ„ ì¶”ì²œ ì„¤ì •
 */
export async function getRangeRecommendationConfig(
  tenantId?: string | null,
  supabase?: SupabaseServerClient
): Promise<RangeRecommendationConfig> {
  const client = supabase ?? (await createSupabaseServerClient());

  try {
    // 1. í…Œë„ŒíŠ¸ë³„ ì„¤ì • ì¡°íšŒ (tenantIdê°€ ìˆëŠ” ê²½ìš°)
    if (tenantId) {
      const { data: tenantConfig, error: tenantError } = await client
        .from("recommendation_settings")
        .select("setting_value")
        .eq("tenant_id", tenantId)
        .eq("setting_type", SETTING_TYPES.RANGE_RECOMMENDATION)
        .eq("setting_key", SETTING_KEYS.RANGE_RECOMMENDATION_CONFIG)
        .maybeSingle();

      if (!tenantError && tenantConfig?.setting_value) {
        const config = tenantConfig.setting_value as RangeRecommendationConfig;
        // ìœ íš¨ì„± ê²€ì¦
        if (isValidRangeConfig(config)) {
          return config;
        }
        console.warn(
          "[configManager] í…Œë„ŒíŠ¸ë³„ ì„¤ì •ì´ ìœ íš¨í•˜ì§€ ì•Šì•„ ê¸°ë³¸ê°’ ì‚¬ìš©:",
          tenantId
        );
      }
    }

    // 2. ì „ì—­ ì„¤ì • ì¡°íšŒ (tenant_idê°€ NULL)
    const { data: globalConfig, error: globalError } = await client
      .from("recommendation_settings")
      .select("setting_value")
      .is("tenant_id", null)
      .eq("setting_type", SETTING_TYPES.RANGE_RECOMMENDATION)
      .eq("setting_key", SETTING_KEYS.RANGE_RECOMMENDATION_CONFIG)
      .maybeSingle();

    if (!globalError && globalConfig?.setting_value) {
      const config = globalConfig.setting_value as RangeRecommendationConfig;
      // ìœ íš¨ì„± ê²€ì¦
      if (isValidRangeConfig(config)) {
        return config;
      }
      console.warn(
        "[configManager] ì „ì—­ ì„¤ì •ì´ ìœ íš¨í•˜ì§€ ì•Šì•„ ê¸°ë³¸ê°’ ì‚¬ìš©"
      );
    }
  } catch (error) {
    console.error("[configManager] ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©:", error);
  }

  // 3. ê¸°ë³¸ê°’ ë°˜í™˜
  return defaultRangeRecommendationConfig;
}

/**
 * ë²”ìœ„ ì¶”ì²œ ì„¤ì • ì—…ë°ì´íŠ¸
 *
 * @param config ë²”ìœ„ ì¶”ì²œ ì„¤ì •
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì—†ìœ¼ë©´ ì „ì—­ ì„¤ì •ìœ¼ë¡œ ì €ì¥)
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì )
 * @returns ì„±ê³µ ì—¬ë¶€
 */
export async function updateRangeRecommendationConfig(
  config: RangeRecommendationConfig,
  tenantId?: string | null,
  supabase?: SupabaseServerClient
): Promise<{ success: boolean; error?: string }> {
  // ìœ íš¨ì„± ê²€ì¦
  if (!isValidRangeConfig(config)) {
    return {
      success: false,
      error: "ì„¤ì • ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
    };
  }

  const client = supabase ?? (await createSupabaseServerClient());

  try {
    const { error } = await client
      .from("recommendation_settings")
      .upsert(
        {
          tenant_id: tenantId || null,
          setting_type: SETTING_TYPES.RANGE_RECOMMENDATION,
          setting_key: SETTING_KEYS.RANGE_RECOMMENDATION_CONFIG,
          setting_value: config,
          version: 1,
          updated_at: new Date().toISOString(),
        },
        {
          onConflict: "tenant_id,setting_type,setting_key",
        }
      );

    if (error) {
      console.error("[configManager] ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
      return {
        success: false,
        error: error.message,
      };
    }

    return { success: true };
  } catch (error) {
    console.error("[configManager] ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜",
    };
  }
}

/**
 * ë²”ìœ„ ì¶”ì²œ ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì¬ì„¤ì •
 *
 * @param tenantId í…Œë„ŒíŠ¸ ID (ì—†ìœ¼ë©´ ì „ì—­ ì„¤ì • ì¬ì„¤ì •)
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸ (ì„ íƒì )
 * @returns ì„±ê³µ ì—¬ë¶€
 */
export async function resetRangeRecommendationConfig(
  tenantId?: string | null,
  supabase?: SupabaseServerClient
): Promise<{ success: boolean; error?: string }> {
  return updateRangeRecommendationConfig(
    defaultRangeRecommendationConfig,
    tenantId,
    supabase
  );
}

/**
 * ë²”ìœ„ ì¶”ì²œ ì„¤ì • ìœ íš¨ì„± ê²€ì¦
 */
function isValidRangeConfig(
  config: unknown
): config is RangeRecommendationConfig {
  if (!config || typeof config !== "object") {
    return false;
  }

  const c = config as Partial<RangeRecommendationConfig>;

  // pagesPerHour ê²€ì¦ (ì–‘ìˆ˜)
  if (
    typeof c.pagesPerHour !== "number" ||
    c.pagesPerHour <= 0 ||
    !Number.isFinite(c.pagesPerHour)
  ) {
    return false;
  }

  // episodesPerHour ê²€ì¦ (ì–‘ìˆ˜)
  if (
    typeof c.episodesPerHour !== "number" ||
    c.episodesPerHour <= 0 ||
    !Number.isFinite(c.episodesPerHour)
  ) {
    return false;
  }

  return true;
}
</file>

<file path="config/defaultConfig.ts">
/**
 * ì¶”ì²œ ì‹œìŠ¤í…œ ê¸°ë³¸ ì„¤ì • ê°’
 * í˜„ì¬ í•˜ë“œì½”ë”©ëœ ê°’ê³¼ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ì—¬ ê¸°ì¡´ ê¸°ëŠ¥ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒ
 */

import { RecommendationConfig } from "./types";

/**
 * ê¸°ë³¸ ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì •
 */
export const defaultRecommendationConfig: RecommendationConfig = {
  rangeRecommendation: {
    pagesPerHour: 10, // í˜„ì¬ í•˜ë“œì½”ë”© ê°’: lib/plan/rangeRecommendation.ts 113ì¤„
    episodesPerHour: 1, // í˜„ì¬ í•˜ë“œì½”ë”© ê°’: lib/plan/rangeRecommendation.ts 127ì¤„
  },
};

/**
 * ê¸°ë³¸ ë²”ìœ„ ì¶”ì²œ ì„¤ì •
 */
export const defaultRangeRecommendationConfig = defaultRecommendationConfig.rangeRecommendation;
</file>

<file path="config/index.ts">
/**
 * ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì • ëª¨ë“ˆ í†µí•© export
 */

export type {
  RangeRecommendationConfig,
  RecommendationConfig,
} from "./types";

export {
  defaultRecommendationConfig,
  defaultRangeRecommendationConfig,
} from "./defaultConfig";

export {
  getRangeRecommendationConfig,
  updateRangeRecommendationConfig,
  resetRangeRecommendationConfig,
} from "./configManager";
</file>

<file path="config/types.ts">
/**
 * ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì • íƒ€ì… ì •ì˜
 */

/**
 * ë²”ìœ„ ì¶”ì²œ ì„¤ì •
 */
export type RangeRecommendationConfig = {
  /** êµì¬: 1ì‹œê°„ë‹¹ í˜ì´ì§€ ìˆ˜ */
  pagesPerHour: number;
  /** ê°•ì˜: 1ì‹œê°„ë‹¹ íšŒì°¨ ìˆ˜ */
  episodesPerHour: number;
};

/**
 * ì „ì²´ ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì •
 * í–¥í›„ í™•ì¥ ê°€ëŠ¥ (contentRecommendation, batchRecommendation ë“±)
 */
export type RecommendationConfig = {
  rangeRecommendation: RangeRecommendationConfig;
  // í–¥í›„ í™•ì¥:
  // contentRecommendation?: ContentRecommendationConfig;
  // batchRecommendation?: BatchRecommendationConfig;
};
</file>

<file path="contentRecommendation.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getSessionsByDateRange } from "@/lib/studySessions/queries";
import { getActiveGoals } from "@/lib/goals/queries";
import { getSubjectFromContent } from "@/lib/studySessions/summary";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

type ContentProgress = {
  id: string;
  contentType: "book" | "lecture" | "custom";
  title: string;
  subject: string | null;
  total: number | null;
  progress: number | null;
  progressPercent: number;
  lastUsedDate: string | null;
};

/**
 * ì½˜í…ì¸ (ì±…/ê°•ì˜/ì»¤ìŠ¤í…€) ì¶”ì²œ ìƒì„±
 * - ì½˜í…ì¸ ë³„ ì§„í–‰ë¥ 
 * - ìµœê·¼ ì‚¬ìš© ê¸°ë¡
 * - ëª©í‘œì™€ ì½˜í…ì¸  ë§¤ì¹­
 */
export async function getContentRecommendations(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<string[]> {
  const recommendations: string[] = [];

  try {
    // ìµœê·¼ 2ì£¼ ë²”ìœ„ ê³„ì‚°
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const twoWeeksAgo = new Date(today);
    twoWeeksAgo.setDate(today.getDate() - 14);
    const twoWeeksAgoStr = twoWeeksAgo.toISOString().slice(0, 10);
    const todayStr = today.toISOString().slice(0, 10);

    // ì§„í–‰ë¥  ì¡°íšŒ
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("content_type,content_id,progress")
        .eq("student_id", studentId);

    let { data: progressRows } = await selectProgress();
    if (!progressRows) {
      ({ data: progressRows } = await selectProgress());
    }

    const progressMap = new Map<string, number | null>();
    (progressRows || []).forEach((row: any) => {
      const key = `${row.content_type}:${row.content_id}`;
      progressMap.set(key, row.progress);
    });

    // ìµœê·¼ ì„¸ì…˜ ì¡°íšŒ (ì‚¬ìš© ê¸°ë¡ í™•ì¸)
    const sessions = await getSessionsByDateRange(
      supabase,
      studentId,
      twoWeeksAgoStr,
      todayStr
    );

    const contentLastUsed = new Map<string, string>();
    sessions.forEach((session) => {
      if (session.content_type && session.content_id) {
        const key = `${session.content_type}:${session.content_id}`;
        const sessionDate = session.started_at
          ? new Date(session.started_at).toISOString().slice(0, 10)
          : null;
        if (sessionDate) {
          const existing = contentLastUsed.get(key);
          if (!existing || sessionDate > existing) {
            contentLastUsed.set(key, sessionDate);
          }
        }
      }
    });

    // ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ ë° ì§„í–‰ë¥  ê³„ì‚°
    const contents: ContentProgress[] = [];

    // ì±… ì¡°íšŒ
    const selectBooks = () =>
      supabase
        .from("books")
        .select("id,title,subject,total_pages")
        .eq("student_id", studentId);

    let { data: books } = await selectBooks();
    if (!books) {
      ({ data: books } = await selectBooks());
    }

    (books || []).forEach((book: any) => {
      const key = `book:${book.id}`;
      const progressValue = progressMap.get(key);
      // progressëŠ” percentageì¼ ìˆ˜ë„ ìˆê³  amountì¼ ìˆ˜ë„ ìˆìŒ
      // total_pagesê°€ ìˆìœ¼ë©´ amountë¡œ ê°€ì •, ì—†ìœ¼ë©´ percentageë¡œ ê°€ì •
      const total = book.total_pages || null;
      let progress: number | null = null;
      let progressPercent = 0;
      
      if (progressValue !== null && progressValue !== undefined) {
        if (total && total > 0) {
          // progressê°€ amountì¸ ê²½ìš°
          progress = progressValue;
          progressPercent = (progressValue / total) * 100;
        } else {
          // progressê°€ percentageì¸ ê²½ìš°
          progressPercent = progressValue;
          progress = null;
        }
      }
      
      contents.push({
        id: book.id,
        contentType: "book",
        title: book.title,
        subject: book.subject,
        total,
        progress,
        progressPercent,
        lastUsedDate: contentLastUsed.get(key) || null,
      });
    });

    // ê°•ì˜ ì¡°íšŒ
    const selectLectures = () =>
      supabase
        .from("lectures")
        .select("id,title,subject,duration")
        .eq("student_id", studentId);

    let { data: lectures } = await selectLectures();
    if (!lectures) {
      ({ data: lectures } = await selectLectures());
    }

    (lectures || []).forEach((lecture: any) => {
      const key = `lecture:${lecture.id}`;
      const progressValue = progressMap.get(key);
      const total = lecture.duration || null;
      let progress: number | null = null;
      let progressPercent = 0;
      
      if (progressValue !== null && progressValue !== undefined) {
        if (total && total > 0) {
          progress = progressValue;
          progressPercent = (progressValue / total) * 100;
        } else {
          progressPercent = progressValue;
          progress = null;
        }
      }
      
      contents.push({
        id: lecture.id,
        contentType: "lecture",
        title: lecture.title,
        subject: lecture.subject,
        total,
        progress,
        progressPercent,
        lastUsedDate: contentLastUsed.get(key) || null,
      });
    });

    // ì»¤ìŠ¤í…€ ì½˜í…ì¸  ì¡°íšŒ
    const selectCustom = () =>
      supabase
        .from("student_custom_contents")
        .select("id,title,subject,total_page_or_time")
        .eq("student_id", studentId);

    let { data: customContents } = await selectCustom();
    if (!customContents) {
      ({ data: customContents } = await selectCustom());
    }

    (customContents || []).forEach((custom: any) => {
      const key = `custom:${custom.id}`;
      const progressValue = progressMap.get(key);
      const total = custom.total_page_or_time || null;
      let progress: number | null = null;
      let progressPercent = 0;
      
      if (progressValue !== null && progressValue !== undefined) {
        if (total && total > 0) {
          progress = progressValue;
          progressPercent = (progressValue / total) * 100;
        } else {
          progressPercent = progressValue;
          progress = null;
        }
      }
      
      contents.push({
        id: custom.id,
        contentType: "custom",
        title: custom.title,
        subject: custom.subject,
        total,
        progress,
        progressPercent,
        lastUsedDate: contentLastUsed.get(key) || null,
      });
    });

    // í™œì„± ëª©í‘œ ì¡°íšŒ
    const activeGoals = await getActiveGoals(supabase, studentId, todayStr);
    const goalsBySubject = new Set(
      activeGoals.map((g) => g.subject).filter((s): s is string => s !== null)
    );

    // Rule 1: 50% ë¯¸ë§Œ ì§„í–‰ ì¤‘ì¸ ì½˜í…ì¸  â†’ 'ê¾¸ì¤€íˆ ì§„í–‰' ì¶”ì²œ
    const lowProgressContents = contents.filter(
      (c) => c.progressPercent > 0 && c.progressPercent < 50 && c.total !== null
    );

    for (const content of lowProgressContents.slice(0, 3)) {
      const contentTypeLabel =
        content.contentType === "book"
          ? "êµì¬"
          : content.contentType === "lecture"
          ? "ê°•ì˜"
          : "ì½˜í…ì¸ ";
      recommendations.push(
        `${contentTypeLabel} "${content.title}"ì€ ${Math.round(content.progressPercent)}% ì§„í–‰ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë²ˆì£¼ì— ${Math.round(content.progressPercent + 10)}%ê¹Œì§€ ëŒì–´ì˜¬ë¦¬ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.`
      );
    }

    // Rule 2: ìµœê·¼ ì‚¬ìš© 0ì¸ ì½˜í…ì¸  â†’ 'ì¬í™œì„±í™”' ì¶”ì²œ
    const unusedContents = contents.filter(
      (c) => !c.lastUsedDate || new Date(c.lastUsedDate) < twoWeeksAgo
    );

    for (const content of unusedContents.slice(0, 2)) {
      const contentTypeLabel =
        content.contentType === "book"
          ? "êµì¬"
          : content.contentType === "lecture"
          ? "ê°•ì˜"
          : "ì½˜í…ì¸ ";
      recommendations.push(
        `${contentTypeLabel} "${content.title}"ì€ ìµœê·¼ 2ì£¼ ë™ì•ˆ ì‚¬ìš© ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤. ì£¼ 1íšŒë¼ë„ í•™ìŠµí•´ë³´ì„¸ìš”.`
      );
    }

    // Rule 3: ëª©í‘œ ëŒ€ë¹„ ì½˜í…ì¸  ë§¤ì¹­ ì•ˆ ë¨ â†’ 'ì½˜í…ì¸  ë“±ë¡/ì—°ê²°' ì¶”ì²œ
    for (const goal of activeGoals) {
      if (!goal.subject) continue;

      // í•´ë‹¹ ê³¼ëª©ì˜ ì½˜í…ì¸ ê°€ ìˆëŠ”ì§€ í™•ì¸
      const hasContentForSubject = contents.some(
        (c) => c.subject === goal.subject && c.progressPercent > 0
      );

      if (!hasContentForSubject) {
        recommendations.push(
          `ëª©í‘œ "${goal.title}"ê³¼ ê´€ë ¨ëœ ì½˜í…ì¸ ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê´€ë ¨ êµì¬ ë˜ëŠ” ê°•ì˜ë¥¼ ë“±ë¡í•˜ì„¸ìš”.`
        );
      }
    }

    // Rule 4: ì§„í–‰ë¥ ì´ ë†’ì€ë° ë©ˆì¶˜ ì½˜í…ì¸ 
    const highProgressStopped = contents.filter(
      (c) =>
        c.progressPercent >= 50 &&
        c.progressPercent < 100 &&
        (!c.lastUsedDate || new Date(c.lastUsedDate) < twoWeeksAgo)
    );

    for (const content of highProgressStopped.slice(0, 2)) {
      const contentTypeLabel =
        content.contentType === "book"
          ? "êµì¬"
          : content.contentType === "lecture"
          ? "ê°•ì˜"
          : "ì½˜í…ì¸ ";
      recommendations.push(
        `${contentTypeLabel} "${content.title}"ì€ ${Math.round(content.progressPercent)}% ì§„í–‰ë˜ì—ˆì§€ë§Œ ìµœê·¼ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì™„ì£¼ë¥¼ ìœ„í•´ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.`
      );
    }

    return recommendations;
  } catch (error) {
    console.error("[recommendations/content] ì½˜í…ì¸  ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    return [];
  }
}
</file>

<file path="engine.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getSubjectRecommendations } from "./subjectRecommendation";
import { getGoalRecommendations } from "./goalRecommendation";
import { getStudyPlanRecommendations } from "./studyPlanRecommendation";
import { getContentRecommendations } from "./contentRecommendation";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * ìµœì¢… ì¶”ì²œ ê²°ê³¼ íƒ€ì…
 */
export type Recommendations = {
  subjects: string[];
  goals: string[];
  studyPlan: string[];
  contents: string[];
};

/**
 * ì¤‘ë³µ ë¬¸ì¥ ì œê±° (ìœ ì‚¬ë„ ê¸°ë°˜)
 */
function removeDuplicates(recommendations: string[]): string[] {
  const unique: string[] = [];

  for (const rec of recommendations) {
    // ì´ë¯¸ ì¶”ê°€ëœ ì¶”ì²œê³¼ ìœ ì‚¬í•œì§€ í™•ì¸
    const isDuplicate = unique.some((existing) => {
      // ê°„ë‹¨í•œ ìœ ì‚¬ë„ ì²´í¬: ê°™ì€ í‚¤ì›Œë“œê°€ ë§ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
      const recWords = rec.split(/\s+/);
      const existingWords = existing.split(/\s+/);
      const commonWords = recWords.filter((w) => existingWords.includes(w));
      const similarity = commonWords.length / Math.max(recWords.length, existingWords.length);
      return similarity > 0.6; // 60% ì´ìƒ ìœ ì‚¬í•˜ë©´ ì¤‘ë³µ
    });

    if (!isDuplicate) {
      unique.push(rec);
    }
  }

  return unique;
}

/**
 * ë¹ˆ ë°°ì—´ ì œê±° ë° ì¤‘ë³µ ì œê±°
 */
function cleanRecommendations(recs: Recommendations): Recommendations {
  return {
    subjects: removeDuplicates(recs.subjects),
    goals: removeDuplicates(recs.goals),
    studyPlan: removeDuplicates(recs.studyPlan),
    contents: removeDuplicates(recs.contents),
  };
}

/**
 * ìµœì¢… ì¶”ì²œ ì—”ì§„ - ëª¨ë“  ì¶”ì²œì„ í†µí•©
 */
export async function getRecommendations(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<Recommendations> {
  try {
    // ëª¨ë“  ì¶”ì²œ ëª¨ë“ˆ ë³‘ë ¬ ì‹¤í–‰
    const [subjects, goals, studyPlan, contents] = await Promise.all([
      getSubjectRecommendations(supabase, studentId),
      getGoalRecommendations(supabase, studentId),
      getStudyPlanRecommendations(supabase, studentId),
      getContentRecommendations(supabase, studentId),
    ]);

    const recommendations: Recommendations = {
      subjects,
      goals,
      studyPlan,
      contents,
    };

    // ì •ë¦¬ ë° ë°˜í™˜
    return cleanRecommendations(recommendations);
  } catch (error) {
    console.error("[recommendations/engine] ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    return {
      subjects: [],
      goals: [],
      studyPlan: [],
      contents: [],
    };
  }
}

/**
 * ëª¨ë“  ì¶”ì²œì„ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ í•©ì¹˜ê¸° (ìš°ì„ ìˆœìœ„ ì •ë ¬)
 */
export function getAllRecommendations(recs: Recommendations): string[] {
  // ìš°ì„ ìˆœìœ„: goals > subjects > studyPlan > contents
  return [
    ...recs.goals,
    ...recs.subjects,
    ...recs.studyPlan,
    ...recs.contents,
  ];
}

/**
 * ìƒìœ„ Nê°œ ì¶”ì²œë§Œ ë°˜í™˜
 */
export function getTopRecommendations(recs: Recommendations, limit: number = 5): string[] {
  const all = getAllRecommendations(recs);
  return all.slice(0, limit);
}
</file>

<file path="goalRecommendation.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getActiveGoals, getGoalProgress } from "@/lib/goals/queries";
import { calculateGoalProgress } from "@/lib/goals/calc";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * ëª©í‘œ ê¸°ë°˜ í–‰ë™ ì¶”ì²œ ìƒì„±
 * - ëª©í‘œ ë§ˆê° D-day, ì§„í–‰ë¥  ê¸°ë°˜ ì¶”ì²œ
 * - ìœ„í—˜ ëª©í‘œ(high risk goals)ëŠ” ê¸´ê¸‰ ì¶”ì²œ
 */
export async function getGoalRecommendations(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<string[]> {
  const recommendations: string[] = [];

  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayDate = today.toISOString().slice(0, 10);

    // í™œì„± ëª©í‘œ ì¡°íšŒ
    const activeGoals = await getActiveGoals(supabase, studentId, todayDate);

    if (activeGoals.length === 0) {
      return [];
    }

    // ê° ëª©í‘œì˜ ì§„í–‰ë¥  ê³„ì‚°
    const goalsWithProgress = await Promise.all(
      activeGoals.map(async (goal) => {
        const progressRows = await getGoalProgress(supabase, studentId, goal.id);
        const progress = calculateGoalProgress(goal, progressRows, today);
        return { goal, progress };
      })
    );

    // Rule 1: D <= 7ì´ê³  ëª©í‘œ ë‹¬ì„±ë¥  < 40% â†’ ê¸´ê¸‰ ì¶”ì²œ
    const urgentGoals = goalsWithProgress.filter(
      (g) =>
        g.progress.daysRemaining !== null &&
        g.progress.daysRemaining <= 7 &&
        g.progress.progressPercentage < 40
    );

    for (const { goal, progress } of urgentGoals) {
      const daysLeft = progress.daysRemaining || 0;
      recommendations.push(
        `"${goal.title}" ëª©í‘œê°€ D-${daysLeft}ì¸ë° ì§„í–‰ë¥ ì´ ${progress.progressPercentage}%ì…ë‹ˆë‹¤. ì´ë²ˆì£¼ í•™ìŠµ ë¹„ì¤‘ì„ ë†’ì—¬ì•¼ í•©ë‹ˆë‹¤.`
      );
    }

    // Rule 2: D <= 3ì´ê³  60% ì´í•˜ â†’ ê²½ê³  ì¶”ì²œ
    const warningGoals = goalsWithProgress.filter(
      (g) =>
        g.progress.daysRemaining !== null &&
        g.progress.daysRemaining <= 3 &&
        g.progress.progressPercentage <= 60
    );

    for (const { goal, progress } of warningGoals) {
      const daysLeft = progress.daysRemaining || 0;
      if (progress.progressPercentage < 40) {
        // Rule 1ì—ì„œ ì´ë¯¸ ì²˜ë¦¬ë¨
        continue;
      }
      recommendations.push(
        `"${goal.title}" ëª©í‘œê°€ D-${daysLeft}ì¸ë° ì§„í–‰ë¥ ì´ ${progress.progressPercentage}%ì…ë‹ˆë‹¤. ë‚¨ì€ ê¸°ê°„ ë™ì•ˆ ì§‘ì¤‘ í•™ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤.`
      );
    }

    // Rule 3: ëª©í‘œê°€ 3ê°œ ì´ìƒì¸ë° 1ê°œë„ >50%ê°€ ì—†ìŒ â†’ ì „ëµ ì¡°ì • ì¶”ì²œ
    if (goalsWithProgress.length >= 3) {
      const highProgressCount = goalsWithProgress.filter(
        (g) => g.progress.progressPercentage > 50
      ).length;

      if (highProgressCount === 0) {
        recommendations.push(
          `ì§„í–‰ ì¤‘ì¸ ëª©í‘œ ${goalsWithProgress.length}ê°œ ì¤‘ ì§„í–‰ë¥  50% ì´ìƒì¸ ëª©í‘œê°€ ì—†ìŠµë‹ˆë‹¤. ëª©í‘œ ìš°ì„ ìˆœìœ„ë¥¼ ì¬ì¡°ì •í•˜ê±°ë‚˜ ëª©í‘œ ê¸°ê°„ì„ ì—°ì¥í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ì„¸ìš”.`
        );
      }
    }

    // Rule 4: D-10 ì´í•˜ ëª©í‘œì— ëŒ€í•œ ì¼ë°˜ ì¶”ì²œ
    const nearDeadlineGoals = goalsWithProgress.filter(
      (g) =>
        g.progress.daysRemaining !== null &&
        g.progress.daysRemaining <= 10 &&
        g.progress.daysRemaining > 7 &&
        g.progress.progressPercentage < 70
    );

    for (const { goal, progress } of nearDeadlineGoals) {
      const daysLeft = progress.daysRemaining || 0;
      recommendations.push(
        `"${goal.title}" ëª©í‘œê°€ D-${daysLeft}ì´ë¯€ë¡œ í•µì‹¬ ë‹¨ì›ì— ì§‘ì¤‘í•˜ì„¸ìš”.`
      );
    }

    // Rule 5: í•˜ë£¨ì— í•„ìš”í•œ í•™ìŠµëŸ‰ì´ ê³¼ë„í•œ ê²½ìš°
    for (const { goal, progress } of goalsWithProgress) {
      if (
        progress.dailyRequiredAmount !== null &&
        progress.dailyRequiredAmount > 100 &&
        progress.progressPercentage < 50
      ) {
        const daysLeft = progress.daysRemaining || 0;
        recommendations.push(
          `"${goal.title}" ëª©í‘œë¥¼ ë‹¬ì„±í•˜ë ¤ë©´ í•˜ë£¨ì— ${progress.dailyRequiredAmount} ì´ìƒ í•™ìŠµí•´ì•¼ í•©ë‹ˆë‹¤. ëª©í‘œ ê¸°ê°„ ì—°ì¥ì„ ê³ ë ¤í•˜ì„¸ìš”.`
        );
      }
    }

    return recommendations;
  } catch (error) {
    console.error("[recommendations/goal] ëª©í‘œ ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    return [];
  }
}
</file>

<file path="masterContentRecommendation.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getWeakSubjects } from "@/lib/metrics/getWeakSubjects";
import { getRiskIndexBySubject, getSchoolScoreSummary, getMockScoreSummary } from "@/lib/scheduler/scoreLoader";
import { searchMasterBooks, searchMasterLectures } from "@/lib/data/contentMasters";
import { MasterBook, MasterLecture } from "@/lib/types/plan";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type RecommendedMasterContent = {
  id: string;
  contentType: "book" | "lecture";
  title: string;
  subject_category: string | null;
  subject: string | null;
  semester?: string | null;
  revision: string | null;
  publisher?: string | null;
  platform?: string | null;
  difficulty_level: string | null;
  reason: string; // ì¶”ì²œ ì´ìœ  (êµ¬ì²´ì ì¸ ì„±ì  ì •ë³´ í¬í•¨)
  priority: number; // ìš°ì„ ìˆœìœ„ (ë‚®ì„ìˆ˜ë¡ ë†’ìŒ)
  scoreDetails?: {
    // ì„±ì  ìƒì„¸ ì •ë³´ (ì¶”ì²œ ì´ìœ ì— ì‚¬ìš©)
    schoolGrade?: number | null;
    schoolAverageGrade?: number | null;
    mockPercentile?: number | null;
    mockGrade?: number | null;
    riskScore?: number;
  };
};

/**
 * ì„±ì  ìˆ˜ì¤€ì— ë”°ë¥¸ ì¶”ì²œ ê°œìˆ˜ ê²°ì •
 */
function getRecommendationCount(riskScore: number, hasWeakSubject: boolean): { books: number; lectures: number } {
  if (hasWeakSubject) {
    // ì·¨ì•½ ê³¼ëª©: ìœ„í—˜ë„ì— ë”°ë¼ ì¡°ì •
    if (riskScore >= 70) return { books: 3, lectures: 2 }; // ë§¤ìš° ìœ„í—˜
    if (riskScore >= 50) return { books: 2, lectures: 2 }; // ìœ„í—˜
    return { books: 2, lectures: 1 }; // ë³´í†µ
  } else {
    // Risk Index ê¸°ë°˜: ìœ„í—˜ë„ì— ë”°ë¼ ì¡°ì •
    if (riskScore >= 60) return { books: 2, lectures: 1 };
    return { books: 1, lectures: 1 };
  }
}

/**
 * ì„±ì  ìˆ˜ì¤€ì— ë”°ë¥¸ ì ì ˆí•œ ë‚œì´ë„ ê²°ì •
 */
function getRecommendedDifficultyLevel(
  schoolGrade: number | null,
  mockGrade: number | null
): string | null {
  // ë“±ê¸‰ì´ ë‚®ì„ìˆ˜ë¡(ìˆ«ìê°€ í´ìˆ˜ë¡) ê¸°ì´ˆ ë‚œì´ë„ ì¶”ì²œ
  const avgGrade = schoolGrade && mockGrade 
    ? (schoolGrade + mockGrade) / 2
    : schoolGrade || mockGrade;

  if (avgGrade === null) return null;

  if (avgGrade >= 6) return "ê¸°ì´ˆ"; // 6ë“±ê¸‰ ì´ìƒ: ê¸°ì´ˆ
  if (avgGrade >= 4) return "ê¸°ë³¸"; // 4-5ë“±ê¸‰: ê¸°ë³¸
  if (avgGrade >= 2) return "ì‹¬í™”"; // 2-3ë“±ê¸‰: ì‹¬í™”
  return "ìµœìƒ"; // 1ë“±ê¸‰: ìµœìƒ
}

/**
 * ì¶”ì²œ ì´ìœ  ìƒì„± (êµ¬ì²´ì ì¸ ì„±ì  ì •ë³´ í¬í•¨)
 */
function buildRecommendationReason(
  subject: string,
  isWeakSubject: boolean,
  riskInfo: { riskScore: number; reasons: string[] } | undefined,
  schoolSummary: { recentGrade: number | null; averageGrade: number | null } | undefined,
  mockSummary: { recentPercentile: number | null; recentGrade: number | null } | undefined
): string {
  const reasons: string[] = [];

  if (isWeakSubject) {
    reasons.push(`ì·¨ì•½ ê³¼ëª© "${subject}"`);
  } else if (riskInfo) {
    reasons.push(`ìœ„í—˜ë„ ë†’ì€ ê³¼ëª© "${subject}"`);
  }

  // êµ¬ì²´ì ì¸ ì„±ì  ì •ë³´ ì¶”ê°€
  if (schoolSummary?.averageGrade !== null && schoolSummary?.averageGrade !== undefined) {
    reasons.push(`ë‚´ì‹  í‰ê·  ${schoolSummary.averageGrade.toFixed(2)}ë“±ê¸‰`);
  }
  if (schoolSummary && schoolSummary.recentGrade !== null && schoolSummary.averageGrade !== null) {
    if (schoolSummary.recentGrade > schoolSummary.averageGrade) {
      const decline = schoolSummary.recentGrade - schoolSummary.averageGrade;
      reasons.push(`ìµœê·¼ ${decline.toFixed(2)}ë‹¨ê³„ í•˜ë½`);
    }
  }
  if (mockSummary && mockSummary.recentPercentile !== null) {
    reasons.push(`ëª¨ì˜ê³ ì‚¬ ë°±ë¶„ìœ„ ${mockSummary.recentPercentile.toFixed(2)}%`);
  }
  if (mockSummary && mockSummary.recentGrade !== null) {
    reasons.push(`ëª¨ì˜ê³ ì‚¬ ${mockSummary.recentGrade.toFixed(2)}ë“±ê¸‰`);
  }
  if (riskInfo && riskInfo.riskScore >= 50) {
    reasons.push(`ìœ„í—˜ë„ ${riskInfo.riskScore.toFixed(2)}ì `);
  }

  return reasons.length > 0 ? reasons.join(", ") : `"${subject}" ê³¼ëª© ì¶”ì²œ`;
}

/**
 * ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
 */
function sortByRevision<T extends { revision?: string | null; updated_at?: string | null }>(
  items: T[]
): T[] {
  return [...items].sort((a, b) => {
    // revisionì´ ìˆëŠ” ê²½ìš° ìš°ì„  (ìµœì‹  ê°œì •íŒ)
    if (a.revision && !b.revision) return -1;
    if (!a.revision && b.revision) return 1;
    
    // revision ìˆ«ì ë¹„êµ (2024 > 2023)
    if (a.revision && b.revision) {
      const revA = parseInt(a.revision) || 0;
      const revB = parseInt(b.revision) || 0;
      if (revA !== revB) return revB - revA; // ë†’ì€ revision ìš°ì„ 
    }
    
    // updated_atìœ¼ë¡œ ì •ë ¬ (ìµœì‹ ìˆœ)
    if (a.updated_at && b.updated_at) {
      return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();
    }
    
    return 0;
  });
}

/**
 * ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¶”ì²œ ìƒì„± (ê°œì„  ë²„ì „)
 * - ì·¨ì•½ ê³¼ëª© ê¸°ë°˜ ì¶”ì²œ (ì„±ì  ìˆ˜ì¤€ì— ë”°ë¥¸ ë™ì  ê°œìˆ˜ ì¡°ì •)
 * - Risk Index ê¸°ë°˜ ì¶”ì²œ (êµ¬ì²´ì ì¸ ì„±ì  ì •ë³´ í¬í•¨)
 * - ë‚œì´ë„ ë§¤ì¹­ (ì„±ì  ìˆ˜ì¤€ì— ë§ëŠ” ë‚œì´ë„ ì¶”ì²œ)
 * - ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
 * - í•„ìˆ˜ ê³¼ëª© ë³´ì¥ (êµ­ì–´, ìˆ˜í•™, ì˜ì–´)
 * - ì„±ì  ë°ì´í„° ë¶€ì¡± ì‹œ ê¸°ë³¸ ì¶”ì²œ ì œê³µ
 */
export async function getRecommendedMasterContents(
  supabase: SupabaseServerClient,
  studentId: string,
  tenantId: string | null,
  requestedSubjectCounts?: Map<string, number>
): Promise<RecommendedMasterContent[]> {
  const recommendations: RecommendedMasterContent[] = [];

  try {
    // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const dayOfWeek = today.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    // ì·¨ì•½ ê³¼ëª©, Risk Index, ì„±ì  ìš”ì•½ ì¡°íšŒ
    const [weakSubjectsData, riskIndexMap, schoolSummaryMap, mockSummaryMap] = await Promise.all([
      getWeakSubjects(supabase, studentId, weekStart, weekEnd),
      getRiskIndexBySubject(studentId),
      getSchoolScoreSummary(studentId),
      getMockScoreSummary(studentId),
    ]);

    const weakSubjects = weakSubjectsData.weakSubjects;
    const riskSubjects = Array.from(riskIndexMap.entries())
      .filter(([_, risk]) => risk.riskScore >= 30)
      .map(([subject, _]) => subject)
      .sort((a, b) => {
        const riskA = riskIndexMap.get(a)?.riskScore || 0;
        const riskB = riskIndexMap.get(b)?.riskScore || 0;
        return riskB - riskA; // ë†’ì€ ìœ„í—˜ë„ ìˆœ
      });

    // í•„ìˆ˜ ê³¼ëª© (êµ­ì–´, ìˆ˜í•™, ì˜ì–´)
    const requiredSubjects = ["êµ­ì–´", "ìˆ˜í•™", "ì˜ì–´"];
    
    // requestedSubjectCountsê°€ ìˆìœ¼ë©´ ìš”ì²­ëœ êµê³¼ë¥¼ í•„ìˆ˜ ê³¼ëª© ëª©ë¡ì— ì¶”ê°€ (ê¸°ë³¸ ì¶”ì²œ ë³´ì¥)
    if (requestedSubjectCounts && requestedSubjectCounts.size > 0) {
      const requestedSubjects = Array.from(requestedSubjectCounts.keys());
      for (const subject of requestedSubjects) {
        if (!requiredSubjects.includes(subject)) {
          requiredSubjects.push(subject);
        }
      }
    }
    
    // ì„±ì  ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    const hasScoreData = weakSubjects.length > 0 || riskSubjects.length > 0 || 
                         schoolSummaryMap.size > 0 || mockSummaryMap.size > 0;

    // ì¶”ì²œ ì½˜í…ì¸  ìˆ˜ì§‘
    const contentMap = new Map<string, RecommendedMasterContent>();

    // 1. ì·¨ì•½ ê³¼ëª© ê¸°ë°˜ ì¶”ì²œ (ìš°ì„ ìˆœìœ„ 1-20)
    console.log("[recommendations/masterContent] ì¶”ì²œ ì‹œì‘:", {
      studentId,
      tenantId,
      weakSubjectsCount: weakSubjects.length,
      riskSubjectsCount: riskSubjects.length,
      hasScoreData,
      requestedSubjectCounts: requestedSubjectCounts ? Object.fromEntries(requestedSubjectCounts) : null,
    });
    
    for (let i = 0; i < weakSubjects.length && i < 5; i++) {
      const subject = weakSubjects[i];
      const riskInfo = riskIndexMap.get(subject);
      const riskScore = riskInfo?.riskScore || 0;
      const schoolSummary = schoolSummaryMap.get(subject);
      const mockSummary = mockSummaryMap.get(subject);
      
      // ì„±ì  ìˆ˜ì¤€ì— ë”°ë¥¸ ì¶”ì²œ ê°œìˆ˜ ê²°ì •
      const { books: bookCount, lectures: lectureCount } = getRecommendationCount(riskScore, true);
      
      // ì ì ˆí•œ ë‚œì´ë„ ê²°ì •
      const recommendedDifficulty = getRecommendedDifficultyLevel(
        schoolSummary?.recentGrade || null,
        mockSummary?.recentGrade || null
      );

      // ìµœëŒ€ ê°œìˆ˜ë¡œ ê²€ìƒ‰ (ë‚œì´ë„ í•„í„°ë§ì€ ì •ë ¬ í›„ ì ìš©)
      console.log(`[recommendations/masterContent] ì·¨ì•½ ê³¼ëª© "${subject}" ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ì‹œì‘:`, {
        subject,
        tenantId,
        studentId,
      });
      
      const [booksResult, lecturesResult] = await Promise.all([
        searchMasterBooks({
          search: subject,
          tenantId,
          limit: 10, // ë” ë§ì´ ê°€ì ¸ì™€ì„œ í•„í„°ë§
        }, supabase),
        searchMasterLectures({
          search: subject,
          tenantId,
          limit: 10,
        }, supabase),
      ]);
      
      console.log(`[recommendations/masterContent] ì·¨ì•½ ê³¼ëª© "${subject}" ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ê²°ê³¼:`, {
        subject,
        booksCount: booksResult.data.length,
        lecturesCount: lecturesResult.data.length,
        booksTotal: booksResult.total,
        lecturesTotal: lecturesResult.total,
      });
      
      console.log(`[recommendations/masterContent] ì·¨ì•½ ê³¼ëª© "${subject}" ê²€ìƒ‰ ê²°ê³¼:`, {
        subject,
        riskScore,
        recommendedDifficulty,
        requestedBookCount: bookCount,
        requestedLectureCount: lectureCount,
        foundBooks: booksResult.data.length,
        foundLectures: lecturesResult.data.length,
        totalBooks: booksResult.total || 0,
        totalLectures: lecturesResult.total || 0,
      });

      // ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
      const sortedBooks = sortByRevision(booksResult.data);
      const sortedLectures = sortByRevision(lecturesResult.data);

      // ë‚œì´ë„ ë§¤ì¹­: ì¶”ì²œ ë‚œì´ë„ê°€ ìˆìœ¼ë©´ ìš°ì„ , ì—†ìœ¼ë©´ ëª¨ë“  ë‚œì´ë„
      const filteredBooks = recommendedDifficulty
        ? sortedBooks.filter(b => b.difficulty_level === recommendedDifficulty || !b.difficulty_level)
            .concat(sortedBooks.filter(b => b.difficulty_level !== recommendedDifficulty && b.difficulty_level))
        : sortedBooks;
      
      const filteredLectures = recommendedDifficulty
        ? sortedLectures.filter(l => l.difficulty_level === recommendedDifficulty || !l.difficulty_level)
            .concat(sortedLectures.filter(l => l.difficulty_level !== recommendedDifficulty && l.difficulty_level))
        : sortedLectures;

      // êµì¬ ì¶”ì²œ
      const addedBooks = [];
      for (const book of filteredBooks.slice(0, bookCount)) {
        const key = `book:${book.id}`;
        if (!contentMap.has(key)) {
          const reason = buildRecommendationReason(
            subject,
            true,
            riskInfo,
            schoolSummary,
            mockSummary
          );
          
          contentMap.set(key, {
            id: book.id,
            contentType: "book",
            title: book.title,
            subject_category: book.subject_category ?? null,
            subject: book.subject ?? null,
            revision: book.revision,
            publisher: book.publisher_name || null,
            difficulty_level: book.difficulty_level,
            reason,
            priority: i * 4 + 1, // ì·¨ì•½ ê³¼ëª©ë‹¹ 4ê°œ ìŠ¬ë¡¯ (êµì¬ 2-3ê°œ, ê°•ì˜ 1-2ê°œ)
            scoreDetails: {
              schoolGrade: schoolSummary?.recentGrade || null,
              schoolAverageGrade: schoolSummary?.averageGrade || null,
              mockPercentile: mockSummary?.recentPercentile || null,
              mockGrade: mockSummary?.recentGrade || null,
              riskScore: riskInfo?.riskScore,
            },
          });
          addedBooks.push(book.id);
        }
      }
      
      // ê°•ì˜ ì¶”ì²œ
      const addedLectures = [];
      for (const lecture of filteredLectures.slice(0, lectureCount)) {
        const key = `lecture:${lecture.id}`;
        if (!contentMap.has(key)) {
          const reason = buildRecommendationReason(
            subject,
            true,
            riskInfo,
            schoolSummary,
            mockSummary
          );
          
          contentMap.set(key, {
            id: lecture.id,
            contentType: "lecture",
            title: lecture.title,
            subject_category: lecture.subject_category ?? null,
            subject: lecture.subject ?? null,
            revision: lecture.revision,
            platform: lecture.platform || null,
            difficulty_level: lecture.difficulty_level,
            reason,
            priority: i * 4 + 2 + (filteredLectures.indexOf(lecture) % 2), // ê°•ì˜ëŠ” +2, +3
            scoreDetails: {
              schoolGrade: schoolSummary?.recentGrade || null,
              schoolAverageGrade: schoolSummary?.averageGrade || null,
              mockPercentile: mockSummary?.recentPercentile || null,
              mockGrade: mockSummary?.recentGrade || null,
              riskScore: riskInfo?.riskScore,
            },
          });
          addedLectures.push(lecture.id);
        }
      }
      
      // ì½˜í…ì¸  ë¶€ì¡± ì´ìœ  ë¶„ì„
      if (addedBooks.length < bookCount || addedLectures.length < lectureCount) {
        console.warn(`[recommendations/masterContent] ì·¨ì•½ ê³¼ëª© "${subject}" ì½˜í…ì¸  ë¶€ì¡±:`, {
          subject,
          requestedBookCount: bookCount,
          requestedLectureCount: lectureCount,
          addedBookCount: addedBooks.length,
          addedLectureCount: addedLectures.length,
          availableBooks: filteredBooks.length,
          availableLectures: filteredLectures.length,
          reason: filteredBooks.length < bookCount 
            ? `êµì¬ ë¶€ì¡±: ìš”ì²­ ${bookCount}ê°œ, ì‚¬ìš© ê°€ëŠ¥ ${filteredBooks.length}ê°œ`
            : filteredLectures.length < lectureCount
            ? `ê°•ì˜ ë¶€ì¡±: ìš”ì²­ ${lectureCount}ê°œ, ì‚¬ìš© ê°€ëŠ¥ ${filteredLectures.length}ê°œ`
            : "ì¤‘ë³µ ì œê±°ë¡œ ì¸í•œ ë¶€ì¡±",
        });
      }
    }

    // 2. Risk Index ê¸°ë°˜ ì¶”ì²œ (ìš°ì„ ìˆœìœ„ 21-40)
    let riskPriorityOffset = 21;
    for (let i = 0; i < riskSubjects.length && i < 5; i++) {
      const subject = riskSubjects[i];
      if (weakSubjects.includes(subject)) continue; // ì´ë¯¸ ì¶”ê°€ë¨

      const riskInfo = riskIndexMap.get(subject);
      const riskScore = riskInfo?.riskScore || 0;
      const schoolSummary = schoolSummaryMap.get(subject);
      const mockSummary = mockSummaryMap.get(subject);
      
      // ì„±ì  ìˆ˜ì¤€ì— ë”°ë¥¸ ì¶”ì²œ ê°œìˆ˜ ê²°ì •
      const { books: bookCount, lectures: lectureCount } = getRecommendationCount(riskScore, false);
      
      // ì ì ˆí•œ ë‚œì´ë„ ê²°ì •
      const recommendedDifficulty = getRecommendedDifficultyLevel(
        schoolSummary?.recentGrade || null,
        mockSummary?.recentGrade || null
      );

      const [booksResult, lecturesResult] = await Promise.all([
        searchMasterBooks({
          search: subject,
          tenantId,
          limit: 10,
        }, supabase),
        searchMasterLectures({
          search: subject,
          tenantId,
          limit: 10,
        }, supabase),
      ]);

      // ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
      const sortedBooks = sortByRevision(booksResult.data);
      const sortedLectures = sortByRevision(lecturesResult.data);

      // ë‚œì´ë„ ë§¤ì¹­
      const filteredBooks = recommendedDifficulty
        ? sortedBooks.filter(b => b.difficulty_level === recommendedDifficulty || !b.difficulty_level)
            .concat(sortedBooks.filter(b => b.difficulty_level !== recommendedDifficulty && b.difficulty_level))
        : sortedBooks;
      
      const filteredLectures = recommendedDifficulty
        ? sortedLectures.filter(l => l.difficulty_level === recommendedDifficulty || !l.difficulty_level)
            .concat(sortedLectures.filter(l => l.difficulty_level !== recommendedDifficulty && l.difficulty_level))
        : sortedLectures;

      // êµì¬ ì¶”ì²œ
      for (const book of filteredBooks.slice(0, bookCount)) {
        const key = `book:${book.id}`;
        if (!contentMap.has(key)) {
          const reason = buildRecommendationReason(
            subject,
            false,
            riskInfo,
            schoolSummary,
            mockSummary
          );
          
          contentMap.set(key, {
            id: book.id,
            contentType: "book",
            title: book.title,
            subject_category: book.subject_category ?? null,
            subject: book.subject ?? null,
            revision: book.revision,
            publisher: book.publisher_name || null,
            difficulty_level: book.difficulty_level,
            reason,
            priority: riskPriorityOffset,
            scoreDetails: {
              schoolGrade: schoolSummary?.recentGrade || null,
              schoolAverageGrade: schoolSummary?.averageGrade || null,
              mockPercentile: mockSummary?.recentPercentile || null,
              mockGrade: mockSummary?.recentGrade || null,
              riskScore: riskInfo?.riskScore,
            },
          });
          riskPriorityOffset++;
        }
      }

      // ê°•ì˜ ì¶”ì²œ
      for (const lecture of filteredLectures.slice(0, lectureCount)) {
        const key = `lecture:${lecture.id}`;
        if (!contentMap.has(key)) {
          const reason = buildRecommendationReason(
            subject,
            false,
            riskInfo,
            schoolSummary,
            mockSummary
          );
          
          contentMap.set(key, {
            id: lecture.id,
            contentType: "lecture",
            title: lecture.title,
            subject_category: lecture.subject_category ?? null,
            subject: lecture.subject ?? null,
            revision: lecture.revision,
            platform: lecture.platform || null,
            difficulty_level: lecture.difficulty_level,
            reason,
            priority: riskPriorityOffset,
            scoreDetails: {
              schoolGrade: schoolSummary?.recentGrade || null,
              schoolAverageGrade: schoolSummary?.averageGrade || null,
              mockPercentile: mockSummary?.recentPercentile || null,
              mockGrade: mockSummary?.recentGrade || null,
              riskScore: riskInfo?.riskScore,
            },
          });
          riskPriorityOffset++;
        }
      }
    }

    // 3. í•„ìˆ˜ ê³¼ëª© (êµ­ì–´, ìˆ˜í•™, ì˜ì–´) ê° 1ê°œì”© ë³´ì¥ (ìš°ì„ ìˆœìœ„ 41-50)
    let requiredPriorityOffset = 41;
    for (const requiredSubject of requiredSubjects) {
      // ì´ë¯¸ í•´ë‹¹ ê³¼ëª©ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
      const hasSubject = Array.from(contentMap.values()).some(
        (c) => c.subject_category === requiredSubject
      );

      if (!hasSubject) {
        const schoolSummary = schoolSummaryMap.get(requiredSubject);
        const mockSummary = mockSummaryMap.get(requiredSubject);
        const riskInfo = riskIndexMap.get(requiredSubject);
        
        // ì ì ˆí•œ ë‚œì´ë„ ê²°ì •
        const recommendedDifficulty = getRecommendedDifficultyLevel(
          schoolSummary?.recentGrade || null,
          mockSummary?.recentGrade || null
        );

        const [booksResult, lecturesResult] = await Promise.all([
          searchMasterBooks({
            search: requiredSubject,
            tenantId,
            limit: 5,
          }),
          searchMasterLectures({
            search: requiredSubject,
            tenantId,
            limit: 5,
          }),
        ]);

        // ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
        const sortedBooks = sortByRevision(booksResult.data);
        const sortedLectures = sortByRevision(lecturesResult.data);

        // ë‚œì´ë„ ë§¤ì¹­
        const filteredBooks = recommendedDifficulty
          ? sortedBooks.filter(b => b.difficulty_level === recommendedDifficulty || !b.difficulty_level)
              .concat(sortedBooks.filter(b => b.difficulty_level !== recommendedDifficulty && b.difficulty_level))
          : sortedBooks;
        
        const filteredLectures = recommendedDifficulty
          ? sortedLectures.filter(l => l.difficulty_level === recommendedDifficulty || !l.difficulty_level)
              .concat(sortedLectures.filter(l => l.difficulty_level !== recommendedDifficulty && l.difficulty_level))
          : sortedLectures;

        // êµì¬ ìš°ì„ , ì—†ìœ¼ë©´ ê°•ì˜
        if (filteredBooks.length > 0) {
          const book = filteredBooks[0];
          const key = `book:${book.id}`;
          if (!contentMap.has(key)) {
            const reason = hasScoreData
              ? buildRecommendationReason(requiredSubject, false, riskInfo, schoolSummary, mockSummary)
              : `í•„ìˆ˜ ê³¼ëª© "${requiredSubject}"`;
            
            contentMap.set(key, {
              id: book.id,
              contentType: "book",
              title: book.title,
              subject_category: book.subject_category,
              subject: book.subject,
              revision: book.revision,
              publisher: book.publisher_name || null,
              difficulty_level: book.difficulty_level,
              reason,
              priority: requiredPriorityOffset,
              scoreDetails: schoolSummary || mockSummary ? {
                schoolGrade: schoolSummary?.recentGrade || null,
                schoolAverageGrade: schoolSummary?.averageGrade || null,
                mockPercentile: mockSummary?.recentPercentile || null,
                mockGrade: mockSummary?.recentGrade || null,
                riskScore: riskInfo?.riskScore,
              } : undefined,
            });
            requiredPriorityOffset++;
          }
        } else if (filteredLectures.length > 0) {
          const lecture = filteredLectures[0];
          const key = `lecture:${lecture.id}`;
          if (!contentMap.has(key)) {
            const reason = hasScoreData
              ? buildRecommendationReason(requiredSubject, false, riskInfo, schoolSummary, mockSummary)
              : `í•„ìˆ˜ ê³¼ëª© "${requiredSubject}"`;
            
            contentMap.set(key, {
              id: lecture.id,
              contentType: "lecture",
              title: lecture.title,
              subject_category: lecture.subject_category ?? null,
              subject: lecture.subject ?? null,
              revision: lecture.revision,
              platform: lecture.platform || null,
              difficulty_level: lecture.difficulty_level,
              reason,
              priority: requiredPriorityOffset,
              scoreDetails: schoolSummary || mockSummary ? {
                schoolGrade: schoolSummary?.recentGrade || null,
                schoolAverageGrade: schoolSummary?.averageGrade || null,
                mockPercentile: mockSummary?.recentPercentile || null,
                mockGrade: mockSummary?.recentGrade || null,
                riskScore: riskInfo?.riskScore,
              } : undefined,
            });
            requiredPriorityOffset++;
          }
        }
      }
    }

    // 4. ì„±ì  ë°ì´í„°ê°€ ë¶€ì¡±í•œ ê²½ìš° ê¸°ë³¸ ì¶”ì²œ ì œê³µ (ìš°ì„ ìˆœìœ„ 51-60)
    if (!hasScoreData && contentMap.size < 3) {
      // í•„ìˆ˜ ê³¼ëª© ì¤‘ ë¹ ì§„ ê²ƒë“¤ì— ëŒ€í•´ ê¸°ë³¸ ì¶”ì²œ
      for (const requiredSubject of requiredSubjects) {
        const hasSubject = Array.from(contentMap.values()).some(
          (c) => c.subject_category === requiredSubject
        );

        if (!hasSubject) {
          console.log(`[recommendations/masterContent] í•„ìˆ˜ ê³¼ëª© "${requiredSubject}" ê¸°ë³¸ ì¶”ì²œ ì¡°íšŒ:`, {
            subject: requiredSubject,
            tenantId,
            studentId,
          });
          
          const [booksResult, lecturesResult] = await Promise.all([
            searchMasterBooks({
              search: requiredSubject,
              tenantId,
              limit: 3,
            }, supabase),
            searchMasterLectures({
              search: requiredSubject,
              tenantId,
              limit: 3,
            }, supabase),
          ]);
          
          console.log(`[recommendations/masterContent] í•„ìˆ˜ ê³¼ëª© "${requiredSubject}" ê¸°ë³¸ ì¶”ì²œ ì¡°íšŒ ê²°ê³¼:`, {
            subject: requiredSubject,
            booksCount: booksResult.data.length,
            lecturesCount: lecturesResult.data.length,
          });

          // ìµœì‹  ê°œì •íŒ ìš°ì„  ì •ë ¬
          const sortedBooks = sortByRevision(booksResult.data);
          const sortedLectures = sortByRevision(lecturesResult.data);

          // êµì¬ ìš°ì„ 
          if (sortedBooks.length > 0) {
            const book = sortedBooks[0];
            const key = `book:${book.id}`;
            if (!contentMap.has(key)) {
              contentMap.set(key, {
                id: book.id,
                contentType: "book",
                title: book.title,
                subject_category: book.subject_category,
                subject: book.subject,
                revision: book.revision,
                publisher: book.publisher_name || null,
                difficulty_level: book.difficulty_level,
                reason: `í•„ìˆ˜ ê³¼ëª© "${requiredSubject}" (ì„±ì  ë°ì´í„°ê°€ ì—†ì–´ ê¸°ë³¸ ì¶”ì²œ)`,
                priority: 51 + requiredSubjects.indexOf(requiredSubject),
              });
            }
          } else if (sortedLectures.length > 0) {
            const lecture = sortedLectures[0];
            const key = `lecture:${lecture.id}`;
            if (!contentMap.has(key)) {
              contentMap.set(key, {
                id: lecture.id,
                contentType: "lecture",
                title: lecture.title,
                subject_category: lecture.subject_category ?? null,
                subject: lecture.subject ?? null,
                revision: lecture.revision,
                platform: lecture.platform || null,
                difficulty_level: lecture.difficulty_level,
                reason: `í•„ìˆ˜ ê³¼ëª© "${requiredSubject}" (ì„±ì  ë°ì´í„°ê°€ ì—†ì–´ ê¸°ë³¸ ì¶”ì²œ)`,
                priority: 51 + requiredSubjects.indexOf(requiredSubject),
              });
            }
          }
        }
      }
    }

    // êµê³¼ë³„ ê°œìˆ˜ íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ” ê²½ìš° í•„í„°ë§
    let finalRecommendations = Array.from(contentMap.values()).sort((a, b) => a.priority - b.priority);
    
    if (requestedSubjectCounts && requestedSubjectCounts.size > 0) {
      const filtered: RecommendedMasterContent[] = [];
      const subjectCounts = new Map<string, number>();
      
      // êµê³¼ë³„ë¡œ ìš”ì²­ëœ ê°œìˆ˜ë§Œí¼ë§Œ ì¶”ì¶œ
      for (const [subject, requestedCount] of requestedSubjectCounts) {
        const subjectRecommendations = finalRecommendations.filter(
          (r) => r.subject_category === subject
        );
        const toTake = Math.min(requestedCount, subjectRecommendations.length);
        subjectCounts.set(subject, toTake);
        
        // ìš”ì²­ëœ ê°œìˆ˜ë³´ë‹¤ ì ì€ ê²½ìš° ê²½ê³ 
        if (toTake < requestedCount) {
          console.warn(`[recommendations/masterContent] êµê³¼ "${subject}" ì¶”ì²œ ë¶€ì¡±:`, {
            subject,
            requestedCount,
            availableCount: subjectRecommendations.length,
            reason: subjectRecommendations.length === 0 
              ? "í•´ë‹¹ êµê³¼ì˜ ì¶”ì²œ ì½˜í…ì¸ ê°€ ì—†ìŒ"
              : `ìš”ì²­ëœ ${requestedCount}ê°œë³´ë‹¤ ${subjectRecommendations.length}ê°œë§Œ ì‚¬ìš© ê°€ëŠ¥`,
          });
        }
        
        for (let i = 0; i < toTake; i++) {
          filtered.push(subjectRecommendations[i]);
        }
      }
      
      // í•„í„°ë§ í›„ ê²°ê³¼ê°€ ì—†ìœ¼ë©´ ì „ì²´ ì¶”ì²œì—ì„œ ìµœì†Œí•œ ê¸°ë³¸ ì¶”ì²œ ì œê³µ
      // ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„°ì— ë“±ë¡ëœ ì½˜í…ì¸ ê°€ ìˆìœ¼ë©´ ìµœì†Œí•œ ì¶”ì²œì´ ë‚˜ì™€ì•¼ í•¨
      if (filtered.length === 0 && finalRecommendations.length > 0) {
        // ì „ì²´ ì¶”ì²œ ì¤‘ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ê²ƒë“¤ì„ ì„ íƒ (ìµœëŒ€ 3ê°œ)
        const fallbackCount = Math.min(3, finalRecommendations.length);
        for (let i = 0; i < fallbackCount; i++) {
          filtered.push(finalRecommendations[i]);
        }
        console.warn(`[recommendations/masterContent] ìš”ì²­í•œ êµê³¼ì˜ ì¶”ì²œì´ ì—†ì–´ ì „ì²´ ì¶”ì²œ ì¤‘ ${fallbackCount}ê°œ ì œê³µ`);
      }
      
      finalRecommendations = filtered;
    }
    
    // ìµœì¢… ì¶”ì²œ ê²°ê³¼ ë¡œê¹…
    console.log("[recommendations/masterContent] ìµœì¢… ì¶”ì²œ ê²°ê³¼:", {
      totalRecommendations: finalRecommendations.length,
      bySubject: Array.from(
        finalRecommendations.reduce((acc, r) => {
          if (r.subject_category) {
            const count = acc.get(r.subject_category) || 0;
            acc.set(r.subject_category, count + 1);
          }
          return acc;
        }, new Map<string, number>())
      ).map(([subject, count]) => ({ subject, count })),
      byType: finalRecommendations.reduce((acc, r) => {
        acc[r.contentType] = (acc[r.contentType] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
    });
    
    // contentType ë³´ì¥: ëª¨ë“  í•­ëª©ì— contentTypeì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ì¶”ê°€
    const normalizedRecommendations = finalRecommendations.map((r) => {
      if (!r.contentType) {
        // publisherê°€ ìˆìœ¼ë©´ book, platformì´ ìˆìœ¼ë©´ lectureë¡œ ì¶”ì •
        const estimatedType = r.publisher ? "book" : r.platform ? "lecture" : "book";
        console.warn("[recommendations/masterContent] contentType ëˆ„ë½, ì¶”ì •ê°’ ì‚¬ìš©:", {
          id: r.id,
          title: r.title,
          estimatedType,
          publisher: r.publisher,
          platform: r.platform,
        });
        return {
          ...r,
          contentType: estimatedType as "book" | "lecture",
        };
      }
      return r;
    });
    
    // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬
    return normalizedRecommendations.sort((a, b) => a.priority - b.priority);
  } catch (error) {
    console.error("[recommendations/masterContent] ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ê¸°ë³¸ ì¶”ì²œ ì œê³µ
    try {
      const requiredSubjects = ["êµ­ì–´", "ìˆ˜í•™", "ì˜ì–´"];
      const fallbackRecommendations: RecommendedMasterContent[] = [];
      
      for (const subject of requiredSubjects) {
        const [booksResult] = await Promise.all([
          searchMasterBooks({
            search: subject,
            tenantId,
            limit: 1,
          }, supabase),
        ]);

        if (booksResult.data.length > 0) {
          const book = sortByRevision(booksResult.data)[0];
          const fallbackItem: RecommendedMasterContent = {
            id: book.id,
            contentType: "book",
            title: book.title,
            subject_category: book.subject_category ?? null,
            subject: book.subject ?? null,
            revision: book.revision,
            publisher: book.publisher_name || null,
            difficulty_level: book.difficulty_level,
            reason: `í•„ìˆ˜ ê³¼ëª© "${subject}" (ê¸°ë³¸ ì¶”ì²œ)`,
            priority: 100 + fallbackRecommendations.length,
          };
          fallbackRecommendations.push(fallbackItem);
        }
      }
      
      return fallbackRecommendations;
    } catch (fallbackError) {
      console.error("[recommendations/masterContent] ê¸°ë³¸ ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", fallbackError);
      return [];
    }
  }
}
</file>

<file path="studyPlanRecommendation.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudyTime } from "@/lib/metrics/getStudyTime";
import { getPlanCompletion } from "@/lib/metrics/getPlanCompletion";
import { getStudentRiskScore } from "@/lib/risk/engine";
import { getActiveGoals, getGoalProgress } from "@/lib/goals/queries";
import { calculateGoalProgress } from "@/lib/goals/calc";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * ë‹¤ìŒì£¼ í•™ìŠµì‹œê°„/í”Œëœ ì¶”ì²œ ìƒì„±
 * - ì´ë²ˆì£¼ í•™ìŠµì‹œê°„, í”Œëœ ì‹¤í–‰ë¥ , ìœ„í—˜ ì‹ í˜¸, ëª©í‘œ D-day ê¸°ë°˜
 */
export async function getStudyPlanRecommendations(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<string[]> {
  const recommendations: string[] = [];

  try {
    // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const dayOfWeek = today.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    // ë°ì´í„° ì¡°íšŒ
    const [studyTime, planCompletion, riskResult, activeGoals] = await Promise.all([
      getStudyTime(supabase, studentId, weekStart, weekEnd),
      getPlanCompletion(supabase, studentId, weekStart, weekEnd),
      getStudentRiskScore(supabase, studentId, { recordHistory: false }),
      getActiveGoals(supabase, studentId, today.toISOString().slice(0, 10)),
    ]);

    // Rule 1: í”Œëœ ì‹¤í–‰ë¥  < 50% â†’ ë‹¤ìŒì£¼ ë¸”ë¡ ìˆ˜ ì¤„ì´ê¸°
    if (planCompletion.completionRate < 50) {
      const reductionPercent = planCompletion.completionRate < 30 ? 20 : 10;
      recommendations.push(
        `ì´ë²ˆì£¼ í”Œëœ ì‹¤í–‰ë¥ ì´ ${planCompletion.completionRate}%ë¡œ ë‚®ì•˜ìœ¼ë¯€ë¡œ, ë‹¤ìŒì£¼ëŠ” ë¸”ë¡ ìˆ˜ë¥¼ ${reductionPercent}% ì¤„ì´ê³  ì‹¤í–‰ ê°€ëŠ¥ì„±ì„ ë†’ì´ì„¸ìš”.`
      );
    }

    // Rule 2: í•™ìŠµì‹œê°„ ê¸‰ê° â†’ ì¼ì • ì¡°ì • + íƒ€ì´ë¨¸ ì§‘ì¤‘ ë£¨í‹´ ë³µêµ¬
    if (studyTime.changePercent < -30 && studyTime.thisWeekMinutes < studyTime.lastWeekMinutes) {
      const hours = Math.floor(studyTime.thisWeekMinutes / 60);
      const lastHours = Math.floor(studyTime.lastWeekMinutes / 60);
      recommendations.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ ${Math.abs(studyTime.changePercent)}% ê°ì†Œí–ˆìŠµë‹ˆë‹¤ (${lastHours}ì‹œê°„ â†’ ${hours}ì‹œê°„). ì¼ì • ì¡°ì •ê³¼ íƒ€ì´ë¨¸ ì§‘ì¤‘ ë£¨í‹´ ë³µêµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.`
      );
    }

    // Rule 3: D-7 ì´í•˜ ëª©í‘œê°€ ë§ìŒ â†’ ëª©í‘œ ê¸°ë°˜ í”Œëœ ìƒì„± ìš°ì„ 
    const goalsWithProgress = await Promise.all(
      activeGoals.map(async (goal) => {
        const progressRows = await getGoalProgress(supabase, studentId, goal.id);
        const progress = calculateGoalProgress(goal, progressRows, today);
        return { goal, progress };
      })
    );

    const urgentGoals = goalsWithProgress.filter(
      (g) =>
        g.progress.daysRemaining !== null &&
        g.progress.daysRemaining <= 7 &&
        g.progress.progressPercentage < 70
    );

    if (urgentGoals.length >= 2) {
      const subjectList = urgentGoals
        .map((g) => g.goal.subject)
        .filter((s): s is string => s !== null)
        .join(", ");
      recommendations.push(
        `ëª©í‘œ ${urgentGoals.length}ê°œê°€ ë§ˆê° ì„ë°•ì´ë¯€ë¡œ í•´ë‹¹ ê³¼ëª©(${subjectList}) ì¤‘ì‹¬ì˜ í”Œëœ êµ¬ì„± ê¶Œì¥.`
      );
    } else if (urgentGoals.length === 1) {
      const goal = urgentGoals[0].goal;
      const subject = goal.subject || "í•´ë‹¹ ê³¼ëª©";
      recommendations.push(
        `"${goal.title}" ëª©í‘œê°€ D-${urgentGoals[0].progress.daysRemaining}ì´ë¯€ë¡œ ${subject}ì— ìµœì†Œ 4ì‹œê°„ ì´ìƒ íˆ¬ìí•˜ëŠ” ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤.`
      );
    }

    // Rule 4: ìœ„í—˜ ì‹ í˜¸ê°€ ìˆëŠ” ê²½ìš°
    if (riskResult.level === "high") {
      if (riskResult.reasons.length > 0) {
        const mainReason = riskResult.reasons[0];
        recommendations.push(
          `ìœ„í—˜ ì‹ í˜¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${mainReason}. ë‹¤ìŒì£¼ í•™ìŠµ ê³„íšì„ ì¬ê²€í† í•˜ì„¸ìš”.`
        );
      }
    }

    // Rule 5: í•™ìŠµì‹œê°„ì´ ë§¤ìš° ë¶€ì¡±í•œ ê²½ìš°
    if (studyTime.thisWeekMinutes < 5 * 60) {
      const hours = Math.floor(studyTime.thisWeekMinutes / 60);
      recommendations.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ${hours}ì‹œê°„ìœ¼ë¡œ ë§¤ìš° ë¶€ì¡±í•©ë‹ˆë‹¤. ë‹¤ìŒì£¼ì—ëŠ” ìµœì†Œ 10ì‹œê°„ ì´ìƒ í•™ìŠµí•˜ë„ë¡ ê³„íší•˜ì„¸ìš”.`
      );
    }

    // Rule 6: ì·¨ì•½ ê³¼ëª©ì— ëŒ€í•œ êµ¬ì²´ì  ì‹œê°„ ì œì•ˆ
    if (urgentGoals.length > 0) {
      const subjectGoals = urgentGoals.filter((g) => g.goal.subject !== null);
      if (subjectGoals.length > 0) {
        const subjects = new Set(
          subjectGoals.map((g) => g.goal.subject).filter((s): s is string => s !== null)
        );
        const minHours = Math.ceil(4 / subjects.size);
        for (const subject of subjects) {
          recommendations.push(
            `ë‹¤ìŒì£¼ì—ëŠ” ${subject}ì— ìµœì†Œ ${minHours}ì‹œê°„ ì´ìƒ íˆ¬ìí•˜ëŠ” ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤.`
          );
        }
      }
    }

    return recommendations;
  } catch (error) {
    console.error("[recommendations/studyPlan] í•™ìŠµ í”Œëœ ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    return [];
  }
}
</file>

<file path="subjectRecommendation.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getWeakSubjects } from "@/lib/metrics/getWeakSubjects";
import { getScoreTrend } from "@/lib/metrics/getScoreTrend";
import { getSessionsByDateRange } from "@/lib/studySessions/queries";
import { getSubjectFromContent } from "@/lib/studySessions/summary";
import { getActiveGoals } from "@/lib/goals/queries";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * ê³¼ëª©ë³„ ì§‘ì¤‘ ì¶”ì²œ ìƒì„±
 * - ì·¨ì•½ ê³¼ëª© í•™ìŠµì‹œê°„ ë¹„ì¤‘ ë¶€ì¡±
 * - ì„±ì  í•˜ë½ ê³¼ëª©
 * - ëª©í‘œê°€ ì—†ëŠ” ì·¨ì•½ ê³¼ëª©
 */
export async function getSubjectRecommendations(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<string[]> {
  const recommendations: string[] = [];

  try {
    // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const dayOfWeek = today.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    // ìµœê·¼ 4ì£¼ ë²”ìœ„ ê³„ì‚°
    const fourWeeksAgo = new Date(weekStart);
    fourWeeksAgo.setDate(weekStart.getDate() - 21);
    const fourWeeksAgoStr = fourWeeksAgo.toISOString().slice(0, 10);
    const weekEndStr = weekEnd.toISOString().slice(0, 10);

    // ë°ì´í„° ì¡°íšŒ
    const [weakSubjectsData, scoreTrend, sessions, activeGoals] = await Promise.all([
      getWeakSubjects(supabase, studentId, weekStart, weekEnd),
      getScoreTrend(supabase, studentId),
      getSessionsByDateRange(supabase, studentId, fourWeeksAgoStr, weekEndStr),
      getActiveGoals(supabase, studentId, today.toISOString().slice(0, 10)),
    ]);

    // ì·¨ì•½ ê³¼ëª©ë³„ í•™ìŠµì‹œê°„ ê³„ì‚° (ìµœê·¼ 4ì£¼)
    const subjectTimeMap = new Map<string, number>();
    const totalTime = sessions.reduce((sum, s) => sum + (s.duration_seconds || 0), 0);

    for (const session of sessions) {
      if (!session.duration_seconds) continue;

      let subject: string | null = null;
      if (session.plan_id) {
        const selectPlan = () =>
          supabase
            .from("student_plan")
            .select("content_type,content_id")
            .eq("id", session.plan_id);

        let { data: plan } = await selectPlan().eq("student_id", studentId).maybeSingle();
        if (!plan) {
          ({ data: plan } = await selectPlan().maybeSingle());
        }

        if (plan && plan.content_type && plan.content_id) {
          subject = await getSubjectFromContent(
            supabase,
            studentId,
            plan.content_type,
            plan.content_id
          );
        }
      } else if (session.content_type && session.content_id) {
        subject = await getSubjectFromContent(
          supabase,
          studentId,
          session.content_type,
          session.content_id
        );
      }

      if (subject) {
        const current = subjectTimeMap.get(subject) || 0;
        subjectTimeMap.set(subject, current + Math.floor(session.duration_seconds / 60));
      }
    }

    // Rule 1: ì·¨ì•½ ê³¼ëª©ì¸ë° í•™ìŠµì‹œê°„ ë¹„ì¤‘ < 15%
    for (const subject of weakSubjectsData.weakSubjects) {
      const subjectTime = subjectTimeMap.get(subject) || 0;
      const subjectRatio = totalTime > 0 ? (subjectTime / (totalTime / 60)) * 100 : 0;

      if (subjectRatio < 15) {
        recommendations.push(
          `ìµœê·¼ 4ì£¼ ë™ì•ˆ ${subject} í•™ìŠµì‹œê°„ì´ ì „ì²´ì˜ ${Math.round(subjectRatio)}%ì— ë¶ˆê³¼í•©ë‹ˆë‹¤. ${subject} í•™ìŠµ ë¹„ì¤‘ì„ ëŠ˜ë¦¬ê¸¸ ê¶Œì¥í•©ë‹ˆë‹¤.`
        );
      }
    }

    // Rule 2: ì„±ì  2íšŒ ì—°ì† í•˜ë½ â†’ ì¶”ì²œ
    for (const subject of scoreTrend.decliningSubjects) {
      if (!weakSubjectsData.weakSubjects.includes(subject)) {
        recommendations.push(
          `${subject}ëŠ” ìµœê·¼ 2íšŒ ì—°ì† ë“±ê¸‰ì´ í•˜ë½í–ˆìŠµë‹ˆë‹¤. ${subject}ì— ì§‘ì¤‘ í•™ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤.`
        );
      }
    }

    // Rule 3: ì·¨ì•½ ê³¼ëª©ì¸ë° ëª©í‘œê°€ ì—†ìŒ
    const goalsBySubject = new Set(
      activeGoals
        .map((g) => g.subject)
        .filter((s): s is string => s !== null)
    );

    for (const subject of weakSubjectsData.weakSubjects) {
      if (!goalsBySubject.has(subject)) {
        recommendations.push(
          `${subject}ëŠ” ì·¨ì•½ ê³¼ëª©ì¸ë° ëª©í‘œê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¨ê¸° ëª©í‘œ ì„¤ì •ì„ ê¶Œì¥í•©ë‹ˆë‹¤.`
        );
      }
    }

    // Rule 4: í”Œëœ ì‹¤í–‰ë¥ ì´ ë‚®ì€ ì·¨ì•½ ê³¼ëª©
    const weekStartStr = weekStart.toISOString().slice(0, 10);
    const selectPlans = () =>
      supabase
        .from("student_plan")
        .select("id,content_type,content_id,completed_amount")
        .gte("plan_date", weekStartStr)
        .lte("plan_date", weekEndStr);

    let { data: plans } = await selectPlans().eq("student_id", studentId);
    if (!plans) {
      ({ data: plans } = await selectPlans());
    }

    const planRows = (plans || []) as Array<{
      id: string;
      content_type: string | null;
      content_id: string | null;
      completed_amount: number | null;
    }>;

    // ê³¼ëª©ë³„ í”Œëœ ì‹¤í–‰ë¥  ê³„ì‚°
    const subjectPlanMap = new Map<string, { total: number; completed: number }>();

    for (const plan of planRows) {
      if (!plan.content_type || !plan.content_id) continue;

      const subject = await getSubjectFromContent(
        supabase,
        studentId,
        plan.content_type,
        plan.content_id
      );

      if (subject && weakSubjectsData.weakSubjects.includes(subject)) {
        const current = subjectPlanMap.get(subject) || { total: 0, completed: 0 };
        current.total += 1;
        if (plan.completed_amount !== null && plan.completed_amount > 0) {
          current.completed += 1;
        }
        subjectPlanMap.set(subject, current);
      }
    }

    for (const [subject, stats] of subjectPlanMap.entries()) {
      const completionRate = stats.total > 0 ? (stats.completed / stats.total) * 100 : 0;
      if (completionRate < 40) {
        recommendations.push(
          `${subject}ì˜ ì´ë²ˆì£¼ í”Œëœ ì‹¤í–‰ë¥ ì´ ${Math.round(completionRate)}%ë¡œ ë§¤ìš° ë‚®ìŠµë‹ˆë‹¤. ${subject} í•™ìŠµ ê³„íšì„ ì¬ê²€í† í•˜ì„¸ìš”.`
        );
      }
    }

    return recommendations;
  } catch (error) {
    console.error("[recommendations/subject] ê³¼ëª© ì¶”ì²œ ìƒì„± ì‹¤íŒ¨", error);
    return [];
  }
}
</file>

</files>
