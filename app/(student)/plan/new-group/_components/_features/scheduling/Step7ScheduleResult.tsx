"use client";

import { useEffect, useRef, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  generatePlansFromGroupAction,
  checkPlansExistAction,
  updatePlanGroupStatus,
} from "@/app/(student)/actions/planGroupActions";
import { getContentScheduleOverview } from "@/lib/domains/plan/actions/contentSchedule";
import {
  CACHE_STALE_TIME_DYNAMIC
} from "@/lib/constants/queryCache";
import { PlanScheduleView } from "@/app/(student)/plan/group/[id]/_components/PlanScheduleView";
import { ContentScheduleList } from "./components/ContentScheduleCard";
import { LayoutGrid, BookOpen } from "lucide-react";
import { SuccessCelebration } from "../../_ui/SuccessCelebration";

type Step7ScheduleResultProps = {
  groupId: string;
  onComplete: () => void;
  isAdminContinueMode?: boolean;
  isCampMode?: boolean;
  /** UX-4: 이전 Step으로 돌아가기 (에러 복구용) */
  onGoToStep?: (step: number) => void;
  /** 플랜 이름 (성공 축하 메시지용) */
  planName?: string;
  /** 학습 기간 라벨 (성공 축하 메시지용) */
  periodLabel?: string;
};

type ViewMode = "summary" | "by-content";

export function Step7ScheduleResult({
  groupId,
  onComplete,
  isAdminContinueMode = false,
  isCampMode = false,
  onGoToStep,
  planName = "학습 플랜",
  periodLabel,
}: Step7ScheduleResultProps) {
  const queryClient = useQueryClient();
  const hasAutoGeneratedRef = useRef(false); // 자동 생성 중복 방지
  const [viewMode, setViewMode] = useState<ViewMode>("summary");
  const [showCelebration, setShowCelebration] = useState(true); // 성공 축하 UI 표시 상태

  // 플랜 존재 여부 확인
  const { data: plansCheck, isLoading: isCheckingPlans } = useQuery({
    queryKey: ["plansExist", groupId],
    queryFn: () => checkPlansExistAction(groupId),
    staleTime: CACHE_STALE_TIME_DYNAMIC, // 1분간 캐시 유지
  });

  // 콘텐츠별 스케줄 조회
  const { data: contentScheduleData, isLoading: isLoadingContentSchedule } = useQuery({
    queryKey: ["contentScheduleOverview", groupId],
    queryFn: () => getContentScheduleOverview(groupId),
    enabled: !!plansCheck?.hasPlans && viewMode === "by-content",
    staleTime: CACHE_STALE_TIME_DYNAMIC,
  });

  // 플랜 생성 뮤테이션
  const generatePlansMutation = useMutation({
    mutationFn: async () => {
      // 플랜 생성 전 상태를 "saved"로 변경 (필수: generatePlansFromGroupAction은 saved/active 상태만 허용)
      await updatePlanGroupStatus(groupId, "saved");
      return generatePlansFromGroupAction(groupId);
    },
    onSuccess: async () => {
      // 플랜 생성 후 DB 동기화를 위한 짧은 지연
      await new Promise((resolve) => setTimeout(resolve, 500));
      // 플랜 생성 후 관련 쿼리 무효화 및 즉시 refetch
      await queryClient.invalidateQueries({ queryKey: ["plansExist", groupId] });
      await queryClient.invalidateQueries({ queryKey: ["planSchedule", groupId] });
      await queryClient.invalidateQueries({ queryKey: ["contentScheduleOverview", groupId] });
      // 즉시 refetch하여 최신 데이터 표시
      // refetch가 완료될 때까지 기다려서 plansCheck가 업데이트되도록 보장
      await queryClient.refetchQueries({
        queryKey: ["plansExist", groupId],
        exact: true
      });
      await queryClient.refetchQueries({ queryKey: ["planSchedule", groupId] });
    },
  });

  // Step 7 진입 시 플랜이 없으면 자동 생성
  useEffect(() => {
    // 캠프 모드는 학생이 플랜을 생성하지 않으므로 자동 생성 스킵
    // (단, 관리자 continue 모드는 제외 - 관리자가 플랜을 미리 볼 수 있어야 함)
    if (isCampMode && !isAdminContinueMode) {
      return;
    }

    // 플랜 확인이 완료되고, 플랜이 없고, 아직 자동 생성하지 않았고, 생성 중이 아닐 때만 실행
    if (
      !isCheckingPlans &&
      plansCheck &&
      !plansCheck.hasPlans &&
      !hasAutoGeneratedRef.current &&
      !generatePlansMutation.isPending &&
      !generatePlansMutation.isSuccess
    ) {
      hasAutoGeneratedRef.current = true;
      generatePlansMutation.mutate();
    }
  }, [
    isCheckingPlans,
    plansCheck,
    groupId,
    isAdminContinueMode,
    isCampMode,
    generatePlansMutation.isPending,
    generatePlansMutation.isSuccess,
  ]);

  // 플랜 재생성 핸들러
  const handleRegenerate = () => {
    if (
      !confirm(
        "플랜을 재생성하시겠습니까? 기존 플랜이 삭제되고 새로 생성됩니다."
      )
    ) {
      return;
    }

    generatePlansMutation.mutate();
  };

  const isGenerating = generatePlansMutation.isPending;
  const isLoadingData = isCheckingPlans;
  const hasError = generatePlansMutation.error;
  
  // 플랜 생성 성공 후 plansCheck가 업데이트될 때까지 로딩 상태 유지
  const isWaitingForPlansCheck = 
    generatePlansMutation.isSuccess && 
    (!plansCheck || !plansCheck.hasPlans);

  if (isLoadingData || isGenerating || isWaitingForPlansCheck) {
    return (
      <div className="flex flex-col gap-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold text-gray-900">스케줄 결과</h2>
          <p className="text-sm text-gray-500">
            {isGenerating ? "플랜을 생성하는 중입니다..." : "생성된 학습 플랜을 확인할 수 있습니다."}
          </p>
        </div>
        <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-gray-50 p-8 text-center">
          <div className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-gray-900"></div>
          <p className="text-sm text-gray-500">
            {isGenerating ? "플랜 생성 중..." : isWaitingForPlansCheck ? "플랜 확인 중..." : "데이터를 불러오는 중..."}
          </p>
        </div>
      </div>
    );
  }

  if (hasError) {
    const errorMessage =
      generatePlansMutation.error instanceof Error
        ? generatePlansMutation.error.message
        : typeof generatePlansMutation.error === 'object' && generatePlansMutation.error !== null && 'message' in generatePlansMutation.error
        ? String((generatePlansMutation.error as { message: unknown }).message)
        : "데이터를 불러오는 중 오류가 발생했습니다.";

    // UX-4: 에러 메시지 기반 복구 가이드
    const isContentError = errorMessage.includes("콘텐츠") || errorMessage.includes("content");
    const isScheduleError = errorMessage.includes("스케줄") || errorMessage.includes("일정") || errorMessage.includes("schedule");
    const isAllocationError = errorMessage.includes("배분") || errorMessage.includes("allocation");

    return (
      <div className="flex flex-col gap-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold text-gray-900">스케줄 결과</h2>
          <p className="text-sm text-gray-500">
            생성된 학습 플랜을 확인할 수 있습니다.
          </p>
        </div>
        <div className="flex flex-col gap-4 rounded-lg border border-red-200 bg-red-50 p-4">
          <div className="flex items-start gap-3">
            <svg className="mt-0.5 h-5 w-5 flex-shrink-0 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <div className="flex flex-col gap-1">
              <h3 className="text-sm font-semibold text-red-800">플랜 생성 실패</h3>
              <p className="text-sm text-red-700">{errorMessage}</p>
            </div>
          </div>

          {/* UX-4: 복구 옵션 */}
          <div className="flex flex-col gap-3 border-t border-red-200 pt-3">
            <p className="text-xs font-medium text-red-800">문제 해결 방법:</p>
            <div className="flex flex-wrap gap-2">
              <button
                type="button"
                onClick={handleRegenerate}
                disabled={generatePlansMutation.isPending}
                className="inline-flex items-center gap-1.5 rounded-md bg-red-600 px-3 py-1.5 text-xs font-medium text-white hover:bg-red-700 disabled:cursor-not-allowed disabled:bg-red-400"
              >
                <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                {generatePlansMutation.isPending ? "재생성 중..." : "다시 시도"}
              </button>

              {onGoToStep && (isContentError || isAllocationError) && (
                <button
                  type="button"
                  onClick={() => onGoToStep(4)}
                  className="inline-flex items-center gap-1.5 rounded-md border border-red-300 bg-white px-3 py-1.5 text-xs font-medium text-red-700 hover:bg-red-50"
                >
                  <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                  </svg>
                  콘텐츠 다시 선택
                </button>
              )}

              {onGoToStep && isScheduleError && (
                <button
                  type="button"
                  onClick={() => onGoToStep(2)}
                  className="inline-flex items-center gap-1.5 rounded-md border border-red-300 bg-white px-3 py-1.5 text-xs font-medium text-red-700 hover:bg-red-50"
                >
                  <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                  </svg>
                  일정 설정 수정
                </button>
              )}

              {onGoToStep && (
                <button
                  type="button"
                  onClick={() => onGoToStep(1)}
                  className="inline-flex items-center gap-1.5 rounded-md border border-gray-300 bg-white px-3 py-1.5 text-xs font-medium text-gray-700 hover:bg-gray-50"
                >
                  <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                  </svg>
                  처음부터 다시
                </button>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // 플랜이 없을 때 에러 표시 (자동 생성 시도 후에도 실패한 경우)
  // 자동 생성이 진행 중이거나 성공한 경우는 로딩 화면으로 처리되므로 여기서는 에러만 표시
  if (
    !isLoadingData &&
    !isGenerating &&
    plansCheck &&
    !plansCheck.hasPlans &&
    (generatePlansMutation.isError || hasAutoGeneratedRef.current)
  ) {
    return (
      <div className="flex flex-col gap-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold text-gray-900">스케줄 결과</h2>
          <p className="text-sm text-gray-500">
            생성된 학습 플랜을 확인할 수 있습니다.
          </p>
        </div>
        <div className="flex flex-col gap-4 rounded-lg border border-red-200 bg-red-50 p-4">
          <div className="flex items-start gap-3">
            <svg className="mt-0.5 h-5 w-5 flex-shrink-0 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <div className="flex flex-col gap-1">
              <h3 className="text-sm font-semibold text-red-800">플랜 생성 실패</h3>
              <p className="text-sm text-red-700">
                플랜 생성에 실패했습니다. 설정을 확인하거나 다시 시도해주세요.
              </p>
            </div>
          </div>

          {/* UX-4: 복구 옵션 */}
          <div className="flex flex-col gap-3 border-t border-red-200 pt-3">
            <p className="text-xs font-medium text-red-800">문제 해결 방법:</p>
            <div className="flex flex-wrap gap-2">
              <button
                type="button"
                onClick={handleRegenerate}
                disabled={generatePlansMutation.isPending}
                className="inline-flex items-center gap-1.5 rounded-md bg-red-600 px-3 py-1.5 text-xs font-medium text-white hover:bg-red-700 disabled:cursor-not-allowed disabled:bg-red-400"
              >
                <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                {generatePlansMutation.isPending ? "재생성 중..." : "다시 시도"}
              </button>

              {onGoToStep && (
                <>
                  <button
                    type="button"
                    onClick={() => onGoToStep(4)}
                    className="inline-flex items-center gap-1.5 rounded-md border border-red-300 bg-white px-3 py-1.5 text-xs font-medium text-red-700 hover:bg-red-50"
                  >
                    <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                    </svg>
                    콘텐츠 다시 선택
                  </button>
                  <button
                    type="button"
                    onClick={() => onGoToStep(2)}
                    className="inline-flex items-center gap-1.5 rounded-md border border-red-300 bg-white px-3 py-1.5 text-xs font-medium text-red-700 hover:bg-red-50"
                  >
                    <svg className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 17l-5-5m0 0l5-5m-5 5h12" />
                    </svg>
                    일정 설정 수정
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // 플랜이 있을 때 스케줄 결과 표시
  // PlanScheduleView가 자체적으로 데이터를 페칭하므로 조건부 렌더링만
  // generatePlansMutation.isSuccess일 때는 plansCheck가 업데이트될 때까지 로딩 상태로 처리되므로
  // 여기서는 plansCheck.hasPlans만 확인
  if (!plansCheck?.hasPlans) {
    return null;
  }

  // 성공 축하 UI 표시 (첫 진입 시)
  if (showCelebration && plansCheck.hasPlans) {
    return (
      <div className="flex flex-col gap-6">
        <SuccessCelebration
          groupId={groupId}
          planName={planName}
          planCount={plansCheck.planCount}
          periodLabel={periodLabel}
          isCampMode={isCampMode}
          onViewSchedule={() => setShowCelebration(false)}
          onDismiss={() => setShowCelebration(false)}
        />
      </div>
    );
  }

  // 콘텐츠별 스케줄 데이터 계산
  const contentScheduleContents =
    contentScheduleData?.success && contentScheduleData.data
      ? contentScheduleData.data.contents
      : [];
  const totalPlans = contentScheduleContents.reduce(
    (sum: number, c) => sum + c.totalPlans,
    0
  );
  const completedPlans = contentScheduleContents.reduce(
    (sum: number, c) => sum + c.completedPlans,
    0
  );
  const overallProgress =
    totalPlans > 0 ? Math.round((completedPlans / totalPlans) * 100) : 0;

  return (
    <div className="flex flex-col gap-6">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold text-gray-900">스케줄 결과</h2>
          <p className="text-sm text-gray-500">
            생성된 학습 플랜을 확인할 수 있습니다.
          </p>
        </div>
        <button
          type="button"
          onClick={handleRegenerate}
          disabled={generatePlansMutation.isPending}
          className="inline-flex items-center justify-center rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white hover:bg-indigo-700 disabled:cursor-not-allowed disabled:bg-indigo-400"
        >
          {generatePlansMutation.isPending ? "재생성 중..." : "플랜 재생성"}
        </button>
      </div>

      {/* 뷰 모드 탭 */}
      <div className="flex items-center gap-1 rounded-lg bg-gray-100 p-1">
        <button
          type="button"
          onClick={() => setViewMode("summary")}
          className={`flex items-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-colors ${
            viewMode === "summary"
              ? "bg-white text-gray-900 shadow-sm"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          <LayoutGrid className="h-4 w-4" />
          종합
        </button>
        <button
          type="button"
          onClick={() => setViewMode("by-content")}
          className={`flex items-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-colors ${
            viewMode === "by-content"
              ? "bg-white text-gray-900 shadow-sm"
              : "text-gray-600 hover:text-gray-900"
          }`}
        >
          <BookOpen className="h-4 w-4" />
          콘텐츠별
        </button>
      </div>

      {/* 뷰 모드에 따른 콘텐츠 표시 */}
      {viewMode === "summary" ? (
        <PlanScheduleView groupId={groupId} />
      ) : (
        <>
          {isLoadingContentSchedule ? (
            <div className="flex flex-col items-center gap-4 rounded-lg border border-gray-200 bg-gray-50 p-8">
              <div className="h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-gray-900" />
              <p className="text-sm text-gray-500">콘텐츠별 스케줄을 불러오는 중...</p>
            </div>
          ) : contentScheduleData?.success === false ? (
            <div className="rounded-lg border border-red-200 bg-red-50 p-4">
              <p className="text-sm text-red-700">{contentScheduleData.error}</p>
            </div>
          ) : (
            <ContentScheduleList
              contents={contentScheduleContents}
              totalPlans={totalPlans}
              overallProgress={overallProgress}
            />
          )}
        </>
      )}
    </div>
  );
}

