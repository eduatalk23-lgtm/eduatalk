# 활성 플랜 그룹 플랜 캘린더 표시 기능 점검 리포트

**점검 일자**: 2025-01-22  
**점검 범위**: 캘린더 페이지의 활성 플랜 그룹 플랜 표시 기능

---

## 📋 목차

1. [기능 개요](#기능-개요)
2. [현재 구현 분석](#현재-구현-분석)
3. [데이터 흐름](#데이터-흐름)
4. [발견된 이슈](#발견된-이슈)
5. [개선 제안](#개선-제안)
6. [테스트 시나리오](#테스트-시나리오)

---

## 기능 개요

### 목적
활성화된 플랜 그룹(`status='active'`)에 속한 플랜들을 캘린더 형식(월/주/일)으로 표시하는 기능

### 주요 기능
- 활성 플랜 그룹 조회
- 플랜 그룹별 기간 범위 계산
- 활성 그룹에 속한 플랜만 필터링
- 제외일 및 학원 일정 표시
- 3가지 뷰 모드 (월/주/일)

---

## 현재 구현 분석

### 1. 캘린더 페이지 구현 (`app/(student)/plan/calendar/page.tsx`)

#### ✅ 잘 구현된 부분

```39:43:app/(student)/plan/calendar/page.tsx
  // 활성화된 플랜 그룹 조회
  const activePlanGroups = await getPlanGroupsForStudent({
    studentId: user.id,
    status: "active",
  });
```

- **활성 플랜 그룹 조회**: `status='active'` 필터 적용
- **인덱스 활용**: `idx_plan_groups_student_status` 인덱스로 최적화됨

```63:76:app/(student)/plan/calendar/page.tsx
  // 활성 플랜 그룹의 기간 범위 계산
  const dateRanges = activePlanGroups.map((group) => ({
    start: group.period_start,
    end: group.period_end,
  }));

  const minDate = dateRanges.reduce(
    (min, range) => (range.start < min ? range.start : min),
    dateRanges[0]?.start || new Date().toISOString().slice(0, 10)
  );
  const maxDate = dateRanges.reduce(
    (max, range) => (range.end > max ? range.end : max),
    dateRanges[0]?.end || new Date().toISOString().slice(0, 10)
  );
```

- **여러 플랜 그룹 처리**: 여러 활성 그룹이 있어도 최소/최대 날짜 범위 계산
- **안전한 폴백**: 플랜 그룹이 없을 때 현재 날짜 사용

```87:95:app/(student)/plan/calendar/page.tsx
  // 활성 플랜 그룹 ID 목록
  const activeGroupIds = new Set(activePlanGroups.map((g) => g.id));

  // 활성 플랜 그룹에 속한 플랜만 필터링
  const filteredPlans = allPlans.filter((plan) => {
    // plan_group_id가 활성 그룹에 속하는지 확인
    // plan_group_id가 없는 경우는 제외 (레거시 데이터)
    return plan.plan_group_id && activeGroupIds.has(plan.plan_group_id);
  });
```

- **효율적인 필터링**: `Set`을 사용하여 O(1) 조회 성능
- **레거시 데이터 처리**: `plan_group_id`가 NULL인 데이터 제외

```99:107:app/(student)/plan/calendar/page.tsx
  const plansWithContent = filteredPlans.map((plan) => {
    return {
      ...plan,
      contentTitle: plan.content_title || "제목 없음",
      contentSubject: plan.content_subject || null,
      contentSubjectCategory: plan.content_subject_category || null, // 교과
      contentCategory: plan.content_category || null, // 유형
    };
  });
```

- **Denormalized 필드 활용**: 조인 없이 콘텐츠 정보 사용

---

## 데이터 흐름

### 현재 데이터 흐름도

```
1. 사용자 인증 확인
   ↓
2. 활성 플랜 그룹 조회 (status='active')
   - getPlanGroupsForStudent({ studentId, status: 'active' })
   - 인덱스: idx_plan_groups_student_status ✅
   ↓
3. 기간 범위 계산 (여러 그룹의 최소/최대 날짜)
   - minDate: 모든 그룹의 period_start 중 최소값
   - maxDate: 모든 그룹의 period_end 중 최대값
   ↓
4. 해당 기간의 모든 플랜 조회
   - getPlansForStudent({ studentId, dateRange: { start, end } })
   - 인덱스: idx_student_plan_student_date ✅
   ↓
5. 활성 그룹에 속한 플랜만 필터링 (애플리케이션 레벨)
   - plan.plan_group_id && activeGroupIds.has(plan.plan_group_id)
   ↓
6. Denormalized 필드로 콘텐츠 정보 추가
   ↓
7. 제외일 조회 (학생별 전역)
   - getStudentExclusions(studentId)
   ↓
8. 학원 일정 조회 (학생별 전역)
   - getStudentAcademySchedules(studentId)
   ↓
9. PlanCalendarView 컴포넌트로 전달
```

### 성능 분석

#### ✅ 효율적인 부분
1. **인덱스 활용**: 모든 주요 쿼리가 적절한 인덱스 사용
2. **Denormalized 필드**: 콘텐츠 정보 조인 불필요
3. **Set 자료구조**: O(n) 필터링 대신 O(1) 조회

#### ⚠️ 최적화 가능한 부분
1. **플랜 조회 범위**: 현재는 전체 기간의 플랜을 가져온 후 애플리케이션 레벨에서 필터링
   - 개선: 데이터베이스 레벨에서 `plan_group_id IN (...)` 필터링 가능

---

## 발견된 이슈

### 🔴 Critical Issues

없음

### 🟡 Medium Priority Issues

#### 1. 플랜 조회 최적화 여지

**현재 구현**:
```typescript
// 1. 전체 기간의 모든 플랜 조회
const allPlans = await getPlansForStudent({
  studentId: user.id,
  dateRange: { start: minDate, end: maxDate },
});

// 2. 애플리케이션 레벨에서 필터링
const filteredPlans = allPlans.filter((plan) => {
  return plan.plan_group_id && activeGroupIds.has(plan.plan_group_id);
});
```

**문제점**:
- 활성 그룹에 속하지 않는 플랜도 조회됨
- 플랜이 많을 경우 불필요한 데이터 전송

**해결책**:
- `getPlansForStudent` 함수에 `planGroupIds` 옵션 추가
- 데이터베이스 레벨에서 `plan_group_id IN (...)` 필터링

**영향도**: 중간 (대용량 데이터 시 성능 향상 기대)

#### 2. 활성 플랜 그룹이 없을 때의 사용자 경험

**현재 구현**:
```45:60:app/(student)/plan/calendar/page.tsx
  if (activePlanGroups.length === 0) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-6 md:py-10">
        <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-10 text-center">
          <div className="mx-auto flex max-w-md flex-col gap-4">
            <div className="text-6xl">📅</div>
            <h3 className="text-lg font-semibold text-gray-900">
              활성화된 플랜 그룹이 없습니다
            </h3>
            <p className="text-sm text-gray-500">
              플랜 그룹을 생성하고 활성화해주세요.
            </p>
          </div>
        </div>
      </section>
    );
  }
```

**평가**: ✅ 적절한 사용자 피드백 제공

### 🟢 Low Priority Issues

#### 3. 날짜 범위 계산 시 타입 안전성

**현재 구현**:
```typescript
const minDate = dateRanges.reduce(
  (min, range) => (range.start < min ? range.start : min),
  dateRanges[0]?.start || new Date().toISOString().slice(0, 10)
);
```

**개선 제안**:
- `dateRanges.length === 0` 체크 추가 (현재는 `dateRanges[0]?.start`로 처리됨)
- 타입 가드 추가

**영향도**: 낮음 (현재도 안전하게 작동)

#### 4. Denormalized 필드 동기화

**현재 상태**:
- `content_title`, `content_subject` 등이 콘텐츠 정보와 불일치할 수 있음
- 별도 리포트에서 다룸 (플랜_캘린더_스키마_점검_리포트.md 참조)

---

## 개선 제안

### 1. 플랜 조회 최적화 (권장)

#### 개선 방법

**1단계**: `getPlansForStudent` 함수에 `planGroupIds` 옵션 추가

```typescript
// lib/data/studentPlans.ts
export type PlanFilters = {
  studentId: string;
  tenantId?: string | null;
  dateRange?: {
    start: string;
    end: string;
  };
  planDate?: string;
  contentType?: "book" | "lecture" | "custom";
  planGroupIds?: string[]; // 새로 추가
};

export async function getPlansForStudent(
  filters: PlanFilters
): Promise<Plan[]> {
  // ...
  
  if (filters.planGroupIds && filters.planGroupIds.length > 0) {
    query = query.in("plan_group_id", filters.planGroupIds);
  }
  
  // ...
}
```

**2단계**: 캘린더 페이지에서 직접 필터링

```typescript
// app/(student)/plan/calendar/page.tsx
const activeGroupIds = activePlanGroups.map((g) => g.id);

const allPlans = await getPlansForStudent({
  studentId: user.id,
  dateRange: {
    start: minDate,
    end: maxDate,
  },
  planGroupIds: activeGroupIds, // 데이터베이스 레벨 필터링
});
```

**기대 효과**:
- 불필요한 데이터 전송 감소
- 대용량 데이터 시 성능 향상
- 네트워크 비용 절감

**우선순위**: 중간 (현재도 충분히 빠르지만 최적화 가능)

### 2. 에러 처리 강화 (선택적)

**현재 상태**: 에러 발생 시 빈 배열 반환

**개선 제안**:
- 에러 로깅 강화
- 사용자 친화적인 에러 메시지 표시
- 재시도 로직 추가

**우선순위**: 낮음

---

## 테스트 시나리오

### ✅ 정상 동작 확인

1. **단일 활성 플랜 그룹**
   - [ ] 플랜 그룹이 1개일 때 정상 표시
   - [ ] 기간 범위 내 플랜만 표시
   - [ ] 기간 범위 외 플랜 미표시

2. **다중 활성 플랜 그룹**
   - [ ] 플랜 그룹이 여러 개일 때 모든 그룹의 플랜 표시
   - [ ] 기간 범위가 겹치는 경우 정상 처리
   - [ ] 기간 범위가 떨어져 있는 경우 정상 처리

3. **플랜 그룹 필터링**
   - [ ] 활성 그룹에 속한 플랜만 표시
   - [ ] 비활성 그룹의 플랜 미표시
   - [ ] `plan_group_id`가 NULL인 레거시 데이터 미표시

4. **제외일 및 학원 일정**
   - [ ] 제외일 정상 표시
   - [ ] 학원 일정 정상 표시

5. **빈 상태 처리**
   - [ ] 활성 플랜 그룹이 없을 때 적절한 메시지 표시
   - [ ] 플랜이 없을 때 빈 캘린더 표시

### ⚠️ 경계 케이스 확인

1. **날짜 범위**
   - [ ] `period_start > period_end`인 잘못된 데이터 처리
   - [ ] 과거/미래 날짜 범위 처리

2. **데이터 일관성**
   - [ ] `plan_group_id`가 존재하지 않는 그룹을 참조하는 플랜 처리
   - [ ] Denormalized 필드가 NULL인 경우 처리

3. **성능**
   - [ ] 플랜 그룹이 많을 때 (10개 이상)
   - [ ] 플랜이 많을 때 (1000개 이상)
   - [ ] 긴 기간 범위 (1년 이상)

---

## 최종 평가

### 전체 평가: ⭐⭐⭐⭐ (4/5)

**강점**:
- ✅ 명확한 데이터 흐름
- ✅ 적절한 인덱스 활용
- ✅ Denormalized 필드로 성능 최적화
- ✅ 레거시 데이터 처리
- ✅ 사용자 친화적인 빈 상태 처리

**개선 필요**:
- ⚠️ 데이터베이스 레벨 필터링 추가 (성능 최적화)
- ⚠️ 에러 처리 강화 (선택적)

**결론**:
현재 구현은 잘 작동하며, 대부분의 시나리오에서 적절한 성능을 보입니다. 
플랜 조회 최적화를 통해 더 나은 성능을 기대할 수 있지만, 
현재 상태로도 충분히 사용 가능합니다.

---

**리포트 작성일**: 2025-01-22  
**다음 점검 권장일**: 2025-02-22 (1개월 후, 또는 성능 이슈 발생 시)

