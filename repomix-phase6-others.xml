This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_components/
  LoginForm.tsx
  ResendEmailButton.tsx
  TermsModal.tsx
actions/
  curriculumSettingsActions.ts
  parentSettingsActions.ts
  parentStudentLinkRequestActions.ts
  tenantlessUserActions.ts
  termsContents.ts
admin/
  check-student-scores/
    route.ts
attendance/
  index.ts
  repository.ts
  service.ts
  statistics.ts
  types.ts
auth/
  check-superadmin/
    route.ts
  index.ts
block/
  index.ts
camp/
  index.ts
  types.ts
content/
  index.ts
curriculum-revisions/
  route.ts
dashboard/
  monthly-report/
    route.ts
global/
  configs/
    adminCategories.ts
    parentCategories.ts
    studentCategories.ts
    superadminCategories.ts
  Breadcrumbs.tsx
  categoryConfig.ts
  CategoryNav.tsx
  resolveActiveCategory.ts
  types.ts
goal/
  index.ts
goals/
  list/
    route.ts
master-books/
  difficulties/
    route.ts
  route.ts
master-content-details/
  route.ts
master-content-info/
  route.ts
master-lectures/
  difficulties/
    route.ts
  route.ts
parent/
  _components/
    _utils/
      calculations.ts
    ParentDashboardContent.tsx
    RecentScores.tsx
    RecommendationSection.tsx
    RiskSignals.tsx
    StudentSelector.tsx
    TodaySummary.tsx
    WeakSubjects.tsx
    WeeklyMonthlySummary.tsx
  dashboard/
    page.tsx
  goals/
    page.tsx
  history/
    page.tsx
  report/
    monthly/
      page.tsx
    weekly/
      _components/
        ParentWeeklyCoachingSection.tsx
      page.tsx
  scores/
    page.tsx
  settings/
    _components/
      LinkedStudentsSection.tsx
      LinkRequestList.tsx
      RoleChangeSection.tsx
      StudentAttendanceNotificationSettings.tsx
      StudentSearchModal.tsx
    page.tsx
plan/
  index.ts
  repository.ts
  service.ts
  types.ts
platforms/
  route.ts
publishers/
  route.ts
purio/
  send/
    route.ts
qrCode/
  index.ts
  repository.ts
  service.ts
recommended-master-contents/
  route.ts
school/
  actions.ts
  index.ts
  repository.ts
  service.ts
  types.ts
  validation.ts
schools/
  auto-register/
    route.ts
  search/
    route.ts
score/
  actions.ts
  index.ts
  repository.ts
  service.ts
  types.ts
  validation.ts
scores/
  internal/
    route.ts
  mock/
    route.ts
  mock.ts
  school.ts
student/
  index.ts
  types.ts
student-content-details/
  batch/
    route.ts
  route.ts
student-content-info/
  route.ts
students/
  [id]/
    score-dashboard/
      route.ts
subject/
  index.ts
  types.ts
subject-groups/
  route.ts
subjects/
  route.ts
superadmin/
  admin-users/
    AdminUsersList.tsx
    CreateAdminUserForm.tsx
    page.tsx
  curriculum-settings/
    _components/
      CurriculumSettingsForm.tsx
    page.tsx
  dashboard/
    page.tsx
  settings/
    page.tsx
  tenantless-users/
    _components/
      AssignTenantDialog.tsx
      TenantlessUsersList.tsx
    page.tsx
  tenants/
    _components/
      TenantCard.tsx
      TenantForm.tsx
      TenantList.tsx
    page.tsx
  terms-management/
    _components/
      TermsContentForm.tsx
      TermsContentList.tsx
      TermsManagementContent.tsx
      TermsPreview.tsx
    page.tsx
  unverified-users/
    _components/
      UnverifiedUsersList.tsx
    page.tsx
tenant/
  index.ts
  types.ts
tenants/
  [id]/
    route.ts
  route.ts
terms/
  [type]/
    route.ts
today/
  plans/
    route.ts
  progress/
    route.ts
_utils.ts
analytics.ts
auth.ts
autoSuggester.ts
batchAdjuster.ts
batchProcessor.ts
blocks.ts
blockSets.ts
cache.ts
conflictDetector.ts
consultingNotes.ts
dateRangeAnalyzer.ts
delayDetector.ts
engine.ts
error.tsx
getWeeklyMetrics.ts
goals.ts
index.ts
jobQueue.ts
layout.tsx
loading.tsx
logger.ts
page.tsx
PageContainer.tsx
PageHeader.tsx
patternAnalyzer.ts
periodCalculator.test.ts
periodCalculator.ts
previewCache.ts
progress.ts
RoleBasedLayout.tsx
rollbackValidator.ts
scheduleEngine.ts
scores-internal.ts
scores.ts
SidebarContext.tsx
SkipLink.tsx
smsActions.ts
studySessions.ts
tenants.ts
transaction.ts
uncompletedRangeCalculator.test.ts
uncompletedRangeCalculator.ts
userRole.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="actions/parentSettingsActions.ts">
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { canAccessStudent } from "../_utils";
import { revalidatePath } from "next/cache";

type StudentAttendanceNotificationSettings = {
  attendance_check_in_enabled: boolean | null;
  attendance_check_out_enabled: boolean | null;
  attendance_absent_enabled: boolean | null;
  attendance_late_enabled: boolean | null;
};

/**
 * í•™ìƒë³„ ì¶œì„ ì•Œë¦¼ ì„¤ì • ì¡°íšŒ
 */
export async function getStudentAttendanceNotificationSettings(
  studentId: string
): Promise<{
  success: boolean;
  data?: StudentAttendanceNotificationSettings | null;
  error?: string;
}> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || role !== "parent") {
      return {
        success: false,
        error: "í•™ë¶€ëª¨ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.",
      };
    }

    const supabase = await createSupabaseServerClient();

    // í•™ë¶€ëª¨ê°€ í•´ë‹¹ í•™ìƒì— ì ‘ê·¼ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸
    const hasAccess = await canAccessStudent(supabase, userId, studentId);
    if (!hasAccess) {
      return {
        success: false,
        error: "í•´ë‹¹ í•™ìƒì— ëŒ€í•œ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    // í•™ìƒë³„ ì¶œì„ ì•Œë¦¼ ì„¤ì • ì¡°íšŒ
    const { data: settings, error } = await supabase
      .from("student_notification_preferences")
      .select(
        "attendance_check_in_enabled, attendance_check_out_enabled, attendance_absent_enabled, attendance_late_enabled"
      )
      .eq("student_id", studentId)
      .maybeSingle();

    if (error) {
      console.error(
        "[parentSettings] ì¶œì„ ì•Œë¦¼ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨:",
        error
      );
      return {
        success: false,
        error: "ì„¤ì • ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return {
      success: true,
      data: settings
        ? {
            attendance_check_in_enabled:
              settings.attendance_check_in_enabled ?? null,
            attendance_check_out_enabled:
              settings.attendance_check_out_enabled ?? null,
            attendance_absent_enabled:
              settings.attendance_absent_enabled ?? null,
            attendance_late_enabled: settings.attendance_late_enabled ?? null,
          }
        : null,
    };
  } catch (error: any) {
    console.error("[parentSettings] ì˜¤ë¥˜:", error);
    return {
      success: false,
      error: error.message || "ì„¤ì • ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í•™ìƒë³„ ì¶œì„ ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸
 */
export async function updateStudentAttendanceNotificationSettings(
  studentId: string,
  settings: StudentAttendanceNotificationSettings
): Promise<{ success: boolean; error?: string }> {
  try {
    const { userId, role } = await getCurrentUserRole();

    if (!userId || role !== "parent") {
      return {
        success: false,
        error: "í•™ë¶€ëª¨ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.",
      };
    }

    const supabase = await createSupabaseServerClient();

    // í•™ë¶€ëª¨ê°€ í•´ë‹¹ í•™ìƒì— ì ‘ê·¼ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸
    const hasAccess = await canAccessStudent(supabase, userId, studentId);
    if (!hasAccess) {
      return {
        success: false,
        error: "í•´ë‹¹ í•™ìƒì— ëŒ€í•œ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    // ê¸°ì¡´ ì„¤ì • í™•ì¸
    const { data: existing } = await supabase
      .from("student_notification_preferences")
      .select("id")
      .eq("student_id", studentId)
      .maybeSingle();

    if (existing) {
      // ì—…ë°ì´íŠ¸ (ì¶œì„ ê´€ë ¨ ì„¤ì •ë§Œ ì—…ë°ì´íŠ¸)
      const { error } = await supabase
        .from("student_notification_preferences")
        .update({
          attendance_check_in_enabled: settings.attendance_check_in_enabled,
          attendance_check_out_enabled: settings.attendance_check_out_enabled,
          attendance_absent_enabled: settings.attendance_absent_enabled,
          attendance_late_enabled: settings.attendance_late_enabled,
          updated_at: new Date().toISOString(),
        })
        .eq("student_id", studentId);

      if (error) {
        console.error(
          "[parentSettings] ì¶œì„ ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:",
          error
        );
        return {
          success: false,
          error: "ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }
    } else {
      // ìƒì„± (ê¸°ë³¸ê°’ìœ¼ë¡œ ë‹¤ë¥¸ í•„ë“œë„ í•¨ê»˜ ìƒì„±)
      const { error } = await supabase
        .from("student_notification_preferences")
        .insert({
          student_id: studentId,
          plan_start_enabled: true,
          plan_complete_enabled: true,
          daily_goal_achieved_enabled: true,
          weekly_report_enabled: true,
          plan_delay_enabled: true,
          plan_delay_threshold_minutes: 30,
          notification_time_start: "09:00",
          notification_time_end: "22:00",
          quiet_hours_enabled: false,
          quiet_hours_start: "22:00",
          quiet_hours_end: "08:00",
          attendance_check_in_enabled: settings.attendance_check_in_enabled,
          attendance_check_out_enabled: settings.attendance_check_out_enabled,
          attendance_absent_enabled: settings.attendance_absent_enabled,
          attendance_late_enabled: settings.attendance_late_enabled,
        });

      if (error) {
        console.error(
          "[parentSettings] ì¶œì„ ì•Œë¦¼ ì„¤ì • ìƒì„± ì‹¤íŒ¨:",
          error
        );
        return {
          success: false,
          error: "ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }
    }

    revalidatePath("/parent/settings");
    return { success: true };
  } catch (error: any) {
    console.error("[parentSettings] ì˜¤ë¥˜:", error);
    return {
      success: false,
      error: error.message || "ì„¤ì • ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/parentStudentLinkRequestActions.ts">
"use server";

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";
import { getAutoApproveSettings } from "@/app/(admin)/actions/tenantSettingsActions";
import { checkAutoApproveConditions } from "@/lib/utils/autoApprove";
import { PARENT_STUDENT_LINK_MESSAGES } from "@/lib/constants/parentStudentLinkMessages";

// íƒ€ì… ì •ì˜
export type SearchableStudent = {
  id: string;
  name: string | null;
  grade: string | null;
  class: string | null;
};

export type LinkRequest = {
  id: string;
  studentId: string;
  studentName: string | null;
  grade: string | null;
  class: string | null;
  relation: string;
  is_approved: boolean | null;
  created_at: string;
};

export type ParentRelation = "father" | "mother" | "guardian" | "other";

/**
 * í•™ë¶€ëª¨ê°€ í•™ìƒì„ ê²€ìƒ‰ (ì´ë¦„, í•™ë…„, ë°˜)
 * ì´ë¯¸ ì—°ê²°ëœ í•™ìƒê³¼ ìš”ì²­ ì¤‘ì¸ í•™ìƒì€ ì œì™¸
 */
export async function searchStudentsForLink(
  query: string,
  parentId: string
): Promise<{ success: boolean; data?: SearchableStudent[]; error?: string }> {
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // ë³¸ì¸ë§Œ ê²€ìƒ‰ ê°€ëŠ¥
  if (userId !== parentId) {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // ìµœì†Œ 2ê¸€ì ì´ìƒ ê²€ìƒ‰
  if (!query || query.trim().length < 2) {
    return { success: true, data: [] };
  }

  const supabase = await createSupabaseServerClient();

  try {
    const searchQuery = query.trim();

    // ì´ë¯¸ ì—°ê²°ë˜ê±°ë‚˜ ìš”ì²­ ì¤‘ì¸ í•™ìƒ ID ì¡°íšŒ
    const { data: existingLinks, error: linksError } = await supabase
      .from("parent_student_links")
      .select("student_id")
      .eq("parent_id", parentId);

    if (linksError) {
      console.error(
        "[parent/linkRequest] ê¸°ì¡´ ì—°ê²° ì¡°íšŒ ì‹¤íŒ¨",
        linksError
      );
      // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (RLS ì •ì±… ë¬¸ì œì¼ ìˆ˜ ìˆìŒ)
    }

    const excludedStudentIds = new Set(
      (existingLinks || []).map((link) => link.student_id)
    );

    // í•™ìƒ ê²€ìƒ‰ (ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰)
    const selectStudents = () =>
      supabase
        .from("students")
        .select("id, name, grade, class")
        .ilike("name", `%${searchQuery}%`)
        .limit(10);

    let { data: students, error } = await selectStudents();

    // ì»¬ëŸ¼ ì—†ìŒ ì—ëŸ¬ ì²˜ë¦¬ (42703)
    if (error && error.code === "42703") {
      ({ data: students, error } = await selectStudents());
    }

    if (error) {
      console.error("[parent/linkRequest] í•™ìƒ ê²€ìƒ‰ ì‹¤íŒ¨", error);
      return {
        success: false,
        error: error.message || "í•™ìƒ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    if (!students) {
      return { success: true, data: [] };
    }

    // ì´ë¯¸ ì—°ê²°ë˜ê±°ë‚˜ ìš”ì²­ ì¤‘ì¸ í•™ìƒ ì œì™¸
    const filtered = students.filter(
      (student) => !excludedStudentIds.has(student.id)
    );

    // ë°ì´í„° ë³€í™˜
    const searchResults: SearchableStudent[] = filtered.map((student) => ({
      id: student.id,
      name: student.name,
      grade: student.grade,
      class: student.class,
    }));

    return { success: true, data: searchResults };
  } catch (error) {
    console.error("[parent/linkRequest] í•™ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: "í•™ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ì—°ê²° ìš”ì²­ ìƒì„±
 */
export async function createLinkRequest(
  studentId: string,
  parentId: string,
  relation: ParentRelation
): Promise<{ success: boolean; requestId?: string; error?: string }> {
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // ë³¸ì¸ë§Œ ìš”ì²­ ê°€ëŠ¥
  if (userId !== parentId) {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // relation ê°’ ê²€ì¦
  const validRelations: ParentRelation[] = ["father", "mother", "guardian", "other"];
  if (!validRelations.includes(relation)) {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.INVALID_RELATION };
  }

  const supabase = await createSupabaseServerClient();

  try {
    // ì¤‘ë³µ ì²´í¬ (ì´ë¯¸ ì—°ê²°ë˜ê±°ë‚˜ ìš”ì²­ ì¤‘ì¸ ê²½ìš°)
    const { data: existing, error: checkError } = await supabase
      .from("parent_student_links")
      .select("id, is_approved")
      .eq("student_id", studentId)
      .eq("parent_id", parentId)
      .maybeSingle();

    if (checkError && checkError.code !== "PGRST116") {
      console.error("[parent/linkRequest] ì¤‘ë³µ ì²´í¬ ì‹¤íŒ¨", checkError);
      return {
        success: false,
        error: "ì—°ê²° í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      };
    }

    if (existing) {
      // ì´ë¯¸ ìŠ¹ì¸ëœ ê²½ìš°
      if (existing.is_approved === true) {
        return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.ALREADY_LINKED };
      }
      // ëŒ€ê¸° ì¤‘ì¸ ê²½ìš°
      return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_ALREADY_EXISTS };
    }

    // ìë™ ìŠ¹ì¸ ë¡œì§: í•™ìƒê³¼ í•™ë¶€ëª¨ì˜ tenant_id ì¡°íšŒ (ë³‘ë ¬ ì²˜ë¦¬)
    const [studentResult, parentResult] = await Promise.all([
      supabase
        .from("students")
        .select("tenant_id")
        .eq("id", studentId)
        .maybeSingle(),
      supabase
        .from("parent_users")
        .select("tenant_id")
        .eq("id", parentId)
        .maybeSingle(),
    ]);

    const { data: student, error: studentError } = studentResult;
    const { data: parent, error: parentError } = parentResult;

    if (studentError) {
      console.error("[parent/linkRequest] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", studentError);
      // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (ìë™ ìŠ¹ì¸ ì‹¤íŒ¨ ì‹œ ìˆ˜ë™ ìŠ¹ì¸ìœ¼ë¡œ í´ë°±)
    }

    if (parentError) {
      console.error("[parent/linkRequest] í•™ë¶€ëª¨ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨", parentError);
      // ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰ (ìë™ ìŠ¹ì¸ ì‹¤íŒ¨ ì‹œ ìˆ˜ë™ ìŠ¹ì¸ìœ¼ë¡œ í´ë°±)
    }

    // ìë™ ìŠ¹ì¸ ì„¤ì • ì¡°íšŒ ë° ì¡°ê±´ í™•ì¸
    let shouldAutoApprove = false;
    if (student?.tenant_id) {
      try {
        const autoApproveResult = await getAutoApproveSettings(
          student.tenant_id
        );

        if (
          autoApproveResult.success &&
          autoApproveResult.data &&
          student?.tenant_id &&
          parent?.tenant_id
        ) {
          shouldAutoApprove = checkAutoApproveConditions(
            autoApproveResult.data,
            student.tenant_id,
            parent.tenant_id,
            relation
          );
        }
      } catch (error) {
        console.error(
          "[parent/linkRequest] ìë™ ìŠ¹ì¸ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨",
          error
        );
        // ì—ëŸ¬ ë°œìƒ ì‹œ ìˆ˜ë™ ìŠ¹ì¸ìœ¼ë¡œ í´ë°±
      }
    }

    // ì—°ê²° ìš”ì²­ ìƒì„± (ìë™ ìŠ¹ì¸ ì¡°ê±´ ë§Œì¡± ì‹œ is_approved: true)
    const insertData: {
      student_id: string;
      parent_id: string;
      relation: string;
      is_approved: boolean;
      approved_at?: string;
    } = {
      student_id: studentId,
      parent_id: parentId,
      relation: relation,
      is_approved: shouldAutoApprove,
    };

    if (shouldAutoApprove) {
      insertData.approved_at = new Date().toISOString();
    }

    const { data, error } = await supabase
      .from("parent_student_links")
      .insert(insertData)
      .select("id")
      .single();

    if (error) {
      // UNIQUE ì œì•½ì¡°ê±´ ì—ëŸ¬ ì²˜ë¦¬
      if (error.code === "23505") {
        return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.REQUEST_ALREADY_EXISTS };
      }

      console.error("[parent/linkRequest] ì—°ê²° ìš”ì²­ ìƒì„± ì‹¤íŒ¨", error);
      return {
        success: false,
        error: error.message || "ì—°ê²° ìš”ì²­ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    revalidatePath("/parent/settings");

    return { success: true, requestId: data.id };
  } catch (error) {
    console.error("[parent/linkRequest] ì—°ê²° ìš”ì²­ ìƒì„± ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: "ì—°ê²° ìš”ì²­ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í•™ë¶€ëª¨ì˜ ì—°ê²° ìš”ì²­ ëª©ë¡ ì¡°íšŒ
 */
export async function getLinkRequests(
  parentId: string
): Promise<{ success: boolean; data?: LinkRequest[]; error?: string }> {
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // ë³¸ì¸ë§Œ ì¡°íšŒ ê°€ëŠ¥
  if (userId !== parentId) {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  const supabase = await createSupabaseServerClient();

  try {
    const selectLinks = () =>
      supabase
        .from("parent_student_links")
        .select(`
          id,
          student_id,
          relation,
          is_approved,
          created_at,
          students:student_id(
            id,
            name,
            grade,
            class
          )
        `)
        .eq("parent_id", parentId)
        .order("created_at", { ascending: false });

    let { data: links, error } = await selectLinks();

    // ì»¬ëŸ¼ ì—†ìŒ ì—ëŸ¬ ì²˜ë¦¬ (42703)
    if (error && error.code === "42703") {
      ({ data: links, error } = await selectLinks());
    }

    if (error) {
      console.error("[parent/linkRequest] ìš”ì²­ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
      return {
        success: false,
        error: error.message || "ìš”ì²­ ëª©ë¡ì„ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    if (!links) {
      return { success: true, data: [] };
    }

    // ë°ì´í„° ë³€í™˜
    const requests: LinkRequest[] = links
      .map((link: any) => {
        const student = link.students;
        if (!student) return null;

        return {
          id: link.id,
          studentId: link.student_id,
          studentName: student.name,
          grade: student.grade,
          class: student.class,
          relation: link.relation || "other",
          is_approved: link.is_approved,
          created_at: link.created_at,
        };
      })
      .filter((r): r is LinkRequest => r !== null);

    // ìƒíƒœë³„ ì •ë ¬: ëŒ€ê¸° ì¤‘(null/false) â†’ ìŠ¹ì¸ë¨(true) â†’ ê±°ë¶€ë¨(false, ìµœì‹ ìˆœ)
    requests.sort((a, b) => {
      // ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ì„ ë¨¼ì €
      if (a.is_approved === null || a.is_approved === false) {
        if (b.is_approved === true) return -1;
      }
      if (b.is_approved === null || b.is_approved === false) {
        if (a.is_approved === true) return 1;
      }
      // ê°™ì€ ìƒíƒœë©´ ìµœì‹ ìˆœ
      return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    });

    return { success: true, data: requests };
  } catch (error) {
    console.error("[parent/linkRequest] ìš”ì²­ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: "ìš”ì²­ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ëŒ€ê¸° ì¤‘ì¸ ì—°ê²° ìš”ì²­ ì·¨ì†Œ
 */
export async function cancelLinkRequest(
  requestId: string,
  parentId: string
): Promise<{ success: boolean; error?: string }> {
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  // ë³¸ì¸ë§Œ ì·¨ì†Œ ê°€ëŠ¥
  if (userId !== parentId) {
    return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.UNAUTHORIZED };
  }

  const supabase = await createSupabaseServerClient();

  try {
    // ë¨¼ì € ìš”ì²­ ì •ë³´ ì¡°íšŒ (ë³¸ì¸ ìš”ì²­ì¸ì§€, ëŒ€ê¸° ì¤‘ì¸ì§€ í™•ì¸)
    const { data: link, error: fetchError } = await supabase
      .from("parent_student_links")
      .select("id, parent_id, is_approved")
      .eq("id", requestId)
      .eq("parent_id", parentId)
      .maybeSingle();

    if (fetchError) {
      console.error("[parent/linkRequest] ìš”ì²­ ì¡°íšŒ ì‹¤íŒ¨", fetchError);
      return {
        success: false,
        error: "ìš”ì²­ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      };
    }

    if (!link) {
      return { success: false, error: "ìš”ì²­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë§Œ ì·¨ì†Œ ê°€ëŠ¥
    if (link.is_approved === true) {
      return { success: false, error: PARENT_STUDENT_LINK_MESSAGES.errors.CANNOT_CANCEL_APPROVED };
    }

    // ìš”ì²­ ì‚­ì œ
    const { error } = await supabase
      .from("parent_student_links")
      .delete()
      .eq("id", requestId)
      .eq("parent_id", parentId);

    if (error) {
      console.error("[parent/linkRequest] ìš”ì²­ ì·¨ì†Œ ì‹¤íŒ¨", error);
      return {
        success: false,
        error: error.message || "ìš”ì²­ ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    revalidatePath("/parent/settings");

    return { success: true };
  } catch (error) {
    console.error("[parent/linkRequest] ìš”ì²­ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: "ìš”ì²­ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="parent/_components/_utils/calculations.ts">
/**
 * ParentDashboardContentì—ì„œ ì‚¬ìš©í•˜ëŠ” ê³„ì‚° ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
 * ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ë¯€ë¡œ ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ì‘ì„±
 */

import type { ScoreRow } from "@/app/(student)/scores/dashboard/_utils";
import type { SubjectRiskAnalysis } from "@/app/(student)/analysis/_utils";

/**
 * ìµœê·¼ ì„±ì ì„ ì •ë ¬í•˜ì—¬ ë°˜í™˜ (ìµœê·¼ 5ê°œ)
 */
export function getRecentScores(allScores: ScoreRow[]): ScoreRow[] {
  return allScores
    .filter((s) => s.grade !== null)
    .sort((a, b) => {
      const dateA = a.test_date ? new Date(a.test_date).getTime() : 0;
      const dateB = b.test_date ? new Date(b.test_date).getTime() : 0;
      return dateB - dateA;
    })
    .slice(0, 5);
}

/**
 * ì·¨ì•½ ê³¼ëª©ì„ ë°˜í™˜ (risk_scoreê°€ ë†’ì€ ìƒìœ„ 3ê°œ)
 */
export function getWeakSubjects(riskAnalyses: SubjectRiskAnalysis[]): SubjectRiskAnalysis[] {
  return riskAnalyses
    .sort((a, b) => b.risk_score - a.risk_score)
    .slice(0, 3);
}

/**
 * ìœ„í—˜ ì‹ í˜¸ë¥¼ ë°˜í™˜ (risk_score >= 60)
 */
export function getRiskSignals(riskAnalyses: SubjectRiskAnalysis[]): SubjectRiskAnalysis[] {
  return riskAnalyses.filter((a) => a.risk_score >= 60);
}
</file>

<file path="parent/_components/ParentDashboardContent.tsx">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getWeekRange } from "@/lib/date/weekRange";
import {
  getWeeklyPlanSummary,
  getWeeklyStudyTimeSummary,
  getWeeklyGoalProgress,
} from "@/lib/reports/weekly";
import { getMonthlyReportData } from "@/lib/reports/monthly";
import { getActiveGoals, getGoalProgress } from "@/lib/goals/queries";
import { calculateGoalProgress } from "@/lib/goals/calc";
import { fetchAllScores } from "@/app/(student)/scores/dashboard/_utils";
import { calculateAllRiskIndices } from "@/app/(student)/analysis/_utils";
import { getSessionsByDateRange } from "@/lib/studySessions/queries";
import { TodaySummary } from "./TodaySummary";
import { WeeklyMonthlySummary } from "./WeeklyMonthlySummary";
import { RecentScores } from "./RecentScores";
import { WeakSubjects } from "./WeakSubjects";
import { RiskSignals } from "./RiskSignals";
import { RecommendationSection } from "./RecommendationSection";
import {
  getRecentScores,
  getWeakSubjects,
  getRiskSignals,
} from "./_utils/calculations";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type ParentDashboardContentProps = {
  studentId: string;
};

export async function ParentDashboardContent({
  studentId,
}: ParentDashboardContentProps) {
  const supabase = await createSupabaseServerClient();

  // í•™ìƒ ì •ë³´ ì¡°íšŒ
  const { data: student } = await supabase
    .from("students")
    .select("id, name, grade, class")
    .eq("id", studentId)
    .maybeSingle();

  if (!student) {
    return (
      <div className="rounded-xl border border-red-200 bg-red-50 p-8 text-center">
        <p className="text-sm text-red-700">í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
      </div>
    );
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
  const { weekStart, weekEnd } = getWeekRange();
  const weekStartStr = weekStart.toISOString().slice(0, 10);
  const weekEndStr = weekEnd.toISOString().slice(0, 10);

  // ë°ì´í„° ë³‘ë ¬ ì¡°íšŒ
  const [
    todaySessions,
    weeklyPlanSummary,
    weeklyStudyTime,
    weeklyGoalProgress,
    monthlyReport,
    activeGoals,
    allScores,
    riskAnalyses,
  ] = await Promise.all([
    // ì˜¤ëŠ˜ í•™ìŠµì‹œê°„
    getSessionsByDateRange(supabase, studentId, todayDate, todayDate),
    // ì£¼ê°„ í”Œëœ ìš”ì•½
    getWeeklyPlanSummary(supabase, studentId, weekStart, weekEnd),
    // ì£¼ê°„ í•™ìŠµì‹œê°„
    getWeeklyStudyTimeSummary(supabase, studentId, weekStart, weekEnd),
    // ì£¼ê°„ ëª©í‘œ ì§„í–‰ë¥ 
    getWeeklyGoalProgress(supabase, studentId, weekStart, weekEnd),
    // ì›”ê°„ ë¦¬í¬íŠ¸
    getMonthlyReportData(supabase, studentId, today).catch(() => null),
    // í™œì„± ëª©í‘œ
    getActiveGoals(supabase, studentId, todayDate),
    // ëª¨ë“  ì„±ì 
    fetchAllScores(supabase, studentId),
    // ìœ„í—˜ ì‹ í˜¸ ë¶„ì„
    calculateAllRiskIndices(supabase, studentId).catch(() => []),
  ]);

  // ì˜¤ëŠ˜ í•™ìŠµì‹œê°„ ê³„ì‚°
  const todayMinutes = Math.floor(
    todaySessions.reduce((sum, s) => sum + (s.duration_seconds || 0), 0) / 60
  );

  // ì˜¤ëŠ˜ í”Œëœ ê°œìˆ˜ (ì£¼ê°„ í”Œëœ ìš”ì•½ì—ì„œ ì˜¤ëŠ˜ ë‚ ì§œ ì¶”ì¶œ)
  const todayPlanData = weeklyPlanSummary.byDay.find(
    (d) => d.date === todayDate
  );
  const todayPlanCount = todayPlanData?.totalPlans || 0;
  const todayCompletedPlans = todayPlanData?.completedPlans || 0;
  const todayExecutionRate =
    todayPlanCount > 0
      ? Math.round((todayCompletedPlans / todayPlanCount) * 100)
      : 0;

  // ëª©í‘œ ì§„í–‰ë¥  ê³„ì‚°
  const goalsWithProgress = await Promise.all(
    activeGoals.slice(0, 3).map(async (goal) => {
      const progressRows = await getGoalProgress(supabase, studentId, goal.id);
      const progress = calculateGoalProgress(goal, progressRows, today);
      return {
        id: goal.id,
        title: goal.title,
        progressPercentage: progress.progressPercentage,
        daysRemaining: progress.daysRemaining,
      };
    })
  );

  // ìµœê·¼ ì„±ì , ì·¨ì•½ ê³¼ëª©, ìœ„í—˜ ì‹ í˜¸ ê³„ì‚° (ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ì—¬ ì¬ì‚¬ìš©ì„± ë° ê°€ë…ì„± í–¥ìƒ)
  const recentScores = getRecentScores(allScores);
  const weakSubjects = getWeakSubjects(riskAnalyses);
  const riskSignals = getRiskSignals(riskAnalyses);

  return (
    <div className="space-y-6">
      {/* ì˜¤ëŠ˜ í•™ìŠµ ìš”ì•½ */}
      <TodaySummary
        todayMinutes={todayMinutes}
        todayPlanCount={todayPlanCount}
        todayExecutionRate={todayExecutionRate}
      />

      {/* ì´ë²ˆì£¼/ì´ë²ˆë‹¬ í•µì‹¬ ì§€í‘œ */}
      <WeeklyMonthlySummary
        weeklyPlanSummary={weeklyPlanSummary}
        weeklyStudyTime={weeklyStudyTime}
        weeklyGoalProgress={weeklyGoalProgress}
        monthlyReport={monthlyReport}
      />

      {/* ìµœê·¼ ì„±ì  ë³€í™” */}
      {recentScores.length > 0 && (
        <RecentScores scores={recentScores} />
      )}

      {/* ì·¨ì•½ ê³¼ëª© ê²½ê³  */}
      {weakSubjects.length > 0 && (
        <WeakSubjects subjects={weakSubjects} />
      )}

      {/* ìœ„í—˜ ì‹ í˜¸ ì¹´ë“œ */}
      {riskSignals.length > 0 && (
        <RiskSignals signals={riskSignals} />
      )}

      {/* í•™ìŠµ ì¶”ì²œ ì„¹ì…˜ */}
      <RecommendationSection studentId={studentId} />

      {/* ëª©í‘œ ì§„í–‰ë¥  */}
      {goalsWithProgress.length > 0 && (
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h3 className="text-lg font-semibold text-gray-900">
            í˜„ì¬ ëª©í‘œ ì§„í–‰ë¥ 
          </h3>
          <div className="flex flex-col gap-4">
            {goalsWithProgress.map((goal) => (
              <div key={goal.id} className="flex flex-col gap-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium text-gray-700">
                    {goal.title}
                  </span>
                  <span className="text-sm font-semibold text-gray-900">
                    {goal.progressPercentage}%
                  </span>
                </div>
                <ProgressBar
                  value={goal.progressPercentage}
                  max={100}
                  color="indigo"
                  size="sm"
                />
                {goal.daysRemaining !== null && (
                  <p className="text-xs text-gray-500">
                    D-{goal.daysRemaining}
                  </p>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="parent/_components/RecentScores.tsx">
import type { ScoreRow } from "@/app/(student)/scores/dashboard/_utils";

type RecentScoresProps = {
  scores: ScoreRow[];
};

export function RecentScores({ scores }: RecentScoresProps) {
  return (
    <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <h3 className="text-lg font-semibold text-gray-900">
        ìµœê·¼ ì„±ì  ë³€í™”
      </h3>
      <div className="flex flex-col gap-3">
        {scores.map((score, index) => {
          const prevScore = index < scores.length - 1 ? scores[index + 1] : null;
          const gradeChange =
            prevScore && score.grade !== null && prevScore.grade !== null
              ? score.grade - prevScore.grade
              : null;

          return (
            <div
              key={score.id}
              className="flex items-center justify-between rounded-lg border border-gray-100 bg-gray-50 p-3"
            >
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-900">
                    {score.course_detail || score.course || "ê³¼ëª©"}
                  </span>
                  {score.test_date && (
                    <span className="text-xs text-gray-500">
                      ({new Date(score.test_date).toLocaleDateString("ko-KR")})
                    </span>
                  )}
                </div>
                {score.semester && (
                  <span className="text-xs text-gray-500">{score.semester}</span>
                )}
              </div>
              <div className="flex items-center gap-3">
                {score.grade !== null && (
                  <span className="text-lg font-bold text-indigo-600">
                    {score.grade}ë“±ê¸‰
                  </span>
                )}
                {gradeChange !== null && gradeChange !== 0 && (
                  <span
                    className={`text-sm font-semibold ${
                      gradeChange < 0
                        ? "text-green-600"
                        : gradeChange > 0
                        ? "text-red-600"
                        : "text-gray-600"
                    }`}
                  >
                    {gradeChange < 0 ? "â†‘" : "â†“"} {Math.abs(gradeChange)}
                  </span>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="parent/_components/RecommendationSection.tsx">
import { getRecommendations, getTopRecommendations } from "@/lib/recommendations/engine";
import { createSupabaseServerClient } from "@/lib/supabase/server";

export async function RecommendationSection({ studentId }: { studentId: string }) {
  const supabase = await createSupabaseServerClient();
  const recommendations = await getRecommendations(supabase, studentId);
  const topRecommendations = getTopRecommendations(recommendations, 5);

  if (topRecommendations.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col gap-4 rounded-xl border border-blue-200 bg-gradient-to-br from-blue-50 to-indigo-50 p-6 shadow-sm">
      <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">
        <span className="text-2xl">ğŸ’¡</span>
        ìš°ë¦¬ ì•„ì´ì—ê²Œ í•„ìš”í•œ í•™ìŠµ ì œì•ˆ
      </h3>
      <p className="text-sm text-gray-600">
        ìë…€ì˜ í•™ìŠµ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìƒì„±ëœ ë§ì¶¤ ì¶”ì²œì…ë‹ˆë‹¤
      </p>

      <ul className="flex flex-col gap-3">
        {topRecommendations.map((rec, index) => (
          <li key={index} className="flex items-start gap-3">
            <span className="flex h-5 w-5 shrink-0 items-center justify-center rounded-full bg-blue-100 text-xs font-semibold text-blue-700">
              {index + 1}
            </span>
            <p className="flex-1 text-sm text-gray-700 leading-relaxed">{rec}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="parent/_components/RiskSignals.tsx">
import type { SubjectRiskAnalysis } from "@/app/(student)/analysis/_utils";
import ProgressBar from "@/components/atoms/ProgressBar";

type RiskSignalsProps = {
  signals: SubjectRiskAnalysis[];
};

export function RiskSignals({ signals }: RiskSignalsProps) {
  return (
    <div className="rounded-xl border-2 border-red-300 bg-red-50 p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold text-red-900">
            ğŸš¨ ìœ„í—˜ ì‹ í˜¸
          </h3>
          <p className="text-sm text-red-700">
            ë‹¤ìŒ ê³¼ëª©ì—ì„œ ìœ„í—˜ ì‹ í˜¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒë‹´ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>
        <div className="flex flex-col gap-3">
          {signals.map((signal) => (
            <div
              key={signal.subject}
              className="rounded-lg border-2 border-red-300 bg-white p-4"
            >
              <div className="flex flex-col gap-2">
                <div className="flex items-center justify-between">
                  <span className="text-base font-semibold text-red-900">
                    {signal.subject}
                  </span>
                  <span className="text-lg font-bold text-red-600">
                    ìœ„í—˜ë„ {Math.round(signal.risk_score)}%
                  </span>
                </div>
                <ProgressBar
                  value={signal.risk_score}
                  max={100}
                  color="red"
                  height="sm"
                />
                <div className="flex flex-col gap-1">
                  <div className="text-xs text-gray-700">
                    ìµœê·¼ í‰ê·  ë“±ê¸‰: {signal.recent3AvgGrade.toFixed(1)}ë“±ê¸‰
                  </div>
                  {signal.gradeChange > 0 && (
                    <div className="text-xs text-red-600 font-semibold">
                      âš ï¸ ë“±ê¸‰ í•˜ë½: +{signal.gradeChange.toFixed(1)}
                    </div>
                  )}
                  <div className="text-xs text-gray-700">
                    ì¼ê´€ì„± ì ìˆ˜: {signal.consistency_score.toFixed(1)}%
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="parent/_components/StudentSelector.tsx">
"use client";

import { useRouter, useSearchParams, usePathname } from "next/navigation";
import { LinkedStudent } from "../../_utils";

type StudentSelectorProps = {
  students: LinkedStudent[];
  selectedStudentId: string;
};

export function StudentSelector({
  students,
  selectedStudentId,
}: StudentSelectorProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const pathname = usePathname();

  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const studentId = e.target.value;
    const params = new URLSearchParams(searchParams.toString());
    params.set("studentId", studentId);
    // í˜„ì¬ ê²½ë¡œ ìœ ì§€
    router.push(`${pathname}?${params.toString()}`);
  };

  if (students.length === 0) {
    return null;
  }

  if (students.length === 1) {
    const student = students[0];
    return (
      <div className="rounded-lg border border-gray-200 bg-white px-4 py-3">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium text-gray-700">ìë…€:</span>
          <span className="text-base font-semibold text-gray-900">
            {student.name || "ì´ë¦„ ì—†ìŒ"}
          </span>
          {student.grade && (
            <span className="text-sm text-gray-500">
              ({student.grade}í•™ë…„ {student.class}ë°˜)
            </span>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="rounded-lg border border-gray-200 bg-white px-4 py-3">
      <label className="flex items-center gap-3">
        <span className="text-sm font-medium text-gray-700">ìë…€ ì„ íƒ:</span>
        <select
          value={selectedStudentId}
          onChange={handleChange}
          className="flex-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium text-gray-900 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
        >
          {students.map((student) => (
            <option key={student.id} value={student.id}>
              {student.name || "ì´ë¦„ ì—†ìŒ"}
              {student.grade && ` (${student.grade}í•™ë…„ ${student.class}ë°˜)`}
            </option>
          ))}
        </select>
      </label>
    </div>
  );
}
</file>

<file path="parent/_components/TodaySummary.tsx">
type TodaySummaryProps = {
  todayMinutes: number;
  todayPlanCount: number;
  todayExecutionRate: number;
};

export function TodaySummary({
  todayMinutes,
  todayPlanCount,
  todayExecutionRate,
}: TodaySummaryProps) {
  const hours = Math.floor(todayMinutes / 60);
  const minutes = todayMinutes % 60;

  return (
    <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-gradient-to-br from-blue-50 to-indigo-50 p-6 shadow-sm">
      <h2 className="text-xl font-semibold text-gray-900">ì˜¤ëŠ˜ í•™ìŠµ ìš”ì•½</h2>
      <div className="grid gap-4 sm:grid-cols-3">
        <div className="flex flex-col gap-1 rounded-lg bg-white p-4">
          <div className="text-sm font-medium text-gray-500">
            ì˜¤ëŠ˜ í•™ìŠµì‹œê°„
          </div>
          <div className="text-2xl font-bold text-indigo-600">
            {hours > 0 ? `${hours}ì‹œê°„ ` : ""}
            {minutes}ë¶„
          </div>
        </div>
        <div className="flex flex-col gap-1 rounded-lg bg-white p-4">
          <div className="text-sm font-medium text-gray-500">
            ì˜¤ëŠ˜ í”Œëœ ê°œìˆ˜
          </div>
          <div className="text-2xl font-bold text-indigo-600">
            {todayPlanCount}ê°œ
          </div>
        </div>
        <div className="flex flex-col gap-1 rounded-lg bg-white p-4">
          <div className="text-sm font-medium text-gray-500">
            ì‹¤í–‰ë¥ 
          </div>
          <div className="text-2xl font-bold text-indigo-600">
            {todayExecutionRate}%
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="parent/_components/WeakSubjects.tsx">
import type { SubjectRiskAnalysis } from "@/app/(student)/analysis/_utils";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type WeakSubjectsProps = {
  subjects: SubjectRiskAnalysis[];
};

export function WeakSubjects({ subjects }: WeakSubjectsProps) {
  return (
    <div className="rounded-xl border border-orange-200 bg-orange-50 p-6 shadow-sm">
      <div className="flex flex-col gap-4">
        <h3 className="text-lg font-semibold text-orange-900">
          âš ï¸ ì·¨ì•½ ê³¼ëª© ê²½ê³ 
        </h3>
        <div className="flex flex-col gap-3">
          {subjects.map((subject) => (
            <div
              key={subject.subject}
              className="rounded-lg border border-orange-200 bg-white p-4"
            >
              <div className="flex flex-col gap-2">
                <div className="flex items-center justify-between">
                  <span className="text-base font-semibold text-gray-900">
                    {subject.subject}
                  </span>
                  <span className="text-sm font-bold text-orange-600">
                    ìœ„í—˜ë„ {Math.round(subject.risk_score)}%
                  </span>
                </div>
                <ProgressBar
                  value={subject.risk_score}
                  max={100}
                  color="orange"
                  size="sm"
                />
                <div className="text-xs text-gray-600">
                  ìµœê·¼ í‰ê·  ë“±ê¸‰: {subject.recent3AvgGrade.toFixed(1)}ë“±ê¸‰ | ì¼ê´€ì„±:{" "}
                  {subject.consistency_score.toFixed(1)}%
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="parent/_components/WeeklyMonthlySummary.tsx">
import type {
  WeeklyPlanSummary,
  WeeklyStudyTimeSummary,
  WeeklyGoalProgress,
} from "@/lib/reports/weekly";
import type { MonthlyReport } from "@/lib/reports/monthly";
import { ProgressBar } from "@/components/atoms/ProgressBar";

type WeeklyMonthlySummaryProps = {
  weeklyPlanSummary: WeeklyPlanSummary;
  weeklyStudyTime: WeeklyStudyTimeSummary;
  weeklyGoalProgress: WeeklyGoalProgress;
  monthlyReport: MonthlyReport | null;
};

export function WeeklyMonthlySummary({
  weeklyPlanSummary,
  weeklyStudyTime,
  weeklyGoalProgress,
  monthlyReport,
}: WeeklyMonthlySummaryProps) {
  const weeklyHours = Math.floor(weeklyStudyTime.totalMinutes / 60);
  const weeklyMinutes = weeklyStudyTime.totalMinutes % 60;

  return (
    <div className="grid gap-4 sm:grid-cols-2">
      {/* ì´ë²ˆì£¼ ìš”ì•½ */}
      <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
        <h3 className="text-lg font-semibold text-gray-900">
          ì´ë²ˆ ì£¼ í•µì‹¬ ì§€í‘œ
        </h3>
        <div className="flex flex-col gap-4">
          <div className="flex items-center justify-between">
            <span className="text-sm text-gray-600">í•™ìŠµì‹œê°„</span>
            <span className="text-sm font-semibold text-gray-900">
              {weeklyHours > 0 ? `${weeklyHours}ì‹œê°„ ` : ""}
              {weeklyMinutes}ë¶„
            </span>
          </div>
          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-600">í”Œëœ ì‹¤í–‰ë¥ </span>
              <span className="text-sm font-semibold text-gray-900">
                {weeklyPlanSummary.completionRate.toFixed(1)}%
              </span>
            </div>
            <ProgressBar
              value={weeklyPlanSummary.completionRate}
              max={100}
              color="indigo"
              size="sm"
            />
          </div>
          <div className="flex flex-col gap-1">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-600">ëª©í‘œ ë‹¬ì„±ë¥ </span>
              <span className="text-sm font-semibold text-gray-900">
                {weeklyGoalProgress.averageProgress.toFixed(1)}%
              </span>
            </div>
            <ProgressBar
              value={weeklyGoalProgress.averageProgress}
              max={100}
              color="green"
              size="sm"
            />
          </div>
        </div>
      </div>

      {/* ì´ë²ˆë‹¬ ìš”ì•½ */}
      {monthlyReport && (
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h3 className="text-lg font-semibold text-gray-900">
            ì´ë²ˆ ë‹¬ í•µì‹¬ ì§€í‘œ
          </h3>
          <div className="flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-600">í•™ìŠµì‹œê°„</span>
              <span className="text-sm font-semibold text-gray-900">
                {Math.floor(monthlyReport.totals.studyMinutes / 60)}ì‹œê°„{" "}
                {monthlyReport.totals.studyMinutes % 60}ë¶„
              </span>
            </div>
            <div className="flex flex-col gap-1">
              <div className="flex items-center justify-between">
                <span className="text-sm text-gray-600">í”Œëœ ì‹¤í–‰ë¥ </span>
                <span className="text-sm font-semibold text-gray-900">
                  {monthlyReport.totals.completionRate.toFixed(1)}%
                </span>
              </div>
              <ProgressBar
                value={monthlyReport.totals.completionRate}
                max={100}
                color="indigo"
                size="sm"
              />
            </div>
            <div className="flex flex-col gap-1">
              <div className="flex items-center justify-between">
                <span className="text-sm text-gray-600">ëª©í‘œ ë‹¬ì„±ë¥ </span>
                <span className="text-sm font-semibold text-gray-900">
                  {monthlyReport.totals.goalRate.toFixed(1)}%
                </span>
              </div>
              <ProgressBar
                value={monthlyReport.totals.goalRate}
                max={100}
                color="green"
                size="sm"
              />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="parent/dashboard/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../_utils";
import { StudentSelector } from "../_components/StudentSelector";
import { ParentDashboardContent } from "../_components/ParentDashboardContent";
import { getContainerClass } from "@/lib/constants/layout";
import { PageHeader } from "@/components/layout/PageHeader";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

export default async function ParentDashboardPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <div className="flex flex-col gap-2">
            <h2 className="text-xl font-semibold text-yellow-900">
              ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
            </h2>
            <p className="text-sm text-yellow-700">
              ê´€ë¦¬ìì—ê²Œ ìë…€ ì—°ê²°ì„ ìš”ì²­í•´ì£¼ì„¸ìš”.
            </p>
          </div>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë˜ëŠ” ì²« ë²ˆì§¸ í•™ìƒ)
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/dashboard");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <div className="flex flex-col gap-2">
            <h2 className="text-xl font-semibold text-red-900">
              ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
            </h2>
            <p className="text-sm text-red-700">
              ì´ í•™ìƒì˜ ì •ë³´ë¥¼ ì¡°íšŒí•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.
            </p>
          </div>
        </div>
      </section>
    );
  }

  return (
    <section className={getContainerClass("DASHBOARD", "md")}>
      <div className="flex flex-col gap-6">
        <PageHeader
          title="í•™ë¶€ëª¨ ëŒ€ì‹œë³´ë“œ"
          description="ìë…€ì˜ í•™ìŠµ í˜„í™©ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ì„¸ìš”"
        />

        {/* í•™ìƒ ì„ íƒ ë“œë¡­ë‹¤ìš´ */}
        <StudentSelector
          students={linkedStudents}
          selectedStudentId={selectedStudentId}
        />

        {/* ëŒ€ì‹œë³´ë“œ ì½˜í…ì¸  */}
        <ParentDashboardContent studentId={selectedStudentId} />
      </div>
    </section>
  );
}
</file>

<file path="parent/goals/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../_utils";
import { getAllGoals, getActiveGoals } from "@/lib/goals/queries";
import { calculateGoalProgress } from "@/lib/goals/calc";
import { StudentSelector } from "../_components/StudentSelector";
import Link from "next/link";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

export default async function ParentGoalsPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-yellow-900">
            ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/goals");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì˜¤ëŠ˜ ë‚ ì§œ
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDate = today.toISOString().slice(0, 10);

  // ëª©í‘œ ì¡°íšŒ
  const [allGoals, activeGoals] = await Promise.all([
    getAllGoals(supabase, selectedStudentId),
    getActiveGoals(supabase, selectedStudentId, todayDate),
  ]);

  // ëª©í‘œ ì§„í–‰ë¥  ê³„ì‚°
  const goalsWithProgress = await Promise.all(
    allGoals.map(async (goal) => {
      const progressRows = await import("@/lib/goals/queries").then((m) =>
        m.getGoalProgress(supabase, selectedStudentId, goal.id)
      );
      const progress = calculateGoalProgress(goal, progressRows, today);
      return {
        ...goal,
        progress,
      };
    })
  );

  // ëª©í‘œ ìƒíƒœë³„ ë¶„ë¥˜
  const upcomingGoals = goalsWithProgress.filter(
    (g) => g.progress.status === "scheduled"
  );
  const inProgressGoals = goalsWithProgress.filter(
    (g) => g.progress.status === "in_progress"
  );
  const completedGoals = goalsWithProgress.filter(
    (g) => g.progress.status === "completed"
  );
  const failedGoals = goalsWithProgress.filter(
    (g) => g.progress.status === "failed"
  );

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h1 className="text-3xl font-semibold text-gray-900">ëª©í‘œ í˜„í™©</h1>
          <p className="text-sm text-gray-500">
            ìë…€ì˜ í•™ìŠµ ëª©í‘œ ì§„í–‰ ìƒí™©ì„ í™•ì¸í•˜ì„¸ìš”
          </p>
        </div>
        <Link
          href="/parent/dashboard"
          className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
        >
          ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
        </Link>
      </div>

      {/* í•™ìƒ ì„ íƒ */}
      <div>
        <StudentSelector
          students={linkedStudents}
          selectedStudentId={selectedStudentId}
        />
      </div>

      {allGoals.length === 0 ? (
        <div className="rounded-xl border border-gray-200 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">ë“±ë¡ëœ ëª©í‘œê°€ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="flex flex-col gap-6">
          {/* í˜„ì¬ ëª©í‘œ ì§„í–‰ë¥  */}
          {activeGoals.length > 0 && (
            <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
              <h2 className="text-lg font-semibold text-gray-900">
                í˜„ì¬ ëª©í‘œ ì§„í–‰ë¥ 
              </h2>
              <div className="flex flex-col gap-4">
                {inProgressGoals.map((goal) => (
                  <div key={goal.id} className="flex flex-col gap-2">
                    <div className="flex items-center justify-between">
                      <div>
                        <span className="text-base font-semibold text-gray-900">
                          {goal.title}
                        </span>
                        {goal.progress.daysRemaining !== null && (
                          <span className="text-sm text-gray-500">
                            {" "}(D-{goal.progress.daysRemaining})
                          </span>
                        )}
                      </div>
                      <span className="text-base font-semibold text-indigo-600">
                        {goal.progress.progressPercentage.toFixed(1)}%
                      </span>
                    </div>
                    {/* TODO: ProgressBar ì»´í¬ë„ŒíŠ¸ë¡œ êµì²´ ê²€í†  í•„ìš” (ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ í•„ìš”) */}
                    <div className="w-full h-3 bg-gray-200 rounded-full overflow-hidden">
                      <div
                        className="h-full bg-indigo-600 transition-all"
                        style={{
                          width: `${goal.progress.progressPercentage}%`,
                        }}
                      />
                    </div>
                    <div className="text-xs text-gray-500">
                      {goal.start_date} ~ {goal.end_date}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* ëª©í‘œ ë‹¬ì„±ë¥  íŠ¸ë Œë“œ */}
          <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
            <h2 className="text-lg font-semibold text-gray-900">
              ëª©í‘œ ë‹¬ì„±ë¥  ìš”ì•½
            </h2>
            <div className="grid gap-4 sm:grid-cols-4">
              <div className="flex flex-col gap-1 rounded-lg border border-blue-200 bg-blue-50 p-4">
                <div className="text-sm font-medium text-blue-700">
                  ì˜ˆì •
                </div>
                <div className="text-2xl font-bold text-blue-600">
                  {upcomingGoals.length}
                </div>
              </div>
              <div className="flex flex-col gap-1 rounded-lg border border-indigo-200 bg-indigo-50 p-4">
                <div className="text-sm font-medium text-indigo-700">
                  ì§„í–‰ì¤‘
                </div>
                <div className="text-2xl font-bold text-indigo-600">
                  {inProgressGoals.length}
                </div>
              </div>
              <div className="flex flex-col gap-1 rounded-lg border border-green-200 bg-green-50 p-4">
                <div className="text-sm font-medium text-green-700">
                  ì™„ë£Œ
                </div>
                <div className="text-2xl font-bold text-green-600">
                  {completedGoals.length}
                </div>
              </div>
              <div className="flex flex-col gap-1 rounded-lg border border-red-200 bg-red-50 p-4">
                <div className="text-sm font-medium text-red-700">
                  ì‹¤íŒ¨
                </div>
                <div className="text-2xl font-bold text-red-600">
                  {failedGoals.length}
                </div>
              </div>
            </div>
          </div>

          {/* ì·¨ì•½ ê³¼ëª© ëª©í‘œ */}
          {inProgressGoals.filter((g) => g.goal_type === "weak_subject").length >
            0 && (
            <div className="flex flex-col gap-4 rounded-xl border border-orange-200 bg-orange-50 p-6 shadow-sm">
              <h2 className="text-lg font-semibold text-orange-900">
                ì·¨ì•½ ê³¼ëª© ëª©í‘œ
              </h2>
              <div className="flex flex-col gap-3">
                {inProgressGoals
                  .filter((g) => g.goal_type === "weak_subject")
                  .map((goal) => (
                    <div
                      key={goal.id}
                      className="flex flex-col gap-2 rounded-lg border border-orange-200 bg-white p-4"
                    >
                      <div className="flex items-center justify-between">
                        <span className="text-base font-semibold text-gray-900">
                          {goal.title}
                        </span>
                        <span className="text-sm font-semibold text-orange-600">
                          {goal.progress.progressPercentage.toFixed(1)}%
                        </span>
                      </div>
                      {/* TODO: ProgressBar ì»´í¬ë„ŒíŠ¸ë¡œ êµì²´ ê²€í†  í•„ìš” (ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ í•„ìš”) */}
                      <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-orange-500 transition-all"
                          style={{
                            width: `${goal.progress.progressPercentage}%`,
                          }}
                        />
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          )}
        </div>
      )}
    </section>
  );
}
</file>

<file path="parent/history/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../_utils";
import { StudentSelector } from "../_components/StudentSelector";
import Link from "next/link";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

type HistoryEvent = {
  id: string;
  event_type: string;
  detail: any;
  created_at: string;
};

const eventTypeLabels: Record<string, string> = {
  plan_completed: "í”Œëœ ì™„ë£Œ",
  study_session: "í•™ìŠµ ì„¸ì…˜",
  goal_progress: "ëª©í‘œ ì§„í–‰",
  goal_created: "ëª©í‘œ ìƒì„±",
  goal_completed: "ëª©í‘œ ì™„ë£Œ",
  score_added: "ì„±ì  ì…ë ¥",
  score_updated: "ì„±ì  ìˆ˜ì •",
  content_progress: "ì½˜í…ì¸  ì§„í–‰",
  auto_schedule_generated: "í•™ìŠµ í”Œëœ ìƒì„±",
};

export default async function ParentHistoryPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-yellow-900">
            ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/history");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // íˆìŠ¤í† ë¦¬ ì¡°íšŒ (ìµœê·¼ 50ê°œ)
  const selectHistory = () =>
    supabase
      .from("student_history")
      .select("id, event_type, detail, created_at")
      .eq("student_id", selectedStudentId)
      .order("created_at", { ascending: false })
      .limit(50);

  let { data: historyData, error } = await selectHistory();

  if (error && error.code === "42703") {
    ({ data: historyData, error } = await selectHistory());
  }

  if (error && error.code !== "PGRST116") {
    console.error("[parent/history] íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  const historyEvents = (historyData as HistoryEvent[] | null) ?? [];

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h1 className="text-3xl font-semibold text-gray-900">í•™ìŠµ í™œë™ ì´ë ¥</h1>
          <p className="text-sm text-gray-500">
            ìë…€ì˜ ìµœê·¼ í•™ìŠµ í™œë™ì„ í™•ì¸í•˜ì„¸ìš”
          </p>
        </div>
        <Link
          href="/parent/dashboard"
          className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
        >
          ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
        </Link>
      </div>

      {/* í•™ìƒ ì„ íƒ */}
      <div>
        <StudentSelector
          students={linkedStudents}
          selectedStudentId={selectedStudentId}
        />
      </div>

      {historyEvents.length === 0 ? (
        <div className="rounded-xl border border-gray-200 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">ê¸°ë¡ëœ í™œë™ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-lg font-semibold text-gray-900">
            ìµœê·¼ í™œë™ ìš”ì•½
          </h2>
          <div className="flex flex-col gap-3">
            {historyEvents.map((event) => (
              <div
                key={event.id}
                className="flex items-start gap-4 rounded-lg border border-gray-100 bg-gray-50 p-4"
              >
                <div className="flex flex-col gap-1 flex-1">
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-semibold text-gray-900">
                      {eventTypeLabels[event.event_type] || event.event_type}
                    </span>
                    <span className="text-xs text-gray-500">
                      {new Date(event.created_at).toLocaleString("ko-KR")}
                    </span>
                  </div>
                  {event.detail && typeof event.detail === "object" && (
                    <div className="text-xs text-gray-600">
                      {JSON.stringify(event.detail, null, 2)}
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </section>
  );
}
</file>

<file path="parent/report/monthly/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../../_utils";
import { getMonthlyReportData } from "@/lib/reports/monthly";
import { MonthlySummaryHeader } from "@/app/(student)/report/monthly/_components/MonthlySummaryHeader";
import { MonthlyCharts } from "@/app/(student)/report/monthly/_components/MonthlyCharts";
import { SubjectAnalysisSection } from "@/app/(student)/report/monthly/_components/SubjectAnalysisSection";
import { GoalProgressSection } from "@/app/(student)/report/monthly/_components/GoalProgressSection";
import { ContentProgressSection } from "@/app/(student)/report/monthly/_components/ContentProgressSection";
import { MonthlyHistorySection } from "@/app/(student)/report/monthly/_components/MonthlyHistorySection";
import { MonthNavigation } from "@/app/(student)/report/monthly/_components/MonthNavigation";
import { StudentSelector } from "../../_components/StudentSelector";
import Link from "next/link";
import { EmptyState } from "@/components/ui/EmptyState";
import { getContainerClass } from "@/lib/constants/layout";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

export default async function ParentMonthlyReportPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-2 rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-yellow-900">
            ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
          </h2>
          <p className="text-sm text-yellow-700">
            ê´€ë¦¬ìì—ê²Œ ìë…€ ì—°ê²°ì„ ìš”ì²­í•´ì£¼ì„¸ìš”.
          </p>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/report/monthly");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì›” íŒŒë¼ë¯¸í„° íŒŒì‹± (YYYY-MM í˜•ì‹)
  let monthDate: Date;
  if (params.month) {
    const [year, month] = params.month.split("-").map(Number);
    if (year && month && month >= 1 && month <= 12) {
      monthDate = new Date(year, month - 1, 1);
    } else {
      monthDate = new Date();
    }
  } else {
    monthDate = new Date();
  }

  // ë¯¸ë˜ ë‚ ì§œëŠ” í˜„ì¬ ë‹¬ë¡œ ì œí•œ
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const currentMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  if (monthDate > currentMonth) {
    monthDate = currentMonth;
  }

  try {
    const reportData = await getMonthlyReportData(supabase, selectedStudentId, monthDate);

    const hasData =
      reportData.totals.studyMinutes > 0 ||
      reportData.totals.completionRate > 0 ||
      reportData.goals.totalGoals > 0;

    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          {/* í—¤ë” */}
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-1">
              <h1 className="text-3xl font-semibold text-gray-900">ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸</h1>
              <p className="text-sm text-gray-500">{reportData.period.monthLabel}</p>
            </div>
            <div className="flex items-center gap-3">
              <Link
                href="/parent/dashboard"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          </div>

          {/* í•™ìƒ ì„ íƒ */}
          <div>
            <StudentSelector
              students={linkedStudents}
              selectedStudentId={selectedStudentId}
            />
          </div>

          {hasData && (
            <div className="rounded-lg border border-blue-200 bg-blue-50 px-4 py-2 text-sm text-blue-800">
              ìë…€ì˜ ì›”ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤. ìƒë‹´ì´ë‚˜ ê³µìœ ìš©ìœ¼ë¡œ í™œìš©í•´ ë³´ì„¸ìš”.
            </div>
          )}

          {/* ì›” ë„¤ë¹„ê²Œì´ì…˜ */}
          <div>
            <MonthNavigation currentMonth={monthDate} />
          </div>

          {!hasData ? (
            <EmptyState
              title="ì´ë²ˆ ë‹¬ ì•„ì§ í•™ìŠµ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤"
              description="í•™ìŠµì„ ì‹œì‘í•˜ë©´ ì›”ê°„ ë¦¬í¬íŠ¸ê°€ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤."
              actionLabel="ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°"
              actionHref="/parent/dashboard"
              icon="ğŸ“Š"
            />
          ) : (
            <div className="flex flex-col gap-8">
              {/* ìš”ì•½ í—¤ë” */}
              <MonthlySummaryHeader
                monthLabel={reportData.period.monthLabel}
                totalStudyMinutes={reportData.totals.studyMinutes}
                completionRate={reportData.totals.completionRate}
                goalRate={reportData.totals.goalRate}
                studyTimeChange={reportData.comparison.studyTimeChange}
                completionRateChange={reportData.comparison.completionRateChange}
                goalRateChange={reportData.comparison.goalRateChange}
              />

              {/* ê·¸ë˜í”„ ì„¹ì…˜ */}
              <div>
                <MonthlyCharts reportData={reportData} />
              </div>

              {/* ê³¼ëª© ë¶„ì„ */}
              {(reportData.subjects.strong.length > 0 || reportData.subjects.weak.length > 0) && (
                <div>
                  <SubjectAnalysisSection
                    strongSubjects={reportData.subjects.strong}
                    weakSubjects={reportData.subjects.weak}
                  />
                </div>
              )}

              {/* ëª©í‘œ ì§„í–‰ë¥  */}
              {reportData.goals.goals.length > 0 && (
                <div>
                  <GoalProgressSection goals={reportData.goals.goals} />
                </div>
              )}

              {/* ì½˜í…ì¸  ì§„í–‰ë¥  */}
              {reportData.content.progressList.length > 0 && (
                <div>
                  <ContentProgressSection progressList={reportData.content.progressList} />
                </div>
              )}

              {/* íˆìŠ¤í† ë¦¬ */}
              {reportData.history.events.length > 0 && (
                <div>
                  <MonthlyHistorySection events={reportData.history.events} />
                </div>
              )}
            </div>
          )}
        </div>
      </section>
    );
  } catch (error) {
    console.error("[parent/report/monthly] í˜ì´ì§€ ë¡œë“œ ì‹¤íŒ¨", error);
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-4 rounded-lg border border-red-200 bg-red-50 p-6">
          <h2 className="text-lg font-semibold text-red-900">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</h2>
          <p className="text-sm text-red-700">
            ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
          </p>
          <Link
            href="/parent/report/monthly"
            className="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700"
          >
            ìƒˆë¡œê³ ì¹¨
          </Link>
        </div>
      </section>
    );
  }
}
</file>

<file path="parent/report/weekly/_components/ParentWeeklyCoachingSection.tsx">
import type { WeeklyCoaching } from "@/lib/coaching/engine";

type ParentWeeklyCoachingSectionProps = {
  coaching: WeeklyCoaching;
};

export function ParentWeeklyCoachingSection({ coaching }: ParentWeeklyCoachingSectionProps) {
  return (
    <div className="flex flex-col gap-6 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="text-xl font-semibold text-gray-900">ì´ë²ˆì£¼ í•™ìŠµ ì½”ì¹­ ìš”ì•½</h2>

      {/* Summary */}
      <div className="rounded-lg bg-indigo-50 p-4">
        <p className="text-lg font-medium text-indigo-900">{coaching.summary}</p>
      </div>

      {/* Highlights */}
      {coaching.highlights.length > 0 && (
        <div className="flex flex-col gap-2">
          <h3 className="text-sm font-semibold text-gray-700">ì˜í•œ ì </h3>
          <ul className="flex flex-col gap-2">
            {coaching.highlights.map((highlight, index) => (
              <li key={index} className="flex items-start gap-2">
                <span className="text-green-600">âœ“</span>
                <span className="text-sm text-gray-700">{highlight}</span>
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Warnings */}
      {coaching.warnings.length > 0 && (
        <div className="flex flex-col gap-2">
          <h3 className="text-sm font-semibold text-gray-700">ì£¼ì˜ê°€ í•„ìš”í•œ ë¶€ë¶„</h3>
          <ul className="flex flex-col gap-2">
            {coaching.warnings.map((warning, index) => (
              <li key={index} className="flex items-start gap-2">
                <span className="text-red-600">âš </span>
                <span className="text-sm text-red-700">{warning}</span>
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Next Week Guide */}
      {coaching.nextWeekGuide.length > 0 && (
        <div className="flex flex-col gap-2">
          <h3 className="text-sm font-semibold text-gray-700">ë‹¤ìŒì£¼ í•™ìŠµ ê°€ì´ë“œ</h3>
          <ul className="flex flex-col gap-2">
            {coaching.nextWeekGuide.map((guide, index) => (
              <li key={index} className="flex items-start gap-2">
                <span className="text-yellow-600">â†’</span>
                <span className="text-sm text-yellow-800">{guide}</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
</file>

<file path="parent/report/weekly/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../../_utils";
import { getWeekRange, formatWeekRangeKorean } from "@/lib/date/weekRange";
import {
  getWeeklyPlanSummary,
  getWeeklyStudyTimeSummary,
  getWeeklyGoalProgress,
  getWeeklyWeakSubjectTrend,
  getDailyBreakdown,
} from "@/lib/reports/weekly";
import { WeeklySummaryHeader } from "@/app/(student)/report/weekly/_components/WeeklySummaryHeader";
import { WeeklyChartsSection } from "@/app/(student)/report/weekly/_components/WeeklyChartsSection";
import { GoalProgressSection } from "@/app/(student)/report/weekly/_components/GoalProgressSection";
import { WeakSubjectsSection } from "@/app/(student)/report/weekly/_components/WeakSubjectsSection";
import { DailyBreakdownSection } from "@/app/(student)/report/weekly/_components/DailyBreakdownSection";
import { ParentWeeklyCoachingSection } from "./_components/ParentWeeklyCoachingSection";
import { getWeeklyCoaching } from "@/app/(student)/report/weekly/coachingAction";
import { StudentSelector } from "../../_components/StudentSelector";
import Link from "next/link";
import { EmptyState } from "@/components/ui/EmptyState";
import { getContainerClass } from "@/lib/constants/layout";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

export default async function ParentWeeklyReportPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-2 rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-yellow-900">
            ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
          </h2>
          <p className="text-sm text-yellow-700">
            ê´€ë¦¬ìì—ê²Œ ìë…€ ì—°ê²°ì„ ìš”ì²­í•´ì£¼ì„¸ìš”.
          </p>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/report/weekly");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
  const { weekStart, weekEnd } = getWeekRange();
  const weekStartStr = weekStart.toISOString().slice(0, 10);
  const weekEndStr = weekEnd.toISOString().slice(0, 10);

  // ì§€ë‚œ ì£¼ ë²”ìœ„ (ë¹„êµìš©)
  const lastWeek = getWeekRange(new Date(weekStart.getTime() - 7 * 24 * 60 * 60 * 1000));
  const lastWeekStartStr = lastWeek.weekStart.toISOString().slice(0, 10);
  const lastWeekEndStr = lastWeek.weekEnd.toISOString().slice(0, 10);

  try {
    // ë°ì´í„° ë³‘ë ¬ ì¡°íšŒ
    const [
      planSummary,
      studyTimeSummary,
      goalProgress,
      weakSubjects,
      dailyBreakdown,
      lastWeekPlanSummary,
      lastWeekStudyTimeSummary,
      coachingResult,
    ] = await Promise.all([
      getWeeklyPlanSummary(supabase, selectedStudentId, weekStart, weekEnd),
      getWeeklyStudyTimeSummary(supabase, selectedStudentId, weekStart, weekEnd),
      getWeeklyGoalProgress(supabase, selectedStudentId, weekStart, weekEnd),
      getWeeklyWeakSubjectTrend(supabase, selectedStudentId, weekStart, weekEnd),
      getDailyBreakdown(supabase, selectedStudentId, weekStart, weekEnd),
      getWeeklyPlanSummary(supabase, selectedStudentId, lastWeek.weekStart, lastWeek.weekEnd),
      getWeeklyStudyTimeSummary(supabase, selectedStudentId, lastWeek.weekStart, lastWeek.weekEnd),
      getWeeklyCoaching(selectedStudentId),
    ]);

    // ì§€ë‚œì£¼ ëŒ€ë¹„ ë³€í™” ê³„ì‚°
    const studyTimeChange = studyTimeSummary.totalMinutes - lastWeekStudyTimeSummary.totalMinutes;
    const planCompletionChange =
      planSummary.completionRate - lastWeekPlanSummary.completionRate;
    const goalProgressChange =
      goalProgress.averageProgress - (lastWeekPlanSummary.completionRate || 0);

    const hasData =
      studyTimeSummary.totalMinutes > 0 ||
      planSummary.totalPlans > 0 ||
      goalProgress.totalGoals > 0;

    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-6">
          {/* í—¤ë” */}
          <div className="flex items-center justify-between">
            <div className="flex flex-col gap-1">
              <h1 className="text-3xl font-semibold text-gray-900">ì£¼ê°„ í•™ìŠµ ë¦¬í¬íŠ¸</h1>
              <p className="text-sm text-gray-500">
                {formatWeekRangeKorean(weekStart, weekEnd)}
              </p>
            </div>
            <div className="flex items-center gap-3">
              <Link
                href="/parent/dashboard"
                className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
              >
                ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          </div>

          {/* í•™ìƒ ì„ íƒ */}
          <div>
            <StudentSelector
              students={linkedStudents}
              selectedStudentId={selectedStudentId}
            />
          </div>

          {hasData && (
            <div className="rounded-lg border border-blue-200 bg-blue-50 px-4 py-2 text-sm text-blue-800">
              ìë…€ì˜ ì£¼ê°„ í•™ìŠµ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤. ìƒë‹´ì´ë‚˜ ê³µìœ ìš©ìœ¼ë¡œ í™œìš©í•´ ë³´ì„¸ìš”.
            </div>
          )}

          {!hasData ? (
            <EmptyState
              title="ì´ë²ˆ ì£¼ ì•„ì§ í•™ìŠµ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤"
              description="í•™ìŠµì„ ì‹œì‘í•˜ë©´ ì£¼ê°„ ë¦¬í¬íŠ¸ê°€ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤."
              actionLabel="ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°"
              actionHref="/parent/dashboard"
              icon="ğŸ“Š"
            />
          ) : (
            <div className="flex flex-col gap-8">
            {/* ìš”ì•½ í—¤ë” */}
            <WeeklySummaryHeader
              totalStudyTimeMinutes={studyTimeSummary.totalMinutes}
              planCompletionRate={planSummary.completionRate}
              goalProgressRate={goalProgress.averageProgress}
              studyTimeChange={studyTimeChange}
              planCompletionChange={planCompletionChange}
              goalProgressChange={goalProgressChange}
            />

            {/* ì½”ì¹­ ì„¹ì…˜ */}
            {coachingResult.success && coachingResult.data && (
              <ParentWeeklyCoachingSection coaching={coachingResult.data} />
            )}

            {/* ê·¸ë˜í”„ ì„¹ì…˜ */}
            <div>
              <WeeklyChartsSection
                studyTimeByDay={studyTimeSummary.byDay}
                studyTimeBySubject={studyTimeSummary.bySubject}
                planCompletionByDay={planSummary.byDay}
              />
            </div>

            {/* ëª©í‘œ ì§„í–‰ë¥  */}
            {goalProgress.goals.length > 0 && (
              <div>
                <GoalProgressSection goals={goalProgress.goals} />
              </div>
            )}

            {/* ì·¨ì•½ê³¼ëª© */}
            {weakSubjects.subjects.length > 0 && (
              <div>
                <WeakSubjectsSection subjects={weakSubjects.subjects} />
              </div>
            )}

            {/* ì¼ë³„ ìƒì„¸ ë¶„ì„ */}
            <div>
              <DailyBreakdownSection breakdown={dailyBreakdown} />
            </div>
            </div>
          )}
        </div>
      </section>
    );
  } catch (error) {
    console.error("[parent/report/weekly] í˜ì´ì§€ ë¡œë“œ ì‹¤íŒ¨", error);
    return (
      <section className={getContainerClass("DASHBOARD", "md")}>
        <div className="flex flex-col gap-4 rounded-lg border border-red-200 bg-red-50 p-6">
          <h2 className="text-lg font-semibold text-red-900">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤</h2>
          <p className="text-sm text-red-700">
            ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
          </p>
          <Link
            href="/parent/report/weekly"
            className="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700"
          >
            ìƒˆë¡œê³ ì¹¨
          </Link>
        </div>
      </section>
    );
  }
}
</file>

<file path="parent/scores/page.tsx">
export const dynamic = 'force-dynamic';

/**
 * í•™ë¶€ëª¨ ì˜ì—­ ì„±ì  í˜ì´ì§€
 * 
 * ìƒˆë¡œìš´ í†µí•© ëŒ€ì‹œë³´ë“œ API(/api/students/[id]/score-dashboard)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
import { redirect } from "next/navigation";
import { cookies } from "next/headers";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents, canAccessStudent } from "../../_utils";
import { fetchScoreDashboard } from "@/lib/api/scoreDashboard";
import {
  getStudentWithTenant,
  handleScoreDashboardError,
} from "@/lib/api/scoreDashboardUtils";
import { StudentSelector } from "../_components/StudentSelector";
import Link from "next/link";

type PageProps = {
  searchParams: Promise<Record<string, string | undefined>>;
};

export default async function ParentScoresPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  if (linkedStudents.length === 0) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-yellow-200 bg-yellow-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-yellow-900">
            ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ì„ íƒëœ í•™ìƒ ID
  const selectedStudentId =
    params.studentId || linkedStudents[0]?.id || null;

  if (!selectedStudentId) {
    redirect("/parent/scores");
  }

  // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  const hasAccess = await canAccessStudent(
    supabase,
    userId,
    selectedStudentId
  );

  if (!hasAccess) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // í•™ìƒ ì •ë³´ ì¡°íšŒ - ê³µí†µ ìœ í‹¸ë¦¬í‹° ì‚¬ìš©
  const studentWithTenant = await getStudentWithTenant(supabase, selectedStudentId);

  if (!studentWithTenant) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // í•™ìƒì˜ ì¶”ê°€ ì •ë³´ ì¡°íšŒ (name, grade, class)
  const { data: student } = await supabase
    .from("students")
    .select("id, name, grade, class")
    .eq("id", selectedStudentId)
    .maybeSingle();

  if (!student) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // tenantIdê°€ ì—†ìœ¼ë©´ ì—ëŸ¬ ë°˜í™˜
  if (!studentWithTenant.tenant_id) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-2 rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <h2 className="text-xl font-semibold text-red-900">
            ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
          </h2>
        </div>
      </section>
    );
  }

  // ìƒˆë¡œìš´ í†µí•© ëŒ€ì‹œë³´ë“œ API ì‚¬ìš© (ì¿ í‚¤ ì „ë‹¬)
  let dashboardData = null;
  let error: string | null = null;
  try {
    const cookieStore = await cookies();
    dashboardData = await fetchScoreDashboard(
      {
        studentId: selectedStudentId,
        tenantId: studentWithTenant.tenant_id,
      },
      {
        cookies: cookieStore,
      }
    );
  } catch (err) {
    error = handleScoreDashboardError(err, "parent/scores");
  }

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h1 className="text-3xl font-semibold text-gray-900">ì„±ì  í˜„í™©</h1>
          <p className="text-sm text-gray-500">
            ìë…€ì˜ ë‚´ì‹  ë° ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ í™•ì¸í•˜ì„¸ìš”
          </p>
        </div>
        <Link
          href="/parent/dashboard"
          className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
        >
          ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
        </Link>
      </div>

      {/* í•™ìƒ ì„ íƒ */}
      <div>
        <StudentSelector
          students={linkedStudents}
          selectedStudentId={selectedStudentId}
        />
      </div>

      {error ? (
        <div className="rounded-xl border border-red-200 bg-red-50 p-8 text-center">
          <p className="text-sm font-medium text-red-700">
            ì„±ì  ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
          </p>
          <p className="mt-2 text-xs text-red-600">{error}</p>
        </div>
      ) : !dashboardData ? (
        <div className="rounded-xl border border-gray-200 bg-gray-50 p-8 text-center">
          <p className="text-sm text-gray-500">ë“±ë¡ëœ ì„±ì ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
      ) : (
        <div className="flex flex-col gap-6">
          {/* ë‚´ì‹  ë¶„ì„ */}
          {dashboardData.internalAnalysis.totalGpa !== null && (
            <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
              <h2 className="text-lg font-semibold text-gray-900">ë‚´ì‹  ë¶„ì„</h2>
              <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
                <div className="flex flex-col gap-1 rounded-lg bg-indigo-50 p-4">
                  <div className="text-sm text-indigo-600">ì „ì²´ GPA</div>
                  <div className="text-2xl font-bold text-indigo-700">
                    {dashboardData.internalAnalysis.totalGpa.toFixed(2)}
                  </div>
                </div>
                {dashboardData.internalAnalysis.zIndex !== null && (
                  <div className="flex flex-col gap-1 rounded-lg bg-blue-50 p-4">
                    <div className="text-sm text-blue-600">Z-Index</div>
                    <div className="text-2xl font-bold text-blue-700">
                      {dashboardData.internalAnalysis.zIndex.toFixed(2)}
                    </div>
                  </div>
                )}
                {Object.keys(dashboardData.internalAnalysis.subjectStrength).length > 0 && (
                  <div className="flex flex-col gap-1 rounded-lg bg-purple-50 p-4">
                    <div className="text-sm text-purple-600">êµê³¼êµ° ìˆ˜</div>
                    <div className="text-2xl font-bold text-purple-700">
                      {Object.keys(dashboardData.internalAnalysis.subjectStrength).length}ê°œ
                    </div>
                  </div>
                )}
              </div>
              {Object.keys(dashboardData.internalAnalysis.subjectStrength).length > 0 && (
                <div className="flex flex-col gap-2">
                  <h3 className="text-sm font-medium text-gray-700">êµê³¼êµ°ë³„ í‰ì </h3>
                  <div className="grid grid-cols-2 gap-2">
                    {Object.entries(dashboardData.internalAnalysis.subjectStrength).map(([subject, gpa]) => (
                      <div key={subject} className="flex items-center justify-between rounded-lg border border-gray-200 bg-white p-2">
                        <span className="text-sm text-gray-700">{subject}</span>
                        <span className="text-sm font-semibold text-gray-900">{gpa.toFixed(2)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* ëª¨ì˜ê³ ì‚¬ ë¶„ì„ */}
          {dashboardData.mockAnalysis.recentExam !== null && (
            <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
              <h2 className="text-lg font-semibold text-gray-900">ëª¨ì˜ê³ ì‚¬ ë¶„ì„</h2>
              <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
                {dashboardData.mockAnalysis.recentExam && (
                  <div className="flex flex-col gap-1 rounded-lg bg-purple-50 p-4">
                    <div className="text-sm text-purple-600">ìµœê·¼ ì‹œí—˜</div>
                    <div className="text-lg font-bold text-purple-700">
                      {dashboardData.mockAnalysis.recentExam.examTitle}
                    </div>
                    <div className="text-xs text-purple-500">
                      {new Date(dashboardData.mockAnalysis.recentExam.examDate).toLocaleDateString("ko-KR")}
                    </div>
                  </div>
                )}
                {dashboardData.mockAnalysis.avgPercentile !== null && (
                  <div className="flex flex-col gap-1 rounded-lg bg-indigo-50 p-4">
                    <div className="text-sm text-indigo-600">í‰ê·  ë°±ë¶„ìœ„</div>
                    <div className="text-2xl font-bold text-indigo-700">
                      {dashboardData.mockAnalysis.avgPercentile.toFixed(1)}%
                    </div>
                  </div>
                )}
              </div>
              {dashboardData.mockAnalysis.best3GradeSum !== null && (
                <div className="flex flex-col gap-1 rounded-lg bg-gray-50 p-3">
                  <div className="text-sm text-gray-600">ìƒìœ„ 3ê°œ ë“±ê¸‰ í•©</div>
                  <div className="text-xl font-bold text-gray-900">
                    {dashboardData.mockAnalysis.best3GradeSum}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* ì…ì‹œ ì „ëµ */}
          {dashboardData.strategyResult && (
            <div className="flex flex-col gap-2 rounded-xl border border-blue-200 bg-blue-50 p-6">
              <h3 className="text-base font-semibold text-blue-900">ì…ì‹œ ì „ëµ</h3>
              <div className="flex items-center gap-2">
                <span className={`rounded-full px-3 py-1 text-sm font-medium ${
                  dashboardData.strategyResult.type === "BALANCED" ? "bg-blue-100 text-blue-800" :
                  dashboardData.strategyResult.type === "MOCK_ADVANTAGE" ? "bg-purple-100 text-purple-800" :
                  "bg-indigo-100 text-indigo-800"
                }`}>
                  {dashboardData.strategyResult.type === "BALANCED" ? "ê· í˜•í˜•" :
                   dashboardData.strategyResult.type === "MOCK_ADVANTAGE" ? "ëª¨ì˜ê³ ì‚¬ ìš°ìœ„" :
                   "ë‚´ì‹  ìš°ìœ„"}
                </span>
              </div>
              <p className="text-sm text-blue-700">{dashboardData.strategyResult.message}</p>
            </div>
          )}
        </div>
      )}
    </section>
  );
}
</file>

<file path="parent/settings/_components/LinkedStudentsSection.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { StudentSearchModal } from "./StudentSearchModal";
import { LinkRequestList } from "./LinkRequestList";
import { getLinkRequests, type LinkRequest } from "@/app/(parent)/actions/parentStudentLinkRequestActions";
import type { LinkedStudent } from "../../../_utils";

type LinkedStudentsSectionProps = {
  linkedStudents: LinkedStudent[];
  parentId: string;
  initialLinkRequests?: LinkRequest[];
};

export function LinkedStudentsSection({
  linkedStudents,
  parentId,
  initialLinkRequests = [],
}: LinkedStudentsSectionProps) {
  const router = useRouter();
  const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
  const [linkRequests, setLinkRequests] = useState<LinkRequest[]>(initialLinkRequests);
  const [isPending, startTransition] = useTransition();

  function handleRefresh() {
    startTransition(async () => {
      const result = await getLinkRequests(parentId);
      if (result.success && result.data) {
        setLinkRequests(result.data);
      }
      router.refresh();
    });
  }

  return (
    <>
      {/* ì—°ê²°ëœ ìë…€ */}
      <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-gray-900">ì—°ê²°ëœ ìë…€</h2>
          <button
            onClick={() => setIsSearchModalOpen(true)}
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-indigo-700"
          >
            í•™ìƒ ì—°ê²° ìš”ì²­
          </button>
        </div>
        {linkedStudents.length === 0 ? (
          <div className="rounded-lg border border-gray-200 bg-gray-50 p-4 text-center">
            <p className="text-sm text-gray-500">
              ì—°ê²°ëœ ìë…€ê°€ ì—†ìŠµë‹ˆë‹¤. ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì—°ê²°ì„ ìš”ì²­í•´ì£¼ì„¸ìš”.
            </p>
          </div>
        ) : (
          <div className="flex flex-col gap-3">
            {linkedStudents.map((student) => (
              <div
                key={student.id}
                className="flex items-center justify-between rounded-lg border border-gray-200 bg-gray-50 p-4"
              >
                <div className="flex flex-col gap-1">
                  <div className="text-base font-semibold text-gray-900">
                    {student.name || "ì´ë¦„ ì—†ìŒ"}
                  </div>
                  {student.grade && (
                    <div className="text-sm text-gray-500">
                      {student.grade}í•™ë…„ {student.class}ë°˜
                    </div>
                  )}
                  <div className="text-xs text-gray-400">
                    ê´€ê³„:{" "}
                    {student.relation === "mother"
                      ? "ì–´ë¨¸ë‹ˆ"
                      : student.relation === "father"
                      ? "ì•„ë²„ì§€"
                      : "ë³´í˜¸ì"}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* ì—°ê²° ìš”ì²­ ëª©ë¡ */}
      <LinkRequestList
        requests={linkRequests}
        parentId={parentId}
        onCancel={handleRefresh}
      />

      {/* í•™ìƒ ê²€ìƒ‰ ëª¨ë‹¬ */}
      <StudentSearchModal
        isOpen={isSearchModalOpen}
        onClose={() => setIsSearchModalOpen(false)}
        parentId={parentId}
        onSuccess={handleRefresh}
      />
    </>
  );
}
</file>

<file path="parent/settings/_components/LinkRequestList.tsx">
"use client";

import { useTransition } from "react";
import { useToast } from "@/components/ui/ToastProvider";
import { cancelLinkRequest, type LinkRequest } from "@/app/(parent)/actions/parentStudentLinkRequestActions";

type LinkRequestListProps = {
  requests: LinkRequest[];
  parentId: string;
  onCancel?: () => void;
};

export function LinkRequestList({
  requests,
  parentId,
  onCancel,
}: LinkRequestListProps) {
  const { showSuccess, showError } = useToast();
  const [isPending, startTransition] = useTransition();

  function handleCancel(requestId: string) {
    startTransition(async () => {
      const result = await cancelLinkRequest(requestId, parentId);

      if (result.success) {
        showSuccess("ì—°ê²° ìš”ì²­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
        onCancel?.();
      } else {
        showError(result.error || "ìš”ì²­ ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  function getStatusBadge(isApproved: boolean | null) {
    if (isApproved === true) {
      return (
        <span className="inline-flex items-center rounded-full bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800">
          ìŠ¹ì¸ë¨
        </span>
      );
    }
    if (isApproved === false) {
      return (
        <span className="inline-flex items-center rounded-full bg-red-100 px-2.5 py-0.5 text-xs font-medium text-red-800">
          ê±°ë¶€ë¨
        </span>
      );
    }
    return (
      <span className="inline-flex items-center rounded-full bg-yellow-100 px-2.5 py-0.5 text-xs font-medium text-yellow-800">
        ëŒ€ê¸° ì¤‘
      </span>
    );
  }

  function getRelationText(relation: string) {
    switch (relation) {
      case "father":
        return "ì•„ë²„ì§€";
      case "mother":
        return "ì–´ë¨¸ë‹ˆ";
      case "guardian":
        return "ë³´í˜¸ì";
      case "other":
        return "ê¸°íƒ€";
      default:
        return relation;
    }
  }

  if (requests.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="text-lg font-semibold text-gray-900">
        ì—°ê²° ìš”ì²­ ëª©ë¡
      </h2>
      <div className="flex flex-col gap-3">
        {requests.map((request) => (
          <div
            key={request.id}
            className="flex items-center justify-between rounded-lg border border-gray-200 bg-gray-50 p-4"
          >
            <div className="flex flex-col gap-1 flex-1">
              <div className="flex items-center gap-2">
                <div className="text-base font-semibold text-gray-900">
                  {request.studentName || "ì´ë¦„ ì—†ìŒ"}
                </div>
                {getStatusBadge(request.is_approved)}
              </div>
              {request.grade && request.class && (
                <div className="text-sm text-gray-500">
                  {request.grade}í•™ë…„ {request.class}ë°˜
                </div>
              )}
              <div className="text-xs text-gray-400">
                ê´€ê³„: {getRelationText(request.relation)} Â· ìš”ì²­ì¼:{" "}
                {new Date(request.created_at).toLocaleDateString("ko-KR")}
              </div>
            </div>
            {request.is_approved !== true && (
              <button
                onClick={() => handleCancel(request.id)}
                disabled={isPending}
                className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isPending ? "ì·¨ì†Œ ì¤‘..." : "ìš”ì²­ ì·¨ì†Œ"}
              </button>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="parent/settings/_components/RoleChangeSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useToast } from "@/components/ui/ToastProvider";
import { changeUserRole } from "@/app/actions/userRole";

export function RoleChangeSection() {
  const router = useRouter();
  const { showSuccess, showError } = useToast();
  const [saving, setSaving] = useState(false);

  const handleChangeToStudent = async () => {
    if (
      !confirm(
        "í•™ìƒ ê³„ì •ìœ¼ë¡œ ì „í™˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ? í˜„ì¬ í•™ë¶€ëª¨ ì •ë³´ê°€ ì‚­ì œë˜ê³ , í•™ìƒ ì •ë³´ë¥¼ ë‹¤ì‹œ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤."
      )
    ) {
      return;
    }

    try {
      setSaving(true);
      const result = await changeUserRole("student");
      if (result.success) {
        showSuccess("í•™ìƒ ê³„ì •ìœ¼ë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.");
        router.push("/settings");
      } else {
        showError(result.error || "ê¶Œí•œ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (error) {
      console.error("ê¶Œí•œ ë³€ê²½ ì‹¤íŒ¨:", error);
      showError("ê¶Œí•œ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
      <h2 className="text-lg font-semibold text-gray-900">
        íšŒì› ìœ í˜• ë³€ê²½
      </h2>
      <div className="flex flex-col gap-4">
        <div className="rounded-lg border border-yellow-200 bg-yellow-50 p-4">
          <p className="text-sm text-yellow-800">
            <strong>ì£¼ì˜:</strong> í•™ìƒ ê³„ì •ìœ¼ë¡œ ì „í™˜í•˜ë©´ í˜„ì¬ í•™ë¶€ëª¨ ì •ë³´ê°€ ì‚­ì œë˜ê³ , í•™ìƒ ê¸°ëŠ¥ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•™ìƒ ì •ë³´ë¥¼ ë‹¤ì‹œ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.
          </p>
        </div>
        <button
          type="button"
          onClick={handleChangeToStudent}
          disabled={saving}
          className="w-full rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {saving ? "ì „í™˜ ì¤‘..." : "í•™ìƒ ê³„ì •ìœ¼ë¡œ ì „í™˜"}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="parent/settings/_components/StudentAttendanceNotificationSettings.tsx">
"use client";

import { useState, useEffect } from "react";
import { updateStudentAttendanceNotificationSettings } from "@/app/(parent)/actions/parentSettingsActions";
import { cn } from "@/lib/cn";

type StudentAttendanceNotificationSettingsProps = {
  studentId: string;
  studentName: string;
  initialSettings: {
    attendance_check_in_enabled: boolean | null;
    attendance_check_out_enabled: boolean | null;
    attendance_absent_enabled: boolean | null;
    attendance_late_enabled: boolean | null;
  };
};

export function StudentAttendanceNotificationSettings({
  studentId,
  studentName,
  initialSettings,
}: StudentAttendanceNotificationSettingsProps) {
  const [settings, setSettings] = useState(initialSettings);
  const [saving, setSaving] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleToggle = (key: keyof typeof settings) => {
    // null -> true -> false -> null ìˆœí™˜
    const currentValue = settings[key];
    if (currentValue === null || currentValue === undefined) {
      setSettings((prev) => ({ ...prev, [key]: true }));
    } else if (currentValue === true) {
      setSettings((prev) => ({ ...prev, [key]: false }));
    } else {
      setSettings((prev) => ({ ...prev, [key]: null }));
    }
    setSuccess(false);
    setError(null);
  };

  const handleSave = async () => {
    setSaving(true);
    setError(null);
    setSuccess(false);

    try {
      const result = await updateStudentAttendanceNotificationSettings(
        studentId,
        settings
      );

      if (result.success) {
        setSuccess(true);
        setTimeout(() => setSuccess(false), 3000);
      } else {
        setError(result.error || "ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (err: any) {
      setError(err.message || "ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setSaving(false);
    }
  };

  const hasChanges =
    JSON.stringify(settings) !== JSON.stringify(initialSettings);

  const getToggleLabel = (value: boolean | null | undefined) => {
    if (value === null || value === undefined) return "ê¸°ë³¸ê°’";
    return value ? "ON" : "OFF";
  };

  const getToggleColor = (value: boolean | null | undefined) => {
    if (value === true) return "bg-indigo-600";
    if (value === false) return "bg-gray-400";
    return "bg-gray-200";
  };

  return (
    <div className="flex flex-col gap-4 rounded-lg border border-gray-200 bg-gray-50 p-4">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h3 className="text-base font-semibold text-gray-900">{studentName}</h3>
          <p className="text-xs text-gray-500">
            ì¶œì„ ê´€ë ¨ SMS ì•Œë¦¼ì„ ë°›ì„ í•­ëª©ì„ ì„¤ì •í•©ë‹ˆë‹¤. ê¸°ë³¸ê°’ì´ë©´ í•™ì› ê¸°ë³¸ ì„¤ì •ì„ ë”°ë¦…ë‹ˆë‹¤.
          </p>
        </div>
      </div>

      {success && (
        <div className="rounded-lg border border-green-200 bg-green-50 p-3 text-sm text-green-800">
          ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.
        </div>
      )}

      {error && (
        <div className="rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-800">
          {error}
        </div>
      )}

      <div className="flex flex-col gap-3">
        <div className="flex items-center justify-between">
          <div>
            <div className="text-sm font-medium text-gray-900">ì…ì‹¤ ì•Œë¦¼</div>
            <div className="text-xs text-gray-500">
              ì…ì‹¤ ì‹œ SMS ë°œì†¡ ì—¬ë¶€
            </div>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-xs text-gray-500">
              {getToggleLabel(settings.attendance_check_in_enabled)}
            </span>
            <button
              type="button"
              onClick={() => handleToggle("attendance_check_in_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                getToggleColor(settings.attendance_check_in_enabled)
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_check_in_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>
        </div>

        <div className="flex items-center justify-between">
          <div>
            <div className="text-sm font-medium text-gray-900">í‡´ì‹¤ ì•Œë¦¼</div>
            <div className="text-xs text-gray-500">
              í‡´ì‹¤ ì‹œ SMS ë°œì†¡ ì—¬ë¶€
            </div>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-xs text-gray-500">
              {getToggleLabel(settings.attendance_check_out_enabled)}
            </span>
            <button
              type="button"
              onClick={() => handleToggle("attendance_check_out_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                getToggleColor(settings.attendance_check_out_enabled)
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_check_out_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>
        </div>

        <div className="flex items-center justify-between">
          <div>
            <div className="text-sm font-medium text-gray-900">ê²°ì„ ì•Œë¦¼</div>
            <div className="text-xs text-gray-500">
              ê²°ì„ ì‹œ SMS ë°œì†¡ ì—¬ë¶€
            </div>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-xs text-gray-500">
              {getToggleLabel(settings.attendance_absent_enabled)}
            </span>
            <button
              type="button"
              onClick={() => handleToggle("attendance_absent_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                getToggleColor(settings.attendance_absent_enabled)
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_absent_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>
        </div>

        <div className="flex items-center justify-between">
          <div>
            <div className="text-sm font-medium text-gray-900">ì§€ê° ì•Œë¦¼</div>
            <div className="text-xs text-gray-500">
              ì§€ê° ì‹œ SMS ë°œì†¡ ì—¬ë¶€
            </div>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-xs text-gray-500">
              {getToggleLabel(settings.attendance_late_enabled)}
            </span>
            <button
              type="button"
              onClick={() => handleToggle("attendance_late_enabled")}
              className={cn(
                "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2",
                getToggleColor(settings.attendance_late_enabled)
              )}
            >
              <span
                className={cn(
                  "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                  settings.attendance_late_enabled === true
                    ? "translate-x-6"
                    : "translate-x-1"
                )}
              />
            </button>
          </div>
        </div>
      </div>

      {hasChanges && (
        <div className="flex items-center justify-end gap-3 border-t border-gray-200 pt-4">
          <button
            type="button"
            onClick={() => setSettings(initialSettings)}
            className="rounded-lg border border-gray-300 px-3 py-1.5 text-sm font-medium text-gray-700 hover:bg-gray-50"
          >
            ì·¨ì†Œ
          </button>
          <button
            type="button"
            onClick={handleSave}
            disabled={saving}
            className={cn(
              "rounded-lg px-4 py-1.5 text-sm font-medium text-white transition",
              saving
                ? "bg-gray-400 cursor-not-allowed"
                : "bg-indigo-600 hover:bg-indigo-700"
            )}
          >
            {saving ? "ì €ì¥ ì¤‘..." : "ì €ì¥í•˜ê¸°"}
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="parent/settings/_components/StudentSearchModal.tsx">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useTransition } from "react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import { useToast } from "@/components/ui/ToastProvider";
import {
  searchStudentsForLink,
  createLinkRequest,
  type SearchableStudent,
  type ParentRelation,
} from "@/app/(parent)/actions/parentStudentLinkRequestActions";

type StudentSearchModalProps = {
  isOpen: boolean;
  onClose: () => void;
  parentId: string;
  onSuccess?: () => void;
};

export function StudentSearchModal({
  isOpen,
  onClose,
  parentId,
  onSuccess,
}: StudentSearchModalProps) {
  const { showSuccess, showError } = useToast();
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<SearchableStudent[]>([]);
  const [selectedRelation, setSelectedRelation] = useState<ParentRelation>("mother");
  const [isSearching, setIsSearching] = useState(false);
  const [isPending, startTransition] = useTransition();
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);

  // ê²€ìƒ‰ ì‹¤í–‰
  const performSearch = useCallback(
    async (query: string) => {
      if (!query || query.trim().length < 2) {
        setSearchResults([]);
        setIsSearching(false);
        return;
      }

      setIsSearching(true);
      const result = await searchStudentsForLink(query.trim(), parentId);

      if (result.success && result.data) {
        setSearchResults(result.data);
      } else {
        setSearchResults([]);
        if (result.error) {
          showError(result.error);
        }
      }
      setIsSearching(false);
    },
    [parentId, showError]
  );

  // Debounce ê²€ìƒ‰
  useEffect(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    const timer = setTimeout(() => {
      performSearch(searchQuery);
    }, 300);

    debounceTimerRef.current = timer;

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [searchQuery, performSearch]);

  // ëª¨ë‹¬ ë‹«ì„ ë•Œ ì´ˆê¸°í™”
  useEffect(() => {
    if (!isOpen) {
      setSearchQuery("");
      setSearchResults([]);
      setSelectedRelation("mother");
      setIsSearching(false);
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
        debounceTimerRef.current = null;
      }
    }
  }, [isOpen]);

  function handleRequest(studentId: string) {
    startTransition(async () => {
      const result = await createLinkRequest(studentId, parentId, selectedRelation);

      if (result.success) {
        showSuccess("ì—°ê²° ìš”ì²­ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.");
        onSuccess?.();
        onClose();
      } else {
        showError(result.error || "ì—°ê²° ìš”ì²­ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  }

  return (
    <Dialog
      open={isOpen}
      onOpenChange={onClose}
      title="í•™ìƒ ê²€ìƒ‰ ë° ì—°ê²° ìš”ì²­"
      maxWidth="lg"
    >
      <DialogContent>
        <div className="flex flex-col gap-4">
          {/* ê²€ìƒ‰ ì…ë ¥ */}
          <div className="flex flex-col gap-2">
            <label
              htmlFor="student-search"
              className="block text-sm font-medium text-gray-700"
            >
              ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰
            </label>
            <input
              id="student-search"
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="ìµœì†Œ 2ê¸€ì ì´ìƒ ì…ë ¥í•˜ì„¸ìš”..."
              className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
            />
            {searchQuery.length > 0 && searchQuery.length < 2 && (
              <p className="text-xs text-gray-500">
                ìµœì†Œ 2ê¸€ì ì´ìƒ ì…ë ¥í•´ì£¼ì„¸ìš”.
              </p>
            )}
          </div>

          {/* ê´€ê³„ ì„ íƒ */}
          <div className="flex flex-col gap-2">
            <label
              htmlFor="relation-select"
              className="block text-sm font-medium text-gray-700"
            >
              ê´€ê³„
            </label>
            <select
              id="relation-select"
              value={selectedRelation}
              onChange={(e) =>
                setSelectedRelation(e.target.value as ParentRelation)
              }
              disabled={isPending}
              className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200 disabled:bg-gray-100"
            >
              <option value="father">ì•„ë²„ì§€</option>
              <option value="mother">ì–´ë¨¸ë‹ˆ</option>
              <option value="guardian">ë³´í˜¸ì</option>
              <option value="other">ê¸°íƒ€</option>
            </select>
          </div>

          {/* ê²€ìƒ‰ ê²°ê³¼ */}
          {isSearching && (
            <div className="py-8 text-center text-sm text-gray-500">
              ê²€ìƒ‰ ì¤‘...
            </div>
          )}

          {!isSearching && searchQuery.length >= 2 && searchResults.length === 0 && (
            <div className="py-8 text-center text-sm text-gray-500">
              ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.
            </div>
          )}

          {!isSearching && searchResults.length > 0 && (
            <div className="flex flex-col gap-2">
              <div className="text-sm font-medium text-gray-700">
                ê²€ìƒ‰ ê²°ê³¼ ({searchResults.length}ê°œ)
              </div>
              <div className="flex flex-col gap-2 max-h-64 overflow-y-auto">
                {searchResults.map((student) => (
                  <div
                    key={student.id}
                    className="flex items-center justify-between rounded-lg border border-gray-200 bg-white p-3 transition hover:bg-gray-50"
                  >
                    <div className="flex-1">
                      <div className="font-medium text-gray-900">
                        {student.name || "ì´ë¦„ ì—†ìŒ"}
                      </div>
                      <div className="text-sm text-gray-500">
                        {student.grade && student.class
                          ? `${student.grade}í•™ë…„ ${student.class}ë°˜`
                          : student.grade
                          ? `${student.grade}í•™ë…„`
                          : "-"}
                      </div>
                    </div>
                    <button
                      onClick={() => handleRequest(student.id)}
                      disabled={isPending}
                      className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-indigo-700 disabled:bg-indigo-400 disabled:cursor-not-allowed"
                    >
                      {isPending ? "ìš”ì²­ ì¤‘..." : "ì—°ê²° ìš”ì²­"}
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </DialogContent>
      <DialogFooter>
        <button
          onClick={onClose}
          disabled={isPending}
          className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50 disabled:opacity-50"
        >
          ë‹«ê¸°
        </button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="parent/settings/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getLinkedStudents } from "../../_utils";
import Link from "next/link";
import { RoleChangeSection } from "./_components/RoleChangeSection";
import { StudentAttendanceNotificationSettings } from "./_components/StudentAttendanceNotificationSettings";
import { getStudentAttendanceNotificationSettings } from "@/app/(parent)/actions/parentSettingsActions";
import { LinkedStudentsSection } from "./_components/LinkedStudentsSection";
import { getLinkRequests } from "@/app/(parent)/actions/parentStudentLinkRequestActions";

export default async function ParentSettingsPage() {
  const supabase = await createSupabaseServerClient();
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // í•™ë¶€ëª¨ ì •ë³´ ì¡°íšŒ
  const { data: parent } = await supabase
    .from("parent_users")
    .select("id, name, created_at")
    .eq("id", userId)
    .maybeSingle();

  // ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
  const linkedStudents = await getLinkedStudents(supabase, userId);

  // ì—°ê²° ìš”ì²­ ëª©ë¡ ì¡°íšŒ
  const linkRequestsResult = await getLinkRequests(userId);
  const linkRequests = linkRequestsResult.success && linkRequestsResult.data
    ? linkRequestsResult.data
    : [];

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h1 className="text-3xl font-semibold text-gray-900">ì„¤ì •</h1>
          <p className="text-sm text-gray-500">
            ê³„ì • ì •ë³´ ë° ì—°ê²°ëœ ìë…€ë¥¼ ê´€ë¦¬í•˜ì„¸ìš”
          </p>
        </div>
        <Link
          href="/parent/dashboard"
          className="rounded-lg border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50"
        >
          ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
        </Link>
      </div>

      <div className="flex flex-col gap-6">
        {/* ë‚˜ì˜ ì •ë³´ */}
        <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
          <h2 className="text-lg font-semibold text-gray-900">
            ë‚˜ì˜ ì •ë³´
          </h2>
          <div className="flex flex-col gap-3">
            <div className="flex flex-col gap-1">
              <label className="text-sm font-medium text-gray-700">ì´ë¦„</label>
              <div className="text-base text-gray-900">
                {parent?.name || "ì´ë¦„ ì—†ìŒ"}
              </div>
            </div>
            {parent?.created_at && (
              <div className="flex flex-col gap-1">
                <label className="text-sm font-medium text-gray-700">
                  ê°€ì…ì¼
                </label>
                <div className="text-base text-gray-900">
                  {new Date(parent.created_at).toLocaleDateString("ko-KR")}
                </div>
              </div>
            )}
          </div>
        </div>

        {/* ì—°ê²°ëœ ìë…€ ë° ì—°ê²° ìš”ì²­ */}
        <LinkedStudentsSection
          linkedStudents={linkedStudents}
          parentId={userId}
          initialLinkRequests={linkRequests}
        />

        {/* ìë…€ë³„ ì¶œì„ ì•Œë¦¼ ì„¤ì • */}
        {linkedStudents.length > 0 && (
          <div className="flex flex-col gap-4 rounded-xl border border-gray-200 bg-white p-6 shadow-sm">
            <h2 className="text-lg font-semibold text-gray-900">
              ì¶œì„ ì•Œë¦¼ ì„¤ì •
            </h2>
            <p className="text-sm text-gray-500">
              ê° ìë…€ë³„ë¡œ ì¶œì„ ê´€ë ¨ SMS ì•Œë¦¼ì„ ë°›ì„ í•­ëª©ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê¸°ë³¸ê°’ì´ë©´ í•™ì› ê¸°ë³¸ ì„¤ì •ì„ ë”°ë¦…ë‹ˆë‹¤.
            </p>
            <div className="flex flex-col gap-4">
              {await Promise.all(
                linkedStudents.map(async (student) => {
                  const settingsResult =
                    await getStudentAttendanceNotificationSettings(student.id);
                  const settings = settingsResult.data || {
                    attendance_check_in_enabled: null,
                    attendance_check_out_enabled: null,
                    attendance_absent_enabled: null,
                    attendance_late_enabled: null,
                  };

                  return (
                    <StudentAttendanceNotificationSettings
                      key={student.id}
                      studentId={student.id}
                      studentName={student.name || "ì´ë¦„ ì—†ìŒ"}
                      initialSettings={settings}
                    />
                  );
                })
              )}
            </div>
          </div>
        )}


        {/* ê¶Œí•œ ë³€ê²½ ì„¹ì…˜ */}
        <RoleChangeSection />
      </div>
    </section>
  );
}
</file>

<file path="_utils.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type LinkedStudent = {
  id: string;
  name: string | null;
  grade: string | null;
  class: string | null;
  relation: string;
};

/**
 * ë¶€ëª¨ê°€ ì—°ê²°ëœ í•™ìƒ ëª©ë¡ ì¡°íšŒ
 */
export async function getLinkedStudents(
  supabase: SupabaseServerClient,
  parentId: string
): Promise<LinkedStudent[]> {
  try {
    const selectLinks = () =>
      supabase
        .from("parent_student_links")
        .select("student_id, relation, students(id, name, grade, class)")
        .eq("parent_id", parentId);

    let { data: links, error } = await selectLinks();

    if (error && error.code === "42703") {
      ({ data: links, error } = await selectLinks());
    }

    if (error) {
      console.error("[parent] ì—°ê²°ëœ í•™ìƒ ì¡°íšŒ ì‹¤íŒ¨", error);
      return [];
    }

    if (!links) return [];

    return links
      .map((link: any) => {
        const student = link.students;
        if (!student) return null;
        return {
          id: student.id,
          name: student.name,
          grade: student.grade,
          class: student.class,
          relation: link.relation,
        };
      })
      .filter((s): s is LinkedStudent => s !== null);
  } catch (error) {
    console.error("[parent] ì—°ê²°ëœ í•™ìƒ ì¡°íšŒ ì‹¤íŒ¨", error);
    return [];
  }
}

/**
 * ë¶€ëª¨ê°€ íŠ¹ì • í•™ìƒì— ì ‘ê·¼ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸
 */
export async function canAccessStudent(
  supabase: SupabaseServerClient,
  parentId: string,
  studentId: string
): Promise<boolean> {
  try {
    const selectLink = () =>
      supabase
        .from("parent_student_links")
        .select("id")
        .eq("parent_id", parentId)
        .eq("student_id", studentId)
        .maybeSingle();

    let { data: link, error } = await selectLink();

    if (error && error.code === "42703") {
      ({ data: link, error } = await selectLink());
    }

    if (error && error.code !== "PGRST116") {
      console.error("[parent] í•™ìƒ ì ‘ê·¼ ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨", error);
      return false;
    }

    return link !== null;
  } catch (error) {
    console.error("[parent] í•™ìƒ ì ‘ê·¼ ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨", error);
    return false;
  }
}
</file>

<file path="error.tsx">
"use client";

import { useEffect } from "react";
import { ErrorState } from "@/components/ui/ErrorState";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error("[parent] ì—ëŸ¬ ë°œìƒ", error);
  }, [error]);

  return (
    <div className="mx-auto max-w-6xl px-4 py-10">
      <ErrorState
        title="ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
        message={error.message || "ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."}
        onRetry={reset}
        retryLabel="ë‹¤ì‹œ ì‹œë„"
        actionHref="/parent/dashboard"
        actionLabel="ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°"
      />
    </div>
  );
}
</file>

<file path="layout.tsx">
export const dynamic = 'force-dynamic';

import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getTenantInfo } from "@/lib/auth/getTenantInfo";
import { RoleBasedLayout } from "@/components/layout/RoleBasedLayout";

export default async function ParentLayout({ children }: { children: ReactNode }) {
  const { userId, role } = await getCurrentUserRole();

  // ê¶Œí•œ í™•ì¸: parentë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ê¸°ê´€ ì •ë³´ ì¡°íšŒ
  const tenantInfo = await getTenantInfo();

  return (
    <RoleBasedLayout
      role="parent"
      dashboardHref="/parent/dashboard"
      roleLabel="Parent"
      tenantInfo={tenantInfo}
    >
      {children}
    </RoleBasedLayout>
  );
}
</file>

<file path="layout.tsx">
export const dynamic = 'force-dynamic';

import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getTenantInfo } from "@/lib/auth/getTenantInfo";
import { RoleBasedLayout } from "@/components/layout/RoleBasedLayout";

export default async function ParentLayout({ children }: { children: ReactNode }) {
  const { userId, role } = await getCurrentUserRole();

  // ê¶Œí•œ í™•ì¸: parentë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "parent") {
    redirect("/login");
  }

  // ê¸°ê´€ ì •ë³´ ì¡°íšŒ
  const tenantInfo = await getTenantInfo();

  return (
    <RoleBasedLayout
      role="parent"
      dashboardHref="/parent/dashboard"
      roleLabel="Parent"
      tenantInfo={tenantInfo}
    >
      {children}
    </RoleBasedLayout>
  );
}
</file>

<file path="loading.tsx">
import { LoadingSkeleton } from "@/components/ui/LoadingSkeleton";

export default function Loading() {
  return (
    <div className="mx-auto max-w-6xl px-4 py-10">
      <LoadingSkeleton />
    </div>
  );
}
</file>

<file path="actions/curriculumSettingsActions.ts">
"use server";

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";

export type CurriculumSetting = {
  id: string;
  key: string;
  value: { start_year: number };
  description: string | null;
  created_at: string;
  updated_at: string;
};

export type CurriculumSettingsData = {
  middle_2022: number;
  high_2022: number;
  middle_2015: number;
  high_2015: number;
};

/**
 * êµìœ¡ê³¼ì • ì„¤ì • ì¡°íšŒ
 */
export async function getCurriculumSettings(): Promise<{
  success: boolean;
  data?: CurriculumSettingsData;
  error?: string;
}> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("system_settings")
      .select("*")
      .in("key", [
        "curriculum_revision_middle_2022",
        "curriculum_revision_high_2022",
        "curriculum_revision_middle_2015",
        "curriculum_revision_high_2015",
      ]);

    if (error) {
      console.error("[curriculum-settings] ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨", error);
      return { success: false, error: error.message || "ì„¤ì • ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    // ê¸°ë³¸ê°’ ì„¤ì •
    const settings: CurriculumSettingsData = {
      middle_2022: 2025,
      high_2022: 2025,
      middle_2015: 2018,
      high_2015: 2018,
    };

    // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒí•œ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    if (data) {
      for (const item of data) {
        const value = item.value as { start_year: number };
        if (item.key === "curriculum_revision_middle_2022") {
          settings.middle_2022 = value.start_year;
        } else if (item.key === "curriculum_revision_high_2022") {
          settings.high_2022 = value.start_year;
        } else if (item.key === "curriculum_revision_middle_2015") {
          settings.middle_2015 = value.start_year;
        } else if (item.key === "curriculum_revision_high_2015") {
          settings.high_2015 = value.start_year;
        }
      }
    }

    return { success: true, data: settings };
  } catch (error) {
    console.error("[curriculum-settings] ì„¤ì • ì¡°íšŒ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì„¤ì • ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * êµìœ¡ê³¼ì • ì„¤ì • ì—…ë°ì´íŠ¸
 */
export async function updateCurriculumSettings(
  formData: FormData
): Promise<{ success: boolean; error?: string }> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // FormDataì—ì„œ ê°’ ì¶”ì¶œ
    const middle_2022 = parseInt(formData.get("middle_2022") as string, 10);
    const high_2022 = parseInt(formData.get("high_2022") as string, 10);
    const middle_2015 = parseInt(formData.get("middle_2015") as string, 10);
    const high_2015 = parseInt(formData.get("high_2015") as string, 10);

    // ìœ íš¨ì„± ê²€ì‚¬
    if (isNaN(middle_2022) || isNaN(high_2022) || isNaN(middle_2015) || isNaN(high_2015)) {
      return { success: false, error: "ëª¨ë“  ë…„ë„ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”." };
    }

    if (middle_2022 < 2000 || high_2022 < 2000 || middle_2015 < 2000 || high_2015 < 2000) {
      return { success: false, error: "ìœ íš¨í•œ ë…„ë„ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”." };
    }

    // ì—…ë°ì´íŠ¸í•  ì„¤ì • ëª©ë¡
    const updates = [
      {
        key: "curriculum_revision_middle_2022",
        value: { start_year: middle_2022 },
        description: "ì¤‘í•™êµ 2022ê°œì • êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„",
      },
      {
        key: "curriculum_revision_high_2022",
        value: { start_year: high_2022 },
        description: "ê³ ë“±í•™êµ 2022ê°œì • êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„",
      },
      {
        key: "curriculum_revision_middle_2015",
        value: { start_year: middle_2015 },
        description: "ì¤‘í•™êµ 2015ê°œì • êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„",
      },
      {
        key: "curriculum_revision_high_2015",
        value: { start_year: high_2015 },
        description: "ê³ ë“±í•™êµ 2015ê°œì • êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„",
      },
    ];

    // ê° ì„¤ì • ì—…ë°ì´íŠ¸ (UPSERT)
    for (const update of updates) {
      const { error } = await supabase
        .from("system_settings")
        .upsert(
          {
            key: update.key,
            value: update.value,
            description: update.description,
          },
          {
            onConflict: "key",
          }
        );

      if (error) {
        console.error(`[curriculum-settings] ${update.key} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨`, error);
        return {
          success: false,
          error: error.message || "ì„¤ì • ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }
    }

    revalidatePath("/superadmin/curriculum-settings");
    return { success: true };
  } catch (error) {
    console.error("[curriculum-settings] ì„¤ì • ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì„¤ì • ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/tenantlessUserActions.ts">
"use server";

import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { revalidatePath } from "next/cache";

export type TenantlessUser = {
  id: string;
  email: string;
  name: string | null;
  role: "student" | "parent" | "admin" | "consultant";
  userType: "student" | "parent" | "admin";
  created_at: string;
};

/**
 * í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì ì¡°íšŒ
 */
export async function getTenantlessUsers(
  userType?: "student" | "parent" | "admin" | "all"
): Promise<{ success: boolean; data?: TenantlessUser[]; error?: string }> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const adminClient = createSupabaseAdminClient();

    // Supabase Authì—ì„œ ëª¨ë“  ì‚¬ìš©ì ì´ë©”ì¼ ì¡°íšŒ
    let allAuthUsers: Array<{ id: string; email?: string; user_metadata?: any }> = [];
    if (adminClient) {
      const { data: authData } = await adminClient.auth.admin.listUsers();
      if (authData?.users) {
        allAuthUsers = authData.users.map((u) => ({
          id: u.id,
          email: u.email,
          user_metadata: u.user_metadata,
        }));
      }
    }

    const tenantlessUsers: TenantlessUser[] = [];

    // 1. í•™ìƒ ì¡°íšŒ (tenant_id IS NULL)
    if (!userType || userType === "student" || userType === "all") {
      const { data: students, error: studentsError } = await supabase
        .from("students")
        .select("id, created_at")
        .is("tenant_id", null);

      if (studentsError) {
        console.error("[tenantless-users] í•™ìƒ ì¡°íšŒ ì‹¤íŒ¨", studentsError);
      } else if (students) {
        for (const student of students) {
          const authUser = allAuthUsers.find((u) => u.id === student.id);
          tenantlessUsers.push({
            id: student.id,
            email: authUser?.email || "ì´ë©”ì¼ ì—†ìŒ",
            name: authUser?.user_metadata?.display_name || null,
            role: "student",
            userType: "student",
            created_at: student.created_at || new Date().toISOString(),
          });
        }
      }
    }

    // 2. í•™ë¶€ëª¨ ì¡°íšŒ (tenant_id IS NULL)
    if (!userType || userType === "parent" || userType === "all") {
      const { data: parents, error: parentsError } = await supabase
        .from("parent_users")
        .select("id, created_at")
        .is("tenant_id", null);

      if (parentsError) {
        console.error("[tenantless-users] í•™ë¶€ëª¨ ì¡°íšŒ ì‹¤íŒ¨", parentsError);
      } else if (parents) {
        for (const parent of parents) {
          const authUser = allAuthUsers.find((u) => u.id === parent.id);
          tenantlessUsers.push({
            id: parent.id,
            email: authUser?.email || "ì´ë©”ì¼ ì—†ìŒ",
            name: authUser?.user_metadata?.display_name || null,
            role: "parent",
            userType: "parent",
            created_at: parent.created_at || new Date().toISOString(),
          });
        }
      }
    }

    // 3. ê´€ë¦¬ì ì¡°íšŒ (tenant_id IS NULL, superadmin ì œì™¸)
    if (!userType || userType === "admin" || userType === "all") {
      const { data: admins, error: adminsError } = await supabase
        .from("admin_users")
        .select("id, role, created_at")
        .is("tenant_id", null)
        .neq("role", "superadmin");

      if (adminsError) {
        console.error("[tenantless-users] ê´€ë¦¬ì ì¡°íšŒ ì‹¤íŒ¨", adminsError);
      } else if (admins) {
        for (const admin of admins) {
          const authUser = allAuthUsers.find((u) => u.id === admin.id);
          tenantlessUsers.push({
            id: admin.id,
            email: authUser?.email || "ì´ë©”ì¼ ì—†ìŒ",
            name: authUser?.user_metadata?.display_name || null,
            role: admin.role === "admin" ? "admin" : "consultant",
            userType: "admin",
            created_at: admin.created_at || new Date().toISOString(),
          });
        }
      }
    }

    // ìƒì„±ì¼ ê¸°ì¤€ ì •ë ¬ (ìµœì‹ ìˆœ)
    tenantlessUsers.sort((a, b) => {
      const dateA = new Date(a.created_at).getTime();
      const dateB = new Date(b.created_at).getTime();
      return dateB - dateA;
    });

    return { success: true, data: tenantlessUsers };
  } catch (error) {
    console.error("[tenantless-users] ì‚¬ìš©ì ì¡°íšŒ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì‚¬ìš©ì ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ë‹¨ì¼ ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ í• ë‹¹
 */
export async function assignTenantToUser(
  userId: string,
  tenantId: string,
  userType: "student" | "parent" | "admin"
): Promise<{ success: boolean; error?: string }> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // í…Œë„ŒíŠ¸ ì¡´ì¬ í™•ì¸
    const { data: tenant, error: tenantError } = await supabase
      .from("tenants")
      .select("id")
      .eq("id", tenantId)
      .maybeSingle();

    if (tenantError || !tenant) {
      return { success: false, error: "í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ì‚¬ìš©ì íƒ€ì…ì— ë”°ë¼ í•´ë‹¹ í…Œì´ë¸” ì—…ë°ì´íŠ¸
    let updateError = null;

    if (userType === "student") {
      const { error } = await supabase
        .from("students")
        .update({ tenant_id: tenantId })
        .eq("id", userId);
      updateError = error;
    } else if (userType === "parent") {
      const { error } = await supabase
        .from("parent_users")
        .update({ tenant_id: tenantId })
        .eq("id", userId);
      updateError = error;
    } else if (userType === "admin") {
      const { error } = await supabase
        .from("admin_users")
        .update({ tenant_id: tenantId })
        .eq("id", userId);
      updateError = error;
    }

    if (updateError) {
      console.error(`[tenantless-users] ${userType} í…Œë„ŒíŠ¸ í• ë‹¹ ì‹¤íŒ¨`, updateError);
      return {
        success: false,
        error: updateError.message || "í…Œë„ŒíŠ¸ í• ë‹¹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    revalidatePath("/superadmin/tenantless-users");
    return { success: true };
  } catch (error) {
    console.error("[tenantless-users] í…Œë„ŒíŠ¸ í• ë‹¹ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í…Œë„ŒíŠ¸ í• ë‹¹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ë‹¤ì¤‘ ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ í• ë‹¹
 */
export async function assignTenantToMultipleUsers(
  userIds: Array<{ userId: string; userType: "student" | "parent" | "admin" }>,
  tenantId: string
): Promise<{ success: boolean; error?: string; assignedCount?: number }> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // í…Œë„ŒíŠ¸ ì¡´ì¬ í™•ì¸
    const { data: tenant, error: tenantError } = await supabase
      .from("tenants")
      .select("id")
      .eq("id", tenantId)
      .maybeSingle();

    if (tenantError || !tenant) {
      return { success: false, error: "í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    let assignedCount = 0;
    const errors: string[] = [];

    for (const { userId, userType } of userIds) {
      let updateError = null;

      if (userType === "student") {
        const { error } = await supabase
          .from("students")
          .update({ tenant_id: tenantId })
          .eq("id", userId);
        updateError = error;
      } else if (userType === "parent") {
        const { error } = await supabase
          .from("parent_users")
          .update({ tenant_id: tenantId })
          .eq("id", userId);
        updateError = error;
      } else if (userType === "admin") {
        const { error } = await supabase
          .from("admin_users")
          .update({ tenant_id: tenantId })
          .eq("id", userId);
        updateError = error;
      }

      if (updateError) {
        errors.push(`${userId}: ${updateError.message}`);
      } else {
        assignedCount++;
      }
    }

    if (errors.length > 0) {
      console.error("[tenantless-users] ì¼ë¶€ ì‚¬ìš©ì í…Œë„ŒíŠ¸ í• ë‹¹ ì‹¤íŒ¨", errors);
    }

    revalidatePath("/superadmin/tenantless-users");
    return { success: true, assignedCount };
  } catch (error) {
    console.error("[tenantless-users] ì¼ê´„ í…Œë„ŒíŠ¸ í• ë‹¹ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì¼ê´„ í…Œë„ŒíŠ¸ í• ë‹¹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í™œì„± í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒ (í…Œë„ŒíŠ¸ í• ë‹¹ìš©)
 */
export async function getActiveTenants(): Promise<
  { success: boolean; data?: Array<{ id: string; name: string }>; error?: string }
> {
  const { role } = await getCurrentUserRole();

  if (role !== "superadmin") {
    return { success: false, error: "Super Adminë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." };
  }

  try {
    const supabase = await createSupabaseServerClient();

    // status ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ í™œì„±í™”ëœ ê¸°ê´€ë§Œ, ì—†ìœ¼ë©´ ëª¨ë‘ ì¡°íšŒ
    let query = supabase.from("tenants").select("id, name").order("name", { ascending: true });

    // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸ í›„ í•„í„°ë§
    try {
      const { data, error } = await query.eq("status", "active");
      if (!error && data) {
        return {
          success: true,
          data: data.map((t) => ({ id: t.id, name: t.name })),
        };
      }
    } catch (e) {
      // status ì»¬ëŸ¼ì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¬´ì‹œí•˜ê³  ì „ì²´ ì¡°íšŒ
    }

    // status ì»¬ëŸ¼ì´ ì—†ê±°ë‚˜ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš° ì „ì²´ ì¡°íšŒ
    const { data, error } = await supabase
      .from("tenants")
      .select("id, name")
      .order("name", { ascending: true });

    if (error) {
      console.error("[tenantless-users] í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", error);
      return { success: false, error: error.message || "í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    return {
      success: true,
      data: (data || []).map((t) => ({ id: t.id, name: t.name })),
    };
  } catch (error) {
    console.error("[tenantless-users] í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="actions/termsContents.ts">
"use server";

import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { TermsContentType, TermsContentInput, TermsContent } from "@/lib/types/terms";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";

/**
 * ìƒˆ ì•½ê´€ ë²„ì „ ìƒì„± (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ ìƒì„±/ìˆ˜ì •/í™œì„±í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const createTermsContent = withErrorHandling(
  async (input: TermsContentInput): Promise<{ success: boolean; data?: TermsContent; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    // í˜„ì¬ ìµœëŒ€ ë²„ì „ ì¡°íšŒ
    const { data: maxVersionData, error: maxVersionError } = await supabase
      .from("terms_contents")
      .select("version")
      .eq("content_type", input.content_type)
      .order("version", { ascending: false })
      .limit(1)
      .single();

    const nextVersion = maxVersionData?.version ? maxVersionData.version + 1 : 1;

    // ìƒˆ ì•½ê´€ ë²„ì „ ìƒì„±
    const { data, error } = await supabase
      .from("terms_contents")
      .insert({
        content_type: input.content_type,
        version: nextVersion,
        title: input.title,
        content: input.content,
        is_active: false, // ìƒˆ ë²„ì „ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë¹„í™œì„±í™”
        created_by: userId,
      })
      .select()
      .single();

    if (error) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ ìƒì„± ì‹¤íŒ¨:", {
        input,
        error: error.message,
        code: error.code,
      });
      throw new AppError(
        error.message || "ì•½ê´€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true, data: data as TermsContent };
  }
);

/**
 * ì•½ê´€ ë‚´ìš© ìˆ˜ì • (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const updateTermsContent = withErrorHandling(
  async (
    id: string,
    input: Partial<Pick<TermsContentInput, "title" | "content">>
  ): Promise<{ success: boolean; data?: TermsContent; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    // ì•½ê´€ ì¡´ì¬ í™•ì¸
    const { data: existing, error: checkError } = await supabase
      .from("terms_contents")
      .select("id")
      .eq("id", id)
      .single();

    if (checkError) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (checkError.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      throw new AppError("ì•½ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
    }

    if (!existing) {
      throw new AppError("ì•½ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
    }

    // ì•½ê´€ ìˆ˜ì •
    const updateData: Partial<{
      title: string;
      content: string;
    }> = {};

    if (input.title !== undefined) {
      updateData.title = input.title;
    }
    if (input.content !== undefined) {
      updateData.content = input.content;
    }

    const { data, error } = await supabase
      .from("terms_contents")
      .update(updateData)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ ìˆ˜ì • ì‹¤íŒ¨:", {
        id,
        input,
        error: error.message,
        code: error.code,
      });
      throw new AppError(
        error.message || "ì•½ê´€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true, data: data as TermsContent };
  }
);

/**
 * íŠ¹ì • ë²„ì „ í™œì„±í™” (ì´ì „ ë²„ì „ ìë™ ë¹„í™œì„±í™”) (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ í™œì„±í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const activateTermsContent = withErrorHandling(
  async (id: string): Promise<{ success: boolean; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    // í™œì„±í™”í•  ì•½ê´€ ì¡°íšŒ
    const { data: target, error: targetError } = await supabase
      .from("terms_contents")
      .select("content_type")
      .eq("id", id)
      .single();

    if (targetError) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (targetError.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      throw new AppError("ì•½ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
    }

    if (!target) {
      throw new AppError("ì•½ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
    }

    // ê°™ì€ content_typeì˜ ëª¨ë“  ë²„ì „ ë¹„í™œì„±í™”
    const { error: deactivateError } = await supabase
      .from("terms_contents")
      .update({ is_active: false })
      .eq("content_type", target.content_type);

    if (deactivateError) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (deactivateError.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ ë¹„í™œì„±í™” ì‹¤íŒ¨:", {
        contentType: target.content_type,
        error: deactivateError.message,
        code: deactivateError.code,
      });
      throw new AppError(
        deactivateError.message || "ì•½ê´€ ë¹„í™œì„±í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    // ì„ íƒí•œ ë²„ì „ í™œì„±í™”
    const { error: activateError } = await supabase
      .from("terms_contents")
      .update({ is_active: true })
      .eq("id", id);

    if (activateError) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (activateError.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ í™œì„±í™” ì‹¤íŒ¨:", {
        id,
        error: activateError.message,
        code: activateError.code,
      });
      throw new AppError(
        activateError.message || "ì•½ê´€ í™œì„±í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true };
  }
);

/**
 * ì•½ê´€ ëª©ë¡ ì¡°íšŒ (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const getTermsContents = withErrorHandling(
  async (contentType: TermsContentType): Promise<{ success: boolean; data?: TermsContent[]; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("terms_contents")
      .select("*")
      .eq("content_type", contentType)
      .order("version", { ascending: false });

    if (error) {
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", {
        contentType,
        error: error.message,
        code: error.code,
      });
      throw new AppError(
        error.message || "ì•½ê´€ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true, data: (data as TermsContent[]) || [] };
  }
);

/**
 * í™œì„± ì•½ê´€ ì¡°íšŒ (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const getActiveTermsContent = withErrorHandling(
  async (contentType: TermsContentType): Promise<{ success: boolean; data?: TermsContent; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("terms_contents")
      .select("*")
      .eq("content_type", contentType)
      .eq("is_active", true)
      .single();

    if (error) {
      // PGRST116: No rows returned
      if (error.code === "PGRST116") {
        return { success: true, data: undefined };
      }
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] í™œì„± ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨:", {
        contentType,
        error: error.message,
        code: error.code,
      });
      throw new AppError(
        error.message || "í™œì„± ì•½ê´€ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true, data: data as TermsContent };
  }
);

/**
 * IDë¡œ ì•½ê´€ ë‚´ìš© ì¡°íšŒ (Super Admin ì „ìš©)
 * 
 * Super Adminë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ëª¨ë“  ë²„ì „ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * RLS ì •ì±…ì„ ìš°íšŒí•˜ì—¬ ì ‘ê·¼í•©ë‹ˆë‹¤.
 */
export const getTermsContentById = withErrorHandling(
  async (id: string): Promise<{ success: boolean; data?: TermsContent; error?: string }> => {
    const { userId, role } = await getCurrentUserRole();

    // Super Admin ê¶Œí•œ í™•ì¸
    if (!userId || role !== "superadmin") {
      throw new AppError("Super Admin ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.FORBIDDEN, 403, true);
    }

    const supabase = await createSupabaseServerClient();

    const { data, error } = await supabase
      .from("terms_contents")
      .select("*")
      .eq("id", id)
      .single();

    if (error) {
      // PGRST116: No rows returned
      if (error.code === "PGRST116") {
        return { success: true, data: undefined };
      }
      // PGRST205: í…Œì´ë¸”ì´ ìŠ¤í‚¤ë§ˆ ìºì‹œì— ì—†ìŒ
      if (error.code === "PGRST205") {
        throw new AppError(
          "ì•½ê´€ í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.",
          ErrorCode.DATABASE_ERROR,
          500,
          true
        );
      }
      console.error("[termsContents] ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨:", {
        id,
        error: error.message,
        code: error.code,
      });
      throw new AppError(
        error.message || "ì•½ê´€ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    return { success: true, data: data as TermsContent };
  }
);
</file>

<file path="superadmin/admin-users/AdminUsersList.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { deleteAdminUser } from "@/app/(admin)/actions/adminUserActions";

type AdminUser = {
  id: string;
  role: string;
  created_at: string;
  email: string;
  tenant_id?: string | null;
  tenant_name?: string | null;
};

export function AdminUsersList({ adminUsers }: { adminUsers: AdminUser[] }) {
  const [isPending, startTransition] = useTransition();
  const router = useRouter();

  function handleDelete(userId: string) {
    if (!confirm("ì •ë§ ì´ ì‚¬ìš©ìì˜ ê´€ë¦¬ì ê¶Œí•œì„ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      return;
    }

    startTransition(async () => {
      try {
        await deleteAdminUser(userId);
        router.refresh();
        alert("ê´€ë¦¬ì ê¶Œí•œì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } catch (error) {
        console.error("ê´€ë¦¬ì ê¶Œí•œ ì œê±° ì‹¤íŒ¨:", error);
        alert(
          error instanceof Error
            ? error.message
            : "ê´€ë¦¬ì ê¶Œí•œ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        );
      }
    });
  }

  if (adminUsers.length === 0) {
    return (
      <div className="rounded-xl border border-dashed border-gray-300 bg-gray-50 p-12 text-center">
        <div className="mx-auto flex max-w-md flex-col gap-6">
          <div className="text-6xl">ğŸ‘¤</div>
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-gray-900">
              ë“±ë¡ëœ ê´€ë¦¬ìê°€ ì—†ìŠµë‹ˆë‹¤
            </h3>
            <p className="text-sm text-gray-500">
              ìœ„ í¼ì„ ì‚¬ìš©í•˜ì—¬ ê´€ë¦¬ì ê³„ì •ì„ ìƒì„±í•˜ì„¸ìš”.
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full border-collapse">
        <thead>
          <tr className="border-b border-gray-200 bg-gray-50">
            <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">
              ì´ë©”ì¼
            </th>
            <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">
              ì—­í• 
            </th>
            <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">
              ê¸°ê´€
            </th>
            <th className="px-4 py-3 text-left text-sm font-semibold text-gray-700">
              ìƒì„±ì¼
            </th>
            <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">
              ì‘ì—…
            </th>
          </tr>
        </thead>
        <tbody>
          {adminUsers.map((adminUser) => (
            <tr
              key={adminUser.id}
              className="border-b border-gray-100 hover:bg-gray-50"
            >
              <td className="px-4 py-3 text-sm text-gray-900">
                {adminUser.email}
              </td>
              <td className="px-4 py-3 text-sm text-gray-600">
                <span
                  className={`inline-flex rounded-full px-2 py-1 text-xs font-medium ${
                    adminUser.role === "admin"
                      ? "bg-indigo-100 text-indigo-800"
                      : adminUser.role === "superadmin"
                      ? "bg-orange-100 text-orange-800"
                      : "bg-green-100 text-green-800"
                  }`}
                >
                  {adminUser.role === "admin"
                    ? "ê´€ë¦¬ì"
                    : adminUser.role === "superadmin"
                    ? "Super Admin"
                    : "ì»¨ì„¤í„´íŠ¸"}
                </span>
              </td>
              <td className="px-4 py-3 text-sm text-gray-600">
                {adminUser.tenant_name ? (
                  <span className="inline-flex items-center gap-1">
                    <span>ğŸ¢</span>
                    <span>{adminUser.tenant_name}</span>
                  </span>
                ) : (
                  <span className="text-gray-400">â€”</span>
                )}
              </td>
              <td className="px-4 py-3 text-sm text-gray-600">
                {new Date(adminUser.created_at).toLocaleDateString("ko-KR", {
                  year: "numeric",
                  month: "long",
                  day: "numeric",
                })}
              </td>
              <td className="px-4 py-3 text-right text-sm">
                <button
                  onClick={() => handleDelete(adminUser.id)}
                  disabled={isPending}
                  className="rounded-lg border border-red-300 bg-white px-3 py-1 text-sm font-medium text-red-700 transition hover:bg-red-50 disabled:opacity-50"
                >
                  ê¶Œí•œ ì œê±°
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="superadmin/admin-users/CreateAdminUserForm.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { createAdminUser } from "@/app/(admin)/actions/adminUserActions";

export function CreateAdminUserForm() {
  const [isPending, startTransition] = useTransition();
  const [userEmail, setUserEmail] = useState("");
  const [userRole, setUserRole] = useState<"admin" | "consultant">("admin");
  const router = useRouter();

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);

    startTransition(async () => {
      try {
        await createAdminUser(formData);
        router.refresh();
        setUserEmail("");
        alert("ê´€ë¦¬ì ê³„ì •ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } catch (error) {
        console.error("ê´€ë¦¬ì ê³„ì • ìƒì„± ì‹¤íŒ¨:", error);
        alert(
          error instanceof Error
            ? error.message
            : "ê´€ë¦¬ì ê³„ì • ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        );
      }
    });
  }

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-4">
      <div className="grid gap-4 md:grid-cols-2">
        {/* ì´ë©”ì¼ ì…ë ¥ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ì‚¬ìš©ì ì´ë©”ì¼ <span className="text-red-500">*</span>
          </label>
          <input
            type="email"
            name="user_email"
            required
            value={userEmail}
            onChange={(e) => setUserEmail(e.target.value)}
            placeholder="user@example.com"
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          />
          <p className="text-xs text-gray-500">
            ê´€ë¦¬ìë¡œ ìŠ¹ê²©í•  ì‚¬ìš©ìì˜ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”.
          </p>
        </div>

        {/* ì—­í•  ì„ íƒ */}
        <div className="flex flex-col gap-1">
          <label className="block text-sm font-medium text-gray-700">
            ì—­í•  <span className="text-red-500">*</span>
          </label>
          <select
            name="role"
            required
            value={userRole}
            onChange={(e) =>
              setUserRole(e.target.value as "admin" | "consultant")
            }
            className="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500"
          >
            <option value="admin">ê´€ë¦¬ì (Admin)</option>
            <option value="consultant">ì»¨ì„¤í„´íŠ¸ (Consultant)</option>
          </select>
          <p className="text-xs text-gray-500">
            ê´€ë¦¬ì: ëª¨ë“  ê¶Œí•œ, ì»¨ì„¤í„´íŠ¸: ìƒë‹´ ë° ì¡°íšŒ ê¶Œí•œ
          </p>
        </div>
      </div>

      {/* ë²„íŠ¼ */}
      <div className="flex gap-3">
        <button
          type="submit"
          disabled={isPending || !userEmail}
          className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
        >
          {isPending ? "ìƒì„± ì¤‘..." : "ê´€ë¦¬ì ê³„ì • ìƒì„±"}
        </button>
      </div>
    </form>
  );
}
</file>

<file path="superadmin/admin-users/page.tsx">
import Link from "next/link";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { AdminUsersList } from "./AdminUsersList";
import { CreateAdminUserForm } from "./CreateAdminUserForm";

export default async function SuperAdminUsersPage() {
  const { role, userId } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  // Admin Clientë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ê´€ë¦¬ì ì¡°íšŒ (RLS ìš°íšŒ)
  // Superadminì€ ëª¨ë“  í…Œë„ŒíŠ¸ì˜ ê´€ë¦¬ìë¥¼ ë³¼ ìˆ˜ ìˆì–´ì•¼ í•¨
  const adminClient = createSupabaseAdminClient();
  let adminUsers = null;
  let adminUsersError = null;

  if (!adminClient) {
    console.warn("[admin-users] Service Role Keyê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ê´€ë¦¬ì ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  } else {
    // Admin Clientë¡œ ëª¨ë“  ê´€ë¦¬ì ì¡°íšŒ (RLS ìš°íšŒ)
    const { data, error } = await adminClient
      .from("admin_users")
      .select("id, role, tenant_id, created_at")
      .order("created_at", { ascending: false });

    adminUsers = data;
    adminUsersError = error;

    if (adminUsersError) {
      console.error("[admin-users] ê´€ë¦¬ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", adminUsersError);
    }
  }

  // Admin Clientë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° Server Clientë¡œ ì‹œë„ (Superadminì€ ëª¨ë“  ë°ì´í„° ì ‘ê·¼ ê°€ëŠ¥í•´ì•¼ í•¨)
  if (!adminClient || adminUsersError) {
    const supabase = await createSupabaseServerClient();
    const { data, error } = await supabase
      .from("admin_users")
      .select("id, role, tenant_id, created_at")
      .order("created_at", { ascending: false });

    if (!adminUsers) {
      adminUsers = data;
    }
    if (error && !adminUsersError) {
      adminUsersError = error;
      console.error("[admin-users] ê´€ë¦¬ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨ (Server Client):", error);
    }
  }

  // ëª¨ë“  ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ (ì´ë©”ì¼ ë§¤ì¹­ìš©) - Service Role Key í•„ìš”
  let allUsersData = null;
  try {
    const clientForUsers = adminClient || createSupabaseAdminClient();
    if (!clientForUsers) {
      console.warn("[admin-users] Service Role Keyê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ì´ë©”ì¼ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    } else {
      const { data, error: allUsersError } = await clientForUsers.auth.admin.listUsers();

      if (allUsersError) {
        console.error("[admin-users] ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", allUsersError);
      } else {
        allUsersData = data;
      }
    }
  } catch (error) {
    console.error("[admin-users] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨:", error);
    // Service Role Keyê°€ ì—†ì–´ë„ ê´€ë¦¬ì ëª©ë¡ì€ í‘œì‹œ ê°€ëŠ¥ (ì´ë©”ì¼ë§Œ ì—†ìŒ)
  }

  // ê¸°ê´€ ì •ë³´ ì¡°íšŒ (tenant_id ëª©ë¡ ìˆ˜ì§‘)
  const tenantIds = Array.from(
    new Set(
      (adminUsers || [])
        .map((au: any) => au.tenant_id)
        .filter((tid: string | null) => tid !== null && tid !== undefined)
    )
  );

  // ê¸°ê´€ ì •ë³´ ì¡°íšŒ (tenant_idê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ)
  let tenantMap = new Map<string, string>();
  if (tenantIds.length > 0) {
    // Admin Clientë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ê´€ ì •ë³´ ì¡°íšŒ (RLS ìš°íšŒ)
    const clientForTenants = adminClient || createSupabaseAdminClient();
    if (clientForTenants) {
      const { data: tenants } = await clientForTenants
        .from("tenants")
        .select("id, name")
        .in("id", tenantIds);

      if (tenants) {
        tenantMap = new Map(tenants.map((t) => [t.id, t.name]));
      }
    } else {
      // Admin Clientë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° Server Clientë¡œ ì‹œë„
      const supabase = await createSupabaseServerClient();
      const { data: tenants } = await supabase
        .from("tenants")
        .select("id, name")
        .in("id", tenantIds);

      if (tenants) {
        tenantMap = new Map(tenants.map((t) => [t.id, t.name]));
      }
    }
  }

  // ê´€ë¦¬ì ëª©ë¡ì— ì´ë©”ì¼ ë° ê¸°ê´€ ì •ë³´ ì¶”ê°€
  const adminUsersWithEmail =
    adminUsers?.map((adminUser: any) => {
      const user = allUsersData?.users.find((u) => u.id === adminUser.id);
      const tenantId = adminUser.tenant_id;
      const tenantName = tenantId ? tenantMap.get(tenantId) : null;

      return {
        ...adminUser,
        email: user?.email || "ì´ë©”ì¼ ì—†ìŒ",
        tenant_id: tenantId || null,
        tenant_name: tenantName || null,
      };
    }) || [];

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-500">ì‹œìŠ¤í…œ ê´€ë¦¬</p>
            <h1 className="text-3xl font-semibold text-gray-900">
              ê´€ë¦¬ì ê³„ì • ê´€ë¦¬
            </h1>
            <p className="text-sm text-gray-500">
              ê´€ë¦¬ì ê³„ì •ì„ ìƒì„±í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/superadmin/dashboard"
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
          >
            ëŒ€ì‹œë³´ë“œë¡œ
          </Link>
        </div>

        {/* ê´€ë¦¬ì ê³„ì • ìƒì„± í¼ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900">
            ê´€ë¦¬ì ê³„ì • ìƒì„±
          </h2>
          <CreateAdminUserForm />
        </div>

        {/* ê´€ë¦¬ì ëª©ë¡ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900">
            ê´€ë¦¬ì ëª©ë¡
          </h2>
          <AdminUsersList adminUsers={adminUsersWithEmail} />
        </div>
      </div>
    </section>
  );
}
</file>

<file path="superadmin/curriculum-settings/_components/CurriculumSettingsForm.tsx">
"use client";

import { useState, useEffect } from "react";
import {
  getCurriculumSettings,
  updateCurriculumSettings,
  type CurriculumSettingsData,
} from "@/app/(superadmin)/actions/curriculumSettingsActions";

export function CurriculumSettingsForm() {
  const [settings, setSettings] = useState<CurriculumSettingsData>({
    middle_2022: 2025,
    high_2022: 2025,
    middle_2015: 2018,
    high_2015: 2018,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  // ì„¤ì • ë¡œë“œ
  useEffect(() => {
    async function loadSettings() {
      setIsLoading(true);
      setError(null);
      try {
        const result = await getCurriculumSettings();
        if (result.success && result.data) {
          setSettings(result.data);
        } else {
          setError(result.error || "ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        );
      } finally {
        setIsLoading(false);
      }
    }
    loadSettings();
  }, []);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSaving(true);
    setError(null);
    setSuccess(false);

    try {
      const formData = new FormData(e.currentTarget);
      const result = await updateCurriculumSettings(formData);

      if (result.success) {
        setSuccess(true);
        // ì„±ê³µ ë©”ì‹œì§€ 3ì´ˆ í›„ ìë™ ì œê±°
        setTimeout(() => setSuccess(false), 3000);
      } else {
        setError(result.error || "ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
      );
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-800 p-6 shadow-sm">
        <div className="text-center text-gray-600 dark:text-gray-400">
          ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
        </div>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-6">
      {error && (
        <div className="rounded-lg border border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/20 p-4 text-red-800 dark:text-red-200">
          {error}
        </div>
      )}

      {success && (
        <div className="rounded-lg border border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-900/20 p-4 text-green-800 dark:text-green-200">
          ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.
        </div>
      )}

      <div className="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-800 p-6 shadow-sm flex flex-col gap-4">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
          2022ê°œì • êµìœ¡ê³¼ì •
        </h3>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="flex flex-col gap-1">
            <label
              htmlFor="middle_2022"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              ì¤‘í•™êµ ì‹œì‘ë…„ë„
            </label>
            <input
              type="number"
              id="middle_2022"
              name="middle_2022"
              value={settings.middle_2022}
              onChange={(e) =>
                setSettings({
                  ...settings,
                  middle_2022: parseInt(e.target.value, 10) || 2025,
                })
              }
              min="2000"
              max="2100"
              required
              className="w-full rounded-md border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-500 dark:placeholder:text-gray-400 focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400"
            />
          </div>
          <div className="flex flex-col gap-1">
            <label
              htmlFor="high_2022"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              ê³ ë“±í•™êµ ì‹œì‘ë…„ë„
            </label>
            <input
              type="number"
              id="high_2022"
              name="high_2022"
              value={settings.high_2022}
              onChange={(e) =>
                setSettings({
                  ...settings,
                  high_2022: parseInt(e.target.value, 10) || 2025,
                })
              }
              min="2000"
              max="2100"
              required
              className="w-full rounded-md border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-500 dark:placeholder:text-gray-400 focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400"
            />
          </div>
        </div>
      </div>

      <div className="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-800 p-6 shadow-sm flex flex-col gap-4">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
          2015ê°œì • êµìœ¡ê³¼ì •
        </h3>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="flex flex-col gap-1">
            <label
              htmlFor="middle_2015"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              ì¤‘í•™êµ ì‹œì‘ë…„ë„
            </label>
            <input
              type="number"
              id="middle_2015"
              name="middle_2015"
              value={settings.middle_2015}
              onChange={(e) =>
                setSettings({
                  ...settings,
                  middle_2015: parseInt(e.target.value, 10) || 2018,
                })
              }
              min="2000"
              max="2100"
              required
              className="w-full rounded-md border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-500 dark:placeholder:text-gray-400 focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400"
            />
          </div>
          <div className="flex flex-col gap-1">
            <label
              htmlFor="high_2015"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300"
            >
              ê³ ë“±í•™êµ ì‹œì‘ë…„ë„
            </label>
            <input
              type="number"
              id="high_2015"
              name="high_2015"
              value={settings.high_2015}
              onChange={(e) =>
                setSettings({
                  ...settings,
                  high_2015: parseInt(e.target.value, 10) || 2018,
                })
              }
              min="2000"
              max="2100"
              required
              className="w-full rounded-md border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-500 dark:placeholder:text-gray-400 focus:border-blue-500 dark:focus:border-blue-400 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400"
            />
          </div>
        </div>
      </div>

      <div className="flex justify-end gap-3">
        <button
          type="submit"
          disabled={isSaving}
          className="rounded-md bg-blue-600 dark:bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 dark:hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
        >
          {isSaving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
        </button>
      </div>
    </form>
  );
}
</file>

<file path="superadmin/curriculum-settings/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { CurriculumSettingsForm } from "./_components/CurriculumSettingsForm";

export default async function CurriculumSettingsPage() {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  return (
    <div className="bg-white dark:bg-gray-900 p-6 md:p-10 flex flex-col gap-8">
      <div className="flex flex-col gap-2">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-gray-100">êµìœ¡ê³¼ì • ì„¤ì •</h1>
        <p className="text-sm text-gray-600 dark:text-gray-400">
          êµìœ¡ê³¼ì • ê³„ì‚° ê¸°ì¤€ì„ ì„¤ì •í•©ë‹ˆë‹¤. ì¤‘í•™êµì™€ ê³ ë“±í•™êµì˜ ê° ê°œì •êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </p>
      </div>

      <div className="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-800 p-6 shadow-sm flex flex-col gap-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">ê°œì •êµìœ¡ê³¼ì • ì‹œì‘ë…„ë„</h2>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            í•™ìƒì˜ í•™ë…„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìë™ìœ¼ë¡œ êµìœ¡ê³¼ì •ì„ ê³„ì‚°í•  ë•Œ ì‚¬ìš©ë˜ëŠ” ê¸°ì¤€ë…„ë„ì…ë‹ˆë‹¤.
          </p>
        </div>

        <CurriculumSettingsForm />
      </div>

      <div className="rounded-lg border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 p-4 flex flex-col gap-2">
        <h3 className="text-sm font-semibold text-blue-900 dark:text-blue-100">ì„¤ì • ì•ˆë‚´</h3>
        <ul className="flex flex-col gap-1 text-sm text-blue-800 dark:text-blue-200">
          <li>â€¢ 2015ê°œì • êµìœ¡ê³¼ì •: 2018ë…„ ì¤‘1, ê³ 1 ë™ì‹œ ì‹œì‘</li>
          <li>â€¢ 2022ê°œì • êµìœ¡ê³¼ì •: 2025ë…„ ì¤‘1, ê³ 1 ë™ì‹œ ì‹œì‘</li>
          <li>â€¢ ì„¤ì • ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜ë˜ë©°, ê¸°ì¡´ í•™ìƒ ë°ì´í„°ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.</li>
          <li>â€¢ ìƒˆë¡œìš´ í•™ìƒ ì •ë³´ ì…ë ¥ ì‹œ ë³€ê²½ëœ ê¸°ì¤€ìœ¼ë¡œ êµìœ¡ê³¼ì •ì´ ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.</li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/dashboard/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import Link from "next/link";
import {
  getTenantStatistics,
  getUserStatistics,
  getRecentTenants,
} from "@/lib/data/superadminDashboard";

export default async function SuperAdminDashboardPage() {
  const { userId, role } = await getCurrentUserRole();

  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  // í†µê³„ ë°ì´í„° ì¡°íšŒ
  const [tenantStats, userStats, recentTenants] = await Promise.all([
    getTenantStatistics(),
    getUserStatistics(),
    getRecentTenants(5),
  ]);

  return (
    <div className="p-6 md:p-10 flex flex-col gap-8">
      <h1 className="text-3xl font-bold text-gray-900">Super Admin ëŒ€ì‹œë³´ë“œ</h1>

      {/* ê¸°ê´€ í†µê³„ ì¹´ë“œ */}
      <div className="flex flex-col gap-4">
        <h2 className="text-xl font-semibold text-gray-900">ê¸°ê´€ í†µê³„</h2>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4">
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ì „ì²´ ê¸°ê´€ ìˆ˜</div>
            <div className="text-3xl font-bold text-gray-900">{tenantStats.total}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">í™œì„± ê¸°ê´€</div>
            <div className="text-3xl font-bold text-green-600">{tenantStats.active}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ë¹„í™œì„± ê¸°ê´€</div>
            <div className="text-3xl font-bold text-gray-600">{tenantStats.inactive}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ì •ì§€ëœ ê¸°ê´€</div>
            <div className="text-3xl font-bold text-red-600">{tenantStats.suspended}</div>
          </div>
        </div>
      </div>

      {/* ì‚¬ìš©ì í†µê³„ ì¹´ë“œ */}
      <div className="flex flex-col gap-4">
        <h2 className="text-xl font-semibold text-gray-900">ì‚¬ìš©ì í†µê³„</h2>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-6">
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">í•™ìƒ</div>
            <div className="text-3xl font-bold text-blue-600">{userStats.students}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">í•™ë¶€ëª¨</div>
            <div className="text-3xl font-bold text-purple-600">{userStats.parents}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ê´€ë¦¬ì</div>
            <div className="text-3xl font-bold text-indigo-600">{userStats.admins}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ì»¨ì„¤í„´íŠ¸</div>
            <div className="text-3xl font-bold text-cyan-600">{userStats.consultants}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">Super Admin</div>
            <div className="text-3xl font-bold text-orange-600">{userStats.superadmins}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm text-gray-500">ì „ì²´ ì‚¬ìš©ì</div>
            <div className="text-3xl font-bold text-gray-900">{userStats.total}</div>
          </div>
        </div>
      </div>

      {/* ìµœê·¼ ìƒì„±ëœ ê¸°ê´€ */}
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold text-gray-900">ìµœê·¼ ìƒì„±ëœ ê¸°ê´€</h2>
          <Link
            href="/superadmin/tenants"
            className="text-sm font-medium text-indigo-600 hover:text-indigo-700"
          >
            ì „ì²´ ë³´ê¸° â†’
          </Link>
        </div>
        {recentTenants.length === 0 ? (
          <p className="text-sm text-gray-500">ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤.</p>
        ) : (
          <div className="flex flex-col gap-3">
            {recentTenants.map((tenant) => (
              <div
                key={tenant.id}
                className="flex items-center justify-between rounded-lg border border-gray-100 p-4 hover:bg-gray-50"
              >
                <div>
                  <div className="font-medium text-gray-900">{tenant.name}</div>
                  <div className="text-sm text-gray-500">
                    {tenant.type === "academy"
                      ? "í•™ì›"
                      : tenant.type === "school"
                      ? "í•™êµ"
                      : tenant.type === "enterprise"
                      ? "ê¸°ì—…"
                      : "ê¸°íƒ€"}
                    {" Â· "}
                    {new Date(tenant.created_at).toLocaleDateString("ko-KR")}
                  </div>
                </div>
                <Link
                  href={`/superadmin/tenants`}
                  className="text-sm font-medium text-indigo-600 hover:text-indigo-700"
                >
                  ê´€ë¦¬ â†’
                </Link>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* ë¹ ë¥¸ ì•¡ì…˜ */}
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
        <h2 className="text-xl font-semibold text-gray-900">ë¹ ë¥¸ ì•¡ì…˜</h2>
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4">
          <Link
            href="/superadmin/tenants"
            className="rounded-lg border border-gray-200 p-4 transition hover:bg-gray-50 flex flex-col gap-1"
          >
            <div className="font-medium text-gray-900">ê¸°ê´€ ê´€ë¦¬</div>
            <div className="text-sm text-gray-600">ê¸°ê´€ ì¶”ê°€, ìˆ˜ì •, ì‚­ì œ</div>
          </Link>
          <Link
            href="/superadmin/admin-users"
            className="rounded-lg border border-gray-200 p-4 transition hover:bg-gray-50 flex flex-col gap-1"
          >
            <div className="font-medium text-gray-900">ê´€ë¦¬ì ê³„ì •</div>
            <div className="text-sm text-gray-600">ê´€ë¦¬ì ê³„ì • ìƒì„± ë° ê´€ë¦¬</div>
          </Link>
          <Link
            href="/superadmin/unverified-users"
            className="rounded-lg border border-gray-200 p-4 transition hover:bg-gray-50 flex flex-col gap-1"
          >
            <div className="font-medium text-gray-900">ë¯¸ì¸ì¦ ê°€ì… ê´€ë¦¬</div>
            <div className="text-sm text-gray-600">ë¯¸ì¸ì¦ ì‚¬ìš©ì í™•ì¸ ë° ì²˜ë¦¬</div>
          </Link>
          <Link
            href="/superadmin/tenantless-users"
            className="rounded-lg border border-gray-200 p-4 transition hover:bg-gray-50 flex flex-col gap-1"
          >
            <div className="font-medium text-gray-900">í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì</div>
            <div className="text-sm text-gray-600">í…Œë„ŒíŠ¸ê°€ í• ë‹¹ë˜ì§€ ì•Šì€ ì‚¬ìš©ì ê´€ë¦¬</div>
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/settings/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getAdminById } from "@/lib/data/admins";

export default async function SuperAdminSettingsPage() {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  const supabase = await createSupabaseServerClient();

  // í˜„ì¬ ê´€ë¦¬ì ì •ë³´ ì¡°íšŒ
  const currentAdmin = await getAdminById(userId, null);

  return (
    <div className="p-6 md:p-10 flex flex-col gap-8">
      <div className="flex flex-col gap-2">
        <h1 className="text-3xl font-bold text-gray-900">Super Admin ì„¤ì •</h1>
        <p className="text-sm text-gray-600">ì‹œìŠ¤í…œ ê´€ë¦¬ ì„¤ì •</p>
      </div>

      <div className="flex flex-col gap-6">
        {/* í˜„ì¬ ê³„ì • ì •ë³´ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
          <h2 className="text-xl font-semibold text-gray-900">í˜„ì¬ ê³„ì • ì •ë³´</h2>
          <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
            <div className="flex flex-col gap-1">
              <div className="text-sm text-gray-500">ì—­í• </div>
              <div className="text-lg font-medium text-gray-900">Super Admin</div>
            </div>
            <div className="flex flex-col gap-1">
              <div className="text-sm text-gray-500">ê³„ì • ID</div>
              <div className="text-lg font-medium text-gray-900">{userId}</div>
            </div>
          </div>
        </div>

        {/* ì‹œìŠ¤í…œ ê´€ë¦¬ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
          <h2 className="text-xl font-semibold text-gray-900">ì‹œìŠ¤í…œ ê´€ë¦¬</h2>
          <p className="text-sm text-gray-600">
            Super Adminì€ ì „ì²´ ì‹œìŠ¤í…œì„ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/tenantless-users/_components/AssignTenantDialog.tsx">
"use client";

import { useState, useTransition, useEffect } from "react";
import { assignTenantToUser, assignTenantToMultipleUsers, getActiveTenants, type TenantlessUser } from "@/app/(superadmin)/actions/tenantlessUserActions";
import { Dialog } from "@/components/ui/Dialog";

type AssignTenantDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  userId: string | null; // nullì´ë©´ ì¼ê´„ í• ë‹¹ ëª¨ë“œ
  userType: "student" | "parent" | "admin" | null;
  selectedUserIds: string[] | null; // ì¼ê´„ í• ë‹¹ ì‹œ ì‚¬ìš©
  users: TenantlessUser[]; // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒìš©
  onComplete: () => void;
};

export function AssignTenantDialog({
  open,
  onOpenChange,
  userId,
  userType,
  selectedUserIds,
  users,
  onComplete,
}: AssignTenantDialogProps) {
  const [isPending, startTransition] = useTransition();
  const [tenants, setTenants] = useState<Array<{ id: string; name: string }>>([]);
  const [selectedTenantId, setSelectedTenantId] = useState<string>("");
  const [loadingTenants, setLoadingTenants] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // ë‹¤ì´ì–¼ë¡œê·¸ê°€ ì—´ë¦´ ë•Œ í…Œë„ŒíŠ¸ ëª©ë¡ ë¡œë“œ
  useEffect(() => {
    if (open) {
      setLoadingTenants(true);
      setError(null);
      getActiveTenants()
        .then((result) => {
          if (result.success && result.data) {
            setTenants(result.data);
            const firstTenant = result.data[0];
            if (firstTenant?.id) {
              setSelectedTenantId(firstTenant.id);
            }
          } else {
            setError(result.error || "í…Œë„ŒíŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          }
        })
        .catch((err) => {
          console.error("[AssignTenantDialog] í…Œë„ŒíŠ¸ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨", err);
          setError("í…Œë„ŒíŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        })
        .finally(() => {
          setLoadingTenants(false);
        });
    } else {
      // ë‹¤ì´ì–¼ë¡œê·¸ê°€ ë‹«í ë•Œ ìƒíƒœ ì´ˆê¸°í™”
      setSelectedTenantId("");
      setError(null);
    }
  }, [open]);

  const handleSubmit = () => {
    if (!selectedTenantId) {
      setError("í…Œë„ŒíŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    startTransition(async () => {
      try {
        let result;

        if (userId && userType) {
          // ë‹¨ì¼ ì‚¬ìš©ì í• ë‹¹
          result = await assignTenantToUser(userId, selectedTenantId, userType);
        } else if (selectedUserIds && selectedUserIds.length > 0) {
          // ë‹¤ì¤‘ ì‚¬ìš©ì í• ë‹¹
          const userData = users
            .filter((u) => selectedUserIds.includes(u.id))
            .map((u) => ({ userId: u.id, userType: u.userType }));

          if (userData.length === 0) {
            setError("ì„ íƒëœ ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
          }

          result = await assignTenantToMultipleUsers(userData, selectedTenantId);
        } else {
          setError("í• ë‹¹í•  ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        if (result.success) {
          onComplete();
          onOpenChange(false);
          alert(
            userId
              ? "í…Œë„ŒíŠ¸ê°€ í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤."
              : `${(result as { assignedCount?: number }).assignedCount || 0}ëª…ì˜ ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ê°€ í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤.`
          );
        } else {
          setError(result.error || "í…Œë„ŒíŠ¸ í• ë‹¹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
      } catch (err) {
        console.error("[AssignTenantDialog] í…Œë„ŒíŠ¸ í• ë‹¹ ì‹¤íŒ¨", err);
        setError(err instanceof Error ? err.message : "í…Œë„ŒíŠ¸ í• ë‹¹ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  const isBulkMode = !userId && selectedUserIds && selectedUserIds.length > 0;
  const targetUser = userId ? users.find((u) => u.id === userId) : null;

  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title={isBulkMode ? "ì¼ê´„ í…Œë„ŒíŠ¸ í• ë‹¹" : "í…Œë„ŒíŠ¸ í• ë‹¹"}
      description={
        isBulkMode
          ? `ì„ íƒí•œ ${selectedUserIds?.length || 0}ëª…ì˜ ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.`
          : targetUser
          ? `${targetUser.email} (${targetUser.name || "ì´ë¦„ ì—†ìŒ"}) ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.`
          : "ì‚¬ìš©ìì— í…Œë„ŒíŠ¸ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤."
      }
      maxWidth="md"
    >
      <div className="flex flex-col gap-4">
        {loadingTenants ? (
          <div className="py-4 text-center text-sm text-gray-500">í…Œë„ŒíŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
        ) : error && !tenants.length ? (
          <div className="rounded-lg border border-red-200 bg-red-50 p-4 text-sm text-red-800">
            {error}
          </div>
        ) : tenants.length === 0 ? (
          <div className="rounded-lg border border-yellow-200 bg-yellow-50 p-4 text-sm text-yellow-800">
            ë“±ë¡ëœ í…Œë„ŒíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í…Œë„ŒíŠ¸ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.
          </div>
        ) : (
          <>
            <div className="flex flex-col gap-1">
              <label className="block text-sm font-medium text-gray-700">í…Œë„ŒíŠ¸ ì„ íƒ</label>
              <select
                value={selectedTenantId}
                onChange={(e) => setSelectedTenantId(e.target.value)}
                className="w-full rounded-lg border border-gray-300 px-4 py-2 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
                disabled={isPending}
              >
                {tenants.map((tenant) => (
                  <option key={tenant.id} value={tenant.id}>
                    {tenant.name}
                  </option>
                ))}
              </select>
            </div>

            {error && (
              <div className="rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-800">
                {error}
              </div>
            )}

            <div className="flex justify-end gap-2">
              <button
                onClick={() => onOpenChange(false)}
                disabled={isPending}
                className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50 disabled:opacity-50"
              >
                ì·¨ì†Œ
              </button>
              <button
                onClick={handleSubmit}
                disabled={isPending || !selectedTenantId}
                className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
              >
                {isPending ? "í• ë‹¹ ì¤‘..." : "í• ë‹¹í•˜ê¸°"}
              </button>
            </div>
          </>
        )}
      </div>
    </Dialog>
  );
}
</file>

<file path="superadmin/tenantless-users/_components/TenantlessUsersList.tsx">
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
import { assignTenantToUser, assignTenantToMultipleUsers, type TenantlessUser } from "@/app/(superadmin)/actions/tenantlessUserActions";
import { AssignTenantDialog } from "./AssignTenantDialog";

type TenantlessUsersListProps = {
  users: TenantlessUser[];
  searchQuery: string;
  userTypeFilter: "student" | "parent" | "admin" | "all";
  currentPage: number;
  totalPages: number;
  totalCount: number;
};

export function TenantlessUsersList({
  users,
  searchQuery,
  userTypeFilter,
  currentPage,
  totalPages,
  totalCount,
}: TenantlessUsersListProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [selectedUsers, setSelectedUsers] = useState<Set<string>>(new Set());
  const [assignDialogOpen, setAssignDialogOpen] = useState(false);
  const [assigningUserId, setAssigningUserId] = useState<string | null>(null);
  const [assigningUserType, setAssigningUserType] = useState<"student" | "parent" | "admin" | null>(null);
  const [actionMessage, setActionMessage] = useState<string | null>(null);

  const handleSelectAll = () => {
    if (selectedUsers.size === users.length) {
      setSelectedUsers(new Set());
    } else {
      setSelectedUsers(new Set(users.map((u) => u.id)));
    }
  };

  const handleToggleSelect = (userId: string) => {
    const newSelected = new Set(selectedUsers);
    if (newSelected.has(userId)) {
      newSelected.delete(userId);
    } else {
      newSelected.add(userId);
    }
    setSelectedUsers(newSelected);
  };

  const handleAssignTenant = (userId: string, userType: "student" | "parent" | "admin") => {
    setAssigningUserId(userId);
    setAssigningUserType(userType);
    setAssignDialogOpen(true);
  };

  const handleBulkAssignTenant = () => {
    if (selectedUsers.size === 0) {
      alert("í…Œë„ŒíŠ¸ë¥¼ í• ë‹¹í•  ì‚¬ìš©ìë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    // ì„ íƒëœ ì‚¬ìš©ìë“¤ì˜ íƒ€ì… ì •ë³´ ìˆ˜ì§‘
    const selectedUserData = users
      .filter((u) => selectedUsers.has(u.id))
      .map((u) => ({ userId: u.id, userType: u.userType }));

    if (selectedUserData.length === 0) {
      alert("ì„ íƒëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    setAssigningUserId(null); // nullì´ë©´ ì¼ê´„ í• ë‹¹ ëª¨ë“œ
    setAssignDialogOpen(true);
  };

  const handleAssignComplete = () => {
    setAssignDialogOpen(false);
    setAssigningUserId(null);
    setAssigningUserType(null);
    setSelectedUsers(new Set());
    router.refresh();
  };

  if (actionMessage) {
    setTimeout(() => setActionMessage(null), 3000);
  }

  // URL íŒŒë¼ë¯¸í„° ìƒì„± í—¬í¼
  const buildUrl = (page: number, search?: string, type?: string) => {
    const params = new URLSearchParams();
    if (page > 1) params.set("page", page.toString());
    if (search) params.set("search", search);
    if (type && type !== "all") params.set("type", type);
    return `/superadmin/tenantless-users${params.toString() ? `?${params.toString()}` : ""}`;
  };

  return (
    <div className="space-y-4">
      {/* ê²€ìƒ‰ ë° í•„í„° */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <form method="get" className="flex flex-1 gap-2">
          <input
            type="text"
            name="search"
            placeholder="ì´ë©”ì¼ ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰..."
            defaultValue={searchQuery}
            className="flex-1 rounded-lg border border-gray-300 px-4 py-2 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
          />
          <input type="hidden" name="type" value={userTypeFilter} />
          <button
            type="submit"
            className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700"
          >
            ê²€ìƒ‰
          </button>
        </form>
        <div className="flex gap-2">
          {/* íƒ€ì… í•„í„° */}
          <div className="flex rounded-lg border border-gray-300 bg-white">
            <a
              href={buildUrl(1, searchQuery || undefined, "all")}
              className={`px-4 py-2 text-sm font-medium transition ${
                userTypeFilter === "all"
                  ? "bg-indigo-600 text-white"
                  : "text-gray-700 hover:bg-gray-50"
              }`}
            >
              ì „ì²´
            </a>
            <a
              href={buildUrl(1, searchQuery || undefined, "student")}
              className={`px-4 py-2 text-sm font-medium transition ${
                userTypeFilter === "student"
                  ? "bg-indigo-600 text-white"
                  : "text-gray-700 hover:bg-gray-50"
              }`}
            >
              í•™ìƒ
            </a>
            <a
              href={buildUrl(1, searchQuery || undefined, "parent")}
              className={`px-4 py-2 text-sm font-medium transition ${
                userTypeFilter === "parent"
                  ? "bg-indigo-600 text-white"
                  : "text-gray-700 hover:bg-gray-50"
              }`}
            >
              í•™ë¶€ëª¨
            </a>
            <a
              href={buildUrl(1, searchQuery || undefined, "admin")}
              className={`px-4 py-2 text-sm font-medium transition ${
                userTypeFilter === "admin"
                  ? "bg-indigo-600 text-white"
                  : "text-gray-700 hover:bg-gray-50"
              }`}
            >
              ê´€ë¦¬ì
            </a>
          </div>
          {/* ì¼ê´„ í• ë‹¹ ë²„íŠ¼ */}
          {selectedUsers.size > 0 && (
            <button
              onClick={handleBulkAssignTenant}
              disabled={isPending}
              className="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-indigo-700 disabled:opacity-50"
            >
              {isPending ? "ì²˜ë¦¬ ì¤‘..." : `ì„ íƒí•œ ${selectedUsers.size}ëª… í• ë‹¹`}
            </button>
          )}
        </div>
      </div>

      {actionMessage && (
        <div className="rounded-lg bg-green-50 px-4 py-2 text-sm text-green-700">
          {actionMessage}
        </div>
      )}

      {/* ì‚¬ìš©ì ëª©ë¡ */}
      {users.length === 0 ? (
        <div className="py-12 text-center text-gray-500">
          {searchQuery
            ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."
            : "í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤."}
        </div>
      ) : (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left">
                  <input
                    type="checkbox"
                    checked={selectedUsers.size === users.length && users.length > 0}
                    onChange={handleSelectAll}
                    className="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                  />
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì´ë©”ì¼
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì´ë¦„
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì—­í• 
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ê°€ì…ì¼
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì‘ì—…
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 bg-white">
              {users.map((user) => (
                <tr key={user.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4">
                    <input
                      type="checkbox"
                      checked={selectedUsers.has(user.id)}
                      onChange={() => handleToggleSelect(user.id)}
                      className="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900">
                    {user.email || "ì´ë©”ì¼ ì—†ìŒ"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    {user.name || "-"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    <span
                      className={`inline-flex rounded-full px-2 py-1 text-xs font-medium ${
                        user.role === "student"
                          ? "bg-blue-100 text-blue-800"
                          : user.role === "parent"
                          ? "bg-purple-100 text-purple-800"
                          : user.role === "admin"
                          ? "bg-indigo-100 text-indigo-800"
                          : "bg-cyan-100 text-cyan-800"
                      }`}
                    >
                      {user.role === "student"
                        ? "í•™ìƒ"
                        : user.role === "parent"
                        ? "í•™ë¶€ëª¨"
                        : user.role === "admin"
                        ? "ê´€ë¦¬ì"
                        : "ì»¨ì„¤í„´íŠ¸"}
                    </span>
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    {user.created_at
                      ? new Date(user.created_at).toLocaleDateString("ko-KR")
                      : "-"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    <button
                      onClick={() => handleAssignTenant(user.id, user.userType)}
                      disabled={isPending}
                      className="rounded-lg bg-indigo-100 px-3 py-1.5 text-xs font-semibold text-indigo-800 transition hover:bg-indigo-200 disabled:opacity-50"
                    >
                      í…Œë„ŒíŠ¸ í• ë‹¹
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* í˜ì´ì§€ë„¤ì´ì…˜ */}
      {totalPages > 1 && (
        <div className="flex items-center justify-center gap-2">
          {currentPage > 1 && (
            <a
              href={buildUrl(currentPage - 1, searchQuery || undefined, userTypeFilter)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì´ì „
            </a>
          )}
          <span className="text-sm text-gray-600">
            {currentPage} / {totalPages} (ì´ {totalCount}ëª…)
          </span>
          {currentPage < totalPages && (
            <a
              href={buildUrl(currentPage + 1, searchQuery || undefined, userTypeFilter)}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ë‹¤ìŒ
            </a>
          )}
        </div>
      )}

      {/* í…Œë„ŒíŠ¸ í• ë‹¹ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <AssignTenantDialog
        open={assignDialogOpen}
        onOpenChange={setAssignDialogOpen}
        userId={assigningUserId}
        userType={assigningUserType}
        selectedUserIds={assigningUserId ? null : Array.from(selectedUsers)}
        users={users}
        onComplete={handleAssignComplete}
      />
    </div>
  );
}
</file>

<file path="superadmin/tenantless-users/page.tsx">
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getTenantlessUsers } from "@/app/(superadmin)/actions/tenantlessUserActions";
import { TenantlessUsersList } from "./_components/TenantlessUsersList";
import Link from "next/link";

export const dynamic = "force-dynamic";

export default async function TenantlessUsersPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const { role, userId } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  const params = await searchParams;
  const searchQuery = params.search?.trim() ?? "";
  const userTypeFilter = (params.type as "student" | "parent" | "admin" | "all") || "all";
  const page = parseInt(params.page || "1", 10);
  const pageSize = 20;

  // í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì ì¡°íšŒ
  const result = await getTenantlessUsers(userTypeFilter === "all" ? undefined : userTypeFilter);

  if (!result.success || !result.data) {
    return (
      <section className="mx-auto w-full max-w-6xl px-4 py-10">
        <div className="flex flex-col gap-8">
          <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
            <div>
              <p className="text-sm font-medium text-gray-500">ì‹œìŠ¤í…œ ê´€ë¦¬</p>
              <h1 className="text-3xl font-semibold text-gray-900">í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì ê´€ë¦¬</h1>
              <p className="text-sm text-gray-500">
                í…Œë„ŒíŠ¸ê°€ í• ë‹¹ë˜ì§€ ì•Šì€ ì‚¬ìš©ìë“¤ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </p>
            </div>
            <Link
              href="/superadmin/dashboard"
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
            >
              ëŒ€ì‹œë³´ë“œë¡œ
            </Link>
          </div>

          <div className="rounded-lg border border-red-200 bg-red-50 p-6 shadow-sm flex flex-col gap-2">
            <h3 className="text-lg font-semibold text-red-900">ì˜¤ë¥˜ ë°œìƒ</h3>
            <p className="text-sm text-red-800">{result.error || "ì‚¬ìš©ì ëª©ë¡ì„ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}</p>
          </div>
        </div>
      </section>
    );
  }

  let users = result.data;

  // ê²€ìƒ‰ í•„í„° ì ìš©
  if (searchQuery) {
    users = users.filter(
      (user) =>
        user.email?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        user.name?.toLowerCase().includes(searchQuery.toLowerCase())
    );
  }

  const totalCount = users.length;

  // í˜ì´ì§€ë„¤ì´ì…˜
  const from = (page - 1) * pageSize;
  const to = from + pageSize;
  const paginatedUsers = users.slice(from, to);
  const totalPages = Math.ceil(totalCount / pageSize);

  // í†µê³„ ê³„ì‚°
  const stats = {
    total: users.length,
    students: users.filter((u) => u.userType === "student").length,
    parents: users.filter((u) => u.userType === "parent").length,
    admins: users.filter((u) => u.userType === "admin").length,
  };

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-500">ì‹œìŠ¤í…œ ê´€ë¦¬</p>
            <h1 className="text-3xl font-semibold text-gray-900">í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì ê´€ë¦¬</h1>
            <p className="text-sm text-gray-500">
              í…Œë„ŒíŠ¸ê°€ í• ë‹¹ë˜ì§€ ì•Šì€ ì‚¬ìš©ìë“¤ì„ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/superadmin/dashboard"
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
          >
            ëŒ€ì‹œë³´ë“œë¡œ
          </Link>
        </div>

        {/* í†µê³„ */}
        <div className="grid gap-4 md:grid-cols-4">
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm font-medium text-gray-500">ì „ì²´ ì‚¬ìš©ì</div>
            <div className="text-3xl font-bold text-gray-900">{stats.total}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm font-medium text-gray-500">í•™ìƒ</div>
            <div className="text-3xl font-bold text-blue-600">{stats.students}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm font-medium text-gray-500">í•™ë¶€ëª¨</div>
            <div className="text-3xl font-bold text-purple-600">{stats.parents}</div>
          </div>
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
            <div className="text-sm font-medium text-gray-500">ê´€ë¦¬ì</div>
            <div className="text-3xl font-bold text-indigo-600">{stats.admins}</div>
          </div>
        </div>

        {/* ì‚¬ìš©ì ëª©ë¡ */}
        <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
          <h2 className="text-lg font-semibold text-gray-900">í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì ëª©ë¡</h2>
          <TenantlessUsersList
            users={paginatedUsers}
            searchQuery={searchQuery}
            userTypeFilter={userTypeFilter}
            currentPage={page}
            totalPages={totalPages}
            totalCount={totalCount}
          />
        </div>
      </div>
    </section>
  );
}
</file>

<file path="superadmin/tenants/_components/TenantCard.tsx">
"use client";

import { useState } from "react";
import { TenantForm } from "./TenantForm";

type Tenant = {
  id: string;
  name: string;
  type: string;
  status?: string | null;
  created_at: string;
  updated_at: string;
};

type TenantCardProps = {
  tenant: Tenant;
  onUpdate: (tenant: Tenant) => void;
  onDelete: (tenantId: string) => void;
};

export function TenantCard({ tenant, onUpdate, onDelete }: TenantCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    if (!confirm(`ì •ë§ "${tenant.name}" ê¸°ê´€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
      return;
    }

    try {
      const response = await fetch(`/api/tenants/${tenant.id}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("ì‚­ì œ ì‹¤íŒ¨");
      }

      onDelete(tenant.id);
    } catch (error) {
      console.error("[tenant] ì‚­ì œ ì‹¤íŒ¨", error);
      alert("ê¸°ê´€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setIsDeleting(false);
    }
  };

  if (isEditing) {
    return (
      <TenantForm
        tenant={tenant}
        onClose={() => setIsEditing(false)}
        onSuccess={(updated) => {
          onUpdate(updated);
          setIsEditing(false);
        }}
      />
    );
  }

  const statusLabel = tenant.status === "active" ? "í™œì„±" : tenant.status === "inactive" ? "ë¹„í™œì„±" : tenant.status === "suspended" ? "ì •ì§€" : "í™œì„±";
  const statusColor = tenant.status === "active" ? "bg-green-100 text-green-800" : tenant.status === "inactive" ? "bg-gray-100 text-gray-800" : tenant.status === "suspended" ? "bg-red-100 text-red-800" : "bg-green-100 text-green-800";

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
      <div className="flex flex-col gap-2">
        <div className="flex items-center justify-between">
          <h3 className="text-xl font-semibold">{tenant.name}</h3>
          <span className={`rounded-full px-2 py-1 text-xs font-medium ${statusColor}`}>
            {statusLabel}
          </span>
        </div>
        <p className="text-sm text-gray-500">
          ìœ í˜•: {tenant.type === "academy" ? "í•™ì›" : tenant.type === "school" ? "í•™êµ" : tenant.type === "enterprise" ? "ê¸°ì—…" : "ê¸°íƒ€"}
        </p>
      </div>

      <div className="text-xs text-gray-400">
        <p>ìƒì„±ì¼: {new Date(tenant.created_at).toLocaleDateString("ko-KR")}</p>
        <p>ìˆ˜ì •ì¼: {new Date(tenant.updated_at).toLocaleDateString("ko-KR")}</p>
      </div>

      <div className="flex gap-2">
        <button
          onClick={() => setIsEditing(true)}
          className="flex-1 rounded bg-gray-100 px-3 py-2 text-sm hover:bg-gray-200"
        >
          ìˆ˜ì •
        </button>
        <button
          onClick={handleDelete}
          disabled={isDeleting}
          className="flex-1 rounded bg-red-100 px-3 py-2 text-sm text-red-700 hover:bg-red-200 disabled:opacity-50"
        >
          {isDeleting ? "ì‚­ì œ ì¤‘..." : "ì‚­ì œ"}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/tenants/_components/TenantForm.tsx">
"use client";

import { useState } from "react";

type Tenant = {
  id: string;
  name: string;
  type: string;
  status?: string | null;
  created_at: string;
  updated_at: string;
};

type TenantFormProps = {
  tenant?: Tenant;
  onClose: () => void;
  onSuccess: (tenant: Tenant) => void;
};

export function TenantForm({ tenant, onClose, onSuccess }: TenantFormProps) {
  const [name, setName] = useState(tenant?.name ?? "");
  const [type, setType] = useState(tenant?.type ?? "academy");
  const [status, setStatus] = useState(tenant?.status ?? "active");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      const url = tenant ? `/api/tenants/${tenant.id}` : "/api/tenants";
      const method = tenant ? "PUT" : "POST";

      console.log("[TenantForm] ìˆ˜ì • ìš”ì²­:", {
        url,
        method,
        tenantId: tenant?.id,
        tenant: tenant,
        name,
        type,
      });

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ name, type, status }),
      });

      const result = await response.json();

      console.log("[TenantForm] API ì‘ë‹µ:", {
        url,
        status: response.status,
        result,
      });

      // API ì‘ë‹µ í˜•ì‹ í™•ì¸: { success: true, data: ... } ë˜ëŠ” { success: false, error: ... }
      if (!result.success) {
        const errorMessage =
          result.error?.message || "ê¸°ê´€ ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
        
        // "í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" ì—ëŸ¬ì¸ ê²½ìš° ì¶”ê°€ ì•ˆë‚´
        if (errorMessage.includes("ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")) {
          const fullMessage = `${errorMessage}\n\ní˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ìµœì‹  ëª©ë¡ì„ í™•ì¸í•´ì£¼ì„¸ìš”.`;
          throw new Error(fullMessage);
        }
        
        throw new Error(errorMessage);
      }

      // ì„±ê³µ ì‹œ data í•„ë“œì—ì„œ tenant ì •ë³´ ì¶”ì¶œ
      onSuccess(result.data);
    } catch (error) {
      console.error("[tenant] ì €ì¥ ì‹¤íŒ¨", error);
      const errorMessage =
        error instanceof Error ? error.message : "ê¸°ê´€ ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
      alert(errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="w-full max-w-md rounded-lg bg-white p-6 flex flex-col gap-4">
        <h2 className="text-xl font-semibold">
          {tenant ? "ê¸°ê´€ ìˆ˜ì •" : "ìƒˆ ê¸°ê´€ ì¶”ê°€"}
        </h2>

        <form onSubmit={handleSubmit} className="flex flex-col gap-4">
          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium">ê¸°ê´€ëª…</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              required
              className="w-full rounded border px-3 py-2"
              placeholder="ì˜ˆ: ì„œìš¸í•™ì›"
            />
          </div>

          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium">ìœ í˜•</label>
            <select
              value={type}
              onChange={(e) => setType(e.target.value)}
              className="w-full rounded border px-3 py-2"
            >
              <option value="academy">í•™ì›</option>
              <option value="school">í•™êµ</option>
              <option value="enterprise">ê¸°ì—…</option>
              <option value="other">ê¸°íƒ€</option>
            </select>
          </div>

          <div className="flex flex-col gap-1">
            <label className="block text-sm font-medium">ìƒíƒœ</label>
            <select
              value={status}
              onChange={(e) => setStatus(e.target.value)}
              className="w-full rounded border px-3 py-2"
            >
              <option value="active">í™œì„±</option>
              <option value="inactive">ë¹„í™œì„±</option>
              <option value="suspended">ì •ì§€</option>
            </select>
          </div>

          <div className="flex gap-2">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 rounded bg-gray-100 px-4 py-2 hover:bg-gray-200"
            >
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="flex-1 rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 disabled:opacity-50"
            >
              {isSubmitting ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/tenants/_components/TenantList.tsx">
"use client";

import { useState } from "react";
import { TenantForm } from "./TenantForm";
import { TenantCard } from "./TenantCard";

type Tenant = {
  id: string;
  name: string;
  type: string;
  status?: string | null;
  created_at: string;
  updated_at: string;
};

type TenantListProps = {
  tenants: Tenant[];
};

export function TenantList({ tenants: initialTenants }: TenantListProps) {
  const [tenants, setTenants] = useState(initialTenants);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const refreshTenants = async () => {
    setIsRefreshing(true);
    try {
      const response = await fetch("/api/tenants");
      const result = await response.json();
      
      if (result.success) {
        setTenants(result.data);
      } else {
        console.error("[TenantList] ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨", result.error);
      }
    } catch (error) {
      console.error("[TenantList] ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨", error);
    } finally {
      setIsRefreshing(false);
    }
  };

  const handleTenantCreated = (newTenant: Tenant) => {
    setTenants([newTenant, ...tenants]);
    setIsFormOpen(false);
  };

  const handleTenantUpdated = (updatedTenant: Tenant) => {
    setTenants(
      tenants.map((t) => (t.id === updatedTenant.id ? updatedTenant : t))
    );
  };

  const handleTenantDeleted = (tenantId: string) => {
    setTenants(tenants.filter((t) => t.id !== tenantId));
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-end gap-2">
        <button
          onClick={refreshTenants}
          disabled={isRefreshing}
          className="rounded bg-gray-100 px-4 py-2 text-gray-700 hover:bg-gray-200 disabled:opacity-50"
        >
          {isRefreshing ? "ìƒˆë¡œê³ ì¹¨ ì¤‘..." : "ğŸ”„ ìƒˆë¡œê³ ì¹¨"}
        </button>
        <button
          onClick={() => setIsFormOpen(true)}
          className="rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700"
        >
          + ìƒˆ ê¸°ê´€ ì¶”ê°€
        </button>
      </div>

      {isFormOpen && (
        <TenantForm
          onClose={() => setIsFormOpen(false)}
          onSuccess={handleTenantCreated}
        />
      )}

      {tenants.length === 0 ? (
        <div className="rounded border border-gray-200 bg-gray-50 p-8 text-center text-gray-500">
          ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤.
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {tenants.map((tenant) => (
            <TenantCard
              key={tenant.id}
              tenant={tenant}
              onUpdate={handleTenantUpdated}
              onDelete={handleTenantDeleted}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="superadmin/tenants/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { TenantList } from "./_components/TenantList";

export default async function SuperAdminTenantsPage() {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  // Super Adminì€ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
  const adminClient = createSupabaseAdminClient();
  if (!adminClient) {
    console.error("[superadmin] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨: SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ í™•ì¸ í•„ìš”");
    return (
      <div className="mx-auto max-w-6xl px-4 py-10">
        <div className="rounded-lg border border-red-200 bg-red-50 p-6 text-center text-red-700">
          ì‹œìŠ¤í…œ ì„¤ì • ì˜¤ë¥˜: SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
        </div>
      </div>
    );
  }

  // status ì»¬ëŸ¼ì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
  let selectQuery = adminClient
    .from("tenants")
    .select("id, name, type, created_at, updated_at");

  // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸ í›„ ì¶”ê°€
  try {
    const { error: testError } = await adminClient
      .from("tenants")
      .select("status")
      .limit(1);
    
    if (!testError) {
      selectQuery = adminClient
        .from("tenants")
        .select("id, name, type, status, created_at, updated_at");
    }
  } catch (e) {
    // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
  }

  const { data: tenants, error } = await selectQuery.order("created_at", { ascending: false });

  console.log("[superadmin] tenants ì¡°íšŒ ê²°ê³¼:", {
    count: tenants?.length ?? 0,
    tenants: tenants,
    error: error ? {
      code: error.code,
      message: error.message,
      details: error.details,
    } : null,
  });

  if (error) {
    console.error("[superadmin] tenants ì¡°íšŒ ì‹¤íŒ¨", error);
  }

  return (
    <div className="mx-auto max-w-6xl px-4 py-10 flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-semibold">ê¸°ê´€ ê´€ë¦¬</h1>
      </div>

      <TenantList tenants={tenants ?? []} />
    </div>
  );
}
</file>

<file path="superadmin/terms-management/_components/TermsContentForm.tsx">
"use client";

import { useEffect, useState, useTransition } from "react";
import { useActionState } from "react";
import {
  createTermsContent,
  updateTermsContent,
  activateTermsContent,
  getTermsContentById,
} from "@/app/(superadmin)/actions/termsContents";
import type { TermsContentType, TermsContentInput } from "@/lib/types/terms";
import FormInput from "@/components/ui/FormInput";
import FormMessage from "@/components/ui/FormMessage";
import FormSubmitButton from "@/components/ui/FormSubmitButton";
import Button from "@/components/atoms/Button";
import { X } from "lucide-react";

type TermsContentFormProps = {
  contentType: TermsContentType;
  contentId?: string | "new";
  onCancel: () => void;
  onSuccess: () => void;
};

type FormState = {
  error?: string;
  message?: string;
};

const initialState: FormState = { error: "", message: "" };

async function formAction(
  prevState: FormState,
  formData: FormData
): Promise<FormState> {
  const contentType = formData.get("contentType") as TermsContentType;
  const contentId = formData.get("contentId") as string;
  const title = formData.get("title") as string;
  const content = formData.get("content") as string;
  const shouldActivate = formData.get("shouldActivate") === "true";

  if (!title || !content) {
    return {
      error: "ì œëª©ê³¼ ë‚´ìš©ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.",
    };
  }

  try {
    if (contentId === "new") {
      // ìƒˆ ë²„ì „ ìƒì„±
      const result = await createTermsContent({
        content_type: contentType,
        title,
        content,
      });

      if (!result.success) {
        return {
          error: result.error || "ì•½ê´€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }

      // í™œì„±í™” ìš”ì²­ì´ ìˆìœ¼ë©´ í™œì„±í™”
      if (shouldActivate && result.data) {
        const activateResult = await activateTermsContent(result.data.id);
        if (!activateResult.success) {
          return {
            error: activateResult.error || "ì•½ê´€ í™œì„±í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
          };
        }
      }

      return {
        message: "ì•½ê´€ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
      };
    } else {
      // ê¸°ì¡´ ë²„ì „ ìˆ˜ì •
      const result = await updateTermsContent(contentId, {
        title,
        content,
      });

      if (!result.success) {
        return {
          error: result.error || "ì•½ê´€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }

      // í™œì„±í™” ìš”ì²­ì´ ìˆìœ¼ë©´ í™œì„±í™”
      if (shouldActivate) {
        const activateResult = await activateTermsContent(contentId);
        if (!activateResult.success) {
          return {
            error: activateResult.error || "ì•½ê´€ í™œì„±í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
          };
        }
      }

      return {
        message: "ì•½ê´€ì´ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.",
      };
    }
  } catch (error) {
    return {
      error: error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

export function TermsContentForm({
  contentType,
  contentId = "new",
  onCancel,
  onSuccess,
}: TermsContentFormProps) {
  const [state, formActionWithState] = useActionState<FormState, FormData>(
    formAction,
    initialState
  );
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [shouldActivate, setShouldActivate] = useState(false);
  const [loading, setLoading] = useState(contentId !== "new");
  const [isPending, startTransition] = useTransition();

  useEffect(() => {
    if (contentId !== "new") {
      loadContent();
    }
  }, [contentId]);

  useEffect(() => {
    if (state.message) {
      const timer = setTimeout(() => {
        onSuccess();
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [state.message, onSuccess]);

  const loadContent = async () => {
    if (contentId === "new") return;

    setLoading(true);
    try {
      const result = await getTermsContentById(contentId);
      if (result.success && result.data) {
        setTitle(result.data.title);
        setContent(result.data.content);
        setShouldActivate(result.data.is_active);
      } else {
        console.error("ì•½ê´€ ë¡œë“œ ì‹¤íŒ¨:", result.error);
      }
    } catch (error) {
      console.error("ì•½ê´€ ë¡œë“œ ì‹¤íŒ¨:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = (formData: FormData) => {
    formData.append("contentType", contentType);
    formData.append("contentId", contentId);
    formData.append("shouldActivate", shouldActivate.toString());
    startTransition(() => {
      formActionWithState(formData);
    });
  };

  if (loading) {
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="text-sm text-gray-500">ë¡œë”© ì¤‘...</div>
      </div>
    );
  }

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-gray-900">
          {contentId === "new" ? "ìƒˆ ë²„ì „ ìƒì„±" : "ì•½ê´€ ìˆ˜ì •"}
        </h2>
        <Button onClick={onCancel} variant="outline" size="sm">
          <X className="w-4 h-4" />
        </Button>
      </div>

      <form action={handleSubmit} className="flex flex-col gap-4">
        <input type="hidden" name="contentType" value={contentType} />
        <input type="hidden" name="contentId" value={contentId} />

        <FormInput
          label="ì œëª©"
          name="title"
          type="text"
          required
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="ì•½ê´€ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
        />

        <div className="flex flex-col gap-2">
          <label htmlFor="content" className="text-sm font-medium text-gray-700">
            ë‚´ìš© (ë§ˆí¬ë‹¤ìš´) <span className="text-red-500">*</span>
          </label>
          <textarea
            id="content"
            name="content"
            required
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="ì•½ê´€ ë‚´ìš©ì„ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”"
            rows={20}
            className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm font-mono focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
          />
          <p className="text-xs text-gray-500">
            ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”. ë¯¸ë¦¬ë³´ê¸°ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>

        <div className="flex items-center gap-2">
          <input
            type="checkbox"
            id="shouldActivate"
            checked={shouldActivate}
            onChange={(e) => setShouldActivate(e.target.checked)}
            className="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
          />
          <label htmlFor="shouldActivate" className="text-sm text-gray-700">
            ì €ì¥ í›„ ì¦‰ì‹œ í™œì„±í™” (ê¸°ì¡´ í™œì„± ë²„ì „ì€ ìë™ìœ¼ë¡œ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤)
          </label>
        </div>

        {state?.error && <FormMessage type="error" message={state.error} />}
        {state?.message && (
          <FormMessage type="success" message={state.message} />
        )}

        <div className="flex items-center gap-2">
          <FormSubmitButton
            defaultText={contentId === "new" ? "ìƒì„±" : "ìˆ˜ì •"}
            pendingText={contentId === "new" ? "ìƒì„± ì¤‘..." : "ìˆ˜ì • ì¤‘..."}
            disabled={isPending}
          />
          <Button
            type="button"
            onClick={onCancel}
            variant="outline"
            disabled={isPending}
          >
            ì·¨ì†Œ
          </Button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="superadmin/terms-management/_components/TermsContentList.tsx">
"use client";

import { useEffect, useState } from "react";
import { getTermsContents } from "@/app/(superadmin)/actions/termsContents";
import type { TermsContent, TermsContentType } from "@/lib/types/terms";
import Button from "@/components/atoms/Button";
import { Plus, Eye, Edit, CheckCircle, XCircle } from "lucide-react";

type TermsContentListProps = {
  contentType: TermsContentType;
  onEdit: (id: string) => void;
  onPreview: (id: string) => void;
  onCreateNew: () => void;
};

export function TermsContentList({
  contentType,
  onEdit,
  onPreview,
  onCreateNew,
}: TermsContentListProps) {
  const [contents, setContents] = useState<TermsContent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadContents();
  }, [contentType]);

  const loadContents = async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await getTermsContents(contentType);
      if (result.success && result.data) {
        setContents(result.data);
      } else {
        setError(result.error || "ì•½ê´€ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="text-sm text-gray-500">ë¡œë”© ì¤‘...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="rounded-lg border border-red-200 bg-red-50 p-6 shadow-sm">
        <div className="text-sm text-red-600">{error}</div>
        <Button
          onClick={loadContents}
          className="mt-4"
          variant="outline"
          size="sm"
        >
          ë‹¤ì‹œ ì‹œë„
        </Button>
      </div>
    );
  }

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-gray-900">ë²„ì „ ëª©ë¡</h2>
        <Button onClick={onCreateNew} size="sm">
          <Plus className="w-4 h-4 mr-2" />
          ìƒˆ ë²„ì „ ìƒì„±
        </Button>
      </div>

      {contents.length === 0 ? (
        <div className="text-sm text-gray-500 text-center py-8">
          ë“±ë¡ëœ ì•½ê´€ì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆ ë²„ì „ì„ ìƒì„±í•´ì£¼ì„¸ìš”.
        </div>
      ) : (
        <div className="flex flex-col gap-3">
          {contents.map((content) => (
            <div
              key={content.id}
              className="flex items-center justify-between rounded-lg border border-gray-200 p-4 hover:bg-gray-50 transition-colors"
            >
              <div className="flex-1 flex flex-col gap-1">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-900">
                    ë²„ì „ {content.version}
                  </span>
                  {content.is_active ? (
                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                      <CheckCircle className="w-3 h-3" />
                      í™œì„±
                    </span>
                  ) : (
                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-600">
                      <XCircle className="w-3 h-3" />
                      ë¹„í™œì„±
                    </span>
                  )}
                </div>
                <div className="text-sm text-gray-600">{content.title}</div>
                <div className="text-xs text-gray-500">
                  ìƒì„±ì¼: {new Date(content.created_at).toLocaleDateString("ko-KR")}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Button
                  onClick={() => onPreview(content.id)}
                  variant="outline"
                  size="sm"
                >
                  <Eye className="w-4 h-4" />
                </Button>
                <Button
                  onClick={() => onEdit(content.id)}
                  variant="outline"
                  size="sm"
                >
                  <Edit className="w-4 h-4" />
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="superadmin/terms-management/_components/TermsManagementContent.tsx">
"use client";

import { useState } from "react";
import { TERMS_CONTENT_TYPES, TERMS_CONTENT_TYPE_LABELS } from "@/lib/constants/terms";
import type { TermsContentType } from "@/lib/types/terms";
import { TermsContentForm } from "./TermsContentForm";
import { TermsContentList } from "./TermsContentList";
import { TermsPreview } from "./TermsPreview";

export function TermsManagementContent() {
  const [activeTab, setActiveTab] = useState<TermsContentType>("terms");
  const [editingId, setEditingId] = useState<string | null>(null);
  const [previewId, setPreviewId] = useState<string | null>(null);

  return (
    <div className="flex flex-col gap-6">
      {/* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */}
      <div className="border-b border-gray-200">
        <nav className="flex gap-4" aria-label="ì•½ê´€ ìœ í˜• íƒ­">
          {TERMS_CONTENT_TYPES.map((type) => (
            <button
              key={type}
              onClick={() => {
                setActiveTab(type);
                setEditingId(null);
                setPreviewId(null);
              }}
              className={`px-4 py-2 text-sm font-medium border-b-2 transition-colors ${
                activeTab === type
                  ? "border-indigo-600 text-indigo-600"
                  : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
              }`}
            >
              {TERMS_CONTENT_TYPE_LABELS[type]}
            </button>
          ))}
        </nav>
      </div>

      {/* ì½˜í…ì¸  ì˜ì—­ */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* ì™¼ìª½: í¸ì§‘ í¼ ë˜ëŠ” ëª©ë¡ */}
        <div className="flex flex-col gap-4">
          {editingId ? (
            <TermsContentForm
              contentType={activeTab}
              contentId={editingId}
              onCancel={() => setEditingId(null)}
              onSuccess={() => {
                setEditingId(null);
              }}
            />
          ) : (
            <TermsContentList
              contentType={activeTab}
              onEdit={(id) => setEditingId(id)}
              onPreview={(id) => setPreviewId(id)}
              onCreateNew={() => setEditingId("new")}
            />
          )}
        </div>

        {/* ì˜¤ë¥¸ìª½: ë¯¸ë¦¬ë³´ê¸° */}
        <div className="flex flex-col gap-4">
          {previewId && (
            <TermsPreview
              contentId={previewId}
              onClose={() => setPreviewId(null)}
            />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/terms-management/_components/TermsPreview.tsx">
"use client";

import { useEffect, useState } from "react";
import { getTermsContentById } from "@/app/(superadmin)/actions/termsContents";
import type { TermsContent } from "@/lib/types/terms";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { X } from "lucide-react";
import Button from "@/components/atoms/Button";

type TermsPreviewProps = {
  contentId: string;
  onClose: () => void;
};

export function TermsPreview({ contentId, onClose }: TermsPreviewProps) {
  const [content, setContent] = useState<TermsContent | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadContent();
  }, [contentId]);

  const loadContent = async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await getTermsContentById(contentId);
      if (result.success && result.data) {
        setContent(result.data);
      } else {
        setError(result.error || "ì•½ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm">
        <div className="text-sm text-gray-500">ë¡œë”© ì¤‘...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="rounded-lg border border-red-200 bg-red-50 p-6 shadow-sm">
        <div className="text-sm text-red-600">{error}</div>
        <Button onClick={onClose} className="mt-4" variant="outline" size="sm">
          ë‹«ê¸°
        </Button>
      </div>
    );
  }

  if (!content) {
    return null;
  }

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <div className="flex flex-col gap-1">
          <h2 className="text-lg font-semibold text-gray-900">{content.title}</h2>
          <div className="text-xs text-gray-500">
            ë²„ì „ {content.version} Â·{" "}
            {new Date(content.created_at).toLocaleDateString("ko-KR")}
          </div>
        </div>
        <Button onClick={onClose} variant="outline" size="sm">
          <X className="w-4 h-4" />
        </Button>
      </div>

      <div className="prose prose-sm max-w-none overflow-y-auto max-h-[600px] border border-gray-200 rounded-lg p-4">
        <ReactMarkdown remarkPlugins={[remarkGfm]}>
          {content.content}
        </ReactMarkdown>
      </div>
    </div>
  );
}
</file>

<file path="superadmin/terms-management/page.tsx">
export const dynamic = 'force-dynamic';

import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { TermsManagementContent } from "./_components/TermsManagementContent";

export default async function TermsManagementPage() {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  return (
    <div className="p-6 md:p-10 flex flex-col gap-8">
      <div className="flex flex-col gap-2">
        <h1 className="text-3xl font-bold text-gray-900">ì•½ê´€ ê´€ë¦¬</h1>
        <p className="text-sm text-gray-600">
          ì´ìš©ì•½ê´€, ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨, ë§ˆì¼€íŒ… í™œìš© ë™ì˜ ë‚´ìš©ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
        </p>
      </div>

      <TermsManagementContent />
    </div>
  );
}
</file>

<file path="superadmin/unverified-users/_components/UnverifiedUsersList.tsx">
"use client";

import { useState, useTransition } from "react";
import {
  deleteUnverifiedUser,
  resendVerificationEmail,
  deleteMultipleUnverifiedUsers,
} from "@/app/(admin)/actions/unverifiedUserActions";
import { useRouter } from "next/navigation";

type UnverifiedUser = {
  id: string;
  email?: string;
  created_at?: string;
  last_sign_in_at?: string | null;
  user_metadata?: {
    display_name?: string;
  };
};

type UnverifiedUsersListProps = {
  users: UnverifiedUser[];
  searchQuery: string;
  currentPage: number;
  totalPages: number;
  totalCount: number;
};

export function UnverifiedUsersList({
  users,
  searchQuery,
  currentPage,
  totalPages,
  totalCount,
}: UnverifiedUsersListProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const [selectedUsers, setSelectedUsers] = useState<Set<string>>(new Set());
  const [actionMessage, setActionMessage] = useState<string | null>(null);

  const handleDelete = (userId: string, email?: string) => {
    if (
      !confirm(
        `ì •ë§ ${email || "ì´ ì‚¬ìš©ì"}ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
      )
    ) {
      return;
    }

    startTransition(async () => {
      const result = await deleteUnverifiedUser(userId);
      if (result.success) {
        setActionMessage("ì‚¬ìš©ìê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
        router.refresh();
      } else {
        alert(result.error || "ì‚¬ìš©ì ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  const handleResendEmail = (email: string) => {
    startTransition(async () => {
      const result = await resendVerificationEmail(email);
      if (result.success) {
        setActionMessage(result.message || "ì¸ì¦ ë©”ì¼ì´ ì¬ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } else {
        alert(result.error || "ì¸ì¦ ë©”ì¼ ì¬ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  const handleSelectAll = () => {
    if (selectedUsers.size === users.length) {
      setSelectedUsers(new Set());
    } else {
      setSelectedUsers(new Set(users.map((u) => u.id)));
    }
  };

  const handleToggleSelect = (userId: string) => {
    const newSelected = new Set(selectedUsers);
    if (newSelected.has(userId)) {
      newSelected.delete(userId);
    } else {
      newSelected.add(userId);
    }
    setSelectedUsers(newSelected);
  };

  const handleBulkDelete = () => {
    if (selectedUsers.size === 0) {
      alert("ì‚­ì œí•  ì‚¬ìš©ìë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    if (
      !confirm(
        `ì„ íƒí•œ ${selectedUsers.size}ëª…ì˜ ì‚¬ìš©ìë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
      )
    ) {
      return;
    }

    startTransition(async () => {
      const result = await deleteMultipleUnverifiedUsers(Array.from(selectedUsers));
      if (result.success) {
        setActionMessage(`${result.deletedCount || 0}ëª…ì˜ ì‚¬ìš©ìê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        setSelectedUsers(new Set());
        router.refresh();
      } else {
        alert(result.error || "ì¼ê´„ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  if (actionMessage) {
    setTimeout(() => setActionMessage(null), 3000);
  }

  return (
    <div className="space-y-4">
      {/* ê²€ìƒ‰ ë° ì¼ê´„ ì‘ì—… */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <form method="get" className="flex-1">
          <input
            type="text"
            name="search"
            placeholder="ì´ë©”ì¼ ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰..."
            defaultValue={searchQuery}
            className="w-full rounded-lg border border-gray-300 px-4 py-2 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-200"
          />
        </form>
        {selectedUsers.size > 0 && (
          <button
            onClick={handleBulkDelete}
            disabled={isPending}
            className="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700 disabled:opacity-50"
          >
            {isPending ? "ì‚­ì œ ì¤‘..." : `ì„ íƒí•œ ${selectedUsers.size}ëª… ì‚­ì œ`}
          </button>
        )}
      </div>

      {actionMessage && (
        <div className="rounded-lg bg-green-50 px-4 py-2 text-sm text-green-700">
          {actionMessage}
        </div>
      )}

      {/* ì‚¬ìš©ì ëª©ë¡ */}
      {users.length === 0 ? (
        <div className="py-12 text-center text-gray-500">
          {searchQuery
            ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."
            : "ë¯¸ì¸ì¦ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤."}
        </div>
      ) : (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left">
                  <input
                    type="checkbox"
                    checked={selectedUsers.size === users.length && users.length > 0}
                    onChange={handleSelectAll}
                    className="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                  />
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì´ë©”ì¼
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì´ë¦„
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ê°€ì…ì¼
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                  ì‘ì—…
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 bg-white">
              {users.map((user) => (
                <tr key={user.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4">
                    <input
                      type="checkbox"
                      checked={selectedUsers.has(user.id)}
                      onChange={() => handleToggleSelect(user.id)}
                      className="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900">
                    {user.email || "ì´ë©”ì¼ ì—†ìŒ"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    {user.user_metadata?.display_name || "-"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    {user.created_at
                      ? new Date(user.created_at).toLocaleDateString("ko-KR")
                      : "-"}
                  </td>
                  <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                    <div className="flex items-center gap-2">
                      {user.email && (
                        <button
                          onClick={() => handleResendEmail(user.email!)}
                          disabled={isPending}
                          className="rounded-lg bg-indigo-100 px-3 py-1.5 text-xs font-semibold text-indigo-800 transition hover:bg-indigo-200 disabled:opacity-50"
                        >
                          ì¸ì¦ ë©”ì¼ ì¬ë°œì†¡
                        </button>
                      )}
                      <button
                        onClick={() => handleDelete(user.id, user.email)}
                        disabled={isPending}
                        className="rounded-lg bg-red-100 px-3 py-1.5 text-xs font-semibold text-red-800 transition hover:bg-red-200 disabled:opacity-50"
                      >
                        ì‚­ì œ
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* í˜ì´ì§€ë„¤ì´ì…˜ */}
      {totalPages > 1 && (
        <div className="flex items-center justify-center gap-2">
          {currentPage > 1 && (
            <a
              href={`/superadmin/unverified-users?page=${currentPage - 1}${searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : ""}`}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ì´ì „
            </a>
          )}
          <span className="text-sm text-gray-600">
            {currentPage} / {totalPages}
          </span>
          {currentPage < totalPages && (
            <a
              href={`/superadmin/unverified-users?page=${currentPage + 1}${searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : ""}`}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-700 transition hover:bg-gray-50"
            >
              ë‹¤ìŒ
            </a>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="superadmin/unverified-users/page.tsx">
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { UnverifiedUsersList } from "./_components/UnverifiedUsersList";
import Link from "next/link";

type UnverifiedUser = {
  id: string;
  email?: string;
  created_at?: string;
  last_sign_in_at?: string | null;
  user_metadata?: {
    display_name?: string;
  };
};

export default async function UnverifiedUsersPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | undefined>>;
}) {
  const { role, userId } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  const params = await searchParams;
  const searchQuery = params.search?.trim() ?? "";
  const page = parseInt(params.page || "1", 10);
  const pageSize = 20;

  let unverifiedUsers: UnverifiedUser[] = [];
  let totalCount = 0;
  let serviceRoleKeyError = false;

  try {
    const adminClient = createSupabaseAdminClient();
    
    if (!adminClient) {
      serviceRoleKeyError = true;
    } else {
      // ëª¨ë“  ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ
      const { data: usersData, error } = await adminClient.auth.admin.listUsers();

    if (error) {
      console.error("[superadmin/unverified-users] ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", error);
    } else if (usersData?.users) {
      // ë¯¸ì¸ì¦ ì‚¬ìš©ì í•„í„°ë§ (email_confirmed_atì´ nullì´ê±°ë‚˜ undefined)
      unverifiedUsers = usersData.users
        .filter((user) => !user.email_confirmed_at)
        .map((user) => ({
          id: user.id,
          email: user.email,
          created_at: user.created_at,
          last_sign_in_at: user.last_sign_in_at,
          user_metadata: user.user_metadata as { display_name?: string } | undefined,
        }));

      // ê²€ìƒ‰ í•„í„° ì ìš©
      if (searchQuery) {
        unverifiedUsers = unverifiedUsers.filter(
          (user) =>
            user.email?.toLowerCase().includes(searchQuery.toLowerCase()) ||
            user.user_metadata?.display_name?.toLowerCase().includes(searchQuery.toLowerCase())
        );
      }

      totalCount = unverifiedUsers.length;

      // ì •ë ¬ (ìµœê·¼ ê°€ì…ìˆœ)
      unverifiedUsers.sort((a, b) => {
        const dateA = a.created_at ? new Date(a.created_at).getTime() : 0;
        const dateB = b.created_at ? new Date(b.created_at).getTime() : 0;
        return dateB - dateA;
      });

      // í˜ì´ì§€ë„¤ì´ì…˜
      const from = (page - 1) * pageSize;
      const to = from + pageSize;
      unverifiedUsers = unverifiedUsers.slice(from, to);
    }
    }
  } catch (error) {
    console.error("[superadmin/unverified-users] ì˜¤ë¥˜:", error);
  }

  const totalPages = Math.ceil(totalCount / pageSize);

  return (
    <section className="mx-auto w-full max-w-6xl px-4 py-10">
      <div className="flex flex-col gap-8">
        {/* Header */}
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <p className="text-sm font-medium text-gray-500">ì‹œìŠ¤í…œ ê´€ë¦¬</p>
            <h1 className="text-3xl font-semibold text-gray-900">
              ë¯¸ì¸ì¦ ê°€ì… ê´€ë¦¬
            </h1>
            <p className="text-sm text-gray-500">
              ì´ë©”ì¼ ì¸ì¦ì„ ì™„ë£Œí•˜ì§€ ì•Šì€ ì‚¬ìš©ìë“¤ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
          <Link
            href="/superadmin/dashboard"
            className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 transition hover:bg-gray-50"
          >
            ëŒ€ì‹œë³´ë“œë¡œ
          </Link>
        </div>

        {/* Service Role Key ì„¤ì • ì•ˆë‚´ */}
        {serviceRoleKeyError && (
          <div className="rounded-lg border border-yellow-200 bg-yellow-50 p-6 shadow-sm flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <h3 className="text-lg font-semibold text-yellow-900">
                âš ï¸ Service Role Key ì„¤ì • í•„ìš”
              </h3>
              <p className="text-sm text-yellow-800">
                ë¯¸ì¸ì¦ ê°€ì… ê´€ë¦¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ <code className="rounded bg-yellow-100 px-2 py-1 text-xs">SUPABASE_SERVICE_ROLE_KEY</code> í™˜ê²½ ë³€ìˆ˜ë¥¼ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.
              </p>
            </div>
            <div className="rounded-lg bg-yellow-100 p-4 flex flex-col gap-2">
              <p className="text-sm font-medium text-yellow-900">ì„¤ì • ë°©ë²•:</p>
              <ol className="list-inside list-decimal space-y-1 text-sm text-yellow-800">
                <li>Supabase ëŒ€ì‹œë³´ë“œ â†’ Settings â†’ API</li>
                <li>Service Role Key ë³µì‚¬</li>
                <li>.env.local íŒŒì¼ì— ì¶”ê°€: <code className="rounded bg-yellow-200 px-1">SUPABASE_SERVICE_ROLE_KEY=your_key_here</code></li>
                <li>ê°œë°œ ì„œë²„ ì¬ì‹œì‘</li>
              </ol>
            </div>
          </div>
        )}

        {/* í†µê³„ */}
        {!serviceRoleKeyError && (
          <div className="grid gap-4 md:grid-cols-3">
            <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-2">
              <div className="text-sm font-medium text-gray-500">ë¯¸ì¸ì¦ ì‚¬ìš©ì ìˆ˜</div>
              <div className="text-3xl font-bold text-gray-900">{totalCount}</div>
            </div>
          </div>
        )}

        {/* ë¯¸ì¸ì¦ ì‚¬ìš©ì ëª©ë¡ */}
        {!serviceRoleKeyError && (
          <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm flex flex-col gap-4">
            <h2 className="text-lg font-semibold text-gray-900">
              ë¯¸ì¸ì¦ ì‚¬ìš©ì ëª©ë¡
            </h2>
            <UnverifiedUsersList
              users={unverifiedUsers}
              searchQuery={searchQuery}
              currentPage={page}
              totalPages={totalPages}
              totalCount={totalCount}
            />
          </div>
        )}
      </div>
    </section>
  );
}
</file>

<file path="layout.tsx">
export const dynamic = 'force-dynamic';

import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { isAdminRole } from "@/lib/auth/isAdminRole";
import { RoleBasedLayout } from "@/components/layout/RoleBasedLayout";

export default async function SuperAdminLayout({ children }: { children: ReactNode }) {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  return (
    <RoleBasedLayout
      role="superadmin"
      dashboardHref="/superadmin/dashboard"
      roleLabel="Super Admin"
      showSidebar={true}
    >
      {children}
    </RoleBasedLayout>
  );
}
</file>

<file path="layout.tsx">
export const dynamic = 'force-dynamic';

import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { isAdminRole } from "@/lib/auth/isAdminRole";
import { RoleBasedLayout } from "@/components/layout/RoleBasedLayout";

export default async function SuperAdminLayout({ children }: { children: ReactNode }) {
  const { userId, role } = await getCurrentUserRole();

  // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
  if (!userId || role !== "superadmin") {
    redirect("/login");
  }

  return (
    <RoleBasedLayout
      role="superadmin"
      dashboardHref="/superadmin/dashboard"
      roleLabel="Super Admin"
      showSidebar={true}
    >
      {children}
    </RoleBasedLayout>
  );
}
</file>

<file path="_components/LoginForm.tsx">
"use client";

import Link from "next/link";
import { useState, useTransition } from "react";
import { useSearchParams } from "next/navigation";
import { signIn } from "@/app/actions/auth";
import { ResendEmailButton } from "./ResendEmailButton";

type LoginFormProps = {
  returnUrl?: string;
};

export function LoginForm({ returnUrl }: LoginFormProps) {
  const searchParams = useSearchParams();
  const message = searchParams.get("message");
  const errorParam = searchParams.get("error");
  const [error, setError] = useState<string | null>(errorParam);
  const [needsEmailVerification, setNeedsEmailVerification] = useState(false);
  const [verificationEmail, setVerificationEmail] = useState<string>("");
  const [isPending, startTransition] = useTransition();
  const [email, setEmail] = useState<string>("");

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    const emailValue = formData.get("email")?.toString() || "";
    setEmail(emailValue);
    setNeedsEmailVerification(false);
    setVerificationEmail("");

    // returnUrlì´ ìˆìœ¼ë©´ FormDataì— ì¶”ê°€
    if (returnUrl) {
      formData.append("returnUrl", returnUrl);
    }

    startTransition(async () => {
      try {
        const result = await signIn(formData); // ì„œë²„ ì•¡ì…˜ í˜¸ì¶œ
        
        // ì´ë©”ì¼ ì¸ì¦ì´ í•„ìš”í•œ ê²½ìš°
        if (result?.needsEmailVerification) {
          setError(result.error || "ì´ë©”ì¼ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.");
          setNeedsEmailVerification(true);
          setVerificationEmail(result.email || emailValue);
          return;
        }
        
        setError(null);
      } catch (err) {
        const errorMessage =
          err instanceof Error
            ? err.message
            : "ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
        setError(errorMessage);
        setNeedsEmailVerification(false);
      }
    });
  };

  return (
    <>
      <div>
        <h1 className="text-h1">ë¡œê·¸ì¸</h1>
        <p className="text-sm text-neutral-500">
          ê³„ì •ì´ ì—†ë‹¤ë©´{" "}
          <Link href="/signup" className="text-black underline">
            íšŒì›ê°€ì…
          </Link>
          ì„ ì§„í–‰í•´ì£¼ì„¸ìš”.
        </p>
      </div>

      {/* â›” ì—¬ê¸°â€¼ ì ˆëŒ€ë¡œ action= ë„£ìœ¼ë©´ ì•ˆ ë¨ */}
      <form onSubmit={handleSubmit} className="flex flex-col gap-4">
        <label className="flex flex-col gap-1 text-sm">
          ì´ë©”ì¼
          <input
            type="email"
            name="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="rounded border px-3 py-2 text-[var(--text-primary)] placeholder:text-[var(--text-placeholder)]"
            placeholder="you@example.com"
          />
        </label>

        <label className="flex flex-col gap-1 text-sm">
          ë¹„ë°€ë²ˆí˜¸
          <input
            type="password"
            name="password"
            required
            className="rounded border px-3 py-2 text-[var(--text-primary)] placeholder:text-[var(--text-placeholder)]"
            placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
          />
        </label>

        <label className="flex items-center gap-2 text-sm">
          <input
            type="checkbox"
            name="rememberMe"
            className="h-4 w-4 rounded border-gray-300"
          />
          <span className="text-neutral-600">ìë™ë¡œê·¸ì¸</span>
        </label>

        {message && (
          <p className="rounded bg-green-50 px-3 py-2 text-sm text-green-700">
            {message}
          </p>
        )}

        {error && (
          <div className="rounded bg-red-50 px-3 py-2 text-sm text-red-700 flex flex-col gap-2">
            <p>{error}</p>
            {needsEmailVerification && verificationEmail && (
              <div>
                <ResendEmailButton email={verificationEmail} />
              </div>
            )}
          </div>
        )}

        <button
          type="submit"
          disabled={isPending}
          className="rounded bg-black px-4 py-2 text-white disabled:opacity-50"
        >
          {isPending ? "ë¡œê·¸ì¸ ì¤‘..." : "ë¡œê·¸ì¸"}
        </button>
      </form>
    </>
  );
}
</file>

<file path="_components/ResendEmailButton.tsx">
"use client";

import { useState, useTransition } from "react";
import { resendConfirmationEmail } from "@/app/actions/auth";

type ResendEmailButtonProps = {
  email: string;
};

export function ResendEmailButton({ email }: ResendEmailButtonProps) {
  const [isPending, startTransition] = useTransition();
  const [message, setMessage] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const handleResend = () => {
    setMessage(null);
    setError(null);

    startTransition(async () => {
      const result = await resendConfirmationEmail(email);
      if (result.success) {
        setMessage(result.message || "ì¸ì¦ ë©”ì¼ì„ ì¬ë°œì†¡í–ˆìŠµë‹ˆë‹¤.");
      } else {
        setError(result.error || "ì´ë©”ì¼ ì¬ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
      }
    });
  };

  return (
    <div className="mt-2">
      <button
        type="button"
        onClick={handleResend}
        disabled={isPending || !email}
        className="text-sm text-indigo-600 hover:text-indigo-800 underline disabled:opacity-50"
      >
        {isPending ? "ë°œì†¡ ì¤‘..." : "ì¸ì¦ ë©”ì¼ ì¬ë°œì†¡"}
      </button>
      {message && (
        <p className="mt-1 text-xs text-green-600">{message}</p>
      )}
      {error && (
        <p className="mt-1 text-xs text-red-600">{error}</p>
      )}
    </div>
  );
}
</file>

<file path="page.tsx">
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { LoginForm } from "./_components/LoginForm";

export const dynamic = 'force-dynamic';

type LoginPageProps = {
  searchParams: Promise<{ returnUrl?: string; error?: string; message?: string }>;
};

export default async function LoginPage({
  searchParams,
}: LoginPageProps) {
  const params = await searchParams;
  const returnUrl = params.returnUrl;
  // getCurrentUserRoleì„ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ (ì—ëŸ¬ ë°œìƒ ì‹œ null ë°˜í™˜)
  let userRole: { userId: string | null; role: string | null; tenantId: string | null } = {
    userId: null,
    role: null,
    tenantId: null,
  };

  try {
    userRole = await getCurrentUserRole();
  } catch (error) {
    // getCurrentUserRole ì‹¤íŒ¨ ì‹œ ì¡°ìš©íˆ ì²˜ë¦¬ (ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ)
    const errorMessage = error instanceof Error ? error.message : String(error);
    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê¹…
    if (process.env.NODE_ENV === "development") {
      console.error("[LoginPage] ì¸ì¦ í™•ì¸ ì¤‘ ì—ëŸ¬ (ë¬´ì‹œë¨)", {
        message: errorMessage,
      });
    }
    // ì—ëŸ¬ê°€ ìˆì–´ë„ ë¡œê·¸ì¸ í˜ì´ì§€ë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ê³„ì† ì§„í–‰
  }

  // ì´ë¯¸ ì¸ì¦ëœ ì‚¬ìš©ìëŠ” ì ì ˆí•œ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (userRole.userId && userRole.role) {
    // í•™ìƒì¸ ê²½ìš° is_active í™•ì¸
    if (userRole.role === "student") {
      try {
        const supabase = await createSupabaseServerClient();
        const { data: student, error: studentError } = await supabase
          .from("students")
          .select("is_active")
          .eq("id", userRole.userId)
          .maybeSingle();

        // ì¿¼ë¦¬ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš°ì—ë„ ê³„ì† ì§„í–‰ (ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ)
        if (studentError) {
          if (process.env.NODE_ENV === "development") {
            console.error("[LoginPage] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ (ë¬´ì‹œë¨)", {
              message: studentError.message,
              code: studentError.code,
            });
          }
          // ì—ëŸ¬ê°€ ìˆì–´ë„ ë¡œê·¸ì¸ í˜ì´ì§€ë¥¼ í‘œì‹œ
        } else if (student && student.is_active === false) {
          // ë¹„í™œì„±í™”ëœ í•™ìƒì¸ ê²½ìš° ë¡œê·¸ì•„ì›ƒ
          try {
            await supabase.auth.signOut();
          } catch (signOutError) {
            // ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
          }
          // ë¡œê·¸ì¸ í˜ì´ì§€ì— ì—ëŸ¬ ë©”ì‹œì§€ì™€ í•¨ê»˜ í‘œì‹œ
        } else if (student) {
          // í™œì„±í™”ëœ í•™ìƒì€ ëŒ€ì‹œë³´ë“œë¡œ (redirectëŠ” try-catch ë°–ì—ì„œ í˜¸ì¶œ)
          redirect("/dashboard");
        }
      } catch (queryError) {
        // redirect ì—ëŸ¬ì¸ì§€ í™•ì¸
        if (
          queryError &&
          typeof queryError === "object" &&
          "digest" in queryError &&
          typeof (queryError as { digest: string }).digest === "string"
        ) {
          const digest = (queryError as { digest: string }).digest;
          // Next.jsì˜ ë¦¬ë‹¤ì´ë ‰íŠ¸ ì—ëŸ¬ëŠ” ì¬throw
          if (digest.startsWith("NEXT_REDIRECT")) {
            throw queryError;
          }
        }
        // ì¿¼ë¦¬ ì¤‘ ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ
        if (process.env.NODE_ENV === "development") {
          console.error("[LoginPage] í•™ìƒ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜ˆì™¸ (ë¬´ì‹œë¨)", queryError);
        }
      }
    } else if (userRole.role === "superadmin") {
      // Super Adminì€ Super Admin ëŒ€ì‹œë³´ë“œë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      redirect("/superadmin/dashboard");
    } else if (userRole.role === "admin" || userRole.role === "consultant") {
      redirect("/admin/dashboard");
    } else if (userRole.role === "parent") {
      redirect("/parent/dashboard");
    }
  }

  return (
    <section className="mx-auto flex min-h-screen max-w-md flex-col justify-center gap-6 px-4">
      <LoginForm returnUrl={returnUrl} />
    </section>
  );
}
</file>

<file path="page.tsx">
import { redirect } from "next/navigation";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { LoginForm } from "./_components/LoginForm";

export const dynamic = 'force-dynamic';

type LoginPageProps = {
  searchParams: Promise<{ returnUrl?: string; error?: string; message?: string }>;
};

export default async function LoginPage({
  searchParams,
}: LoginPageProps) {
  const params = await searchParams;
  const returnUrl = params.returnUrl;
  // getCurrentUserRoleì„ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ (ì—ëŸ¬ ë°œìƒ ì‹œ null ë°˜í™˜)
  let userRole: { userId: string | null; role: string | null; tenantId: string | null } = {
    userId: null,
    role: null,
    tenantId: null,
  };

  try {
    userRole = await getCurrentUserRole();
  } catch (error) {
    // getCurrentUserRole ì‹¤íŒ¨ ì‹œ ì¡°ìš©íˆ ì²˜ë¦¬ (ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ)
    const errorMessage = error instanceof Error ? error.message : String(error);
    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê¹…
    if (process.env.NODE_ENV === "development") {
      console.error("[LoginPage] ì¸ì¦ í™•ì¸ ì¤‘ ì—ëŸ¬ (ë¬´ì‹œë¨)", {
        message: errorMessage,
      });
    }
    // ì—ëŸ¬ê°€ ìˆì–´ë„ ë¡œê·¸ì¸ í˜ì´ì§€ë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ê³„ì† ì§„í–‰
  }

  // ì´ë¯¸ ì¸ì¦ëœ ì‚¬ìš©ìëŠ” ì ì ˆí•œ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (userRole.userId && userRole.role) {
    // í•™ìƒì¸ ê²½ìš° is_active í™•ì¸
    if (userRole.role === "student") {
      try {
        const supabase = await createSupabaseServerClient();
        const { data: student, error: studentError } = await supabase
          .from("students")
          .select("is_active")
          .eq("id", userRole.userId)
          .maybeSingle();

        // ì¿¼ë¦¬ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš°ì—ë„ ê³„ì† ì§„í–‰ (ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ)
        if (studentError) {
          if (process.env.NODE_ENV === "development") {
            console.error("[LoginPage] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ (ë¬´ì‹œë¨)", {
              message: studentError.message,
              code: studentError.code,
            });
          }
          // ì—ëŸ¬ê°€ ìˆì–´ë„ ë¡œê·¸ì¸ í˜ì´ì§€ë¥¼ í‘œì‹œ
        } else if (student && student.is_active === false) {
          // ë¹„í™œì„±í™”ëœ í•™ìƒì¸ ê²½ìš° ë¡œê·¸ì•„ì›ƒ
          try {
            await supabase.auth.signOut();
          } catch (signOutError) {
            // ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
          }
          // ë¡œê·¸ì¸ í˜ì´ì§€ì— ì—ëŸ¬ ë©”ì‹œì§€ì™€ í•¨ê»˜ í‘œì‹œ
        } else if (student) {
          // í™œì„±í™”ëœ í•™ìƒì€ ëŒ€ì‹œë³´ë“œë¡œ (redirectëŠ” try-catch ë°–ì—ì„œ í˜¸ì¶œ)
          redirect("/dashboard");
        }
      } catch (queryError) {
        // redirect ì—ëŸ¬ì¸ì§€ í™•ì¸
        if (
          queryError &&
          typeof queryError === "object" &&
          "digest" in queryError &&
          typeof (queryError as { digest: string }).digest === "string"
        ) {
          const digest = (queryError as { digest: string }).digest;
          // Next.jsì˜ ë¦¬ë‹¤ì´ë ‰íŠ¸ ì—ëŸ¬ëŠ” ì¬throw
          if (digest.startsWith("NEXT_REDIRECT")) {
            throw queryError;
          }
        }
        // ì¿¼ë¦¬ ì¤‘ ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ í‘œì‹œ
        if (process.env.NODE_ENV === "development") {
          console.error("[LoginPage] í•™ìƒ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜ˆì™¸ (ë¬´ì‹œë¨)", queryError);
        }
      }
    } else if (userRole.role === "superadmin") {
      // Super Adminì€ Super Admin ëŒ€ì‹œë³´ë“œë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      redirect("/superadmin/dashboard");
    } else if (userRole.role === "admin" || userRole.role === "consultant") {
      redirect("/admin/dashboard");
    } else if (userRole.role === "parent") {
      redirect("/parent/dashboard");
    }
  }

  return (
    <section className="mx-auto flex min-h-screen max-w-md flex-col justify-center gap-6 px-4">
      <LoginForm returnUrl={returnUrl} />
    </section>
  );
}
</file>

<file path="_components/TermsModal.tsx">
"use client";

import { useEffect, useState } from "react";
import { Dialog, DialogContent, DialogFooter } from "@/components/ui/Dialog";
import type { TermsContentType } from "@/lib/types/terms";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import Button from "@/components/atoms/Button";

type TermsModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  contentType: TermsContentType;
  title: string;
};

export function TermsModal({
  open,
  onOpenChange,
  contentType,
  title,
}: TermsModalProps) {
  const [content, setContent] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (open) {
      loadContent();
    } else {
      // ëª¨ë‹¬ì´ ë‹«í ë•Œ ìƒíƒœ ì´ˆê¸°í™”
      setContent(null);
      setError(null);
    }
  }, [open, contentType]);

  const loadContent = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/terms/${contentType}`);
      if (!response.ok) {
        throw new Error(`ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨: ${response.statusText}`);
      }
      const data = await response.json();
      if (data.content) {
        setContent(data.content);
      } else {
        setError("ì•½ê´€ ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange} title={title} size="2xl">
      <DialogContent>
        {loading && (
          <div className="flex items-center justify-center py-12">
            <div className="text-sm text-gray-500">ë¡œë”© ì¤‘...</div>
          </div>
        )}

        {error && (
          <div className="flex flex-col items-center justify-center py-12 gap-4">
            <div className="text-sm text-red-600">{error}</div>
            <Button onClick={loadContent} variant="outline" size="sm">
              ë‹¤ì‹œ ì‹œë„
            </Button>
          </div>
        )}

        {content && !loading && !error && (
          <div className="prose prose-sm max-w-none overflow-y-auto max-h-[60vh]">
            <ReactMarkdown remarkPlugins={[remarkGfm]}>
              {content}
            </ReactMarkdown>
          </div>
        )}
      </DialogContent>
      <DialogFooter>
        <Button onClick={() => onOpenChange(false)}>ë‹«ê¸°</Button>
      </DialogFooter>
    </Dialog>
  );
}
</file>

<file path="page.tsx">
"use client";

import Link from "next/link";
import { useActionState, useEffect, useState } from "react";
import { useRouter } from "next/navigation";

import { signUp } from "@/app/actions/auth";
import { getTenantOptionsForSignup } from "@/app/actions/tenants";
import type { TenantOption } from "@/app/actions/tenants";
import FormInput from "@/components/ui/FormInput";
import FormMessage from "@/components/ui/FormMessage";
import FormSubmitButton from "@/components/ui/FormSubmitButton";
import FormCheckbox from "@/components/ui/FormCheckbox";
import { TermsModal } from "./_components/TermsModal";

type SignupState = {
  error?: string;
  message?: string;
  redirect?: string;
};

const initialState: SignupState = { error: "", message: "" };

export default function SignupPage() {
  const router = useRouter();
  const [state, formAction] = useActionState<SignupState, FormData>(
    signUp,
    initialState
  );
  const [tenants, setTenants] = useState<TenantOption[]>([]);
  const [loadingTenants, setLoadingTenants] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedTenantId, setSelectedTenantId] = useState("");
  const [selectedRole, setSelectedRole] = useState<"student" | "parent" | "">("");
  const [termsModalOpen, setTermsModalOpen] = useState(false);
  const [privacyModalOpen, setPrivacyModalOpen] = useState(false);
  const [marketingModalOpen, setMarketingModalOpen] = useState(false);

  // ê¸°ê´€ ëª©ë¡ ë¡œë“œ
  useEffect(() => {
    const loadTenants = async () => {
      try {
        const data = await getTenantOptionsForSignup();
        if (data.length === 0) {
          console.warn("[signup] ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤.");
        }
        setTenants(data);
      } catch (error) {
        console.error("[signup] ê¸°ê´€ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:", error);
        // ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •í•˜ì—¬ UIê°€ ì ì ˆíˆ í‘œì‹œë˜ë„ë¡ í•¨
        setTenants([]);
      } finally {
        setLoadingTenants(false);
      }
    };

    loadTenants();
  }, []);

  // íšŒì›ê°€ì… ì„±ê³µ ì‹œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  useEffect(() => {
    if (state?.redirect && state?.message && !state?.error) {
      const timer = setTimeout(() => {
        router.push(`${state.redirect}?message=${encodeURIComponent(state.message!)}`);
      }, 500); // ì§§ì€ ë”œë ˆì´ë¡œ ë©”ì‹œì§€ í‘œì‹œ í›„ ë¦¬ë‹¤ì´ë ‰íŠ¸
      return () => clearTimeout(timer);
    }
  }, [state, router]);

  // ê²€ìƒ‰ í•„í„°ë§
  const filteredTenants = tenants.filter((tenant) =>
    tenant.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <section className="mx-auto flex min-h-screen max-w-md flex-col justify-center gap-6 px-4">
      <div>
        <h1 className="text-3xl font-semibold">íšŒì›ê°€ì…</h1>
        <p className="text-sm text-neutral-500">
          ì´ë¯¸ ê³„ì •ì´ ìˆë‹¤ë©´{" "}
          <Link href="/login" className="text-black underline">
            ë¡œê·¸ì¸
          </Link>
          í•´ì£¼ì„¸ìš”.
        </p>
      </div>

      <form action={formAction} className="flex flex-col gap-4">
        <FormInput
          label="í‘œì‹œ ì´ë¦„"
          name="displayName"
          type="text"
          required
          placeholder="í™ê¸¸ë™"
        />

        <FormInput
          label="ì´ë©”ì¼"
          name="email"
          type="email"
          required
          placeholder="you@example.com"
        />

        <FormInput
          label="ë¹„ë°€ë²ˆí˜¸"
          name="password"
          type="password"
          required
          placeholder="ìµœì†Œ 6ì ì´ìƒ"
        />

        {/* ê¸°ê´€ ì„ íƒ */}
        <div className="flex flex-col gap-2">
          <label htmlFor="tenant_id" className="text-sm font-medium text-gray-700">
            ì†Œì† ê¸°ê´€ <span className="text-red-500">*</span>
          </label>
          {loadingTenants ? (
            <div className="text-sm text-gray-500">ê¸°ê´€ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
          ) : tenants.length === 0 ? (
            <div className="text-sm text-red-500">
              ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.
            </div>
          ) : (
            <>
              <input
                type="text"
                placeholder="ê¸°ê´€ëª…ìœ¼ë¡œ ê²€ìƒ‰... (ì„ íƒì‚¬í•­)"
                value={searchQuery}
                onChange={(e) => {
                  setSearchQuery(e.target.value);
                  // ê²€ìƒ‰ ì‹œ ì„ íƒ í•´ì œ
                  if (e.target.value && !filteredTenants.find(t => t.id === selectedTenantId)) {
                    setSelectedTenantId("");
                  }
                }}
                className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
              />
              <select
                id="tenant_id"
                name="tenant_id"
                required
                value={selectedTenantId}
                onChange={(e) => setSelectedTenantId(e.target.value)}
                className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
              >
                <option value="">ê¸°ê´€ì„ ì„ íƒí•˜ì„¸ìš”</option>
                {filteredTenants.length === 0 ? (
                  <option value="" disabled>
                    {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤" : "ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤"}
                  </option>
                ) : (
                  filteredTenants.map((tenant) => (
                    <option key={tenant.id} value={tenant.id}>
                      {tenant.name} {tenant.type ? `(${tenant.type})` : ""}
                    </option>
                  ))
                )}
              </select>
              {searchQuery && filteredTenants.length === 0 && (
                <p className="text-xs text-gray-500">
                  ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ê²€ìƒ‰ì–´ë¥¼ ì§€ìš°ê³  ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”.
                </p>
              )}
              {tenants.length > 0 && (
                <p className="text-xs text-gray-500">
                  ì´ {tenants.length}ê°œì˜ ê¸°ê´€ì´ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
                </p>
              )}
            </>
          )}
        </div>

        {/* ê¶Œí•œ ì„ íƒ */}
        <div className="flex flex-col gap-2">
          <label htmlFor="role" className="text-sm font-medium text-gray-700">
            íšŒì› ìœ í˜• <span className="text-red-500">*</span>
          </label>
          <select
            id="role"
            name="role"
            required
            value={selectedRole}
            onChange={(e) => setSelectedRole(e.target.value as "student" | "parent")}
            className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
          >
            <option value="">íšŒì› ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”</option>
            <option value="student">í•™ìƒ</option>
            <option value="parent">í•™ë¶€ëª¨</option>
          </select>
          <p className="text-xs text-gray-500">
            í•™ìƒ: í•™ìŠµ ê³„íš ë° ì„±ì  ê´€ë¦¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•™ë¶€ëª¨: ìë…€ì˜ í•™ìŠµ í˜„í™©ì„ í™•ì¸í•©ë‹ˆë‹¤.
          </p>
        </div>

        {/* ì•½ê´€ ë™ì˜ */}
        <div className="flex flex-col gap-3 rounded-lg border border-gray-200 p-4">
          <h3 className="text-sm font-medium text-gray-900">ì•½ê´€ ë™ì˜</h3>
          <div className="flex flex-col gap-3">
            {/* ì´ìš©ì•½ê´€ (í•„ìˆ˜) */}
            <FormCheckbox
              name="consent_terms"
              required
              label={
                <>
                  <button
                    type="button"
                    onClick={(e) => {
                      e.preventDefault();
                      setTermsModalOpen(true);
                    }}
                    className="text-indigo-600 hover:text-indigo-800 underline"
                  >
                    ì´ìš©ì•½ê´€
                  </button>
                  ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-red-500">(í•„ìˆ˜)</span>
                </>
              }
            />

            {/* ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨ (í•„ìˆ˜) */}
            <FormCheckbox
              name="consent_privacy"
              required
              label={
                <>
                  <button
                    type="button"
                    onClick={(e) => {
                      e.preventDefault();
                      setPrivacyModalOpen(true);
                    }}
                    className="text-indigo-600 hover:text-indigo-800 underline"
                  >
                    ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨
                  </button>
                  ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-red-500">(í•„ìˆ˜)</span>
                </>
              }
            />

            {/* ë§ˆì¼€íŒ… í™œìš© ë™ì˜ (ì„ íƒ) */}
            <FormCheckbox
              name="consent_marketing"
              label={
                <>
                  ë§ˆì¼€íŒ… ì •ë³´ ìˆ˜ì‹ ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-gray-500">(ì„ íƒ)</span>
                </>
              }
            />
          </div>
        </div>

        {state?.error && <FormMessage type="error" message={state.error} />}

        {state?.message && !state.error && (
          <FormMessage type="success" message={state.message} />
        )}

        <FormSubmitButton
          defaultText="íšŒì›ê°€ì…"
          pendingText="íšŒì›ê°€ì… ì¤‘..."
        />
      </form>

      {/* ì•½ê´€ ëª¨ë‹¬ */}
      <TermsModal
        open={termsModalOpen}
        onOpenChange={setTermsModalOpen}
        contentType="terms"
        title="ì´ìš©ì•½ê´€"
      />
      <TermsModal
        open={privacyModalOpen}
        onOpenChange={setPrivacyModalOpen}
        contentType="privacy"
        title="ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨"
      />
      <TermsModal
        open={marketingModalOpen}
        onOpenChange={setMarketingModalOpen}
        contentType="marketing"
        title="ë§ˆì¼€íŒ… í™œìš© ë™ì˜"
      />
    </section>
  );
}
</file>

<file path="page.tsx">
"use client";

import Link from "next/link";
import { useActionState, useEffect, useState } from "react";
import { useRouter } from "next/navigation";

import { signUp } from "@/app/actions/auth";
import { getTenantOptionsForSignup } from "@/app/actions/tenants";
import type { TenantOption } from "@/app/actions/tenants";
import FormInput from "@/components/ui/FormInput";
import FormMessage from "@/components/ui/FormMessage";
import FormSubmitButton from "@/components/ui/FormSubmitButton";
import FormCheckbox from "@/components/ui/FormCheckbox";
import { TermsModal } from "./_components/TermsModal";

type SignupState = {
  error?: string;
  message?: string;
  redirect?: string;
};

const initialState: SignupState = { error: "", message: "" };

export default function SignupPage() {
  const router = useRouter();
  const [state, formAction] = useActionState<SignupState, FormData>(
    signUp,
    initialState
  );
  const [tenants, setTenants] = useState<TenantOption[]>([]);
  const [loadingTenants, setLoadingTenants] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedTenantId, setSelectedTenantId] = useState("");
  const [selectedRole, setSelectedRole] = useState<"student" | "parent" | "">("");
  const [termsModalOpen, setTermsModalOpen] = useState(false);
  const [privacyModalOpen, setPrivacyModalOpen] = useState(false);
  const [marketingModalOpen, setMarketingModalOpen] = useState(false);

  // ê¸°ê´€ ëª©ë¡ ë¡œë“œ
  useEffect(() => {
    const loadTenants = async () => {
      try {
        const data = await getTenantOptionsForSignup();
        if (data.length === 0) {
          console.warn("[signup] ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤.");
        }
        setTenants(data);
      } catch (error) {
        console.error("[signup] ê¸°ê´€ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:", error);
        // ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •í•˜ì—¬ UIê°€ ì ì ˆíˆ í‘œì‹œë˜ë„ë¡ í•¨
        setTenants([]);
      } finally {
        setLoadingTenants(false);
      }
    };

    loadTenants();
  }, []);

  // íšŒì›ê°€ì… ì„±ê³µ ì‹œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  useEffect(() => {
    if (state?.redirect && state?.message && !state?.error) {
      const timer = setTimeout(() => {
        router.push(`${state.redirect}?message=${encodeURIComponent(state.message!)}`);
      }, 500); // ì§§ì€ ë”œë ˆì´ë¡œ ë©”ì‹œì§€ í‘œì‹œ í›„ ë¦¬ë‹¤ì´ë ‰íŠ¸
      return () => clearTimeout(timer);
    }
  }, [state, router]);

  // ê²€ìƒ‰ í•„í„°ë§
  const filteredTenants = tenants.filter((tenant) =>
    tenant.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <section className="mx-auto flex min-h-screen max-w-md flex-col justify-center gap-6 px-4">
      <div>
        <h1 className="text-3xl font-semibold">íšŒì›ê°€ì…</h1>
        <p className="text-sm text-neutral-500">
          ì´ë¯¸ ê³„ì •ì´ ìˆë‹¤ë©´{" "}
          <Link href="/login" className="text-black underline">
            ë¡œê·¸ì¸
          </Link>
          í•´ì£¼ì„¸ìš”.
        </p>
      </div>

      <form action={formAction} className="flex flex-col gap-4">
        <FormInput
          label="í‘œì‹œ ì´ë¦„"
          name="displayName"
          type="text"
          required
          placeholder="í™ê¸¸ë™"
        />

        <FormInput
          label="ì´ë©”ì¼"
          name="email"
          type="email"
          required
          placeholder="you@example.com"
        />

        <FormInput
          label="ë¹„ë°€ë²ˆí˜¸"
          name="password"
          type="password"
          required
          placeholder="ìµœì†Œ 6ì ì´ìƒ"
        />

        {/* ê¸°ê´€ ì„ íƒ */}
        <div className="flex flex-col gap-2">
          <label htmlFor="tenant_id" className="text-sm font-medium text-gray-700">
            ì†Œì† ê¸°ê´€ <span className="text-red-500">*</span>
          </label>
          {loadingTenants ? (
            <div className="text-sm text-gray-500">ê¸°ê´€ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
          ) : tenants.length === 0 ? (
            <div className="text-sm text-red-500">
              ë“±ë¡ëœ ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.
            </div>
          ) : (
            <>
              <input
                type="text"
                placeholder="ê¸°ê´€ëª…ìœ¼ë¡œ ê²€ìƒ‰... (ì„ íƒì‚¬í•­)"
                value={searchQuery}
                onChange={(e) => {
                  setSearchQuery(e.target.value);
                  // ê²€ìƒ‰ ì‹œ ì„ íƒ í•´ì œ
                  if (e.target.value && !filteredTenants.find(t => t.id === selectedTenantId)) {
                    setSelectedTenantId("");
                  }
                }}
                className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
              />
              <select
                id="tenant_id"
                name="tenant_id"
                required
                value={selectedTenantId}
                onChange={(e) => setSelectedTenantId(e.target.value)}
                className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
              >
                <option value="">ê¸°ê´€ì„ ì„ íƒí•˜ì„¸ìš”</option>
                {filteredTenants.length === 0 ? (
                  <option value="" disabled>
                    {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤" : "ê¸°ê´€ì´ ì—†ìŠµë‹ˆë‹¤"}
                  </option>
                ) : (
                  filteredTenants.map((tenant) => (
                    <option key={tenant.id} value={tenant.id}>
                      {tenant.name} {tenant.type ? `(${tenant.type})` : ""}
                    </option>
                  ))
                )}
              </select>
              {searchQuery && filteredTenants.length === 0 && (
                <p className="text-xs text-gray-500">
                  ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ê²€ìƒ‰ì–´ë¥¼ ì§€ìš°ê³  ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”.
                </p>
              )}
              {tenants.length > 0 && (
                <p className="text-xs text-gray-500">
                  ì´ {tenants.length}ê°œì˜ ê¸°ê´€ì´ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
                </p>
              )}
            </>
          )}
        </div>

        {/* ê¶Œí•œ ì„ íƒ */}
        <div className="flex flex-col gap-2">
          <label htmlFor="role" className="text-sm font-medium text-gray-700">
            íšŒì› ìœ í˜• <span className="text-red-500">*</span>
          </label>
          <select
            id="role"
            name="role"
            required
            value={selectedRole}
            onChange={(e) => setSelectedRole(e.target.value as "student" | "parent")}
            className="w-full rounded-lg border border-gray-300 px-4 py-2 text-sm"
          >
            <option value="">íšŒì› ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”</option>
            <option value="student">í•™ìƒ</option>
            <option value="parent">í•™ë¶€ëª¨</option>
          </select>
          <p className="text-xs text-gray-500">
            í•™ìƒ: í•™ìŠµ ê³„íš ë° ì„±ì  ê´€ë¦¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•™ë¶€ëª¨: ìë…€ì˜ í•™ìŠµ í˜„í™©ì„ í™•ì¸í•©ë‹ˆë‹¤.
          </p>
        </div>

        {/* ì•½ê´€ ë™ì˜ */}
        <div className="flex flex-col gap-3 rounded-lg border border-gray-200 p-4">
          <h3 className="text-sm font-medium text-gray-900">ì•½ê´€ ë™ì˜</h3>
          <div className="flex flex-col gap-3">
            {/* ì´ìš©ì•½ê´€ (í•„ìˆ˜) */}
            <FormCheckbox
              name="consent_terms"
              required
              label={
                <>
                  <button
                    type="button"
                    onClick={(e) => {
                      e.preventDefault();
                      setTermsModalOpen(true);
                    }}
                    className="text-indigo-600 hover:text-indigo-800 underline"
                  >
                    ì´ìš©ì•½ê´€
                  </button>
                  ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-red-500">(í•„ìˆ˜)</span>
                </>
              }
            />

            {/* ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨ (í•„ìˆ˜) */}
            <FormCheckbox
              name="consent_privacy"
              required
              label={
                <>
                  <button
                    type="button"
                    onClick={(e) => {
                      e.preventDefault();
                      setPrivacyModalOpen(true);
                    }}
                    className="text-indigo-600 hover:text-indigo-800 underline"
                  >
                    ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨
                  </button>
                  ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-red-500">(í•„ìˆ˜)</span>
                </>
              }
            />

            {/* ë§ˆì¼€íŒ… í™œìš© ë™ì˜ (ì„ íƒ) */}
            <FormCheckbox
              name="consent_marketing"
              label={
                <>
                  ë§ˆì¼€íŒ… ì •ë³´ ìˆ˜ì‹ ì— ë™ì˜í•©ë‹ˆë‹¤ <span className="text-gray-500">(ì„ íƒ)</span>
                </>
              }
            />
          </div>
        </div>

        {state?.error && <FormMessage type="error" message={state.error} />}

        {state?.message && !state.error && (
          <FormMessage type="success" message={state.message} />
        )}

        <FormSubmitButton
          defaultText="íšŒì›ê°€ì…"
          pendingText="íšŒì›ê°€ì… ì¤‘..."
        />
      </form>

      {/* ì•½ê´€ ëª¨ë‹¬ */}
      <TermsModal
        open={termsModalOpen}
        onOpenChange={setTermsModalOpen}
        contentType="terms"
        title="ì´ìš©ì•½ê´€"
      />
      <TermsModal
        open={privacyModalOpen}
        onOpenChange={setPrivacyModalOpen}
        contentType="privacy"
        title="ê°œì¸ì •ë³´ì·¨ê¸‰ë°©ì¹¨"
      />
      <TermsModal
        open={marketingModalOpen}
        onOpenChange={setMarketingModalOpen}
        contentType="marketing"
        title="ë§ˆì¼€íŒ… í™œìš© ë™ì˜"
      />
    </section>
  );
}
</file>

<file path="scores/mock.ts">
// ì´ íŒŒì¼ì€ app/(student)/actions/scoreActions.tsë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
// ê¸°ì¡´ importë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”:
// - addMockScore â†’ app/(student)/actions/scoreActions.ts
// - updateMockScore â†’ app/(student)/actions/scoreActions.ts (updateMockScoreActionìœ¼ë¡œ ë³€ê²½)
// - deleteMockScore â†’ app/(student)/actions/scoreActions.ts (deleteMockScoreActionìœ¼ë¡œ ë³€ê²½)

export {
  addMockScore,
  updateMockScoreAction as updateMockScore,
  deleteMockScoreAction as deleteMockScore,
} from "@/app/(student)/actions/scoreActions";
</file>

<file path="scores/school.ts">
// ì´ íŒŒì¼ì€ app/(student)/actions/scoreActions.tsë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
// ê¸°ì¡´ importë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”:
// - addSchoolScore â†’ app/(student)/actions/scoreActions.ts
// - updateSchoolScore â†’ app/(student)/actions/scoreActions.ts (updateSchoolScoreActionìœ¼ë¡œ ë³€ê²½)
// - deleteSchoolScore â†’ app/(student)/actions/scoreActions.ts (deleteSchoolScoreActionìœ¼ë¡œ ë³€ê²½)

export {
  addSchoolScore,
  updateSchoolScoreAction as updateSchoolScore,
  deleteSchoolScoreAction as deleteSchoolScore,
} from "@/app/(student)/actions/scoreActions";
</file>

<file path="auth.ts">
"use server";

import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";
import { saveUserSession } from "@/lib/auth/sessionManager";
import { getDefaultTenant } from "@/lib/data/tenants";
import { DATABASE_ERROR_CODES } from "@/lib/constants/databaseErrorCodes";
import type { SignupRole, SignupMetadata, UserWithSignupMetadata } from "@/lib/types/auth";
import { z } from "zod";
import { getEmailRedirectUrl } from "@/lib/utils/getEmailRedirectUrl";
import { saveUserConsents } from "@/lib/data/userConsents";

const signInSchema = z.object({
  email: z.string().email("ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.").min(1, "ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."),
  password: z.string().min(1, "ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."),
});

async function _signIn(formData: FormData): Promise<{ error?: string; needsEmailVerification?: boolean; email?: string }> {
  const email = String(formData.get("email") ?? "").trim();
  const password = String(formData.get("password") ?? "").trim();
  const rememberMe = formData.get("rememberMe") === "on";
  const returnUrl = String(formData.get("returnUrl") ?? "").trim();

  // ì…ë ¥ ê²€ì¦
  const validation = signInSchema.safeParse({ email, password });
  if (!validation.success) {
    const firstError = validation.error.issues[0];
    throw new AppError(
      firstError?.message || "ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  const supabase = await createSupabaseServerClient(undefined, { rememberMe });
  const { data, error } = await supabase.auth.signInWithPassword({
    email: validation.data.email,
    password: validation.data.password,
  });

  // ë¡œê·¸ì¸ ì„±ê³µ ì‹œ ì„¸ì…˜ ì •ë³´ ì €ì¥ ë° ë ˆì½”ë“œ í™•ì¸
  if (data?.session && data.user) {
    const expiresAt = data.session.expires_at
      ? new Date(data.session.expires_at * 1000)
      : undefined;
    
    // ì„¸ì…˜ ì •ë³´ ì €ì¥ (ë¹„ë™ê¸°, ì‹¤íŒ¨í•´ë„ ë¡œê·¸ì¸ì€ ê³„ì† ì§„í–‰)
    saveUserSession(
      data.user.id,
      data.session.access_token,
      expiresAt
    ).catch((err) => {
      console.error("[auth] ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œë¨):", err);
    });

    // ì²« ë¡œê·¸ì¸ ì‹œ ë ˆì½”ë“œ í™•ì¸ ë° ìƒì„± (ì™„ì „í•œ ì¸ì¦ ìƒíƒœì´ë¯€ë¡œ RLS ì •ì±… ì •ìƒ ì‘ë™)
    // ì‹¤íŒ¨í•´ë„ ë¡œê·¸ì¸ì€ ê³„ì† ì§„í–‰
    ensureUserRecord(data.user).catch((err) => {
      console.error("[auth] ë ˆì½”ë“œ í™•ì¸/ìƒì„± ì‹¤íŒ¨ (ë¬´ì‹œë¨):", err);
    });
  }

  if (error) {
    // ì´ë©”ì¼ ë¯¸ì¸ì¦ ì˜¤ë¥˜ì¸ì§€ ì •í™•í•˜ê²Œ í™•ì¸
    // Supabaseì˜ ì´ë©”ì¼ ë¯¸ì¸ì¦ ì—ëŸ¬ëŠ” íŠ¹ì • ë©”ì‹œì§€ë¥¼ í¬í•¨í•©ë‹ˆë‹¤
    const errorMessage = error.message?.toLowerCase() || "";
    const emailNotConfirmedMessages = [
      "email not confirmed",
      "email not verified",
      "email address not confirmed",
      "user email not confirmed",
    ];
    
    const isEmailNotConfirmed = emailNotConfirmedMessages.some(
      (msg) => errorMessage.includes(msg)
    );

    // ì •í™•í•œ ì´ë©”ì¼ ë¯¸ì¸ì¦ ì—ëŸ¬ì¸ ê²½ìš°ì—ë§Œ ì²˜ë¦¬
    // error.status === 400ë§Œìœ¼ë¡œëŠ” íŒë‹¨í•˜ì§€ ì•ŠìŒ (ë¹„ë°€ë²ˆí˜¸ ì˜¤ë¥˜ë„ 400ì¼ ìˆ˜ ìˆìŒ)
    if (isEmailNotConfirmed) {
      console.log("[auth] ì´ë©”ì¼ ë¯¸ì¸ì¦ ê°ì§€:", {
        email: validation.data.email,
        errorMessage: error.message,
        errorStatus: error.status,
      });

      return {
        error: "ì´ë©”ì¼ ì¸ì¦ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•˜ì—¬ ì¸ì¦ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.",
        needsEmailVerification: true,
        email: validation.data.email,
      };
    }

    // ì´ë©”ì¼ ë¯¸ì¸ì¦ì´ ì•„ë‹Œ ë‹¤ë¥¸ ì—ëŸ¬ì¸ ê²½ìš° ë¡œê¹…
    console.log("[auth] ë¡œê·¸ì¸ ì‹¤íŒ¨:", {
      email: validation.data.email,
      errorMessage: error.message,
      errorStatus: error.status,
    });

    // ì¸ì¦ ì‹¤íŒ¨ëŠ” ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ìˆ˜ ìˆëŠ” ì—ëŸ¬
    throw new AppError(
      error.message || "ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.UNAUTHORIZED,
      401,
      true
    );
  }

  // ë¡œê·¸ì¸ ì„±ê³µ ì‹œ returnUrlì´ ìˆìœ¼ë©´ í•´ë‹¹ URLë¡œ, ì—†ìœ¼ë©´ ë£¨íŠ¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (returnUrl) {
    redirect(decodeURIComponent(returnUrl));
  } else {
    // ë£¨íŠ¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ (ì—­í• ë³„ ë¦¬ë‹¤ì´ë ‰íŠ¸ëŠ” ë£¨íŠ¸ í˜ì´ì§€ì—ì„œ ì²˜ë¦¬)
    redirect("/");
  }
}

// ì—ëŸ¬ í•¸ë“¤ë§ ë˜í¼ ì ìš©
// _signInì€ ì´ì œ ê°ì²´ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì§ì ‘ export
export const signIn = _signIn;

/**
 * ì²« ë¡œê·¸ì¸ ì‹œ ì‚¬ìš©ì ë ˆì½”ë“œ í™•ì¸ ë° ìƒì„±
 * ì´ë©”ì¼ ì¸ì¦ ì™„ë£Œ í›„ ì²« ë¡œê·¸ì¸ ì‹œì ì— í˜¸ì¶œë˜ë©°, ì™„ì „í•œ ì¸ì¦ ìƒíƒœì´ë¯€ë¡œ RLS ì •ì±…ì´ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤.
 */
async function ensureUserRecord(
  user: UserWithSignupMetadata
): Promise<void> {
  try {
    const metadata = user.user_metadata;
    const signupRole = metadata?.signup_role;
    
    // signup_roleì´ ì—†ìœ¼ë©´ ë ˆì½”ë“œ ìƒì„± ì‹œë„í•˜ì§€ ì•ŠìŒ
    if (!signupRole || (signupRole !== "student" && signupRole !== "parent")) {
      return;
    }

    const supabase = await createSupabaseServerClient();
    const tenantId = metadata?.tenant_id;
    const displayName = metadata?.display_name;

    if (signupRole === "student") {
      // students í…Œì´ë¸”ì— ë ˆì½”ë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
      const { data: student, error: checkError } = await supabase
        .from("students")
        .select("id")
        .eq("id", user.id)
        .maybeSingle();

      if (checkError) {
        console.error("[auth] í•™ìƒ ë ˆì½”ë“œ í™•ì¸ ì‹¤íŒ¨", {
          userId: user.id,
          error: checkError.message,
          code: checkError.code,
        });
        return;
      }

      // ë ˆì½”ë“œê°€ ì—†ìœ¼ë©´ ìƒì„± ì‹œë„
      if (!student) {
        const result = await createStudentRecord(user.id, tenantId, displayName);
        if (result.success) {
          console.log("[auth] ì²« ë¡œê·¸ì¸ ì‹œ í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì„±ê³µ", {
            userId: user.id,
            tenantId: tenantId || "ê¸°ë³¸ tenant",
          });
        } else {
          console.error("[auth] ì²« ë¡œê·¸ì¸ ì‹œ í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨", {
            userId: user.id,
            error: result.error,
          });
        }
      } else {
        console.log("[auth] í•™ìƒ ë ˆì½”ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.", { userId: user.id });
      }
    } else if (signupRole === "parent") {
      // parent_users í…Œì´ë¸”ì— ë ˆì½”ë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
      const { data: parent, error: checkError } = await supabase
        .from("parent_users")
        .select("id")
        .eq("id", user.id)
        .maybeSingle();

      if (checkError) {
        console.error("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œ í™•ì¸ ì‹¤íŒ¨", {
          userId: user.id,
          error: checkError.message,
          code: checkError.code,
        });
        return;
      }

      // ë ˆì½”ë“œê°€ ì—†ìœ¼ë©´ ìƒì„± ì‹œë„
      if (!parent) {
        const result = await createParentRecord(user.id, tenantId, displayName);
        if (result.success) {
          console.log("[auth] ì²« ë¡œê·¸ì¸ ì‹œ í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì„±ê³µ", {
            userId: user.id,
            tenantId: tenantId || "ê¸°ë³¸ tenant ë˜ëŠ” null",
          });
        } else {
          console.error("[auth] ì²« ë¡œê·¸ì¸ ì‹œ í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨", {
            userId: user.id,
            error: result.error,
          });
        }
      } else {
        console.log("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.", { userId: user.id });
      }
    }
  } catch (error) {
    // ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨ëŠ” ë¡œê·¸ì¸ ì„±ê³µì— ì˜í–¥ ì—†ìŒ
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[auth] ensureUserRecord ì˜ˆì™¸", {
      userId: user.id,
      error: errorMessage,
    });
  }
}

/**
 * íšŒì›ê°€ì… ì‹œ í•™ìƒ ë ˆì½”ë“œ ìƒì„±
 */
async function createStudentRecord(
  userId: string,
  tenantId: string | null | undefined,
  displayName?: string | null
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    // tenant_idê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ tenant ì¡°íšŒ
    let finalTenantId = tenantId;
    if (!finalTenantId) {
      const defaultTenant = await getDefaultTenant();
      if (!defaultTenant) {
        console.error("[auth] Default Tenantê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨");
        return {
          success: false,
          error: "ê¸°ë³¸ ê¸°ê´€ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
        };
      }
      finalTenantId = defaultTenant.id;
    }

    // students í…Œì´ë¸”ì— ìµœì†Œ í•„ë“œë¡œ ë ˆì½”ë“œ ìƒì„±
    // name í•„ë“œëŠ” NOT NULL ì œì•½ì¡°ê±´ì´ ìˆìœ¼ë¯€ë¡œ displayNameì„ í¬í•¨
    // displayNameì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ ì‚¬ìš© (NOT NULL ì œì•½ì¡°ê±´ ì¶©ì¡±)
    const { error } = await supabase.from("students").insert({
      id: userId,
      tenant_id: finalTenantId,
      name: displayName || "",
    });

    if (error) {
      // UNIQUE constraint violation (ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°)ëŠ” ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
      if (error.code === DATABASE_ERROR_CODES.UNIQUE_VIOLATION) {
        console.log("[auth] í•™ìƒ ë ˆì½”ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.", { userId });
        return { success: true };
      }

      // RLS ì •ì±… ìœ„ë°˜ ì—ëŸ¬ ëª…ì‹œì  ì²˜ë¦¬
      if (error.code === DATABASE_ERROR_CODES.RLS_POLICY_VIOLATION) {
        console.error("[auth] í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨ - RLS ì •ì±… ìœ„ë°˜", {
          userId,
          tenantId: finalTenantId,
          error: error.message,
          code: error.code,
        });
        return {
          success: false,
          error: "ë ˆì½”ë“œ ìƒì„± ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. RLS ì •ì±…ì„ í™•ì¸í•˜ì„¸ìš”.",
        };
      }

      console.error("[auth] í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨", {
        userId,
        tenantId: finalTenantId,
        error: error.message,
        code: error.code,
      });
      return {
        success: false,
        error: error.message || "í•™ìƒ ë ˆì½”ë“œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    console.log("[auth] í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì„±ê³µ", { userId, tenantId: finalTenantId });
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[auth] createStudentRecord ì˜ˆì™¸", {
      userId,
      error: errorMessage,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * íšŒì›ê°€ì… ì‹œ í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„±
 */
async function createParentRecord(
  userId: string,
  tenantId: string | null | undefined,
  displayName?: string | null
): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = await createSupabaseServerClient();

    // tenant_idê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ tenant ì¡°íšŒ (nullableì´ë¯€ë¡œ ì„ íƒì‚¬í•­)
    let finalTenantId = tenantId;
    if (!finalTenantId) {
      const defaultTenant = await getDefaultTenant();
      if (defaultTenant) {
        finalTenantId = defaultTenant.id;
      }
      // defaultTenantê°€ ì—†ì–´ë„ parent_usersëŠ” nullableì´ë¯€ë¡œ ê³„ì† ì§„í–‰
    }

    // parent_users í…Œì´ë¸”ì— ìµœì†Œ í•„ë“œë¡œ ë ˆì½”ë“œ ìƒì„±
    // name í•„ë“œëŠ” NOT NULL ì œì•½ì¡°ê±´ì´ ìˆìœ¼ë¯€ë¡œ displayNameì„ í¬í•¨
    // displayNameì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ ì‚¬ìš© (NOT NULL ì œì•½ì¡°ê±´ ì¶©ì¡±)
    const { error } = await supabase.from("parent_users").insert({
      id: userId,
      tenant_id: finalTenantId ?? null,
      name: displayName || "",
    });

    if (error) {
      // UNIQUE constraint violation (ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš°)ëŠ” ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
      if (error.code === DATABASE_ERROR_CODES.UNIQUE_VIOLATION) {
        console.log("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.", { userId });
        return { success: true };
      }

      // RLS ì •ì±… ìœ„ë°˜ ì—ëŸ¬ ëª…ì‹œì  ì²˜ë¦¬
      if (error.code === DATABASE_ERROR_CODES.RLS_POLICY_VIOLATION) {
        console.error("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨ - RLS ì •ì±… ìœ„ë°˜", {
          userId,
          tenantId: finalTenantId,
          error: error.message,
          code: error.code,
        });
        return {
          success: false,
          error: "ë ˆì½”ë“œ ìƒì„± ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. RLS ì •ì±…ì„ í™•ì¸í•˜ì„¸ìš”.",
        };
      }

      console.error("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨", {
        userId,
        tenantId: finalTenantId,
        error: error.message,
        code: error.code,
      });
      return {
        success: false,
        error: error.message || "í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    console.log("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì„±ê³µ", { userId, tenantId: finalTenantId });
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[auth] createParentRecord ì˜ˆì™¸", {
      userId,
      error: errorMessage,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

const signUpSchema = z.object({
  email: z.string().email("ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.").min(1, "ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."),
  password: z.string().min(6, "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 6ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤."),
  displayName: z.string().min(1, "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.").max(100, "ì´ë¦„ì€ 100ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤."),
  tenantId: z.string().min(1, "ê¸°ê´€ì„ ì„ íƒí•´ì£¼ì„¸ìš”.").optional(),
  role: z.enum(["student", "parent"]).optional(),
});

export async function signUp(
  prevState: { error?: string; message?: string } | null,
  formData: FormData
): Promise<{ error?: string; message?: string; redirect?: string }> {
  const email = String(formData.get("email") ?? "").trim();
  const password = String(formData.get("password") ?? "").trim();
  const displayName = String(formData.get("displayName") ?? "").trim();
  const tenantId = String(formData.get("tenant_id") ?? "").trim();
  const role = String(formData.get("role") ?? "").trim() as "student" | "parent" | "";

  // ì•½ê´€ ë™ì˜ ì •ë³´ ì¶”ì¶œ
  const consentTerms = formData.get("consent_terms") === "on";
  const consentPrivacy = formData.get("consent_privacy") === "on";
  const consentMarketing = formData.get("consent_marketing") === "on";

  // í•„ìˆ˜ ì•½ê´€ ì²´í¬
  if (!consentTerms || !consentPrivacy) {
    return { error: "í•„ìˆ˜ ì•½ê´€ì— ë™ì˜í•´ì£¼ì„¸ìš”." };
  }

  // ì…ë ¥ ê²€ì¦
  const validation = signUpSchema.safeParse({ email, password, displayName, tenantId, role: role || undefined });
  if (!validation.success) {
    const firstError = validation.error.issues[0];
    return { error: firstError?.message || "ëª¨ë“  í•„ë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•´ì£¼ì„¸ìš”." };
  }

  try {
    const supabase = await createSupabaseServerClient();
    const emailRedirectTo = await getEmailRedirectUrl();
    const { data: authData, error } = await supabase.auth.signUp({
      email: validation.data.email,
      password: validation.data.password,
      options: {
        emailRedirectTo: emailRedirectTo,
        data: {
          display_name: validation.data.displayName,
          tenant_id: validation.data.tenantId || null, // ê¸°ê´€ IDë¥¼ user_metadataì— ì €ì¥
          signup_role: validation.data.role || null, // íšŒì›ê°€ì… ì‹œ ì„ íƒí•œ ê¶Œí•œ ì €ì¥
        },
      },
    });

    if (error) {
      return { error: error.message || "íšŒì›ê°€ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." };
    }

    // íšŒì›ê°€ì… ì„±ê³µ ì‹œ ë ˆì½”ë“œ ìƒì„± ì‹œë„
    if (authData.user) {
      const role = validation.data.role;
      const tenantId = validation.data.tenantId || null;
      const displayName = validation.data.displayName;

      if (role === "student") {
        const result = await createStudentRecord(authData.user.id, tenantId, displayName);
        if (!result.success) {
          // ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨ëŠ” ë¡œê¹…ë§Œ í•˜ê³  íšŒì›ê°€ì…ì€ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
          console.error("[auth] í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨:", result.error);
        }
      } else if (role === "parent") {
        const result = await createParentRecord(authData.user.id, tenantId, displayName);
        if (!result.success) {
          // ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨ëŠ” ë¡œê¹…ë§Œ í•˜ê³  íšŒì›ê°€ì…ì€ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
          console.error("[auth] í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨:", result.error);
        }
      }

      // ì•½ê´€ ë™ì˜ ì •ë³´ ì €ì¥
      const consentResult = await saveUserConsents(
        authData.user.id,
        {
          terms: consentTerms,
          privacy: consentPrivacy,
          marketing: consentMarketing,
        }
      );

      if (!consentResult.success) {
        // ì•½ê´€ ë™ì˜ ì €ì¥ ì‹¤íŒ¨ëŠ” ë¡œê¹…ë§Œ í•˜ê³  íšŒì›ê°€ì…ì€ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
        console.error("[auth] ì•½ê´€ ë™ì˜ ì €ì¥ ì‹¤íŒ¨:", consentResult.error);
      }
    }

    // íšŒì›ê°€ì… ì„±ê³µ - ì´ë©”ì¼ í™•ì¸ ì•ˆë‚´ì™€ í•¨ê»˜ ë¦¬ë‹¤ì´ë ‰íŠ¸
    return {
      message:
        "íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ê°€ì…í•˜ì‹  ì´ë©”ì¼ ì£¼ì†Œë¡œ ì¸ì¦ ë©”ì¼ì„ ë°œì†¡í–ˆìŠµë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•˜ì—¬ ê³„ì •ì„ í™œì„±í™”í•´ì£¼ì„¸ìš”.",
      redirect: "/login",
    };
  } catch (error) {
    return {
      error: error instanceof Error ? error.message : "íšŒì›ê°€ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ì´ë©”ì¼ í™•ì¸ ë©”ì¼ ì¬ë°œì†¡
 */
export async function resendConfirmationEmail(
  email: string
): Promise<{ success: boolean; error?: string; message?: string }> {
  try {
    const supabase = await createSupabaseServerClient();
    const emailRedirectTo = await getEmailRedirectUrl();
    
    console.log("[auth] ì´ë©”ì¼ ì¬ë°œì†¡ ìš”ì²­:", email, "redirectTo:", emailRedirectTo);

    // ì´ë©”ì¼ ì¬ë°œì†¡ ì‹œë„
    const { data, error } = await supabase.auth.resend({
      type: "signup",
      email: email,
      options: {
        emailRedirectTo: emailRedirectTo,
      },
    });

    if (error) {
      // ì´ë¯¸ ì¸ì¦ëœ ì‚¬ìš©ìì¸ ê²½ìš°
      if (
        error.message?.toLowerCase().includes("already confirmed") ||
        error.message?.toLowerCase().includes("already verified") ||
        error.message?.toLowerCase().includes("user already registered")
      ) {
        return {
          success: false,
          error: "ì´ ê³„ì •ì€ ì´ë¯¸ ì¸ì¦ë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ì„ ì‹œë„í•´ì£¼ì„¸ìš”.",
        };
      }

      // ë‹¤ë¥¸ ì—ëŸ¬
      console.error("[auth] ì´ë©”ì¼ ì¬ë°œì†¡ ì‹¤íŒ¨:", error);
      return {
        success: false,
        error: error.message || "ì´ë©”ì¼ ì¬ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      };
    }

    return {
      success: true,
      message: "ì¸ì¦ ë©”ì¼ì„ ì¬ë°œì†¡í–ˆìŠµë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”. (ìŠ¤íŒ¸ ë©”ì¼í•¨ë„ í™•ì¸í•´ì£¼ì„¸ìš”)",
    };
  } catch (error) {
    console.error("[auth] ì´ë©”ì¼ ì¬ë°œì†¡ ì˜ˆì™¸:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "ì´ë©”ì¼ ì¬ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

async function _signOut(): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const { error } = await supabase.auth.signOut();

  if (error) {
    throw new AppError(
      error.message || "ë¡œê·¸ì•„ì›ƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.INTERNAL_ERROR,
      500,
      true
    );
  }

  redirect("/login");
}

// ì—ëŸ¬ í•¸ë“¤ë§ ë˜í¼ ì ìš©
export const signOut = withErrorHandling(_signOut);
</file>

<file path="blocks.ts">
"use server";

import { revalidatePath } from "next/cache";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";
import { blockSchema, validateFormData } from "@/lib/validation/schemas";
import { checkBlockOverlap } from "@/lib/blocks/validation";

async function _addBlock(formData: FormData): Promise<void> {
  // ì…ë ¥ ê²€ì¦
  const validation = validateFormData(formData, blockSchema);
  if (!validation.success) {
    const firstError = validation.errors.issues[0];
    throw new AppError(
      firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  const { day, start_time: startTime, end_time: endTime } = validation.data;
  const blockSetId = formData.get("block_set_id");

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .single();

  if (studentError) {
    throw new AppError(
      studentError.message || "í•™ìƒ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: studentError }
    );
  }

  if (!student) {
    throw new AppError("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // block_set_idê°€ ì œê³µë˜ë©´ í•´ë‹¹ ì„¸íŠ¸ ì‚¬ìš©, ì—†ìœ¼ë©´ í™œì„± ì„¸íŠ¸ ì‚¬ìš©
  let activeSetId: string | null = null;
  
  if (blockSetId && typeof blockSetId === "string") {
    // ì œê³µëœ block_set_idê°€ ì‚¬ìš©ìì˜ ì„¸íŠ¸ì¸ì§€ í™•ì¸
    const { data: providedSet, error: setError } = await supabase
      .from("student_block_sets")
      .select("id")
      .eq("id", blockSetId)
      .eq("student_id", user.id)
      .single();

    if (setError || !providedSet) {
      throw new AppError(
        "ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }
    activeSetId = providedSet.id;
  } else {
    // í™œì„± ì„¸íŠ¸ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì„¸íŠ¸ ìƒì„± ë˜ëŠ” ì¡°íšŒ
    activeSetId = student.active_block_set_id;
    if (!activeSetId) {
      // ê¸°ë³¸ ì„¸íŠ¸ ì°¾ê¸° ë˜ëŠ” ìƒì„±
      const { data: defaultSet, error: defaultSetError } = await supabase
        .from("student_block_sets")
        .select("id")
        .eq("student_id", user.id)
        .eq("name", "ê¸°ë³¸")
        .maybeSingle();

      // ì—ëŸ¬ê°€ ìˆê³  PGRST116(not found)ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì—ëŸ¬ ì²˜ë¦¬
      if (defaultSetError && defaultSetError.code !== "PGRST116") {
        throw new AppError(
          defaultSetError.message || "ê¸°ë³¸ ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
          ErrorCode.DATABASE_ERROR,
          500,
          true,
          { supabaseError: defaultSetError }
        );
      }

      if (defaultSet) {
        activeSetId = defaultSet.id;
        // í™œì„± ì„¸íŠ¸ë¡œ ì„¤ì •
        await supabase
          .from("students")
          .update({ active_block_set_id: defaultSet.id })
          .eq("id", user.id);
      } else {
        // ê¸°ë³¸ ì„¸íŠ¸ ìƒì„±
        const { data: newDefaultSet, error: createSetError } = await supabase
          .from("student_block_sets")
          .insert({
            tenant_id: student.tenant_id,
            student_id: user.id,
            name: "ê¸°ë³¸",
            description: "ê¸°ë³¸ ì‹œê°„ ë¸”ë¡ ì„¸íŠ¸",
            display_order: 0,
          })
          .select()
          .single();

        if (createSetError) {
          throw new AppError(
            createSetError.message || "ê¸°ë³¸ ë¸”ë¡ ì„¸íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
            ErrorCode.DATABASE_ERROR,
            500,
            true,
            { supabaseError: createSetError }
          );
        }

        if (newDefaultSet) {
          activeSetId = newDefaultSet.id;
          await supabase
            .from("students")
            .update({ active_block_set_id: newDefaultSet.id })
            .eq("id", user.id);
        }
      }
    }
  }

  if (!activeSetId) {
    throw new AppError("ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // ê²¹ì¹¨ ê²€ì¦ (ê°™ì€ ì„¸íŠ¸ ë‚´ì—ì„œë§Œ)
  const { data: existingBlocks } = await supabase
    .from("student_block_schedule")
    .select("start_time, end_time")
    .eq("student_id", user.id)
    .eq("day_of_week", day)
    .eq("block_set_id", activeSetId);

  if (existingBlocks) {
    const hasOverlap = checkBlockOverlap(
      { startTime, endTime },
      existingBlocks.map((b) => ({
        startTime: b.start_time ?? "",
        endTime: b.end_time ?? "",
      }))
    );

    if (hasOverlap) {
      throw new AppError(
        "ì´ë¯¸ ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ê³¼ ê²¹ì¹©ë‹ˆë‹¤. ë‹¤ë¥¸ ì‹œê°„ëŒ€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }
  }

  const { error } = await supabase.from("student_block_schedule").insert({
    tenant_id: student.tenant_id,
    student_id: user.id,
    block_set_id: activeSetId,
    day_of_week: day,
    start_time: startTime,
    end_time: endTime,
  });

  if (error) {
    // Supabase ì—ëŸ¬ë¥¼ AppErrorë¡œ ë³€í™˜
    throw new AppError(
      error.message || "ì‹œê°„ ë¸”ë¡ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: error }
    );
  }

  revalidatePath("/blocks");
}

async function _updateBlock(formData: FormData): Promise<void> {
  const blockId = formData.get("id");
  if (!blockId || typeof blockId !== "string") {
    throw new AppError("ë¸”ë¡ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const validation = validateFormData(formData, blockSchema);
  if (!validation.success) {
    const firstError = validation.errors.issues[0];
    throw new AppError(
      firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  const { day, start_time: startTime, end_time: endTime } = validation.data;

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ê¸°ì¡´ ë¸”ë¡ í™•ì¸ (ì†Œìœ ê¶Œ ê²€ì¦)
  const { data: existingBlock, error: blockError } = await supabase
    .from("student_block_schedule")
    .select("id, day_of_week, block_set_id")
    .eq("id", blockId)
    .eq("student_id", user.id)
    .single();

  if (blockError && blockError.code !== "PGRST116") {
    throw new AppError(
      blockError.message || "ë¸”ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: blockError }
    );
  }

  if (!existingBlock) {
    throw new AppError("ë¸”ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id")
    .eq("id", user.id)
    .single();

  if (studentError) {
    throw new AppError(
      studentError.message || "í•™ìƒ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: studentError }
    );
  }

  // ë¸”ë¡ì´ ì†í•œ ì›ë˜ ì„¸íŠ¸ ID ì‚¬ìš© (í™œì„± ì„¸íŠ¸ê°€ ì•„ë‹˜)
  const blockSetId = existingBlock.block_set_id;

  if (!blockSetId) {
    throw new AppError("ë¸”ë¡ì´ ì†í•œ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // ê²¹ì¹¨ ê²€ì¦ (ê°™ì€ ì„¸íŠ¸ ë‚´ì—ì„œ, ìê¸° ìì‹  ì œì™¸)
  const { data: otherBlocks } = await supabase
    .from("student_block_schedule")
    .select("start_time, end_time")
    .eq("student_id", user.id)
    .eq("day_of_week", day)
    .eq("block_set_id", blockSetId)
    .neq("id", blockId);

  if (otherBlocks) {
    const hasOverlap = checkBlockOverlap(
      { startTime, endTime },
      otherBlocks.map((b) => ({
        startTime: b.start_time ?? "",
        endTime: b.end_time ?? "",
      }))
    );

    if (hasOverlap) {
      throw new AppError(
        "ì´ë¯¸ ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ê³¼ ê²¹ì¹©ë‹ˆë‹¤. ë‹¤ë¥¸ ì‹œê°„ëŒ€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }
  }

  // ë¸”ë¡ ìˆ˜ì • ì‹œ block_set_idëŠ” ì›ë˜ ê°’ ìœ ì§€ (í™œì„± ì„¸íŠ¸ë¡œ ë³€ê²½í•˜ì§€ ì•ŠìŒ)
  const { error } = await supabase
    .from("student_block_schedule")
    .update({
      day_of_week: day,
      start_time: startTime,
      end_time: endTime,
      // block_set_idëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ - ì›ë˜ ì„¸íŠ¸ì— ìœ ì§€
    })
    .eq("id", blockId)
    .eq("student_id", user.id);

  if (error) {
    // Supabase ì—ëŸ¬ë¥¼ AppErrorë¡œ ë³€í™˜
    throw new AppError(
      error.message || "ì‹œê°„ ë¸”ë¡ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: error }
    );
  }

  revalidatePath("/blocks");
}

async function _deleteBlock(formData: FormData): Promise<void> {
  const blockId = formData.get("id");
  if (!blockId || typeof blockId !== "string") {
    throw new AppError("ë¸”ë¡ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  const { error } = await supabase
    .from("student_block_schedule")
    .delete()
    .eq("id", blockId)
    .eq("student_id", user.id);

  if (error) {
    // Supabase ì—ëŸ¬ë¥¼ AppErrorë¡œ ë³€í™˜
    throw new AppError(
      error.message || "ì‹œê°„ ë¸”ë¡ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: error }
    );
  }

  revalidatePath("/blocks");
}

async function _duplicateBlock(formData: FormData): Promise<void> {
  const blockId = formData.get("id");
  const targetDay = formData.get("target_day");

  if (!blockId || typeof blockId !== "string") {
    throw new AppError("ë¸”ë¡ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!targetDay || typeof targetDay !== "string") {
    throw new AppError("ëŒ€ìƒ ìš”ì¼ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const targetDayNum = Number(targetDay);
  if (isNaN(targetDayNum) || targetDayNum < 0 || targetDayNum > 6) {
    throw new AppError("ì˜¬ë°”ë¥¸ ìš”ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì›ë³¸ ë¸”ë¡ ì¡°íšŒ
  const { data: sourceBlock, error: sourceBlockError } = await supabase
    .from("student_block_schedule")
    .select("start_time, end_time, block_set_id")
    .eq("id", blockId)
    .eq("student_id", user.id)
    .single();

  if (sourceBlockError && sourceBlockError.code !== "PGRST116") {
    throw new AppError(
      sourceBlockError.message || "ë¸”ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: sourceBlockError }
    );
  }

  if (!sourceBlock || !sourceBlock.start_time || !sourceBlock.end_time) {
    throw new AppError("ë¸”ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .single();

  if (studentError) {
    throw new AppError(
      studentError.message || "í•™ìƒ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: studentError }
    );
  }

  if (!student) {
    throw new AppError("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  const activeSetId = student.active_block_set_id ?? sourceBlock.block_set_id;

  // ëŒ€ìƒ ìš”ì¼ì˜ ê²¹ì¹¨ ê²€ì¦ (ê°™ì€ ì„¸íŠ¸ ë‚´ì—ì„œë§Œ)
  const { data: existingBlocks } = await supabase
    .from("student_block_schedule")
    .select("start_time, end_time")
    .eq("student_id", user.id)
    .eq("day_of_week", targetDayNum)
    .eq("block_set_id", activeSetId);

  if (existingBlocks) {
    const hasOverlap = checkBlockOverlap(
      { startTime: sourceBlock.start_time, endTime: sourceBlock.end_time },
      existingBlocks.map((b) => ({
        startTime: b.start_time ?? "",
        endTime: b.end_time ?? "",
      }))
    );

    if (hasOverlap) {
      throw new AppError(
        "ëŒ€ìƒ ìš”ì¼ì— ì´ë¯¸ ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ê³¼ ê²¹ì¹©ë‹ˆë‹¤.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }
  }

  const { error } = await supabase.from("student_block_schedule").insert({
    tenant_id: student.tenant_id,
    student_id: user.id,
    block_set_id: activeSetId,
    day_of_week: targetDayNum,
    start_time: sourceBlock.start_time,
    end_time: sourceBlock.end_time,
  });

  if (error) {
    // Supabase ì—ëŸ¬ë¥¼ AppErrorë¡œ ë³€í™˜
    throw new AppError(
      error.message || "ì‹œê°„ ë¸”ë¡ ë³µì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: error }
    );
  }

  revalidatePath("/blocks");
}

async function _addBlocksToMultipleDays(formData: FormData): Promise<void> {
  const targetDays = formData.get("target_days"); // "1,2,3,4,5" í˜•ì‹
  const startTime = formData.get("start_time");
  const endTime = formData.get("end_time");
  const blockSetId = formData.get("block_set_id"); // íŠ¹ì • ì„¸íŠ¸ì— ì¶”ê°€í•˜ëŠ” ê²½ìš°

  if (!targetDays || typeof targetDays !== "string") {
    throw new AppError("ëŒ€ìƒ ìš”ì¼ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!startTime || typeof startTime !== "string") {
    throw new AppError("ì‹œì‘ ì‹œê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!endTime || typeof endTime !== "string") {
    throw new AppError("ì¢…ë£Œ ì‹œê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const targetDayNums = targetDays
    .split(",")
    .map((d) => Number(d.trim()))
    .filter((d) => !isNaN(d) && d >= 0 && d <= 6);

  if (targetDayNums.length === 0) {
    throw new AppError("ì¶”ê°€í•  ìš”ì¼ì„ ìµœì†Œ 1ê°œ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // í™œì„± ë¸”ë¡ ì„¸íŠ¸ ì¡°íšŒ
  const { data: student, error: studentError } = await supabase
    .from("students")
    .select("active_block_set_id, tenant_id")
    .eq("id", user.id)
    .single();

  if (studentError) {
    throw new AppError(
      studentError.message || "í•™ìƒ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true,
      { supabaseError: studentError }
    );
  }

  if (!student) {
    throw new AppError("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // block_set_idê°€ ì œê³µë˜ë©´ í•´ë‹¹ ì„¸íŠ¸ ì‚¬ìš©, ì—†ìœ¼ë©´ í™œì„± ì„¸íŠ¸ ì‚¬ìš©
  let activeSetId: string | null = null;
  
  if (blockSetId && typeof blockSetId === "string") {
    // ì œê³µëœ block_set_idê°€ ì‚¬ìš©ìì˜ ì„¸íŠ¸ì¸ì§€ í™•ì¸
    const { data: providedSet, error: setError } = await supabase
      .from("student_block_sets")
      .select("id")
      .eq("id", blockSetId)
      .eq("student_id", user.id)
      .single();

    if (setError || !providedSet) {
      throw new AppError(
        "ë¸”ë¡ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }
    activeSetId = providedSet.id;
  } else {
    activeSetId = student.active_block_set_id;
    
    if (!activeSetId) {
      throw new AppError("í™œì„± ë¸”ë¡ ì„¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë¸”ë¡ ì„¸íŠ¸ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
    }
  }

  // ê° ëŒ€ìƒ ìš”ì¼ë¡œ ë¸”ë¡ ì¶”ê°€ (ê²¹ì¹˜ëŠ” ë¸”ë¡ì€ ìŠ¤í‚µí•˜ê³  ë‚˜ë¨¸ì§€ë§Œ ì¶”ê°€)
  const insertPromises = targetDayNums.map(async (targetDay) => {
    // ëŒ€ìƒ ìš”ì¼ì˜ ê¸°ì¡´ ë¸”ë¡ ì¡°íšŒ (ê°™ì€ ì„¸íŠ¸ ë‚´ì—ì„œë§Œ)
    const { data: existingBlocks } = await supabase
      .from("student_block_schedule")
      .select("start_time, end_time")
      .eq("student_id", user.id)
      .eq("day_of_week", targetDay)
      .eq("block_set_id", activeSetId);

    // ê²¹ì¹¨ ê²€ì¦
    const existingBlocksArray = existingBlocks || [];
    const hasOverlap = existingBlocksArray.length > 0 && checkBlockOverlap(
      { startTime, endTime },
      existingBlocksArray.map((b) => ({
        startTime: b.start_time ?? "",
        endTime: b.end_time ?? "",
      }))
    );

    if (hasOverlap) {
      return { 
        targetDay, 
        skipped: true, 
        reason: "ì´ë¯¸ ë“±ë¡ëœ ì‹œê°„ ë¸”ë¡ê³¼ ê²¹ì¹©ë‹ˆë‹¤"
      };
    }

    // ë¸”ë¡ ì‚½ì…
    const { error } = await supabase.from("student_block_schedule").insert({
      tenant_id: student.tenant_id,
      student_id: user.id,
      block_set_id: activeSetId,
      day_of_week: targetDay,
      start_time: startTime,
      end_time: endTime,
    });

    if (error) {
      return { 
        targetDay, 
        skipped: true, 
        reason: error.message || "ë¸”ë¡ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
      };
    }

    return { 
      targetDay, 
      skipped: false
    };
  });

  const results = await Promise.all(insertPromises);
  const successResults = results.filter((r) => !r.skipped);
  const skippedResults = results.filter((r) => r.skipped);

  // ë¶€ë¶„ ì„±ê³µë„ í—ˆìš©í•˜ë˜, ìƒì„¸í•œ í”¼ë“œë°± ì œê³µ
  if (successResults.length === 0) {
    // ëª¨ë“  ìš”ì¼ì´ ì‹¤íŒ¨í•œ ê²½ìš°
    const skippedDays = skippedResults.map((r) => ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "][r.targetDay]).join(", ");
    const reasons = skippedResults.map((r) => r.reason).filter(Boolean).join("; ");
    throw new AppError(
      `ëª¨ë“  ìš”ì¼(${skippedDays})ë¡œì˜ ì¶”ê°€ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${reasons}`,
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  revalidatePath("/blocks");

  // ë¶€ë¶„ ì„±ê³µì¸ ê²½ìš° ìƒì„¸ ì •ë³´ ì œê³µ (ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬í•˜ë˜ ì •ë³´ ë©”ì‹œì§€ ì „ë‹¬)
  if (skippedResults.length > 0) {
    const successDays = successResults.map((r) => ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "][r.targetDay]).join(", ");
    const skippedDays = skippedResults.map((r) => ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "][r.targetDay]).join(", ");
    
    // ë¶€ë¶„ ì„±ê³µ ì •ë³´ë¥¼ í¬í•¨í•œ ì •ë³´ì„± ë©”ì‹œì§€ (ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬)
    const infoMessage = `${successDays}ìš”ì¼ì— ë¸”ë¡ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. ${skippedDays}ìš”ì¼ì€ ê²¹ì¹˜ëŠ” ì‹œê°„ëŒ€ê°€ ìˆì–´ ìŠ¤í‚µë˜ì—ˆìŠµë‹ˆë‹¤.`;
    
    // ì •ë³´ ë©”ì‹œì§€ë¥¼ í¬í•¨í•œ ì—ëŸ¬ë¡œ ì „ë‹¬ (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„±ê³µ ë©”ì‹œì§€ë¡œ í‘œì‹œ)
    throw new AppError(
      `INFO: ${infoMessage}`,
      ErrorCode.BUSINESS_LOGIC_ERROR,
      200,
      true
    );
  }
}

// ì—ëŸ¬ í•¸ë“¤ë§ ë˜í¼ ì ìš©
export const addBlock = withErrorHandling(_addBlock);
export const updateBlock = withErrorHandling(_updateBlock);
export const deleteBlock = withErrorHandling(_deleteBlock);
export const duplicateBlock = withErrorHandling(_duplicateBlock);
export const addBlocksToMultipleDays = withErrorHandling(_addBlocksToMultipleDays);
</file>

<file path="blockSets.ts">
"use server";

import { revalidatePath } from "next/cache";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";
import { fetchBlockSetsWithBlocks } from "@/lib/data/blockSets";

const MAX_BLOCK_SETS = 5;

async function _createBlockSet(formData: FormData): Promise<{ blockSetId: string; name: string }> {
  const name = formData.get("name");
  const description = formData.get("description");

  if (!name || typeof name !== "string" || name.trim() === "") {
    throw new AppError("ì„¸íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (name.length > 100) {
    throw new AppError("ì„¸íŠ¸ ì´ë¦„ì€ 100ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // í•™ìƒ ì •ë³´ ì¡°íšŒ (tenant_id í•„ìš”)
  const { data: student } = await supabase
    .from("students")
    .select("tenant_id")
    .eq("id", user.id)
    .single();

  if (!student || !student.tenant_id) {
    throw new AppError("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // ì„¸íŠ¸ ê°œìˆ˜ ì œí•œ í™•ì¸
  const { count } = await supabase
    .from("student_block_sets")
    .select("*", { count: "exact", head: true })
    .eq("student_id", user.id);

  if ((count ?? 0) >= MAX_BLOCK_SETS) {
    throw new AppError(
      `ë¸”ë¡ ì„¸íŠ¸ëŠ” ìµœëŒ€ ${MAX_BLOCK_SETS}ê°œê¹Œì§€ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  // ì¤‘ë³µ ì´ë¦„ í™•ì¸
  const { data: existingSet } = await supabase
    .from("student_block_sets")
    .select("id")
    .eq("student_id", user.id)
    .eq("name", name.trim())
    .single();

  if (existingSet) {
    throw new AppError("ì´ë¯¸ ê°™ì€ ì´ë¦„ì˜ ì„¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  // display_order ê³„ì‚° (ê°€ì¥ í° ê°’ + 1)
  const { data: lastSet } = await supabase
    .from("student_block_sets")
    .select("display_order")
    .eq("student_id", user.id)
    .order("display_order", { ascending: false })
    .limit(1)
    .single();

  const displayOrder = (lastSet?.display_order ?? -1) + 1;

  const { data: newSet, error } = await supabase
    .from("student_block_sets")
    .insert({
      tenant_id: student.tenant_id,
      student_id: user.id,
      name: name.trim(),
      description: description && typeof description === "string" ? description.trim() : null,
      display_order: displayOrder,
    })
    .select("id, name")
    .single();

  if (error) {
    throw error;
  }

  if (!newSet) {
    throw new AppError("ë¸”ë¡ ì„¸íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", ErrorCode.INTERNAL_ERROR, 500, true);
  }

  revalidatePath("/blocks");
  return { blockSetId: newSet.id, name: newSet.name };
}

async function _updateBlockSet(formData: FormData): Promise<void> {
  const setId = formData.get("id");
  const name = formData.get("name");
  const description = formData.get("description");

  if (!setId || typeof setId !== "string") {
    throw new AppError("ì„¸íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!name || typeof name !== "string" || name.trim() === "") {
    throw new AppError("ì„¸íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (name.length > 100) {
    throw new AppError("ì„¸íŠ¸ ì´ë¦„ì€ 100ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì„¸íŠ¸ ì†Œìœ ê¶Œ í™•ì¸
  const { data: existingSet } = await supabase
    .from("student_block_sets")
    .select("id, name")
    .eq("id", setId)
    .eq("student_id", user.id)
    .single();

  if (!existingSet) {
    throw new AppError("ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // ì´ë¦„ ë³€ê²½ ì‹œ ì¤‘ë³µ í™•ì¸ (ìê¸° ìì‹  ì œì™¸)
  if (existingSet.name !== name.trim()) {
    const { data: duplicateSet } = await supabase
      .from("student_block_sets")
      .select("id")
      .eq("student_id", user.id)
      .eq("name", name.trim())
      .neq("id", setId)
      .single();

    if (duplicateSet) {
      throw new AppError("ì´ë¯¸ ê°™ì€ ì´ë¦„ì˜ ì„¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
    }
  }

  const { error } = await supabase
    .from("student_block_sets")
    .update({
      name: name.trim(),
      description: description && typeof description === "string" ? description.trim() : null,
    })
    .eq("id", setId)
    .eq("student_id", user.id);

  if (error) {
    throw error;
  }

  revalidatePath("/blocks");
}

async function _deleteBlockSet(formData: FormData): Promise<void> {
  const setId = formData.get("id");

  if (!setId || typeof setId !== "string") {
    throw new AppError("ì„¸íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì„¸íŠ¸ ì†Œìœ ê¶Œ í™•ì¸
  const { data: existingSet } = await supabase
    .from("student_block_sets")
    .select("id")
    .eq("id", setId)
    .eq("student_id", user.id)
    .single();

  if (!existingSet) {
    throw new AppError("ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // í™œì„± ì„¸íŠ¸ì¸ì§€ í™•ì¸
  const { data: student } = await supabase
    .from("students")
    .select("active_block_set_id")
    .eq("id", user.id)
    .single();

  if (student?.active_block_set_id === setId) {
    // í™œì„± ì„¸íŠ¸ë¥¼ ì‚­ì œí•˜ëŠ” ê²½ìš°, ë‹¤ë¥¸ ì„¸íŠ¸ë¥¼ í™œì„±í™”í•˜ê±°ë‚˜ NULLë¡œ ì„¤ì •
    const { data: otherSet } = await supabase
      .from("student_block_sets")
      .select("id")
      .eq("student_id", user.id)
      .neq("id", setId)
      .order("display_order", { ascending: true })
      .limit(1)
      .single();

    if (otherSet) {
      await supabase
        .from("students")
        .update({ active_block_set_id: otherSet.id })
        .eq("id", user.id);
    } else {
      await supabase
        .from("students")
        .update({ active_block_set_id: null })
        .eq("id", user.id);
    }
  }

  // ì„¸íŠ¸ ì‚­ì œ (CASCADEë¡œ ë¸”ë¡ë„ í•¨ê»˜ ì‚­ì œë¨)
  const { error } = await supabase
    .from("student_block_sets")
    .delete()
    .eq("id", setId)
    .eq("student_id", user.id);

  if (error) {
    throw error;
  }

  revalidatePath("/blocks");
}

async function _setActiveBlockSet(formData: FormData): Promise<void> {
  const setId = formData.get("id");

  if (!setId || typeof setId !== "string") {
    throw new AppError("ì„¸íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì„¸íŠ¸ ì†Œìœ ê¶Œ í™•ì¸
  const { data: existingSet } = await supabase
    .from("student_block_sets")
    .select("id")
    .eq("id", setId)
    .eq("student_id", user.id)
    .single();

  if (!existingSet) {
    throw new AppError("ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // í™œì„± ì„¸íŠ¸ ì„¤ì •
  const { error } = await supabase
    .from("students")
    .update({ active_block_set_id: setId })
    .eq("id", user.id);

  if (error) {
    throw error;
  }

  revalidatePath("/blocks");
}

async function _duplicateBlockSet(formData: FormData): Promise<void> {
  const sourceSetId = formData.get("source_id");
  const newName = formData.get("name");

  if (!sourceSetId || typeof sourceSetId !== "string") {
    throw new AppError("ì›ë³¸ ì„¸íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!newName || typeof newName !== "string" || newName.trim() === "") {
    throw new AppError("ìƒˆ ì„¸íŠ¸ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì›ë³¸ ì„¸íŠ¸ ì¡°íšŒ
  const { data: sourceSet } = await supabase
    .from("student_block_sets")
    .select("tenant_id, name, description, display_order")
    .eq("id", sourceSetId)
    .eq("student_id", user.id)
    .single();

  if (!sourceSet) {
    throw new AppError("ì›ë³¸ ì„¸íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  // ì„¸íŠ¸ ê°œìˆ˜ ì œí•œ í™•ì¸
  const { count } = await supabase
    .from("student_block_sets")
    .select("*", { count: "exact", head: true })
    .eq("student_id", user.id);

  if ((count ?? 0) >= MAX_BLOCK_SETS) {
    throw new AppError(
      `ë¸”ë¡ ì„¸íŠ¸ëŠ” ìµœëŒ€ ${MAX_BLOCK_SETS}ê°œê¹Œì§€ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  // ì¤‘ë³µ ì´ë¦„ í™•ì¸
  const { data: existingSet } = await supabase
    .from("student_block_sets")
    .select("id")
    .eq("student_id", user.id)
    .eq("name", newName.trim())
    .single();

  if (existingSet) {
    throw new AppError("ì´ë¯¸ ê°™ì€ ì´ë¦„ì˜ ì„¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  // ì›ë³¸ ì„¸íŠ¸ì˜ ë¸”ë¡ë“¤ ì¡°íšŒ
  const { data: sourceBlocks } = await supabase
    .from("student_block_schedule")
    .select("day_of_week, start_time, end_time")
    .eq("block_set_id", sourceSetId)
    .eq("student_id", user.id)
    .order("day_of_week")
    .order("start_time");

  // ìƒˆ ì„¸íŠ¸ ìƒì„±
  const { data: newSet, error: insertError } = await supabase
    .from("student_block_sets")
    .insert({
      tenant_id: sourceSet.tenant_id,
      student_id: user.id,
      name: newName.trim(),
      description: sourceSet.description,
      display_order: (sourceSet.display_order ?? 0) + 1,
    })
    .select()
    .single();

  if (insertError || !newSet) {
    throw insertError || new AppError("ì„¸íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", ErrorCode.INTERNAL_ERROR, 500, true);
  }

  // ë¸”ë¡ë“¤ ë³µì œ
  if (sourceBlocks && sourceBlocks.length > 0) {
    const blocksToInsert = sourceBlocks.map((block) => ({
      tenant_id: sourceSet.tenant_id,
      student_id: user.id,
      block_set_id: newSet.id,
      day_of_week: block.day_of_week,
      start_time: block.start_time,
      end_time: block.end_time,
    }));

    const { error: blocksError } = await supabase
      .from("student_block_schedule")
      .insert(blocksToInsert);

    if (blocksError) {
      // ë¡¤ë°±: ìƒˆ ì„¸íŠ¸ ì‚­ì œ
      await supabase.from("student_block_sets").delete().eq("id", newSet.id);
      throw blocksError;
    }
  }

  revalidatePath("/blocks");
}

async function _getBlockSets(): Promise<Array<{ id: string; name: string; blocks?: Array<{ id: string; day_of_week: number; start_time: string; end_time: string }> }>> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©
  return await fetchBlockSetsWithBlocks(user.id);
}

// ì—ëŸ¬ í•¸ë“¤ë§ ë˜í¼ ì ìš©
export const createBlockSet = withErrorHandling(_createBlockSet);
export const updateBlockSet = withErrorHandling(_updateBlockSet);
export const deleteBlockSet = withErrorHandling(_deleteBlockSet);
export const setActiveBlockSet = withErrorHandling(_setActiveBlockSet);
export const duplicateBlockSet = withErrorHandling(_duplicateBlockSet);
export const getBlockSets = withErrorHandling(_getBlockSets);
</file>

<file path="consultingNotes.ts">
// ì´ íŒŒì¼ì€ app/(admin)/actions/consultingNoteActions.tsë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
// ê¸°ì¡´ importë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”:
// - addConsultingNote â†’ app/(admin)/actions/consultingNoteActions.ts
// - deleteConsultingNote â†’ app/(admin)/actions/consultingNoteActions.ts

export {
  addConsultingNote,
  deleteConsultingNote,
} from "@/app/(admin)/actions/consultingNoteActions";
</file>

<file path="goals.ts">
// ì´ íŒŒì¼ì€ app/(student)/actions/goalActions.tsë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
// ê¸°ì¡´ importë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”:
// - createGoal â†’ app/(student)/actions/goalActions.ts (createGoalActionìœ¼ë¡œ ë³€ê²½)
// - updateGoal â†’ app/(student)/actions/goalActions.ts (updateGoalActionìœ¼ë¡œ ë³€ê²½)
// - deleteGoal â†’ app/(student)/actions/goalActions.ts (deleteGoalActionìœ¼ë¡œ ë³€ê²½)
// - getAllGoalsAction â†’ app/(student)/actions/goalActions.ts
// - recordGoalProgress â†’ app/(student)/actions/goalActions.ts (recordGoalProgressActionìœ¼ë¡œ ë³€ê²½)

export {
  createGoalAction as createGoal,
  updateGoalAction as updateGoal,
  deleteGoalAction as deleteGoal,
  getAllGoalsAction,
  recordGoalProgressAction as recordGoalProgress,
} from "@/app/(student)/actions/goalActions";
</file>

<file path="progress.ts">
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { recordHistory } from "@/lib/history/record";

const VALID_CONTENT_TYPES = ["book", "lecture", "custom"] as const;

type ContentType = (typeof VALID_CONTENT_TYPES)[number];

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

type PlanRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
};

type ContentProgressRow = {
  id: string;
  content_type?: string | null;
  content_id?: string | null;
  completed_amount?: number | null;
  progress?: number | null;
};

type BookRow = {
  id: string;
  total_pages?: number | null;
};

type LectureRow = {
  id: string;
  duration?: number | null;
};

type CustomRow = {
  id: string;
  total_page_or_time?: number | null;
};

export async function updateProgress(formData: FormData): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
  }

  const planIdInput = String(formData.get("plan_id") ?? "").trim();
  const completedAmountInput = formData.get("completed_amount");

  if (!planIdInput) {
    throw new Error("í”Œëœ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.");
  }

  const completedAmount =
    completedAmountInput !== null
      ? Number(completedAmountInput)
      : null;

  if (completedAmount !== null && !Number.isFinite(completedAmount)) {
    throw new Error("ì˜¬ë°”ë¥¸ ì™„ë£ŒëŸ‰ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
  }

  try {
    // 1. student_plan ì¡°íšŒ
    const plan = await fetchPlan(supabase, user.id, planIdInput);
    if (!plan || !plan.content_type || !plan.content_id) {
      throw new Error("í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    const contentType = toContentType(plan.content_type);
    const contentId = plan.content_id;

    // 2. ì½˜í…ì¸ ë³„ ì´ëŸ‰ ì¡°íšŒ
    const totalAmount = await fetchContentTotal(
      supabase,
      user.id,
      contentType,
      contentId
    );

    if (totalAmount === null || totalAmount <= 0) {
      throw new Error("ì½˜í…ì¸  ì´ëŸ‰ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    // 3. ê¸°ì¡´ progress ë ˆì½”ë“œ ì¡°íšŒ
    const existingProgress = await fetchContentProgress(
      supabase,
      user.id,
      contentType,
      contentId
    );

    // 4. ì™„ë£ŒëŸ‰ ê³„ì‚°
    const currentCompleted =
      existingProgress?.completed_amount ?? 0;
    const newCompletedAmount =
      completedAmount !== null
        ? currentCompleted + completedAmount
        : currentCompleted;

    // 5. ì§„í–‰ë¥  ê³„ì‚°
    const progress = Math.min(
      Math.round((newCompletedAmount / totalAmount) * 100),
      100
    );

    // 6. insert ë˜ëŠ” update
    if (existingProgress) {
      await updateContentProgress(
        supabase,
        user.id,
        existingProgress.id,
        newCompletedAmount,
        progress
      );
    } else {
      await insertContentProgress(
        supabase,
        user.id,
        contentType,
        contentId,
        newCompletedAmount,
        progress
      );
    }

    // íˆìŠ¤í† ë¦¬ ê¸°ë¡
    await recordHistory(supabase, user.id, "content_progress", {
      content_type: contentType,
      content_id: contentId,
      completed_amount: newCompletedAmount,
      progress,
      plan_id: planIdInput,
    });

    // 7. ì˜¤ëŠ˜ í˜ì´ì§€ë¡œ redirect
    revalidatePath("/today");
    redirect("/today");
  } catch (error) {
    console.error("[progress] ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error("ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
  }
}

async function fetchPlan(
  supabase: SupabaseServerClient,
  studentId: string,
  planId: string
): Promise<PlanRow | null> {
  try {
    const selectPlan = () =>
      supabase
        .from("student_plan")
        .select(
          "id,content_type,content_id,planned_start_page_or_time,planned_end_page_or_time"
        )
        .eq("id", planId);

    let { data, error } = await selectPlan().eq("student_id", studentId).maybeSingle<PlanRow>();
    if (error && error.code === "42703") {
      ({ data, error } = await selectPlan().maybeSingle<PlanRow>());
    }
    if (error) throw error;

    return data;
  } catch (error) {
    console.error("[progress] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

async function fetchContentTotal(
  supabase: SupabaseServerClient,
  studentId: string,
  contentType: ContentType,
  contentId: string
): Promise<number | null> {
  try {
    if (contentType === "book") {
      const selectBook = () =>
        supabase
          .from("books")
          .select("id,total_pages")
          .eq("id", contentId);

      let { data, error } = await selectBook().eq("student_id", studentId).maybeSingle<BookRow>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectBook().maybeSingle<BookRow>());
      }
      if (error) throw error;

      return data?.total_pages ?? null;
    }

    if (contentType === "lecture") {
      const selectLecture = () =>
        supabase
          .from("lectures")
          .select("id,duration")
          .eq("id", contentId);

      let { data, error } = await selectLecture().eq("student_id", studentId).maybeSingle<LectureRow>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectLecture().maybeSingle<LectureRow>());
      }
      if (error) throw error;

      return data?.duration ?? null;
    }

    if (contentType === "custom") {
      const selectCustom = () =>
        supabase
          .from("student_custom_contents")
          .select("id,total_page_or_time")
          .eq("id", contentId);

      let { data, error } = await selectCustom().eq("student_id", studentId).maybeSingle<CustomRow>();
      if (error && error.code === "42703") {
        ({ data, error } = await selectCustom().maybeSingle<CustomRow>());
      }
      if (error) throw error;

      return data?.total_page_or_time ?? null;
    }

    return null;
  } catch (error) {
    console.error("[progress] ì½˜í…ì¸  ì´ëŸ‰ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

async function fetchContentProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  contentType: ContentType,
  contentId: string
): Promise<ContentProgressRow | null> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("id,content_type,content_id,completed_amount,progress")
        .eq("content_type", contentType)
        .eq("content_id", contentId);

    let { data, error } = await selectProgress().eq("student_id", studentId).maybeSingle<ContentProgressRow>();
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress().maybeSingle<ContentProgressRow>());
    }
    if (error && error.code !== "PGRST116") {
      throw error;
    }

    return data;
  } catch (error) {
    console.error("[progress] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

async function insertContentProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  contentType: ContentType,
  contentId: string,
  completedAmount: number,
  progress: number
): Promise<void> {
  // studentì˜ tenant_id ì¡°íšŒ
  const { data: student } = await supabase
    .from("students")
    .select("tenant_id")
    .eq("id", studentId)
    .single();

  if (!student || !student.tenant_id) {
    throw new Error("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  const payload = {
    student_id: studentId,
    tenant_id: student.tenant_id,
    content_type: contentType,
    content_id: contentId,
    completed_amount: completedAmount,
    progress: progress,
    last_updated: new Date().toISOString(),
  };

  let { error } = await supabase
    .from("student_content_progress")
    .insert(payload);

  if (error && error.code === "42703") {
    const { student_id: _studentId, tenant_id: _tenantId, ...fallbackPayload } = payload;
    void _studentId;
    void _tenantId;
    ({ error } = await supabase
      .from("student_content_progress")
      .insert(fallbackPayload));
  }

  if (error) {
    throw new Error(error.message);
  }
}

async function updateContentProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  progressId: string,
  completedAmount: number,
  progress: number
): Promise<void> {
  const payload = {
    completed_amount: completedAmount,
    progress: progress,
    last_updated: new Date().toISOString(),
  };

  const updateQuery = () =>
    supabase
      .from("student_content_progress")
      .update(payload)
      .eq("id", progressId);

  let { error } = await updateQuery().eq("student_id", studentId);
  if (error && error.code === "42703") {
    ({ error } = await updateQuery());
  }

  if (error) {
    throw new Error(error.message);
  }
}

export async function updatePlanProgress(formData: FormData): Promise<void> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
  }

  const planIdInput = String(formData.get("plan_id") ?? "").trim();
  const progressInput = formData.get("progress");
  const startInput = formData.get("start_page_or_time");
  const endInput = formData.get("end_page_or_time");

  if (!planIdInput) {
    throw new Error("í”Œëœ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.");
  }

  try {
    // 1. student_plan ì¡°íšŒ
    const plan = await fetchPlanForProgress(supabase, user.id, planIdInput);
    if (!plan || !plan.content_type || !plan.content_id) {
      throw new Error("í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    const contentType = toContentType(plan.content_type);
    const contentId = plan.content_id;

    // 2. ì½˜í…ì¸ ë³„ ì´ëŸ‰ ì¡°íšŒ
    const totalAmount = await fetchContentTotal(
      supabase,
      user.id,
      contentType,
      contentId
    );

    if (totalAmount === null || totalAmount <= 0) {
      throw new Error("ì½˜í…ì¸  ì´ëŸ‰ì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    // 3. ì§„í–‰ë¥  ê³„ì‚°
    let progress: number;
    let startPageOrTime: number | null = null;
    let endPageOrTime: number | null = null;

    if (progressInput !== null && progressInput !== "") {
      // ì§„í–‰ë¥  ì§ì ‘ ì…ë ¥
      progress = Number(progressInput);
      if (!Number.isFinite(progress) || progress < 0 || progress > 100) {
        throw new Error("ì§„í–‰ë¥ ì€ 0-100 ì‚¬ì´ì˜ ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
      }
    } else if (startInput !== null && endInput !== null) {
      // ì‹œì‘/ì¢…ë£Œë¡œ ê³„ì‚°
      const start = Number(startInput);
      const end = Number(endInput);

      if (!Number.isFinite(start) || !Number.isFinite(end)) {
        throw new Error("ì˜¬ë°”ë¥¸ ì‹œì‘/ì¢…ë£Œ ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      }

      if (start < 0 || end < start) {
        throw new Error("ì‹œì‘ ê°’ì€ 0 ì´ìƒì´ì–´ì•¼ í•˜ë©°, ì¢…ë£Œ ê°’ì€ ì‹œì‘ ê°’ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.");
      }

      if (end > totalAmount) {
        throw new Error(`ì¢…ë£Œ ê°’ì€ ì´ëŸ‰(${totalAmount})ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
      }

      startPageOrTime = start;
      endPageOrTime = end;

      // ì§„í–‰ë¥  ê³„ì‚°: ((end - start) / totalAmount) * 100
      const completedAmount = end - start;
      progress = Math.min(
        Math.round((completedAmount / totalAmount) * 100),
        100
      );
    } else {
      throw new Error("ì§„í–‰ë¥  ë˜ëŠ” ì‹œì‘/ì¢…ë£Œ ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    }

    // 4. ê¸°ì¡´ progress ë ˆì½”ë“œ ì¡°íšŒ
    const existingProgress = await fetchPlanProgress(
      supabase,
      user.id,
      planIdInput
    );

    // 5. upsert
    if (existingProgress) {
      await updatePlanProgressRecord(
        supabase,
        user.id,
        existingProgress.id,
        progress,
        startPageOrTime,
        endPageOrTime
      );
    } else {
      await insertPlanProgress(
        supabase,
        user.id,
        planIdInput,
        progress,
        startPageOrTime,
        endPageOrTime
      );
    }

    // 6. revalidate
    revalidatePath("/plan");
  } catch (error) {
    console.error("[progress] í”Œëœ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨", error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error("ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
  }
}

async function fetchPlanForProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  planId: string
): Promise<PlanRow | null> {
  try {
    const selectPlan = () =>
      supabase
        .from("student_plan")
        .select(
          "id,content_type,content_id,planned_start_page_or_time,planned_end_page_or_time"
        )
        .eq("id", planId);

    let { data, error } = await selectPlan().eq("student_id", studentId).maybeSingle<PlanRow>();
    if (error && error.code === "42703") {
      ({ data, error } = await selectPlan().maybeSingle<PlanRow>());
    }
    if (error) throw error;

    return data;
  } catch (error) {
    console.error("[progress] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

type PlanProgressRow = {
  id: string;
  plan_id?: string | null;
  progress?: number | null;
  start_page_or_time?: number | null;
  end_page_or_time?: number | null;
};

async function fetchPlanProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  planId: string
): Promise<PlanProgressRow | null> {
  try {
    const selectProgress = () =>
      supabase
        .from("student_content_progress")
        .select("id,plan_id,progress,start_page_or_time,end_page_or_time")
        .eq("plan_id", planId);

    let { data, error } = await selectProgress().eq("student_id", studentId).maybeSingle<PlanProgressRow>();
    if (error && error.code === "42703") {
      ({ data, error } = await selectProgress().maybeSingle<PlanProgressRow>());
    }
    if (error && error.code !== "PGRST116") {
      throw error;
    }

    return data;
  } catch (error) {
    console.error("[progress] ì§„í–‰ë¥  ì¡°íšŒ ì‹¤íŒ¨", error);
    return null;
  }
}

async function insertPlanProgress(
  supabase: SupabaseServerClient,
  studentId: string,
  planId: string,
  progress: number,
  startPageOrTime: number | null,
  endPageOrTime: number | null
): Promise<void> {
  // studentì˜ tenant_id ì¡°íšŒ
  const { data: student } = await supabase
    .from("students")
    .select("tenant_id")
    .eq("id", studentId)
    .single();

  if (!student || !student.tenant_id) {
    throw new Error("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
  }

  const payload = {
    student_id: studentId,
    tenant_id: student.tenant_id,
    plan_id: planId,
    progress: progress,
    start_page_or_time: startPageOrTime,
    end_page_or_time: endPageOrTime,
    last_updated: new Date().toISOString(),
  };

  let { error } = await supabase
    .from("student_content_progress")
    .insert(payload);

  if (error && error.code === "42703") {
    const { student_id: _studentId, tenant_id: _tenantId, ...fallbackPayload } = payload;
    void _studentId;
    void _tenantId;
    ({ error } = await supabase
      .from("student_content_progress")
      .insert(fallbackPayload));
  }

  if (error) {
    throw new Error(error.message);
  }
}

async function updatePlanProgressRecord(
  supabase: SupabaseServerClient,
  studentId: string,
  progressId: string,
  progress: number,
  startPageOrTime: number | null,
  endPageOrTime: number | null
): Promise<void> {
  const payload = {
    progress: progress,
    start_page_or_time: startPageOrTime,
    end_page_or_time: endPageOrTime,
    last_updated: new Date().toISOString(),
  };

  const updateQuery = () =>
    supabase
      .from("student_content_progress")
      .update(payload)
      .eq("id", progressId);

  let { error } = await updateQuery().eq("student_id", studentId);
  if (error && error.code === "42703") {
    ({ error } = await updateQuery());
  }

  if (error) {
    throw new Error(error.message);
  }
}

function toContentType(raw?: string | null): ContentType {
  if (raw === "lecture" || raw === "custom") {
    return raw;
  }
  return "book";
}
</file>

<file path="scores-internal.ts">
"use server";

/**
 * ë‚´ì‹  ì„±ì  ì…ë ¥ API
 * 
 * student_termsë¥¼ ì¡°íšŒ/ìƒì„±í•˜ì—¬ student_term_idë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.
 */

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getOrCreateStudentTerm, calculateSchoolYear } from "@/lib/data/studentTerms";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";

/**
 * ë‚´ì‹  ì„±ì  ìƒì„±
 */
async function _createInternalScore(formData: FormData) {
  const supabase = await createSupabaseServerClient();
  const user = await getCurrentUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // FormDataì—ì„œ ê°’ ì¶”ì¶œ
  const student_id = formData.get("student_id") as string;
  const tenant_id = formData.get("tenant_id") as string;
  const school_year = formData.get("school_year") ? parseInt(formData.get("school_year") as string) : calculateSchoolYear();
  const grade = parseInt(formData.get("grade") as string);
  const semester = parseInt(formData.get("semester") as string);
  const curriculum_revision_id = formData.get("curriculum_revision_id") as string;
  const subject_group_id = formData.get("subject_group_id") as string;
  const subject_type_id = formData.get("subject_type_id") as string;
  const subject_id = formData.get("subject_id") as string;
  const credit_hours = parseFloat(formData.get("credit_hours") as string);
  const raw_score = formData.get("raw_score") ? parseFloat(formData.get("raw_score") as string) : null;
  const avg_score = formData.get("avg_score") ? parseFloat(formData.get("avg_score") as string) : null;
  const std_dev = formData.get("std_dev") ? parseFloat(formData.get("std_dev") as string) : null;
  const rank_grade = formData.get("rank_grade") ? parseInt(formData.get("rank_grade") as string) : null;
  const total_students = formData.get("total_students") ? parseInt(formData.get("total_students") as string) : null;
  const class_name = formData.get("class_name") as string | null;
  const homeroom_teacher = formData.get("homeroom_teacher") as string | null;
  const notes = formData.get("notes") as string | null;

  // í•„ìˆ˜ í•„ë“œ ê²€ì¦
  if (!student_id || !tenant_id || !curriculum_revision_id || !subject_group_id || !subject_type_id || !subject_id) {
    throw new AppError("í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  if (!grade || !semester || !credit_hours) {
    throw new AppError("í•™ë…„, í•™ê¸°, ì´ìˆ˜ë‹¨ìœ„ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„±
  const student_term_id = await getOrCreateStudentTerm({
    tenant_id,
    student_id,
    school_year,
    grade,
    semester,
    curriculum_revision_id,
    class_name: class_name || null,
    homeroom_teacher: homeroom_teacher || null,
    notes: notes || null,
  });

  // ë‚´ì‹  ì„±ì  ìƒì„±
  const { data, error } = await supabase
    .from("student_internal_scores")
    .insert({
      tenant_id,
      student_id,
      student_term_id,
      curriculum_revision_id,
      subject_group_id,
      subject_type_id,
      subject_id,
      grade,
      semester,
      credit_hours,
      raw_score,
      avg_score,
      std_dev,
      rank_grade,
      total_students,
    })
    .select("id")
    .single();

  if (error) {
    console.error("[actions/scores-internal] ë‚´ì‹  ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    throw new AppError("ë‚´ì‹  ì„±ì  ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", ErrorCode.DATABASE_ERROR, 500, true);
  }

  revalidatePath("/scores");
  return { success: true, scoreId: data.id };
}

export const createInternalScore = withErrorHandling(_createInternalScore);

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„±
 */
async function _createMockScore(formData: FormData) {
  const supabase = await createSupabaseServerClient();
  const user = await getCurrentUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // FormDataì—ì„œ ê°’ ì¶”ì¶œ
  const student_id = formData.get("student_id") as string;
  const tenant_id = formData.get("tenant_id") as string;
  const exam_date = formData.get("exam_date") as string; // YYYY-MM-DD
  const exam_title = formData.get("exam_title") as string;
  const grade = parseInt(formData.get("grade") as string);
  const subject_id = formData.get("subject_id") as string;
  const subject_group_id = formData.get("subject_group_id") as string;
  const curriculum_revision_id = formData.get("curriculum_revision_id") as string;
  const raw_score = formData.get("raw_score") ? parseFloat(formData.get("raw_score") as string) : null;
  const standard_score = formData.get("standard_score") ? parseFloat(formData.get("standard_score") as string) : null;
  const percentile = formData.get("percentile") ? parseFloat(formData.get("percentile") as string) : null;
  const grade_score = formData.get("grade_score") ? parseInt(formData.get("grade_score") as string) : null;
  const semester = formData.get("semester") ? parseInt(formData.get("semester") as string) : null;

  // í•„ìˆ˜ í•„ë“œ ê²€ì¦
  if (!student_id || !tenant_id || !exam_date || !exam_title || !grade || !subject_id || !subject_group_id || !curriculum_revision_id) {
    throw new AppError("í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  // exam_dateë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•™ë…„ë„ ê³„ì‚°
  const examDate = new Date(exam_date);
  const school_year = calculateSchoolYear(examDate);

  // í•™ê¸° ê³„ì‚° (ì—†ìœ¼ë©´ exam_date ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •: 3~8ì›” = 1í•™ê¸°, 9~2ì›” = 2í•™ê¸°)
  const calculatedSemester = semester ?? (examDate.getMonth() + 1 >= 3 && examDate.getMonth() + 1 <= 8 ? 1 : 2);

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„± (ì‹¤íŒ¨ ì‹œ NULL í—ˆìš©)
  let student_term_id: string | null = null;
  try {
    student_term_id = await getOrCreateStudentTerm({
      tenant_id,
      student_id,
      school_year,
      grade,
      semester: calculatedSemester,
      curriculum_revision_id,
    });
  } catch (error) {
    // ëª¨ì˜ê³ ì‚¬ ì„±ì ì˜ ê²½ìš° student_term_idê°€ ì—†ì–´ë„ ì €ì¥ ê°€ëŠ¥
    console.warn("[actions/scores-internal] student_term ì¡°íšŒ/ìƒì„± ì‹¤íŒ¨ (NULLë¡œ ì €ì¥)", error);
  }

  // ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„±
  const { data, error } = await supabase
    .from("student_mock_scores")
    .insert({
      tenant_id,
      student_id,
      student_term_id: student_term_id ?? null, // nullable
      exam_date,
      exam_title,
      grade,
      subject_id,
      subject_group_id,
      raw_score,
      standard_score,
      percentile,
      grade_score,
    })
    .select("id")
    .single();

  if (error) {
    console.error("[actions/scores-internal] ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± ì‹¤íŒ¨", error);
    throw new AppError("ëª¨ì˜ê³ ì‚¬ ì„±ì  ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", ErrorCode.DATABASE_ERROR, 500, true);
  }

  revalidatePath("/scores");
  return { success: true, scoreId: data.id };
}

export const createMockScore = withErrorHandling(_createMockScore);
</file>

<file path="scores.ts">
"use server";

/**
 * âš ï¸ DEPRECATED: ì´ íŒŒì¼ì€ ë ˆê±°ì‹œ student_scores í…Œì´ë¸”ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * 
 * ìƒˆ êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”:
 * - ë‚´ì‹  ì„±ì : student_internal_scores í…Œì´ë¸” ì‚¬ìš©
 * - ëª¨ì˜ê³ ì‚¬ ì„±ì : student_mock_scores í…Œì´ë¸” ì‚¬ìš©
 * 
 * ìƒˆ êµ¬ì¡°ëŠ” student_termsë¥¼ í†µí•´ í•™ê¸° ì •ë³´ë¥¼ ê´€ë¦¬í•˜ë©°,
 * student_term_id FKë¥¼ í†µí•´ ì—°ê²°ë©ë‹ˆë‹¤.
 * 
 * @see lib/data/studentScores.ts - createInternalScore, createMockScore
 * @see lib/domains/score/repository.ts - insertInternalScore, insertMockScore
 */

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { recordHistory } from "@/lib/history/record";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";
import { validateFormData, studentScoreSchema } from "@/lib/validation/schemas";
import { safeQuery } from "@/lib/supabase/queryHelpers";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

// ì„±ì  ë“±ë¡
async function _addStudentScore(formData: FormData) {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  // ì…ë ¥ ê²€ì¦
  const validation = validateFormData(formData, studentScoreSchema);
  if (!validation.success) {
    const firstError = validation.errors.issues[0];
    throw new AppError(
      firstError?.message ?? "ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  const {
    subject_type,
    semester,
    course,
    course_detail,
    raw_score,
    grade,
    score_type_detail,
    test_date,
  } = validation.data;

  // studentì˜ tenant_id ì¡°íšŒ
  const selectStudent = async () => {
    const result = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", user.id)
      .single();
    return { data: result.data, error: result.error };
  };

  const student = await safeQuery(selectStudent, selectStudent);

  if (!student || !student.tenant_id) {
    throw new AppError("í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", ErrorCode.NOT_FOUND, 404, true);
  }

  const insertPayload = {
    student_id: user.id,
    tenant_id: student.tenant_id,
    subject_type,
    semester,
    course,
    course_detail: course_detail ?? null,
    raw_score,
    grade,
    score_type_detail,
    test_date,
  };

  const insertQuery = async () => {
    const result = await supabase.from("student_scores").insert(insertPayload);
    return { data: result.data, error: result.error };
  };
  const fallbackInsertQuery = async () => {
    const { student_id: _studentId, ...fallbackPayload } = insertPayload;
    const result = await supabase.from("student_scores").insert(fallbackPayload);
    return { data: result.data, error: result.error };
  };

  const insertResult = await safeQuery(insertQuery, fallbackInsertQuery);

  if (insertResult === null) {
    throw new AppError(
      "ì„±ì  ë“±ë¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true
    );
  }

  // íˆìŠ¤í† ë¦¬ ê¸°ë¡
  await recordHistory(supabase, user.id, "score_added", {
    subject_type,
    course,
    course_detail: course_detail ?? null,
    raw_score,
    grade,
    test_date,
  });

  revalidatePath("/scores");
  redirect("/scores");
}

export const addStudentScore = withErrorHandling(_addStudentScore);

// ì„±ì  ìˆ˜ì •
async function _updateStudentScore(id: string, formData: FormData) {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  if (!id) {
    throw new AppError("ì„±ì  IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  // ì…ë ¥ ê²€ì¦
  const validation = validateFormData(formData, studentScoreSchema);
  if (!validation.success) {
    const firstError = validation.errors.issues[0];
    throw new AppError(
      firstError?.message ?? "ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  const {
    subject_type,
    semester,
    course,
    course_detail,
    raw_score,
    grade,
    score_type_detail,
    test_date,
  } = validation.data;

  const updatePayload = {
    subject_type,
    semester,
    course,
    course_detail: course_detail ?? null,
    raw_score,
    grade,
    score_type_detail,
    test_date,
  };

  const updateQuery = async () => {
    const result = await supabase
      .from("student_scores")
      .update(updatePayload)
      .eq("id", id)
      .eq("student_id", user.id);
    return { data: result.data, error: result.error };
  };

  const fallbackUpdateQuery = async () => {
    const result = await supabase
      .from("student_scores")
      .update(updatePayload)
      .eq("id", id);
    return { data: result.data, error: result.error };
  };

  const updateResult = await safeQuery(updateQuery, fallbackUpdateQuery);

  if (updateResult === null) {
    throw new AppError(
      "ì„±ì  ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true
    );
  }

  // íˆìŠ¤í† ë¦¬ ê¸°ë¡
  await recordHistory(supabase, user.id, "score_updated", {
    score_id: id,
    subject_type,
    course,
    course_detail: course_detail ?? null,
    raw_score,
    grade,
    test_date,
  });

  revalidatePath("/scores");
  revalidatePath(`/scores/${id}/edit`);
  redirect("/scores");
}

export const updateStudentScore = withErrorHandling(_updateStudentScore);

// ì„±ì  ì‚­ì œ
async function _deleteStudentScore(id: string) {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new AppError("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.UNAUTHORIZED, 401, true);
  }

  if (!id) {
    throw new AppError("ì„±ì  IDê°€ í•„ìš”í•©ë‹ˆë‹¤.", ErrorCode.VALIDATION_ERROR, 400, true);
  }

  const deleteQuery = async () => {
    const result = await supabase
      .from("student_scores")
      .delete()
      .eq("id", id)
      .eq("student_id", user.id);
    return { data: result.data, error: result.error };
  };

  const fallbackDeleteQuery = async () => {
    const result = await supabase
      .from("student_scores")
      .delete()
      .eq("id", id);
    return { data: result.data, error: result.error };
  };

  const deleteResult = await safeQuery(deleteQuery, fallbackDeleteQuery);

  if (deleteResult === null) {
    throw new AppError(
      "ì„±ì  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      ErrorCode.DATABASE_ERROR,
      500,
      true
    );
  }

  revalidatePath("/scores");
  redirect("/scores");
}

export const deleteStudentScore = withErrorHandling(_deleteStudentScore);
</file>

<file path="smsActions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { sendSMS, sendBulkSMS } from "@/lib/services/smsService";
import {
  formatSMSTemplate,
  type SMSTemplateType,
} from "@/lib/services/smsTemplates";
import { requireAdminAuth } from "@/lib/auth/requireAdminAuth";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { AppError, ErrorCode, withErrorHandling } from "@/lib/errors";
import { getStudentPhones, getStudentPhonesBatch } from "@/lib/utils/studentPhoneUtils";

/**
 * í…Œë„ŒíŠ¸ ì„¤ì •ê³¼ í•™ìƒ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ SMS ìˆ˜ì‹ ì ì „í™”ë²ˆí˜¸ ëª©ë¡ ê²°ì •
 */
function determineRecipientPhones(
  recipientSetting: 'mother' | 'father' | 'both' | 'auto',
  student: { mother_phone: string | null; father_phone: string | null }
): string[] {
  const recipientPhones: string[] = [];
  
  switch (recipientSetting) {
    case 'mother':
      if (student.mother_phone) {
        recipientPhones.push(student.mother_phone);
      }
      break;
    case 'father':
      if (student.father_phone) {
        recipientPhones.push(student.father_phone);
      }
      break;
    case 'both':
      if (student.mother_phone) {
        recipientPhones.push(student.mother_phone);
      }
      if (student.father_phone) {
        recipientPhones.push(student.father_phone);
      }
      break;
    case 'auto':
    default: {
      // ê¸°ì¡´ ë¡œì§: ë¨¼ì € ìˆëŠ” ë²ˆí˜¸ ì‚¬ìš©
      const parentContact = student.mother_phone || student.father_phone;
      if (parentContact) {
        recipientPhones.push(parentContact);
      }
      break;
    }
  }
  
  return recipientPhones;
}

/**
 * ì¶œì„ ê´€ë ¨ SMS ë°œì†¡ (ë‚´ë¶€ ì‚¬ìš©, ê¶Œí•œ ì²´í¬ ì—†ìŒ)
 * í•™ìƒ ì§ì ‘ ì²´í¬ì¸/ì²´í¬ì•„ì›ƒ ì‹œ ì‚¬ìš©
 */
export async function sendAttendanceSMSInternal(
  studentId: string,
  templateType:
    | "attendance_check_in"
    | "attendance_check_out"
    | "attendance_absent"
    | "attendance_late",
  variables: Record<string, string>
): Promise<{ success: boolean; msgId?: string; error?: string }> {
  const handler = withErrorHandling(async () => {
    const tenantContext = await getTenantContext();

    if (!tenantContext?.tenantId) {
      throw new AppError(
        "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    // í…Œë„ŒíŠ¸ SMS ìˆ˜ì‹ ì ì„¤ì • ì¡°íšŒ
    const supabase = await createSupabaseServerClient();
    const { data: tenant, error: tenantError } = await supabase
      .from("tenants")
      .select("attendance_sms_recipient")
      .eq("id", tenantContext.tenantId)
      .single();

    if (tenantError) {
      console.error("[SMS] í…Œë„ŒíŠ¸ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨:", tenantError);
      throw new AppError(
        "í…Œë„ŒíŠ¸ ì„¤ì •ì„ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    const recipientSetting = (tenant?.attendance_sms_recipient as 'mother' | 'father' | 'both' | 'auto') ?? 'auto';

    // í•™ìƒ ì „í™”ë²ˆí˜¸ ì •ë³´ ì¡°íšŒ (ê³µí†µ í—¬í¼ í•¨ìˆ˜ ì‚¬ìš©)
    const studentPhoneData = await getStudentPhones(studentId);

    if (!studentPhoneData) {
      throw new AppError(
        "í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    // ì„¤ì •ì— ë”°ë¼ ìˆ˜ì‹ ì ê²°ì • (ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©)
    const recipientPhones = determineRecipientPhones(recipientSetting, {
      mother_phone: studentPhoneData.mother_phone,
      father_phone: studentPhoneData.father_phone,
    });

    if (recipientPhones.length === 0) {
      throw new AppError(
        "í•™ë¶€ëª¨ ì—°ë½ì²˜ê°€ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }

    // í…œí”Œë¦¿ í¬ë§·íŒ…
    const message = formatSMSTemplate(templateType, {
      ...variables,
      í•™ìƒëª…: studentPhoneData.name || "í•™ìƒ",
    });

    // SMS ë°œì†¡ (ì—¬ëŸ¬ ìˆ˜ì‹ ìì¸ ê²½ìš° ê°ê° ë°œì†¡)
    let lastMsgId: string | undefined;
    for (const recipientPhone of recipientPhones) {
      const result = await sendSMS({
        recipientPhone,
        message,
        recipientId: studentId,
        tenantId: tenantContext.tenantId,
      });

      if (!result.success) {
        throw new AppError(
          result.error || "SMS ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
          ErrorCode.EXTERNAL_SERVICE_ERROR,
          500,
          true
        );
      }

      lastMsgId = result.messageKey;
    }

    revalidatePath("/admin/sms");
    return { success: true, msgId: lastMsgId };
  });
  return handler();
}

/**
 * ì¶œì„ ê´€ë ¨ SMS ë°œì†¡ (ê´€ë¦¬ì ì „ìš©)
 * ê´€ë¦¬ì ì•¡ì…˜ì—ì„œ ì‚¬ìš©
 */
export async function sendAttendanceSMS(
  studentId: string,
  templateType:
    | "attendance_check_in"
    | "attendance_check_out"
    | "attendance_absent"
    | "attendance_late",
  variables: Record<string, string>
): Promise<{ success: boolean; msgId?: string; error?: string }> {
  const handler = withErrorHandling(async () => {
    await requireAdminAuth();
    return await sendAttendanceSMSInternal(studentId, templateType, variables);
  });
  return handler();
}

/**
 * ì—¬ëŸ¬ í•™ìƒì—ê²Œ ì¼ê´„ ì¶œì„ SMS ë°œì†¡
 */
export async function sendBulkAttendanceSMS(
  studentIds: string[],
  templateType:
    | "attendance_check_in"
    | "attendance_check_out"
    | "attendance_absent"
    | "attendance_late",
  variables: Record<string, string>
): Promise<{
  success: number;
  failed: number;
  errors: Array<{ studentId: string; error: string }>;
}> {
  const handler = withErrorHandling(async () => {
    await requireAdminAuth();
    const tenantContext = await getTenantContext();

    if (!tenantContext?.tenantId) {
      throw new AppError(
        "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    // í…Œë„ŒíŠ¸ SMS ìˆ˜ì‹ ì ì„¤ì • ì¡°íšŒ
    const supabase = await createSupabaseServerClient();
    const { data: tenant, error: tenantError } = await supabase
      .from("tenants")
      .select("attendance_sms_recipient")
      .eq("id", tenantContext.tenantId)
      .single();

    if (tenantError) {
      console.error("[SMS] í…Œë„ŒíŠ¸ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨:", tenantError);
      throw new AppError(
        "í…Œë„ŒíŠ¸ ì„¤ì •ì„ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.DATABASE_ERROR,
        500,
        true
      );
    }

    const recipientSetting = (tenant?.attendance_sms_recipient as 'mother' | 'father' | 'both' | 'auto') ?? 'auto';

    // í•™ìƒ ì „í™”ë²ˆí˜¸ ì •ë³´ ì¼ê´„ ì¡°íšŒ (ê³µí†µ í—¬í¼ í•¨ìˆ˜ ì‚¬ìš©)
    const studentsWithPhones = await getStudentPhonesBatch(studentIds);

    if (studentsWithPhones.length === 0) {
      throw new AppError(
        "í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    // ì„¤ì •ì— ë”°ë¼ SMS ë°œì†¡ ëŒ€ìƒ ì¤€ë¹„
    const recipients: Array<{
      phone: string;
      message: string;
      recipientId: string;
    }> = [];

    for (const student of studentsWithPhones) {
      // ì„¤ì •ì— ë”°ë¼ ìˆ˜ì‹ ì ê²°ì • (ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©)
      const recipientPhones = determineRecipientPhones(recipientSetting, {
        mother_phone: student.mother_phone,
        father_phone: student.father_phone,
      });

      // ê° ìˆ˜ì‹ ìì—ê²Œ SMS ë°œì†¡ ëŒ€ìƒ ì¶”ê°€
      for (const recipientPhone of recipientPhones) {
        recipients.push({
          phone: recipientPhone,
          message: formatSMSTemplate(templateType, {
            ...variables,
            í•™ìƒëª…: student.name || "í•™ìƒ",
          }),
          recipientId: student.id,
        });
      }
    }

    if (recipients.length === 0) {
      throw new AppError(
        "ë°œì†¡ ê°€ëŠ¥í•œ í•™ë¶€ëª¨ ì—°ë½ì²˜ê°€ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }

    // ëŒ€ëŸ‰ ë°œì†¡
    const result = await sendBulkSMS(
      recipients,
      tenantContext.tenantId
    );

    // ê²°ê³¼ ë§¤í•‘ (studentId í¬í•¨)
    const errors = result.errors.map((err, index) => {
      const recipient = recipients[index];
      return {
        studentId: recipient.recipientId || "",
        error: err.error,
      };
    });

    revalidatePath("/admin/sms");
    return {
      success: result.success,
      failed: result.failed,
      errors,
    };
  });
  return handler();
}

/**
 * ì¼ë°˜ SMS ë°œì†¡ (ê³µì§€ì‚¬í•­ ë“±)
 */
export async function sendGeneralSMS(
  recipientPhone: string,
  message: string,
  recipientId?: string
): Promise<{ success: boolean; msgId?: string; error?: string }> {
  const handler = withErrorHandling(async () => {
    await requireAdminAuth();
    const tenantContext = await getTenantContext();

    if (!tenantContext?.tenantId) {
      throw new AppError(
        "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    const result = await sendSMS({
      recipientPhone,
      message,
      recipientId,
      tenantId: tenantContext.tenantId,
    });

    if (!result.success) {
      throw new AppError(
        result.error || "SMS ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        ErrorCode.EXTERNAL_SERVICE_ERROR,
        500,
        true
      );
    }

    revalidatePath("/admin/sms");
    return { success: true, msgId: result.messageKey };
  });
  return handler();
}

/**
 * ì—¬ëŸ¬ í•™ìƒì—ê²Œ ì¼ê´„ ì¼ë°˜ SMS ë°œì†¡
 */
export async function sendBulkGeneralSMS(
  studentIds: string[],
  message: string,
  templateVariables?: Record<string, string>,
  recipientType: "student" | "mother" | "father" = "mother"
): Promise<{
  success: number;
  failed: number;
  errors: Array<{ studentId: string; error: string }>;
}> {
  const handler = withErrorHandling(async () => {
    await requireAdminAuth();
    const tenantContext = await getTenantContext();

    if (!tenantContext?.tenantId) {
      throw new AppError(
        "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    if (!studentIds || studentIds.length === 0) {
      throw new AppError(
        "ë°œì†¡ ëŒ€ìƒ í•™ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }

    // í•™ìƒ ì „í™”ë²ˆí˜¸ ì •ë³´ ì¼ê´„ ì¡°íšŒ (ê³µí†µ í—¬í¼ í•¨ìˆ˜ ì‚¬ìš©)
    const studentsWithPhones = await getStudentPhonesBatch(studentIds);

    if (studentsWithPhones.length === 0) {
      throw new AppError(
        "í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.NOT_FOUND,
        404,
        true
      );
    }

    // í•™ì›ëª… ì¡°íšŒ
    const supabase = await createSupabaseServerClient();
    const { data: tenant } = await supabase
      .from("tenants")
      .select("name")
      .eq("id", tenantContext.tenantId)
      .single();

    const academyName = tenant?.name || "í•™ì›";

    // ì „ì†¡ ëŒ€ìƒìì— ë”°ë¼ ì „í™”ë²ˆí˜¸ ì„ íƒ
    const getPhoneByRecipientType = (student: { phone: string | null; mother_phone: string | null; father_phone: string | null }, type: "student" | "mother" | "father"): string | null => {
      switch (type) {
        case "student":
          return student.phone;
        case "mother":
          return student.mother_phone;
        case "father":
          return student.father_phone;
        default:
          return student.mother_phone ?? student.father_phone ?? student.phone;
      }
    };

    // SMS ë°œì†¡ ëŒ€ìƒ ì¤€ë¹„ (ì„ íƒí•œ ëŒ€ìƒì íƒ€ì…ì— ë”°ë¼)
    const recipients = studentsWithPhones
      .map((student) => {
        const phone = getPhoneByRecipientType(student, recipientType);
        return { ...student, selectedPhone: phone };
      })
      .filter((student) => student.selectedPhone)
      .map((student) => {
        // ê° í•™ìƒë³„ë¡œ ë©”ì‹œì§€ ë³€ìˆ˜ ì¹˜í™˜
        let finalMessage = message;
        
        // í•™ìƒëª… ìë™ ì¹˜í™˜ (í•­ìƒ)
        finalMessage = finalMessage.replace(
          /\{í•™ìƒëª…\}/g,
          student.name || "í•™ìƒ"
        );
        
        // í•™ì›ëª… ìë™ ì¹˜í™˜ (í•­ìƒ)
        finalMessage = finalMessage.replace(/\{í•™ì›ëª…\}/g, academyName);
        
        // í…œí”Œë¦¿ ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ ì¶”ê°€ ë³€ìˆ˜ ì¹˜í™˜
        if (templateVariables) {
          for (const [key, value] of Object.entries(templateVariables)) {
            if (key !== "í•™ìƒëª…" && key !== "í•™ì›ëª…" && value) {
              finalMessage = finalMessage.replace(
                new RegExp(`\\{${key}\\}`, "g"),
                value
              );
            }
          }
        }

        return {
          phone: student.selectedPhone!,
          message: finalMessage,
          recipientId: student.id,
        };
      });

    if (recipients.length === 0) {
      throw new AppError(
        "ë°œì†¡ ê°€ëŠ¥í•œ í•™ë¶€ëª¨ ì—°ë½ì²˜ê°€ ì—†ìŠµë‹ˆë‹¤.",
        ErrorCode.VALIDATION_ERROR,
        400,
        true
      );
    }

    // ëŒ€ëŸ‰ ë°œì†¡
    const result = await sendBulkSMS(recipients, tenantContext.tenantId);

    // ê²°ê³¼ ë§¤í•‘ (studentId í¬í•¨)
    const errors = result.errors.map((err, index) => {
      const recipient = recipients[index];
      return {
        studentId: recipient.recipientId || "",
        error: err.error,
      };
    });

    revalidatePath("/admin/sms");
    return {
      success: result.success,
      failed: result.failed,
      errors,
    };
  });
  return handler();
}
</file>

<file path="studySessions.ts">
// ì´ íŒŒì¼ì€ app/(student)/actions/studySessionActions.tsë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
// ê¸°ì¡´ importë¥¼ ì—…ë°ì´íŠ¸í•´ì£¼ì„¸ìš”:
// - startStudySession â†’ app/(student)/actions/studySessionActions.ts
// - endStudySession â†’ app/(student)/actions/studySessionActions.ts
// - cancelStudySession â†’ app/(student)/actions/studySessionActions.ts

export {
  startStudySession,
  endStudySession,
  cancelStudySession,
} from "@/app/(student)/actions/studySessionActions";
</file>

<file path="tenants.ts">
"use server";

import { createSupabaseAdminClient } from "@/lib/supabase/admin";

export type TenantOption = {
  id: string;
  name: string;
  type: string | null;
};

/**
 * íšŒì›ê°€ì…ìš© ê¸°ê´€ ëª©ë¡ ì¡°íšŒ
 * í™œì„±í™”ëœ ê¸°ê´€ë§Œ ì¡°íšŒ
 * ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìë„ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
 */
export async function getTenantOptionsForSignup(): Promise<TenantOption[]> {
  // íšŒì›ê°€ì… ì‹œì ì—ëŠ” ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì´ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
  const adminClient = createSupabaseAdminClient();
  
  if (!adminClient) {
    console.error("[tenants] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨: SUPABASE_SERVICE_ROLE_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
    return [];
  }

  // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸ í›„ ì¿¼ë¦¬ êµ¬ì„±
  let query = adminClient
    .from("tenants")
    .select("id, name, type")
    .order("name", { ascending: true });

  // status ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ í™œì„±í™”ëœ ê¸°ê´€ë§Œ í•„í„°ë§
  try {
    const { error: testError } = await adminClient
      .from("tenants")
      .select("status")
      .limit(1);
    
    if (!testError) {
      // status ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ í™œì„±í™”ëœ ê¸°ê´€ë§Œ ì¡°íšŒ
      query = adminClient
        .from("tenants")
        .select("id, name, type")
        .eq("status", "active")
        .order("name", { ascending: true });
    }
  } catch (e) {
    // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
  }

  const { data, error } = await query;

  if (error) {
    console.error("[tenants] ê¸°ê´€ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }

  return (data || []).map((tenant) => ({
    id: tenant.id,
    name: tenant.name,
    type: tenant.type,
  }));
}
</file>

<file path="userRole.ts">
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { revalidatePath } from "next/cache";

/**
 * ì‚¬ìš©ì ê¶Œí•œ ë³€ê²½
 * í•™ìƒ â†” í•™ë¶€ëª¨ ì „í™˜
 */
export async function changeUserRole(
  newRole: "student" | "parent"
): Promise<{ success: boolean; error?: string }> {
  const { userId } = await getCurrentUserRole();

  if (!userId) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const supabase = await createSupabaseServerClient();

  try {
    // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return { success: false, error: "ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // user_metadataì—ì„œ tenant_id ê°€ì ¸ì˜¤ê¸°
    let tenantId = (user.user_metadata?.tenant_id as string) || null;

    // tenant_idê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ tenant ì¡°íšŒ
    if (!tenantId) {
      const { data: defaultTenant, error: tenantError } = await supabase
        .from("tenants")
        .select("id")
        .eq("name", "Default Tenant")
        .maybeSingle();

      if (tenantError) {
        console.error("[userRole] Default Tenant ì¡°íšŒ ì‹¤íŒ¨:", tenantError);
        return {
          success: false,
          error: "ê¸°ë³¸ ê¸°ê´€ ì •ë³´ë¥¼ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        };
      }

      if (!defaultTenant) {
        console.error("[userRole] Default Tenantê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return {
          success: false,
          error:
            "ê¸°ë³¸ ê¸°ê´€ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.",
        };
      }

      tenantId = defaultTenant.id;
    }

    if (newRole === "student") {
      // í•™ë¶€ëª¨ â†’ í•™ìƒ ì „í™˜
      // 1. parent_users í…Œì´ë¸”ì—ì„œ ë ˆì½”ë“œ ì‚­ì œ
      const { error: deleteParentError } = await supabase
        .from("parent_users")
        .delete()
        .eq("id", userId);

      if (deleteParentError && deleteParentError.code !== "PGRST116") {
        console.error("[userRole] í•™ë¶€ëª¨ ë ˆì½”ë“œ ì‚­ì œ ì‹¤íŒ¨:", deleteParentError);
        // ë ˆì½”ë“œê°€ ì—†ì–´ë„ ê³„ì† ì§„í–‰
      }

      // 2. students í…Œì´ë¸”ì— ë ˆì½”ë“œ ìƒì„± (ê¸°ë³¸ ì •ë³´ë§Œ)
      // í•™ìƒ ì •ë³´ëŠ” /settingsì—ì„œ ì…ë ¥í•˜ë„ë¡ ì•ˆë‚´
      const displayName = (user.user_metadata?.display_name as string) || "ì´ë¦„ ì—†ìŒ";
      const { error: createStudentError } = await supabase
        .from("students")
        .upsert({
          id: userId,
          user_id: userId,
          tenant_id: tenantId,
          name: displayName, // nameì€ í•„ìˆ˜ í•„ë“œ
          grade: null,
          school_id: null,
          school_type: null,
        });

      if (createStudentError) {
        console.error("[userRole] í•™ìƒ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨:", createStudentError);
        return {
          success: false,
          error: createStudentError.message || "í•™ìƒ ê¶Œí•œ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }

      // 3. user_metadata ì—…ë°ì´íŠ¸
      await supabase.auth.updateUser({
        data: {
          signup_role: "student",
        },
      });
    } else {
      // í•™ìƒ â†’ í•™ë¶€ëª¨ ì „í™˜
      // 1. students í…Œì´ë¸”ì—ì„œ ë ˆì½”ë“œ ì‚­ì œ (id ë˜ëŠ” user_idë¡œ ì¡°íšŒ)
      let deleteStudentError = null;
      
      // idë¡œ ë¨¼ì € ì‹œë„
      const { error: error1 } = await supabase
        .from("students")
        .delete()
        .eq("id", userId);
      
      if (error1) {
        // user_idë¡œ ì‹œë„
        const { error: error2 } = await supabase
          .from("students")
          .delete()
          .eq("user_id", userId);
        
        deleteStudentError = error2;
      }

      if (deleteStudentError && deleteStudentError.code !== "PGRST116") {
        console.error("[userRole] í•™ìƒ ë ˆì½”ë“œ ì‚­ì œ ì‹¤íŒ¨:", deleteStudentError);
        // ë ˆì½”ë“œê°€ ì—†ì–´ë„ ê³„ì† ì§„í–‰
      }

      // 2. parent_users í…Œì´ë¸”ì— ë ˆì½”ë“œ ìƒì„±
      const { error: createParentError } = await supabase
        .from("parent_users")
        .upsert({
          id: userId,
          tenant_id: tenantId,
          relationship: null,
          occupation: null,
        });

      if (createParentError) {
        console.error("[userRole] í•™ë¶€ëª¨ ë ˆì½”ë“œ ìƒì„± ì‹¤íŒ¨:", createParentError);
        return {
          success: false,
          error: createParentError.message || "í•™ë¶€ëª¨ ê¶Œí•œ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
        };
      }

      // 3. user_metadata ì—…ë°ì´íŠ¸
      await supabase.auth.updateUser({
        data: {
          signup_role: "parent",
        },
      });
    }

    revalidatePath("/settings");
    revalidatePath("/parent/settings");

    return { success: true };
  } catch (error) {
    console.error("[userRole] ê¶Œí•œ ë³€ê²½ ì¤‘ ì˜¤ë¥˜:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "ê¶Œí•œ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    };
  }
}
</file>

<file path="admin/check-student-scores/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getSchoolScoreSummary, getMockScoreSummary, getRiskIndexBySubject } from "@/lib/scheduler/scoreLoader";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import {
  apiSuccess,
  apiUnauthorized,
  apiForbidden,
  apiNotFound,
  handleApiError,
} from "@/lib/api";

/**
 * í•™ìƒ ì„±ì  í™•ì¸ API (ê´€ë¦¬ììš©)
 * GET /api/admin/check-student-scores?email=...&student_id=...
 *
 * @returns
 * ì„±ê³µ: { success: true, data: StudentScoresData }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const email = searchParams.get("email");
    const studentIdParam = searchParams.get("student_id");

    const supabase = await createSupabaseServerClient();

    let studentId: string | null = null;
    let targetEmail: string | null = null;

    // student_idê°€ ì§ì ‘ ì œê³µëœ ê²½ìš° ìš°ì„  ì‚¬ìš©
    if (studentIdParam) {
      studentId = studentIdParam;
      targetEmail = email || null;
    } else if (email) {
      const currentUser = await getCurrentUser();

      if (currentUser?.email === email) {
        studentId = currentUser.userId;
        targetEmail = email;
      } else {
        const { data: student, error: studentError } = await supabase
          .from("students")
          .select("id")
          .eq("email", email)
          .maybeSingle();

        if (studentError || !student) {
          return apiForbidden(
            "ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ë ¤ë©´ student_id íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤."
          );
        }

        studentId = student.id;
        targetEmail = email;
      }
    } else {
      const currentUser = await getCurrentUser();

      if (!currentUser) {
        return apiUnauthorized();
      }

      studentId = currentUser.userId;
      targetEmail = currentUser.email || null;
    }

    if (!studentId) {
      return apiNotFound("ì‚¬ìš©ì IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    // âš ï¸ DEPRECATED: student_school_scores í…Œì´ë¸” ì‚¬ìš©
    // ìƒˆ êµ¬ì¡°: student_internal_scores í…Œì´ë¸” ì‚¬ìš© ê¶Œì¥
    
    // 1. ë‚´ì‹  ì„±ì  ì¡°íšŒ
    const selectSchoolScores = () =>
      supabase
        .from("student_school_scores")
        .select("*")
        .eq("student_id", studentId)
        .order("grade", { ascending: true })
        .order("semester", { ascending: true })
        .order("created_at", { ascending: false });

    let { data: schoolScores, error: schoolError } = await selectSchoolScores();

    if (schoolError && schoolError.code === "42703") {
      ({ data: schoolScores, error: schoolError } = await supabase
        .from("student_school_scores")
        .select("*")
        .order("grade", { ascending: true })
        .order("semester", { ascending: true })
        .order("created_at", { ascending: false }));
    }

    if (schoolError) {
      console.error("[check-student-scores] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì˜¤ë¥˜:", schoolError);
    }

    // 2. ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ
    const selectMockScores = () =>
      supabase
        .from("student_mock_scores")
        .select("*")
        .eq("student_id", studentId)
        .order("grade", { ascending: true })
        .order("created_at", { ascending: false });

    let { data: mockScores, error: mockError } = await selectMockScores();

    if (mockError && mockError.code === "42703") {
      ({ data: mockScores, error: mockError } = await supabase
        .from("student_mock_scores")
        .select("*")
        .order("grade", { ascending: true })
        .order("created_at", { ascending: false }));
    }

    if (mockError) {
      console.error("[check-student-scores] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì˜¤ë¥˜:", mockError);
    }

    // ë””ë²„ê¹…: í…Œì´ë¸”ì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    const { data: allSchoolScores } = await supabase
      .from("student_school_scores")
      .select("id, student_id, subject_group, grade_score")
      .limit(10);

    const { data: allMockScores } = await supabase
      .from("student_mock_scores")
      .select("id, student_id, subject_group, percentile")
      .limit(10);

    const { data: uniqueStudentIds } = await supabase
      .from("student_school_scores")
      .select("student_id")
      .limit(100);

    const uniqueIds = uniqueStudentIds
      ? Array.from(new Set(uniqueStudentIds.map((s) => s.student_id).filter(Boolean)))
      : [];

    // 3. ì¶”ì²œ ì‹œìŠ¤í…œ ìš”ì•½ ë°ì´í„°
    const [schoolSummary, mockSummary, riskIndex] = await Promise.all([
      getSchoolScoreSummary(studentId),
      getMockScoreSummary(studentId),
      getRiskIndexBySubject(studentId),
    ]);

    // 4. ê³¼ëª©ë³„ ë¶„ì„
    const allSubjects = new Set<string>();
    schoolSummary.forEach((_, subject) => allSubjects.add(subject));
    mockSummary.forEach((_, subject) => allSubjects.add(subject));

    const requiredSubjects = ["êµ­ì–´", "ìˆ˜í•™", "ì˜ì–´"];
    const subjectAnalysis = Array.from(allSubjects).map((subject) => {
      const school = schoolSummary.get(subject);
      const mock = mockSummary.get(subject);
      const risk = riskIndex.get(subject);

      const schoolCount =
        schoolScores?.filter((s) => s.subject_group?.toLowerCase().trim() === subject).length || 0;
      const mockCount =
        mockScores?.filter((s) => s.subject_group?.toLowerCase().trim() === subject).length || 0;

      const hasSchool = school && school.recentGrade !== null;
      const hasMock = mock && (mock.recentPercentile !== null || mock.recentGrade !== null);
      const hasMultipleSchool = school && school.averageGrade !== null && school.gradeVariance > 0;
      const hasMultipleMock = mock && mock.averagePercentile !== null;

      let level = "ì—†ìŒ";
      if (hasMultipleSchool && hasMultipleMock) {
        level = "ìµœì ";
      } else if (hasMultipleSchool || hasMultipleMock) {
        level = "ì¢‹ìŒ";
      } else if (hasSchool || hasMock) {
        level = "ê¸°ë³¸";
      }

      return {
        subject,
        level,
        schoolCount,
        mockCount,
        hasSchool,
        hasMock,
        hasMultipleSchool,
        hasMultipleMock,
        schoolSummary: school
          ? {
              recentGrade: school.recentGrade,
              averageGrade: school.averageGrade,
              gradeVariance: school.gradeVariance,
            }
          : null,
        mockSummary: mock
          ? {
              recentPercentile: mock.recentPercentile,
              averagePercentile: mock.averagePercentile,
              recentGrade: mock.recentGrade,
              averageGrade: mock.averageGrade,
            }
          : null,
        riskScore: risk?.riskScore || null,
        riskReasons: risk?.reasons || [],
      };
    });

    // 5. ê°œì„  ê¶Œì¥ì‚¬í•­
    const recommendations: string[] = [];

    if (schoolSummary.size === 0 && mockSummary.size === 0) {
      recommendations.push("ì„±ì  ë°ì´í„°ê°€ ì „í˜€ ì—†ìŠµë‹ˆë‹¤. ìµœì†Œ 1ê°œ ê³¼ëª©ì˜ ì„±ì ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    } else {
      if (schoolSummary.size === 0) {
        recommendations.push("ë‚´ì‹  ì„±ì ì´ ì—†ìŠµë‹ˆë‹¤. ë‚´ì‹  ì„±ì ì„ ì…ë ¥í•˜ë©´ ë” ì •í™•í•œ ì¶”ì²œì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
      if (mockSummary.size === 0) {
        recommendations.push("ëª¨ì˜ê³ ì‚¬ ì„±ì ì´ ì—†ìŠµë‹ˆë‹¤. ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ ì…ë ¥í•˜ë©´ ìœ„í—˜ë„ ë¶„ì„ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
      }

      requiredSubjects.forEach((subject) => {
        const lowerSubject = subject.toLowerCase();
        const analysis = subjectAnalysis.find((a) => a.subject === lowerSubject);
        if (!analysis) {
          recommendations.push(`í•„ìˆ˜ ê³¼ëª© "${subject}"ì˜ ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
        } else if (!analysis.hasSchool && !analysis.hasMock) {
          recommendations.push(`í•„ìˆ˜ ê³¼ëª© "${subject}"ì˜ ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
        } else if (analysis.hasSchool && !analysis.hasMultipleSchool) {
          recommendations.push(`í•„ìˆ˜ ê³¼ëª© "${subject}"ì˜ ë‚´ì‹  ì„±ì ì„ 2ê°œ ì´ìƒ ì…ë ¥í•˜ë©´ í‰ê·  ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
        } else if (analysis.hasMock && !analysis.hasMultipleMock) {
          recommendations.push(`í•„ìˆ˜ ê³¼ëª© "${subject}"ì˜ ëª¨ì˜ê³ ì‚¬ ì„±ì ì„ 2ê°œ ì´ìƒ ì…ë ¥í•˜ë©´ í‰ê·  ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
        }
      });
    }

    return apiSuccess({
      email: targetEmail,
      studentId,
      debug: {
        queryStudentId: studentId,
        schoolError: schoolError
          ? {
              message: schoolError.message,
              code: schoolError.code,
              details: schoolError.details,
            }
          : null,
        mockError: mockError
          ? {
              message: mockError.message,
              code: mockError.code,
              details: mockError.details,
            }
          : null,
        tableSample: {
          schoolScoresCount: allSchoolScores?.length || 0,
          mockScoresCount: allMockScores?.length || 0,
          uniqueStudentIds: uniqueIds,
          schoolScoresSample: allSchoolScores?.slice(0, 3).map((s) => ({
            id: s.id,
            student_id: s.student_id,
            subject_group: s.subject_group,
          })),
          mockScoresSample: allMockScores?.slice(0, 3).map((m) => ({
            id: m.id,
            student_id: m.student_id,
            subject_group: m.subject_group,
          })),
        },
      },
      summary: {
        schoolScoresCount: schoolScores?.length || 0,
        mockScoresCount: mockScores?.length || 0,
        schoolSummaryCount: schoolSummary.size,
        mockSummaryCount: mockSummary.size,
        riskIndexCount: riskIndex.size,
        allSubjectsCount: allSubjects.size,
      },
      schoolScores: schoolScores || [],
      mockScores: mockScores || [],
      subjectAnalysis,
      recommendations,
      requiredSubjectsCoverage: requiredSubjects.map((subject) => {
        const lowerSubject = subject.toLowerCase();
        return {
          subject,
          hasData: allSubjects.has(lowerSubject),
          analysis: subjectAnalysis.find((a) => a.subject === lowerSubject) || null,
        };
      }),
    });
  } catch (error) {
    return handleApiError(error, "[admin/check-student-scores] ì˜¤ë¥˜");
  }
}
</file>

<file path="auth/check-superadmin/route.ts">
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { apiSuccess } from "@/lib/api";

type CheckSuperAdminResponse = {
  isSuperAdmin: boolean;
};

/**
 * Super Admin ê¶Œí•œ í™•ì¸ API
 * GET /api/auth/check-superadmin
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { isSuperAdmin: boolean } }
 */
export async function GET() {
  const tenantContext = await getTenantContext();

  return apiSuccess<CheckSuperAdminResponse>({
    isSuperAdmin: tenantContext?.role === "superadmin",
  });
}
</file>

<file path="curriculum-revisions/route.ts">
import { NextResponse } from "next/server";
import { getCurriculumRevisions } from "@/lib/data/contentMasters";

export async function GET() {
  try {
    const revisions = await getCurriculumRevisions();

    return NextResponse.json({
      success: true,
      data: revisions,
    });
  } catch (error) {
    console.error("[api/curriculum-revisions] ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "ê°œì •êµìœ¡ê³¼ì • ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="dashboard/monthly-report/route.ts">
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getMonthlyReportData } from "@/lib/reports/monthly";
import {
  apiSuccess,
  apiUnauthorized,
  handleApiError,
} from "@/lib/api";
import { perfTime } from "@/lib/utils/perfLog";

export const dynamic = "force-dynamic";

/**
 * ëŒ€ì‹œë³´ë“œ ì›”ê°„ ë¦¬í¬íŠ¸ ì¡°íšŒ API
 * GET /api/dashboard/monthly-report?monthDate=YYYY-MM-DD
 *
 * @returns
 * ì„±ê³µ: { success: true, data: MonthlyReport }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: Request) {
  const timer = perfTime("[dashboard] api - monthlyReport");
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      timer.end();
      return apiUnauthorized();
    }

    const { searchParams } = new URL(request.url);
    const monthDateParam = searchParams.get("monthDate");
    
    // monthDateê°€ ì—†ìœ¼ë©´ ì˜¤ëŠ˜ ë‚ ì§œ ì‚¬ìš©
    const monthDate = monthDateParam
      ? new Date(monthDateParam + "T00:00:00")
      : new Date();

    if (Number.isNaN(monthDate.getTime())) {
      timer.end();
      return handleApiError(
        new Error("Invalid monthDate parameter"),
        "[api/dashboard/monthly-report] ì˜ëª»ëœ ë‚ ì§œ í˜•ì‹"
      );
    }

    const supabase = await createSupabaseServerClient();
    const monthlyReport = await getMonthlyReportData(
      supabase,
      user.userId,
      monthDate
    );

    timer.end();
    return apiSuccess(monthlyReport);
  } catch (error) {
    timer.end();
    return handleApiError(error, "[api/dashboard/monthly-report] ì˜¤ë¥˜");
  }
}
</file>

<file path="goals/list/route.ts">
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  apiSuccess,
  apiUnauthorized,
  handleApiError,
} from "@/lib/api";

type Goal = {
  id: string;
  title: string;
  goal_type: string | null;
  subject: string | null;
};

/**
 * ëª©í‘œ ëª©ë¡ ì¡°íšŒ API
 * GET /api/goals/list
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { goals: Goal[] } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET() {
  try {
    const supabase = await createSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return apiUnauthorized();
    }

    const selectGoals = () =>
      supabase
        .from("student_goals")
        .select("id,title,goal_type,subject")
        .order("created_at", { ascending: false });

    let { data: goals, error } = await selectGoals().eq("student_id", user.id);

    // student_id ì»¬ëŸ¼ì´ ì—†ëŠ” ê²½ìš° fallback
    if (error && error.code === "42703") {
      ({ data: goals, error } = await selectGoals());
    }

    if (error) {
      return handleApiError(error, "[api/goals/list] ëª©í‘œ ì¡°íšŒ ì‹¤íŒ¨");
    }

    return apiSuccess({ goals: (goals as Goal[]) || [] });
  } catch (error) {
    return handleApiError(error, "[api/goals/list] ì˜¤ë¥˜");
  }
}
</file>

<file path="master-books/difficulties/route.ts">
import { NextRequest } from "next/server";
import { getDifficultiesForMasterBooks } from "@/lib/data/contentMasters";
import { getTenantContext } from "@/lib/tenant/getTenantContext";

export async function GET(request: NextRequest) {
  try {
    const tenantContext = await getTenantContext();
    const tenantId = tenantContext?.tenantId || null;

    const difficulties = await getDifficultiesForMasterBooks(tenantId);

    return Response.json({
      success: true,
      data: difficulties,
    });
  } catch (error) {
    console.error("[api/master-books/difficulties] ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return Response.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "ë‚œì´ë„ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="master-books/route.ts">
import { NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { searchMasterBooks } from "@/lib/data/contentMasters";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

/**
 * ë§ˆìŠ¤í„° êµì¬ ê²€ìƒ‰ API
 * GET /api/master-books?search=...&subject_category=...&semester=...&page=1&limit=20
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { books, pagination: { total, page, limit, totalPages } } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    
    // ê²€ìƒ‰ íŒŒë¼ë¯¸í„°
    const search = searchParams.get("search") || undefined;
    const subject_category = searchParams.get("subject_category") || undefined;
    const semester = searchParams.get("semester") || undefined;
    const revision = searchParams.get("revision") || undefined;
    const difficulty_level = searchParams.get("difficulty_level") || undefined;
    
    // í˜ì´ì§€ë„¤ì´ì…˜
    const page = parseInt(searchParams.get("page") || "1", 10);
    const limit = Math.min(
      parseInt(searchParams.get("limit") || "20", 10),
      100 // ìµœëŒ€ 100ê°œ
    );

    if (page < 1 || limit < 1) {
      return apiBadRequest("pageì™€ limitì€ 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
    }

    const offset = (page - 1) * limit;

    // ê²€ìƒ‰ ì‹¤í–‰
    const result = await searchMasterBooks({
      search,
      limit,
      offset,
    });

    const totalPages = Math.ceil(result.total / limit);

    return apiSuccess({
      books: result.data,
      pagination: {
        total: result.total,
        page,
        limit,
        totalPages,
      },
    });
  } catch (error) {
    return handleApiError(error, "[api/master-books]");
  }
}
</file>

<file path="master-content-details/route.ts">
import { NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getMasterBookById, getMasterLectureById } from "@/lib/data/contentMasters";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

/**
 * ë§ˆìŠ¤í„° ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ì¡°íšŒ API
 * GET /api/master-content-details?contentType=book&contentId=...&includeMetadata=true
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { details/episodes, metadata? } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    const contentType = searchParams.get("contentType");
    const contentId = searchParams.get("contentId");
    const includeMetadata = searchParams.get("includeMetadata") === "true";

    if (!contentType || !contentId) {
      return apiBadRequest("contentTypeê³¼ contentIdê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    // contentType ê²€ì¦
    if (contentType !== "book" && contentType !== "lecture") {
      console.error("[api/master-content-details] ì˜ëª»ëœ contentType:", {
        contentType,
        contentId,
        receivedValue: contentType,
        expectedValues: ["book", "lecture"],
      });
      return apiBadRequest(
        `ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½˜í…ì¸  íƒ€ì…ì…ë‹ˆë‹¤. book ë˜ëŠ” lectureë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. (ë°›ì€ ê°’: ${contentType})`
      );
    }

    const supabase = await createSupabaseServerClient();

    if (contentType === "book") {
      try {
        const result = await getMasterBookById(contentId);
        const { details, book } = result;

        if (includeMetadata) {
          const { data: bookData } = await supabase
            .from("master_books")
            .select("subject, semester, revision, difficulty_level, publisher")
            .eq("id", contentId)
            .maybeSingle();

          return apiSuccess({
            details: details || [],
            total_pages: book?.total_pages || null,
            metadata: bookData || null,
          });
        }

        return apiSuccess({ 
          details: details || [],
          total_pages: book?.total_pages || null,
        });
      } catch (error) {
        console.error("[api/master-content-details] êµì¬ ì¡°íšŒ ì‹¤íŒ¨:", {
          contentId,
          contentType,
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined,
        });
        // getMasterBookByIdì—ì„œ ë°œìƒí•œ ì—ëŸ¬ë¥¼ ì¬ë˜ì§€ê¸°
        throw error;
      }
    } else if (contentType === "lecture") {
      try {
        const result = await getMasterLectureById(contentId);
        const { episodes, lecture } = result;

        if (includeMetadata) {
          const { data: lectureData } = await supabase
            .from("master_lectures")
            .select("subject, semester, revision, difficulty_level, platform")
            .eq("id", contentId)
            .maybeSingle();

          return apiSuccess({
            episodes: episodes || [],
            total_episodes: lecture?.total_episodes || null,
            metadata: lectureData || null,
          });
        }

        return apiSuccess({ 
          episodes: episodes || [],
          total_episodes: lecture?.total_episodes || null,
        });
      } catch (error) {
        console.error("[api/master-content-details] ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨:", {
          contentId,
          contentType,
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined,
        });
        // getMasterLectureByIdì—ì„œ ë°œìƒí•œ ì—ëŸ¬ë¥¼ ì¬ë˜ì§€ê¸°
        throw error;
      }
    } else {
      return apiBadRequest("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½˜í…ì¸  íƒ€ì…ì…ë‹ˆë‹¤. book ë˜ëŠ” lectureë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.");
    }
  } catch (error) {
    console.error("[api/master-content-details] ì˜ˆì™¸ ë°œìƒ:", {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });
    return handleApiError(error, "[api/master-content-details]");
  }
}
</file>

<file path="master-content-info/route.ts">
import { NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getMasterBookById, getMasterLectureById } from "@/lib/data/contentMasters";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  apiNotFound,
  handleApiError,
} from "@/lib/api";

type MasterContentInfoResponse = {
  total_pages: number | null;
  total_episodes: number | null;
};

/**
 * ë§ˆìŠ¤í„° ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ API
 * GET /api/master-content-info?content_type=book&content_id=...
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { total_pages, total_episodes } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    const contentType = searchParams.get("content_type");
    const contentId = searchParams.get("content_id");

    if (!contentType || !contentId) {
      return apiBadRequest("content_typeê³¼ content_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    if (contentType === "book") {
      const { book } = await getMasterBookById(contentId);
      if (!book) {
        return apiNotFound("êµì¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }
      return apiSuccess<MasterContentInfoResponse>({
        total_pages: book.total_pages,
        total_episodes: null,
      });
    } else if (contentType === "lecture") {
      const { lecture } = await getMasterLectureById(contentId);
      if (!lecture) {
        return apiNotFound("ê°•ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }
      return apiSuccess<MasterContentInfoResponse>({
        total_pages: null,
        total_episodes: lecture.total_episodes,
      });
    } else {
      return apiBadRequest("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½˜í…ì¸  íƒ€ì…ì…ë‹ˆë‹¤. book ë˜ëŠ” lectureë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.");
    }
  } catch (error) {
    return handleApiError(error, "[api/master-content-info]");
  }
}
</file>

<file path="master-lectures/difficulties/route.ts">
import { NextRequest } from "next/server";
import { getDifficultiesForMasterLectures } from "@/lib/data/contentMasters";
import { getTenantContext } from "@/lib/tenant/getTenantContext";

export async function GET(request: NextRequest) {
  try {
    const tenantContext = await getTenantContext();
    const tenantId = tenantContext?.tenantId || null;

    const difficulties = await getDifficultiesForMasterLectures(tenantId);

    return Response.json({
      success: true,
      data: difficulties,
    });
  } catch (error) {
    console.error("[api/master-lectures/difficulties] ë‚œì´ë„ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return Response.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "ë‚œì´ë„ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="master-lectures/route.ts">
import { NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { searchMasterLectures } from "@/lib/data/contentMasters";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

/**
 * ë§ˆìŠ¤í„° ê°•ì˜ ê²€ìƒ‰ API
 * GET /api/master-lectures?search=...&subject_category=...&semester=...&page=1&limit=20
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { lectures, pagination: { total, page, limit, totalPages } } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    
    // ê²€ìƒ‰ íŒŒë¼ë¯¸í„°
    const search = searchParams.get("search") || undefined;
    const subject_category = searchParams.get("subject_category") || undefined;
    const semester = searchParams.get("semester") || undefined;
    const revision = searchParams.get("revision") || undefined;
    const difficulty_level = searchParams.get("difficulty_level") || undefined;
    const platform = searchParams.get("platform") || undefined;
    
    // í˜ì´ì§€ë„¤ì´ì…˜
    const page = parseInt(searchParams.get("page") || "1", 10);
    const limit = Math.min(
      parseInt(searchParams.get("limit") || "20", 10),
      100 // ìµœëŒ€ 100ê°œ
    );

    if (page < 1 || limit < 1) {
      return apiBadRequest("pageì™€ limitì€ 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
    }

    const offset = (page - 1) * limit;

    // ê²€ìƒ‰ ì‹¤í–‰
    const result = await searchMasterLectures({
      search,
      limit,
      offset,
    });

    const totalPages = Math.ceil(result.total / limit);

    return apiSuccess({
      lectures: result.data,
      pagination: {
        total: result.total,
        page,
        limit,
        totalPages,
      },
    });
  } catch (error) {
    return handleApiError(error, "[api/master-lectures]");
  }
}
</file>

<file path="platforms/route.ts">
import { NextResponse } from "next/server";
import { getPlatformsForFilter } from "@/lib/data/contentMasters";

export async function GET() {
  try {
    const platforms = await getPlatformsForFilter();

    return NextResponse.json({
      success: true,
      data: platforms,
    });
  } catch (error) {
    console.error("[api/platforms] ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "í”Œë«í¼ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="publishers/route.ts">
import { NextResponse } from "next/server";
import { getPublishersForFilter } from "@/lib/data/contentMasters";

export async function GET() {
  try {
    const publishers = await getPublishersForFilter();

    return NextResponse.json({
      success: true,
      data: publishers,
    });
  } catch (error) {
    console.error("[api/publishers] ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "ì¶œíŒì‚¬ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="purio/send/route.ts">
/**
 * ë¿Œë¦¬ì˜¤ SMS ë°œì†¡ API Route
 * Client Componentì—ì„œ í˜¸ì¶œí•˜ëŠ” ì„œë²„ ì „ìš© ì—”ë“œí¬ì¸íŠ¸
 */

import { NextRequest, NextResponse } from "next/server";
import { requireAdminAuth } from "@/lib/auth/requireAdminAuth";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { sendSMS, sendBulkSMS } from "@/lib/services/smsService";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  formatSMSTemplate,
  type SMSTemplateType,
} from "@/lib/services/smsTemplates";
import { AppError, ErrorCode } from "@/lib/errors";

/**
 * ë‹¨ì¼ SMS ë°œì†¡
 * POST /api/purio/send
 * Body: { type: "single", phone: string, message: string, recipientId?: string }
 */
export async function POST(request: NextRequest) {
  try {
    // ì¸ì¦ í™•ì¸
    await requireAdminAuth();
    const tenantContext = await getTenantContext();

    if (!tenantContext?.tenantId) {
      return NextResponse.json(
        {
          success: false,
          error: "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        },
        { status: 404 }
      );
    }

    // ìš”ì²­ ë³¸ë¬¸ íŒŒì‹±
    const body = await request.json();
    const { type, phone, message, studentIds, templateVariables, recipientType } = body;

    // ì…ë ¥ê°’ ê²€ì¦
    if (!type || (type !== "single" && type !== "bulk")) {
      return NextResponse.json(
        {
          success: false,
          error: "ë°œì†¡ íƒ€ì…ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (single ë˜ëŠ” bulk)",
        },
        { status: 400 }
      );
    }

    if (type === "single") {
      // ë‹¨ì¼ ë°œì†¡
      if (!phone || !message) {
        return NextResponse.json(
          {
            success: false,
            error: "ì „í™”ë²ˆí˜¸ì™€ ë©”ì‹œì§€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.",
          },
          { status: 400 }
        );
      }

      const result = await sendSMS({
        recipientPhone: phone,
        message,
        recipientId: body.recipientId,
        tenantId: tenantContext.tenantId,
      });

      if (!result.success) {
        return NextResponse.json(
          {
            success: false,
            error: result.error || "SMS ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
          },
          { status: 500 }
        );
      }

      return NextResponse.json({
        success: true,
        msgId: result.messageKey,
      });
    } else {
      // ì¼ê´„ ë°œì†¡
      if (!studentIds || !Array.isArray(studentIds) || studentIds.length === 0) {
        return NextResponse.json(
          {
            success: false,
            error: "ë°œì†¡ ëŒ€ìƒ í•™ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”.",
          },
          { status: 400 }
        );
      }

      if (!message) {
        return NextResponse.json(
          {
            success: false,
            error: "ë©”ì‹œì§€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.",
          },
          { status: 400 }
        );
      }

      // í•™ìƒ ì •ë³´ ì¼ê´„ ì¡°íšŒ
      const supabase = await createSupabaseServerClient();
      const { data: students, error: studentsError } = await supabase
        .from("students")
        .select("id, name")
        .in("id", studentIds);

      if (studentsError) {
        console.error("[SMS API] í•™ìƒ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", studentsError);
        return NextResponse.json(
          {
            success: false,
            error: "í•™ìƒ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
          },
          { status: 500 }
        );
      }

      if (!students || students.length === 0) {
        return NextResponse.json(
          {
            success: false,
            error: "í•™ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          },
          { status: 404 }
        );
      }

      // student_profiles í…Œì´ë¸”ì—ì„œ phone ì •ë³´ ì¡°íšŒ
      let profiles: Array<{
        id: string;
        phone?: string | null;
        mother_phone?: string | null;
        father_phone?: string | null;
      }> = [];

      if (studentIds.length > 0) {
        try {
          const { data: profilesData, error: profilesError } = await supabase
            .from("student_profiles")
            .select("id, phone, mother_phone, father_phone")
            .in("id", studentIds);

          if (!profilesError && profilesData) {
            profiles = profilesData;
          }
        } catch (e) {
          // student_profiles í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
        }
      }

      // í”„ë¡œí•„ ì •ë³´ë¥¼ í•™ìƒ ì •ë³´ì™€ ë³‘í•©
      const studentsWithPhones = students.map((student: any) => {
        const profile = profiles.find((p: any) => p.id === student.id);
        return {
          ...student,
          phone: profile?.phone ?? null,
          mother_phone: profile?.mother_phone ?? student.mother_phone ?? null,
          father_phone: profile?.father_phone ?? student.father_phone ?? null,
        };
      });

      // í•™ì›ëª… ì¡°íšŒ
      const { data: tenant } = await supabase
        .from("tenants")
        .select("name")
        .eq("id", tenantContext.tenantId)
        .single();

      const academyName = tenant?.name || "í•™ì›";

      // ì „ì†¡ ëŒ€ìƒìì— ë”°ë¼ ì „í™”ë²ˆí˜¸ ì„ íƒ
      const getPhoneByRecipientType = (
        student: any,
        type: "student" | "mother" | "father"
      ): string | null => {
        switch (type) {
          case "student":
            return student.phone;
          case "mother":
            return student.mother_phone;
          case "father":
            return student.father_phone;
          default:
            return student.mother_phone ?? student.father_phone ?? student.phone;
        }
      };

      // SMS ë°œì†¡ ëŒ€ìƒ ì¤€ë¹„
      const recipients = studentsWithPhones
        .map((student) => {
          const phone = getPhoneByRecipientType(
            student,
            recipientType || "mother"
          );
          return { ...student, selectedPhone: phone };
        })
        .filter((student) => student.selectedPhone)
        .map((student) => {
          // ê° í•™ìƒë³„ë¡œ ë©”ì‹œì§€ ë³€ìˆ˜ ì¹˜í™˜
          let finalMessage = message;

          // í•™ìƒëª… ìë™ ì¹˜í™˜ (í•­ìƒ)
          finalMessage = finalMessage.replace(
            /\{í•™ìƒëª…\}/g,
            student.name || "í•™ìƒ"
          );

          // í•™ì›ëª… ìë™ ì¹˜í™˜ (í•­ìƒ)
          finalMessage = finalMessage.replace(/\{í•™ì›ëª…\}/g, academyName);

          // í…œí”Œë¦¿ ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ ì¶”ê°€ ë³€ìˆ˜ ì¹˜í™˜
          if (templateVariables) {
            for (const [key, value] of Object.entries(templateVariables)) {
              if (key !== "í•™ìƒëª…" && key !== "í•™ì›ëª…" && value) {
                finalMessage = finalMessage.replace(
                  new RegExp(`\\{${key}\\}`, "g"),
                  value as string
                );
              }
            }
          }

          return {
            phone: student.selectedPhone!,
            message: finalMessage,
            recipientId: student.id,
          };
        });

      if (recipients.length === 0) {
        return NextResponse.json(
          {
            success: false,
            error: "ë°œì†¡ ê°€ëŠ¥í•œ ì—°ë½ì²˜ê°€ ì—†ìŠµë‹ˆë‹¤.",
          },
          { status: 400 }
        );
      }

      // ëŒ€ëŸ‰ ë°œì†¡
      const result = await sendBulkSMS(recipients, tenantContext.tenantId);

      // ê²°ê³¼ ë§¤í•‘ (studentId í¬í•¨)
      const errors = result.errors.map((err, index) => {
        const recipient = recipients[index];
        return {
          studentId: recipient.recipientId || "",
          error: err.error,
        };
      });

      return NextResponse.json({
        success: result.success,
        failed: result.failed,
        errors,
      });
    }
  } catch (error: any) {
    console.error("[SMS API] ì˜¤ë¥˜:", error);

    // AppErrorì¸ ê²½ìš°
    if (error instanceof AppError) {
      return NextResponse.json(
        {
          success: false,
          error: error.message,
        },
        { status: error.statusCode || 500 }
      );
    }

    // ì¼ë°˜ ì—ëŸ¬
    return NextResponse.json(
      {
        success: false,
        error: error.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="recommended-master-contents/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getRecommendedMasterContents } from "@/lib/recommendations/masterContentRecommendation";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

/**
 * ì¶”ì²œ ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ API
 * GET /api/recommended-master-contents?subjects=êµ­ì–´&subjects=ìˆ˜í•™&count_êµ­ì–´=2&student_id=xxx
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { recommendations: [...] } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return apiUnauthorized();
    }

    const { role } = await getCurrentUserRole();
    
    // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ êµê³¼ì™€ ê°œìˆ˜ ì •ë³´ ì¶”ì¶œ
    const { searchParams } = new URL(request.url);
    const studentIdParam = searchParams.get("student_id");
    
    // í•™ìƒ ID ê²°ì •: ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì¸ ê²½ìš° student_id íŒŒë¼ë¯¸í„° ì‚¬ìš©, í•™ìƒì¸ ê²½ìš° ìì‹ ì˜ ID ì‚¬ìš©
    let targetStudentId: string;
    const isAdminOrConsultant = role === "admin" || role === "consultant";
    
    if (isAdminOrConsultant) {
      if (!studentIdParam) {
        return apiBadRequest("ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
      }
      targetStudentId = studentIdParam;
    } else {
      targetStudentId = user.userId;
    }

    // ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ê°€ ë‹¤ë¥¸ í•™ìƒì˜ ì¶”ì²œ ì½˜í…ì¸ ë¥¼ ì¡°íšŒí•  ë•ŒëŠ” Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš© (RLS ìš°íšŒ)
    // ë§ˆìŠ¤í„° ì½˜í…ì¸  ì¡°íšŒ ì‹œì—ë„ RLS ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    let supabase;
    if (isAdminOrConsultant && studentIdParam) {
      const adminClient = createSupabaseAdminClient();
      if (!adminClient) {
        console.warn("[api/recommended-master-contents] Admin í´ë¼ì´ì–¸íŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ì–´ ì¼ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©");
        supabase = await createSupabaseServerClient();
      } else {
        supabase = adminClient;
      }
    } else {
      supabase = await createSupabaseServerClient();
    }

    // ëŒ€ìƒ í•™ìƒì˜ tenant_id ì¡°íšŒ
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("tenant_id")
      .eq("id", targetStudentId)
      .maybeSingle();

    if (studentError) {
      return handleApiError(studentError, "[api/recommended-master-contents] í•™ìƒ ì¡°íšŒ ì‹¤íŒ¨");
    }

    if (!student) {
      return apiBadRequest("í•™ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    const subjectsParam = searchParams.getAll("subjects");
    const subjectCounts = new Map<string, number>();

    if (subjectsParam.length > 0) {
      subjectsParam.forEach((subject) => {
        const countParam = searchParams.get(`count_${subject}`);
        const count = countParam ? parseInt(countParam, 10) : 1;
        if (!isNaN(count) && count > 0) {
          subjectCounts.set(subject, count);
        }
      });
    }

    const recommendations = await getRecommendedMasterContents(
      supabase,
      targetStudentId,
      student.tenant_id || null,
      subjectCounts.size > 0 ? subjectCounts : undefined
    );

    // contentType ë³´ì¥: API ì‘ë‹µ ì§ë ¬í™” ì „ ìµœì¢… ì •ê·œí™”
    const normalizedRecommendations = recommendations.map((r) => {
      // contentTypeì´ ì—†ìœ¼ë©´ ì¶”ì •
      if (!r.contentType) {
        const estimatedType = r.publisher ? "book" : r.platform ? "lecture" : "book";
        console.warn("[api/recommended-master-contents] contentType ëˆ„ë½, ì¶”ì •ê°’ ì‚¬ìš©:", {
          id: r.id,
          title: r.title,
          estimatedType,
          publisher: r.publisher,
          platform: r.platform,
        });
        return {
          ...r,
          contentType: estimatedType as "book" | "lecture",
        };
      }
      return r;
    });

    return apiSuccess({ recommendations: normalizedRecommendations });
  } catch (error) {
    return handleApiError(error, "[api/recommended-master-contents]");
  }
}
</file>

<file path="schools/auto-register/route.ts">
import { NextRequest } from "next/server";
import { getSchoolByName, getRegions } from "@/lib/data/schools";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  apiSuccess,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

type School = {
  id: string;
  name: string;
  type: string;
  region: string | null;
};

type AutoRegisterResponse = {
  school: School;
};

/**
 * í•™êµ ìë™ ë“±ë¡ API
 * POST /api/schools/auto-register
 * í•™êµ ì„ íƒ ì‹œ DBì— ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ë“±ë¡
 *
 * @body { name: string, type: string, region?: string }
 * @returns
 * ì„±ê³µ: { success: true, data: { school: School } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { name, type, region } = body;

    if (!name || !type) {
      return apiBadRequest("í•™êµëª…ê³¼ íƒ€ì…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.");
    }

    if (!["ì¤‘í•™êµ", "ê³ ë“±í•™êµ", "ëŒ€í•™êµ"].includes(type)) {
      return apiBadRequest("ì˜¬ë°”ë¥¸ í•™êµ íƒ€ì…ì„ ì„ íƒí•˜ì„¸ìš”. (ì¤‘í•™êµ, ê³ ë“±í•™êµ, ëŒ€í•™êµ)");
    }

    // ê¸°ì¡´ í•™êµ í™•ì¸
    const existing = await getSchoolByName(name, type);

    if (existing) {
      return apiSuccess<AutoRegisterResponse>({
        school: {
          id: existing.id,
          name: existing.name,
          type: existing.type,
          region: existing.region,
        },
      });
    }

    // ì§€ì—­ ë§¤ì¹­ (region í…ìŠ¤íŠ¸ë¡œ region_id ì°¾ê¸°)
    let regionId: string | null = null;
    if (region) {
      const regions = await getRegions();
      const matchedRegion = regions.find((r) => r.name === region);
      if (matchedRegion) {
        regionId = matchedRegion.id;
      }
    }

    // ìƒˆë¡œ ë“±ë¡
    const supabase = await createSupabaseServerClient();
    const { data: newSchool, error } = await supabase
      .from("schools")
      .insert({
        name,
        type,
        region_id: regionId,
      })
      .select("id, name, type")
      .single();

    if (error) {
      return handleApiError(error, "[api/schools/auto-register] ë“±ë¡ ì‹¤íŒ¨");
    }

    // ì§€ì—­ ì •ë³´ í¬í•¨í•˜ì—¬ ë°˜í™˜
    const schoolWithRegion = await getSchoolByName(name, type);

    return apiSuccess<AutoRegisterResponse>({
      school: schoolWithRegion
        ? {
            id: schoolWithRegion.id,
            name: schoolWithRegion.name,
            type: schoolWithRegion.type,
            region: schoolWithRegion.region,
          }
        : {
            id: newSchool.id,
            name: newSchool.name,
            type: newSchool.type,
            region: null,
          },
    });
  } catch (error) {
    return handleApiError(error, "[api/schools/auto-register]");
  }
}
</file>

<file path="schools/search/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  apiSuccess,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

type School = {
  id: string;
  name: string;
  type: string | null;
  region: string | null;
};

/**
 * í•™êµ ê²€ìƒ‰ API
 * GET /api/schools/search?q=ê²€ìƒ‰ì–´&type=ëŒ€í•™êµ
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { schools: School[] } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get("id");
    const query = searchParams.get("q") || "";
    const type = searchParams.get("type") || "";
    const name = searchParams.get("name");

    const supabase = await createSupabaseServerClient();

    // IDë¡œ ì¡°íšŒ
    if (id) {
      const { data: school, error } = await supabase
        .from("schools")
        .select("id, name, type, region")
        .eq("id", id)
        .maybeSingle();

      if (error) {
        return handleApiError(error, "[api/schools/search] ID ì¡°íšŒ ì‹¤íŒ¨");
      }

      return apiSuccess({ schools: school ? [school] : [] });
    }

    // í•™êµëª…ìœ¼ë¡œ ì§ì ‘ ì¡°íšŒ
    if (name) {
      const { data: schools, error } = await supabase
        .from("schools")
        .select("id, name, type, region")
        .eq("name", name)
        .limit(1);

      if (error) {
        return handleApiError(error, "[api/schools/search] ì´ë¦„ ì¡°íšŒ ì‹¤íŒ¨");
      }

      return apiSuccess({ schools: (schools as School[]) || [] });
    }

    // íƒ€ì… ê²€ì¦
    if (type && !["ì¤‘í•™êµ", "ê³ ë“±í•™êµ", "ëŒ€í•™êµ"].includes(type)) {
      return apiBadRequest("ìœ íš¨í•˜ì§€ ì•Šì€ í•™êµ íƒ€ì…ì…ë‹ˆë‹¤.", { validTypes: ["ì¤‘í•™êµ", "ê³ ë“±í•™êµ", "ëŒ€í•™êµ"] });
    }

    // ê²€ìƒ‰ ì¿¼ë¦¬
    let schoolsQuery = supabase
      .from("schools")
      .select("id, name, type, region")
      .order("name", { ascending: true })
      .limit(50);

    if (query.trim()) {
      schoolsQuery = schoolsQuery.ilike("name", `%${query.trim()}%`);
    }

    if (type) {
      schoolsQuery = schoolsQuery.eq("type", type);
    }

    const { data: schools, error } = await schoolsQuery;

    if (error) {
      return handleApiError(error, "[api/schools/search] ê²€ìƒ‰ ì‹¤íŒ¨");
    }

    return apiSuccess({ schools: (schools as School[]) || [] });
  } catch (error) {
    return handleApiError(error, "[api/schools/search] ì˜¤ë¥˜");
  }
}
</file>

<file path="scores/internal/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getOrCreateStudentTerm } from "@/lib/data/studentTerms";
import type { InternalScoreInputForm, InternalScoreInsert } from "@/lib/types/scoreInput";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      studentId,
      tenantId,
      curriculumRevisionId,
      schoolYear,
      scores,
    }: {
      studentId: string;
      tenantId: string;
      curriculumRevisionId: string;
      schoolYear: number;
      scores: InternalScoreInputForm[];
    } = body;

    // ìœ íš¨ì„± ê²€ì¦
    if (!studentId || !tenantId || !curriculumRevisionId || !schoolYear) {
      return NextResponse.json(
        { error: "í•„ìˆ˜ íŒŒë¼ë¯¸í„°ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    if (!scores || scores.length === 0) {
      return NextResponse.json(
        { error: "ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    const supabase = await createSupabaseServerClient();

    // ê° ì„±ì ë³„ë¡œ student_term_id ì¡°íšŒ/ìƒì„± ë° ì €ì¥
    const insertedScores: InternalScoreInsert[] = [];

    for (const score of scores) {
      // student_term_id ì¡°íšŒ/ìƒì„±
      const studentTermId = await getOrCreateStudentTerm({
        tenant_id: tenantId,
        student_id: studentId,
        school_year: schoolYear,
        grade: score.grade,
        semester: score.semester,
        curriculum_revision_id: curriculumRevisionId,
      });

      // ì„±ì  ë°ì´í„° ì¤€ë¹„
      const scoreData: InternalScoreInsert = {
        tenant_id: tenantId,
        student_id: studentId,
        student_term_id: studentTermId,
        curriculum_revision_id: curriculumRevisionId,
        subject_group_id: score.subject_group_id,
        subject_type_id: score.subject_type_id,
        subject_id: score.subject_id,
        grade: score.grade,
        semester: score.semester,
        credit_hours: score.credit_hours,
        rank_grade: score.rank_grade,
        raw_score: score.raw_score ?? null,
        avg_score: score.avg_score ?? null,
        std_dev: score.std_dev ?? null,
        total_students: score.total_students ?? null,
      };

      insertedScores.push(scoreData);
    }

    // ì¼ê´„ ì‚½ì…
    const { data, error } = await supabase
      .from("student_internal_scores")
      .insert(insertedScores)
      .select();

    if (error) {
      console.error("[API] ë‚´ì‹  ì„±ì  ì €ì¥ ì‹¤íŒ¨", error);
      return NextResponse.json(
        { error: "ì„±ì  ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", details: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "ë‚´ì‹  ì„±ì ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.",
      data: { internal_scores: data },
    });
  } catch (error) {
    console.error("[API] ë‚´ì‹  ì„±ì  ì €ì¥ ì¤‘ ì˜¤ë¥˜", error);
    return NextResponse.json(
      {
        error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="scores/mock/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentTerm, calculateSchoolYear } from "@/lib/data/studentTerms";
import type { MockScoreInputForm, MockScoreInsert } from "@/lib/types/scoreInput";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      studentId,
      tenantId,
      scores,
    }: {
      studentId: string;
      tenantId: string;
      scores: MockScoreInputForm[];
    } = body;

    // ìœ íš¨ì„± ê²€ì¦
    if (!studentId || !tenantId) {
      return NextResponse.json(
        { error: "í•„ìˆ˜ íŒŒë¼ë¯¸í„°ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    if (!scores || scores.length === 0) {
      return NextResponse.json(
        { error: "ì„±ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    const supabase = await createSupabaseServerClient();

    // ê° ì„±ì ë³„ë¡œ student_term_id ì¡°íšŒ ë° ì €ì¥
    const insertedScores: MockScoreInsert[] = [];

    for (const score of scores) {
      // ì‹œí—˜ì¼ë¡œë¶€í„° í•™ë…„ë„ ê³„ì‚°
      const examDate = new Date(score.exam_date);
      const schoolYear = calculateSchoolYear(examDate);

      // student_term_id ì¡°íšŒ (ëª¨ì˜ê³ ì‚¬ëŠ” í•™ê¸° ì •ë³´ê°€ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ nullable)
      // ë¨¼ì € í•´ë‹¹ í•™ë…„ë„ì˜ 1í•™ê¸° termì„ ì°¾ì•„ë´„
      let studentTermId: string | null = null;
      
      const term = await getStudentTerm({
        tenant_id: tenantId,
        student_id: studentId,
        school_year: schoolYear,
        grade: score.grade,
        semester: 1, // ê¸°ë³¸ê°’ìœ¼ë¡œ 1í•™ê¸°
      });

      if (term) {
        studentTermId = term.id;
      }

      // ì„±ì  ë°ì´í„° ì¤€ë¹„
      const scoreData: MockScoreInsert = {
        tenant_id: tenantId,
        student_id: studentId,
        student_term_id: studentTermId, // nullable
        exam_date: score.exam_date,
        exam_title: score.exam_title,
        grade: score.grade,
        subject_id: score.subject_id,
        subject_group_id: score.subject_group_id,
        grade_score: score.grade_score,
        standard_score: score.standard_score ?? null,
        percentile: score.percentile ?? null,
        raw_score: score.raw_score ?? null,
      };

      insertedScores.push(scoreData);
    }

    // ì¼ê´„ ì‚½ì…
    const { data, error } = await supabase
      .from("student_mock_scores")
      .insert(insertedScores)
      .select();

    if (error) {
      console.error("[API] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì €ì¥ ì‹¤íŒ¨", error);
      return NextResponse.json(
        { error: "ì„±ì  ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", details: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: "ëª¨ì˜ê³ ì‚¬ ì„±ì ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.",
      data: { mock_scores: data },
    });
  } catch (error) {
    console.error("[API] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì €ì¥ ì¤‘ ì˜¤ë¥˜", error);
    return NextResponse.json(
      {
        error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="student-content-details/batch/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  getStudentBookDetailsBatch,
  getStudentLectureEpisodesBatch,
} from "@/lib/data/contentMasters";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

// ë™ì  ë Œë”ë§ ì„¤ì •: ì¸ì¦ì´ í•„ìš”í•˜ë¯€ë¡œ ë™ì  ë Œë”ë§ í•„ìˆ˜
export const dynamic = 'force-dynamic';

// ìºì‹œ ì„¤ì •: ë°°ì¹˜ APIë„ ë™ì¼í•˜ê²Œ 5ë¶„ ìºì‹œ
export const revalidate = 300;

type BatchRequest = {
  contents: Array<{
    contentId: string;
    contentType: "book" | "lecture";
  }>;
  includeMetadata?: boolean;
};

type BatchResponse = {
  [contentId: string]: {
    details?: Array<{
      id: string;
      page_number?: number;
      episode_number?: number;
      major_unit?: string | null;
      minor_unit?: string | null;
      title?: string | null;
    }>;
    episodes?: Array<{
      id: string;
      episode_number: number;
      title: string | null;
      duration?: number | null;
    }>;
    metadata?: {
      subject?: string | null;
      semester?: string | null;
      revision?: string | null;
      difficulty_level?: string | null;
      publisher?: string | null;
      platform?: string | null;
    };
  };
};

/**
 * í•™ìƒ ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ë°°ì¹˜ ì¡°íšŒ API
 * POST /api/student-content-details/batch
 *
 * @returns
 * ì„±ê³µ: { success: true, data: BatchResponse }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const body: BatchRequest & { student_id?: string } = await request.json();
    const { contents, includeMetadata = false, student_id } = body;

    if (!contents || !Array.isArray(contents) || contents.length === 0) {
      return apiBadRequest("contents ë°°ì—´ì´ í•„ìš”í•˜ë©°, ìµœì†Œ 1ê°œ ì´ìƒì˜ í•­ëª©ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    // ìµœëŒ€ 20ê°œê¹Œì§€ ë°°ì¹˜ ì¡°íšŒ í—ˆìš© (ì„œë²„ ë¶€í•˜ ë°©ì§€)
    if (contents.length > 20) {
      return apiBadRequest("í•œ ë²ˆì— ìµœëŒ€ 20ê°œê¹Œì§€ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    // ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”
    if ((role === "admin" || role === "consultant") && !student_id) {
      return apiBadRequest("ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    const supabase = await createSupabaseServerClient();
    const targetStudentId = role === "student" ? user.userId : student_id!;

    // ì½˜í…ì¸ ë¥¼ íƒ€ì…ë³„ë¡œ ë¶„ë¥˜
    const bookIds: string[] = [];
    const lectureIds: string[] = [];
    const contentMap = new Map<string, "book" | "lecture">();

    contents.forEach((content) => {
      if (content.contentType === "book") {
        bookIds.push(content.contentId);
      } else {
        lectureIds.push(content.contentId);
      }
      contentMap.set(content.contentId, content.contentType);
    });

    // ë³‘ë ¬ë¡œ ë°°ì¹˜ ì¡°íšŒ ìˆ˜í–‰
    // ìƒì„¸ ì •ë³´ì™€ ë©”íƒ€ë°ì´í„°ë¥¼ ë™ì‹œì— ì¡°íšŒí•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
    const selectBookFields = includeMetadata
      ? "id, total_pages, master_content_id, subject, semester, revision, difficulty_level, publisher"
      : "id, total_pages, master_content_id";
    const selectLectureFields = includeMetadata
      ? "id, total_episodes, master_content_id, subject, semester, revision, difficulty_level, platform"
      : "id, total_episodes, master_content_id";

    const [
      bookDetailsMap,
      lectureEpisodesMap,
      booksDataResult,
      lecturesDataResult,
    ] = await Promise.all([
      bookIds.length > 0
        ? getStudentBookDetailsBatch(bookIds, targetStudentId)
        : Promise.resolve(new Map()),
      lectureIds.length > 0
        ? getStudentLectureEpisodesBatch(lectureIds, targetStudentId)
        : Promise.resolve(new Map()),
      bookIds.length > 0
        ? supabase
            .from("books")
            .select(selectBookFields)
            .in("id", bookIds)
            .eq("student_id", targetStudentId)
        : Promise.resolve({ data: null }),
      lectureIds.length > 0
        ? supabase
            .from("lectures")
            .select(selectLectureFields)
            .in("id", lectureIds)
            .eq("student_id", targetStudentId)
        : Promise.resolve({ data: null }),
    ]);

    // ë©”íƒ€ë°ì´í„° ë° ì´ëŸ‰ ì •ë³´ ë§µ ìƒì„±
    const metadataMap = new Map<
      string,
      {
        subject?: string | null;
        semester?: string | null;
        revision?: string | null;
        difficulty_level?: string | null;
        publisher?: string | null;
        platform?: string | null;
      }
    >();
    const totalPagesMap = new Map<string, number | null>();
    const totalEpisodesMap = new Map<string, number | null>();
    const masterContentIdMap = new Map<string, string | null>();

    // êµì¬ ë°ì´í„° ì²˜ë¦¬
    if (booksDataResult.data) {
      (booksDataResult.data as unknown as Array<{
        id: string;
        total_pages: number | null;
        master_content_id: string | null;
        subject?: string | null;
        semester?: string | null;
        revision?: string | null;
        difficulty_level?: string | null;
        publisher?: string | null;
      }>).forEach((book) => {
        totalPagesMap.set(book.id, book.total_pages);
        masterContentIdMap.set(book.id, book.master_content_id);
        if (includeMetadata) {
          metadataMap.set(book.id, {
            subject: book.subject,
            semester: book.semester,
            revision: book.revision,
            difficulty_level: book.difficulty_level,
            publisher: book.publisher,
          });
        }
      });
    }

    // ê°•ì˜ ë°ì´í„° ì²˜ë¦¬
    if (lecturesDataResult.data) {
      (lecturesDataResult.data as unknown as Array<{
        id: string;
        total_episodes: number | null;
        master_content_id: string | null;
        subject?: string | null;
        semester?: string | null;
        revision?: string | null;
        difficulty_level?: string | null;
        platform?: string | null;
      }>).forEach((lecture) => {
        totalEpisodesMap.set(lecture.id, lecture.total_episodes);
        masterContentIdMap.set(lecture.id, lecture.master_content_id);
        if (includeMetadata) {
          metadataMap.set(lecture.id, {
            subject: lecture.subject,
            semester: lecture.semester,
            revision: lecture.revision,
            difficulty_level: lecture.difficulty_level,
            platform: lecture.platform,
          });
        }
      });
    }

    // master_content_idê°€ ìˆì§€ë§Œ total_pages/total_episodesê°€ ì—†ëŠ” ê²½ìš° ë§ˆìŠ¤í„°ì—ì„œ ì¡°íšŒ (fallback)
    const masterBookIds = Array.from(masterContentIdMap.entries())
      .filter(([contentId, masterId]) => {
        const contentType = contentMap.get(contentId);
        return (
          contentType === "book" &&
          masterId &&
          !totalPagesMap.get(contentId)
        );
      })
      .map(([, masterId]) => masterId!);
    const masterLectureIds = Array.from(masterContentIdMap.entries())
      .filter(([contentId, masterId]) => {
        const contentType = contentMap.get(contentId);
        return (
          contentType === "lecture" &&
          masterId &&
          !totalEpisodesMap.get(contentId)
        );
      })
      .map(([, masterId]) => masterId!);

    const [masterBooksResult, masterLecturesResult] = await Promise.all([
      masterBookIds.length > 0
        ? supabase
            .from("master_books")
            .select("id, total_pages")
            .in("id", masterBookIds)
        : Promise.resolve({ data: null }),
      masterLectureIds.length > 0
        ? supabase
            .from("master_lectures")
            .select("id, total_episodes")
            .in("id", masterLectureIds)
        : Promise.resolve({ data: null }),
    ]);

    // ë§ˆìŠ¤í„° ë°ì´í„°ë¡œ fallback ì²˜ë¦¬
    if (masterBooksResult.data) {
      masterBooksResult.data.forEach((book: {
        id: string;
        total_pages: number | null;
      }) => {
        // master_content_idë¡œ ì—­ë§¤í•‘í•˜ì—¬ contentId ì°¾ê¸°
        for (const [contentId, masterId] of masterContentIdMap.entries()) {
          if (masterId === book.id && contentMap.get(contentId) === "book") {
            if (!totalPagesMap.has(contentId) || !totalPagesMap.get(contentId)) {
              totalPagesMap.set(contentId, book.total_pages);
            }
            break;
          }
        }
      });
    }

    if (masterLecturesResult.data) {
      masterLecturesResult.data.forEach((lecture: {
        id: string;
        total_episodes: number | null;
      }) => {
        // master_content_idë¡œ ì—­ë§¤í•‘í•˜ì—¬ contentId ì°¾ê¸°
        for (const [contentId, masterId] of masterContentIdMap.entries()) {
          if (
            masterId === lecture.id &&
            contentMap.get(contentId) === "lecture"
          ) {
            if (
              !totalEpisodesMap.has(contentId) ||
              !totalEpisodesMap.get(contentId)
            ) {
              totalEpisodesMap.set(contentId, lecture.total_episodes);
            }
            break;
          }
        }
      });
    }

    // ê²°ê³¼ë¥¼ í†µí•©í•˜ì—¬ ì‘ë‹µ ìƒì„±
    const response: BatchResponse & {
      [contentId: string]: {
        details?: Array<{
          id: string;
          page_number?: number;
          episode_number?: number;
          major_unit?: string | null;
          minor_unit?: string | null;
          title?: string | null;
        }>;
        episodes?: Array<{
          id: string;
          episode_number: number;
          title: string | null;
          duration?: number | null;
        }>;
        total_pages?: number | null;
        total_episodes?: number | null;
        metadata?: {
          subject?: string | null;
          semester?: string | null;
          revision?: string | null;
          difficulty_level?: string | null;
          publisher?: string | null;
          platform?: string | null;
        };
      };
    } = {};

    contents.forEach((content) => {
      const contentType = contentMap.get(content.contentId);
      const metadata = includeMetadata ? metadataMap.get(content.contentId) : undefined;

      if (contentType === "book") {
        const details = bookDetailsMap.get(content.contentId) || [];
        response[content.contentId] = {
          details: details.map((d: { id: string; page_number: number | null; major_unit: string | null; minor_unit: string | null }) => ({
            id: d.id,
            page_number: d.page_number,
            major_unit: d.major_unit,
            minor_unit: d.minor_unit,
          })),
          total_pages: totalPagesMap.get(content.contentId) ?? null,
          metadata,
        };
      } else {
        const episodes = lectureEpisodesMap.get(content.contentId) || [];
        response[content.contentId] = {
          episodes: episodes.map((e: { id: string; episode_number: number; title: string | null; duration: number | null }) => ({
            id: e.id,
            episode_number: e.episode_number,
            title: e.title,
            duration: e.duration ?? null,
          })),
          total_episodes: totalEpisodesMap.get(content.contentId) ?? null,
          metadata,
        };
      }
    });

    return apiSuccess(response);
  } catch (error) {
    return handleApiError(error, "[api/student-content-details/batch]");
  }
}
</file>

<file path="student-content-details/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudentBookDetails, getStudentLectureEpisodes } from "@/lib/data/contentMasters";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  handleApiError,
} from "@/lib/api";

// ë™ì  ë Œë”ë§ ì„¤ì •: ì¸ì¦ì´ í•„ìš”í•˜ë¯€ë¡œ ë™ì  ë Œë”ë§ í•„ìˆ˜
export const dynamic = 'force-dynamic';

// ìºì‹œ ì„¤ì •: ì½˜í…ì¸  ìƒì„¸ ì •ë³´ëŠ” ìì£¼ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ 5ë¶„ ìºì‹œ
export const revalidate = 300;

/**
 * í•™ìƒ ì½˜í…ì¸  ìƒì„¸ ì •ë³´ ì¡°íšŒ API
 * GET /api/student-content-details?contentType=book&contentId=...&student_id=...
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { details/episodes, metadata? } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    const contentType = searchParams.get("contentType");
    const contentId = searchParams.get("contentId");
    const includeMetadata = searchParams.get("includeMetadata") === "true";
    const studentId = searchParams.get("student_id");

    if (!contentType || !contentId) {
      return apiBadRequest("contentTypeê³¼ contentIdê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    // ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”
    if ((role === "admin" || role === "consultant") && !studentId) {
      return apiBadRequest("ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    const supabase = await createSupabaseServerClient();
    const targetStudentId = role === "student" ? user.userId : studentId!;

    if (contentType === "book") {
      // ë³‘ë ¬ ì²˜ë¦¬: ìƒì„¸ ì •ë³´ì™€ ë©”íƒ€ë°ì´í„°ë¥¼ ë™ì‹œì— ì¡°íšŒ
      // books í…Œì´ë¸” ì¡°íšŒë¥¼ ë‹¨ì¼ ì¿¼ë¦¬ë¡œ í†µí•© (total_pages, master_content_id, ë©”íƒ€ë°ì´í„° í•„ë“œ í¬í•¨)
      const selectFields = includeMetadata
        ? "total_pages, master_content_id, subject, semester, revision, difficulty_level, publisher"
        : "total_pages, master_content_id";

      const [details, { data: studentBookRaw }] = await Promise.all([
        getStudentBookDetails(contentId, targetStudentId),
        supabase
          .from("books")
          .select(selectFields)
          .eq("id", contentId)
          .eq("student_id", targetStudentId)
          .maybeSingle(),
      ]);

      type StudentBook = {
        total_pages: number | null;
        master_content_id: string | null;
        subject?: string | null;
        semester?: string | null;
        revision?: string | null;
        difficulty_level?: string | null;
        publisher?: string | null;
      };

      const studentBook = studentBookRaw as StudentBook | null;
      let totalPages: number | null = studentBook?.total_pages || null;

      // master_content_idê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í„°ì—ì„œë„ ì¡°íšŒ (fallback) - ì¡°ê±´ë¶€ ë³‘ë ¬ ì²˜ë¦¬
      const masterBookPromise = !totalPages && studentBook?.master_content_id
        ? supabase
            .from("master_books")
            .select("total_pages")
            .eq("id", studentBook.master_content_id)
            .maybeSingle()
        : Promise.resolve({ data: null });

      const { data: masterBook } = await masterBookPromise;
      totalPages = totalPages || (masterBook as { total_pages: number | null } | null)?.total_pages || null;

      return apiSuccess({
        details,
        total_pages: totalPages,
        metadata: includeMetadata && studentBook
          ? {
              subject: studentBook.subject,
              semester: studentBook.semester,
              revision: studentBook.revision,
              difficulty_level: studentBook.difficulty_level,
              publisher: studentBook.publisher,
            }
          : undefined,
      });
    } else if (contentType === "lecture") {
      // ë³‘ë ¬ ì²˜ë¦¬: episode ì •ë³´ì™€ ë©”íƒ€ë°ì´í„°ë¥¼ ë™ì‹œì— ì¡°íšŒ
      // lectures í…Œì´ë¸” ì¡°íšŒë¥¼ ë‹¨ì¼ ì¿¼ë¦¬ë¡œ í†µí•© (master_content_id, total_episodes, ë©”íƒ€ë°ì´í„° í•„ë“œ í¬í•¨)
      const selectFields = includeMetadata
        ? "master_content_id, total_episodes, subject, semester, revision, difficulty_level, platform"
        : "master_content_id, total_episodes";

      const [episodes, { data: studentLectureRaw }] = await Promise.all([
        getStudentLectureEpisodes(contentId, targetStudentId),
        supabase
          .from("lectures")
          .select(selectFields)
          .eq("id", contentId)
          .eq("student_id", targetStudentId)
          .maybeSingle(),
      ]);

      type StudentLecture = {
        master_content_id: string | null;
        total_episodes: number | null;
        subject?: string | null;
        semester?: string | null;
        revision?: string | null;
        difficulty_level?: string | null;
        platform?: string | null;
      };

      const studentLecture = studentLectureRaw as StudentLecture | null;
      let totalEpisodes: number | null = studentLecture?.total_episodes || null;

      // master_content_idê°€ ìˆìœ¼ë©´ ë§ˆìŠ¤í„°ì—ì„œë„ ì¡°íšŒ (fallback) - ì¡°ê±´ë¶€ ë³‘ë ¬ ì²˜ë¦¬
      const masterLecturePromise = !totalEpisodes && studentLecture?.master_content_id
        ? supabase
            .from("master_lectures")
            .select("total_episodes")
            .eq("id", studentLecture.master_content_id)
            .maybeSingle()
        : Promise.resolve({ data: null });

      const { data: masterLecture } = await masterLecturePromise;
      totalEpisodes = totalEpisodes || (masterLecture as { total_episodes: number | null } | null)?.total_episodes || null;

      return apiSuccess({
        episodes,
        total_episodes: totalEpisodes,
        metadata: includeMetadata && studentLecture
          ? {
              subject: studentLecture.subject,
              semester: studentLecture.semester,
              revision: studentLecture.revision,
              difficulty_level: studentLecture.difficulty_level,
              platform: studentLecture.platform,
            }
          : undefined,
      });
    } else {
      return apiBadRequest("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½˜í…ì¸  íƒ€ì…ì…ë‹ˆë‹¤. book ë˜ëŠ” lectureë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.");
    }
  } catch (error) {
    return handleApiError(error, "[api/student-content-details]");
  }
}
</file>

<file path="student-content-info/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiUnauthorized,
  apiBadRequest,
  apiNotFound,
  handleApiError,
} from "@/lib/api";

type StudentContentInfoResponse = {
  title: string;
  subject_category: string | null;
  total_pages?: number | null;
  total_episodes?: number | null;
};

/**
 * í•™ìƒ ì½˜í…ì¸  ì •ë³´ ì¡°íšŒ API
 * GET /api/student-content-info?content_type=book&content_id=...&student_id=...
 *
 * @returns
 * ì„±ê³µ: { success: true, data: { title, subject_category, ... } }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    const { role } = await getCurrentUserRole();

    if (!user || (role !== "student" && role !== "admin" && role !== "consultant")) {
      return apiUnauthorized();
    }

    const searchParams = request.nextUrl.searchParams;
    const contentType = searchParams.get("content_type");
    const contentId = searchParams.get("content_id");
    const studentId = searchParams.get("student_id");

    if (!contentType || !contentId) {
      return apiBadRequest("content_typeê³¼ content_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    // ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”
    if ((role === "admin" || role === "consultant") && !studentId) {
      return apiBadRequest("ê´€ë¦¬ì/ì»¨ì„¤í„´íŠ¸ì˜ ê²½ìš° student_idê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }

    const supabase = await createSupabaseServerClient();
    const targetStudentId = role === "student" ? user.userId : studentId!;

    if (contentType === "book") {
      const { data: studentBook, error: bookError } = await supabase
        .from("books")
        .select("id, title, subject_category, master_content_id, total_pages")
        .eq("id", contentId)
        .eq("student_id", targetStudentId)
        .maybeSingle();

      if (bookError) {
        return handleApiError(bookError, "[api/student-content-info] êµì¬ ì¡°íšŒ ì‹¤íŒ¨");
      }

      if (!studentBook) {
        return apiNotFound("êµì¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }

      // master_content_idê°€ ìˆìœ¼ë©´ ì›ë³¸ ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ subject_category ì¡°íšŒ
      if (studentBook.master_content_id) {
        const { data: masterBook } = await supabase
          .from("master_books")
          .select("subject_category, total_pages")
          .eq("id", studentBook.master_content_id)
          .maybeSingle();

        if (masterBook?.subject_category) {
          return apiSuccess<StudentContentInfoResponse>({
            title: studentBook.title,
            subject_category: masterBook.subject_category,
            total_pages: studentBook.total_pages || masterBook.total_pages || null,
          });
        }
      }

      return apiSuccess<StudentContentInfoResponse>({
        title: studentBook.title,
        subject_category: studentBook.subject_category || null,
        total_pages: studentBook.total_pages || null,
      });
    } else if (contentType === "lecture") {
      const { data: studentLecture, error: lectureError } = await supabase
        .from("lectures")
        .select("id, title, subject_category, master_content_id, duration")
        .eq("id", contentId)
        .eq("student_id", targetStudentId)
        .maybeSingle();

      if (lectureError) {
        return handleApiError(lectureError, "[api/student-content-info] ê°•ì˜ ì¡°íšŒ ì‹¤íŒ¨");
      }

      if (!studentLecture) {
        return apiNotFound("ê°•ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }

      // master_content_idê°€ ìˆìœ¼ë©´ ì›ë³¸ ë§ˆìŠ¤í„° ì½˜í…ì¸ ì—ì„œ subject_category ì¡°íšŒ
      if (studentLecture.master_content_id) {
        const { data: masterLecture } = await supabase
          .from("master_lectures")
          .select("subject_category, total_episodes")
          .eq("id", studentLecture.master_content_id)
          .maybeSingle();

        if (masterLecture?.subject_category) {
          return apiSuccess<StudentContentInfoResponse>({
            title: studentLecture.title,
            subject_category: masterLecture.subject_category,
            total_episodes: masterLecture.total_episodes || null,
          });
        }
      }

      return apiSuccess<StudentContentInfoResponse>({
        title: studentLecture.title,
        subject_category: studentLecture.subject_category || null,
        total_episodes: null,
      });
    } else {
      return apiBadRequest("ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½˜í…ì¸  íƒ€ì…ì…ë‹ˆë‹¤.");
    }
  } catch (error) {
    return handleApiError(error, "[api/student-content-info]");
  }
}
</file>

<file path="students/[id]/score-dashboard/route.ts">
/**
 * í•™ìƒ ì„±ì  ëŒ€ì‹œë³´ë“œ API
 * 
 * GET /api/students/:id/score-dashboard?tenantId=...&grade=...&semester=...
 * 
 * ë‚´ì‹  ë¶„ì„ + ëª¨ì˜ê³ ì‚¬ ë¶„ì„ + ìˆ˜ì‹œ/ì •ì‹œ ì „ëµ ë¶„ì„ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 */

import { NextRequest, NextResponse } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { getInternalAnalysis } from "@/lib/scores/internalAnalysis";
import { getMockAnalysis } from "@/lib/scores/mockAnalysis";
import {
  getInternalPercentile,
  analyzeAdmissionStrategy,
} from "@/lib/scores/admissionStrategy";

/**
 * í•™ìƒ ì„±ì  ëŒ€ì‹œë³´ë“œ ì‘ë‹µ íƒ€ì…
 */
type ScoreDashboardResponse = {
  studentProfile: {
    id: string;
    name: string;
    grade: number | null;
    class: number | null;
    schoolType: string | null;
    schoolYear: number | null;
    termGrade: number | null;
    semester: number | null;
  };
  internalAnalysis: {
    totalGpa: number | null;
    zIndex: number | null;
    subjectStrength: Record<string, number>;
  };
  mockAnalysis: {
    recentExam: { examDate: string; examTitle: string } | null;
    avgPercentile: number | null;
    totalStdScore: number | null;
    best3GradeSum: number | null;
  };
  strategyResult: {
    type: string;
    message: string;
    data: {
      internalPct: number | null;
      mockPct: number | null;
      diff: number | null;
    };
  };
};

/**
 * í•™ìƒ ì„±ì  ëŒ€ì‹œë³´ë“œ API
 * 
 * ë³€ê²½ì‚¬í•­ (2025-01-XX):
 * - termId íŒŒë¼ë¯¸í„° ì§€ì› ì¶”ê°€
 * - grade, semesterê°€ ìˆìœ¼ë©´ student_termsì—ì„œ termId ì¡°íšŒ
 * - student_internal_scores í…Œì´ë¸” ê¸°ì¤€ìœ¼ë¡œ ë‚´ì‹  ë¶„ì„
 * - student_school_scores ì°¸ì¡° ì œê±°
 */

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: studentId } = await params;
    const searchParams = req.nextUrl.searchParams;
    const tenantIdParam = searchParams.get("tenantId");
    const termIdParam = searchParams.get("termId");
    const gradeParam = searchParams.get("grade");
    const semesterParam = searchParams.get("semester");

    // tenantIdëŠ” "null" ë¬¸ìì—´ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì²˜ë¦¬
    const tenantId = tenantIdParam === "null" || tenantIdParam === "undefined" ? null : tenantIdParam;

    // ì¸ì¦ í™•ì¸
    const currentUser = await getCurrentUser();
    const { role: currentRole } = await getCurrentUserRole();

    // í•™ìƒ ê¶Œí•œ ê²€ì¦: í•™ìƒì€ ìì‹ ì˜ ë°ì´í„°ë§Œ ì¡°íšŒ ê°€ëŠ¥
    if (currentRole === "student" && currentUser?.userId !== studentId) {
      console.warn("[api/score-dashboard] í•™ìƒ ê¶Œí•œ ê²€ì¦ ì‹¤íŒ¨", {
        currentUserId: currentUser?.userId,
        requestedStudentId: studentId,
        role: currentRole,
      });

      return NextResponse.json(
        { 
          error: "Forbidden",
          details: "Students can only access their own data",
          currentUserId: currentUser?.userId,
          requestedStudentId: studentId,
        },
        { status: 403 }
      );
    }

    // Supabase í´ë¼ì´ì–¸íŠ¸ ì„ íƒ
    // ê´€ë¦¬ì/ë¶€ëª¨ ì—­í• ì´ê±°ë‚˜ ê°œë°œ í™˜ê²½ì—ì„œëŠ” Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    // í•™ìƒì´ ìì‹ ì˜ ë°ì´í„°ë¥¼ ì¡°íšŒí•  ë•Œë„ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    // ì„œë²„ ì»´í¬ë„ŒíŠ¸ì—ì„œ fetch í˜¸ì¶œ ì‹œ ì¸ì¦ ì •ë³´ê°€ ì—†ì„ ë•Œë„ Admin Client ì‚¬ìš©
    const useAdminClient =
      currentRole === "admin" ||
      currentRole === "parent" ||
      process.env.NODE_ENV === "development" ||
      (currentRole === "student" && currentUser?.userId === studentId) ||
      (!currentUser && !currentRole); // ì¸ì¦ ì •ë³´ê°€ ì—†ì„ ë•Œë„ Admin Client ì‚¬ìš©

    let supabase;
    if (useAdminClient) {
      const adminClient = createSupabaseAdminClient();
      if (!adminClient) {
        // Service Role Keyê°€ ì—†ìœ¼ë©´ ê²½ê³  ë¡œê·¸
        console.warn("[api/score-dashboard] Admin Client ìƒì„± ì‹¤íŒ¨ (Service Role Key ì—†ìŒ), Server Client ì‚¬ìš©", {
          currentRole,
          studentId,
          currentUserId: currentUser?.userId,
          nodeEnv: process.env.NODE_ENV,
        });
        supabase = await createSupabaseServerClient();
      } else {
        supabase = adminClient;
      }
    } else {
      supabase = await createSupabaseServerClient();
    }

    // 1) í•™ìƒ ì¡°íšŒ (school_id, school_type í¬í•¨)
    // tenantId ì¡°ê±´ ì—†ì´ ë¨¼ì € ì¡°íšŒí•˜ì—¬ í•™ìƒ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const { data: student, error: studentError } = await supabase
      .from("students")
      .select("id, name, grade, class, school_id, school_type, tenant_id")
      .eq("id", studentId)
      .maybeSingle();

    if (studentError) {
      console.error("[api/score-dashboard] í•™ìƒ ì¡°íšŒ ì‹¤íŒ¨", {
        error: studentError,
        code: studentError.code,
        message: studentError.message,
        studentId,
        currentUserId: currentUser?.userId,
        currentRole,
        useAdminClient,
      });

      return NextResponse.json(
        { 
          error: "Failed to fetch student", 
          details: studentError.message,
          studentId,
        },
        { status: 500 }
      );
    }

    if (!student) {
      console.warn("[api/score-dashboard] í•™ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŒ", {
        studentId,
        currentUserId: currentUser?.userId,
        currentRole,
        useAdminClient,
      });

      return NextResponse.json(
        { 
          error: "Student not found",
          details: `Student with id ${studentId} does not exist`,
          studentId,
        },
        { status: 404 }
      );
    }

    // tenantId ê²€ì¦: ìš”ì²­í•œ tenantIdê°€ ìˆìœ¼ë©´ í•™ìƒì˜ tenant_idì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
    if (tenantId && student.tenant_id && tenantId !== student.tenant_id) {
      console.warn("[api/score-dashboard] tenant_id ë¶ˆì¼ì¹˜", {
        studentId,
        requestedTenantId: tenantId,
        actualTenantId: student.tenant_id,
        studentName: student.name,
      });
      // ê²½ê³ ë§Œ í•˜ê³  í•™ìƒì˜ ì‹¤ì œ tenant_id ì‚¬ìš© (ë³´ì•ˆìƒ ê²½ê³ ëŠ” ë‚¨ê¸°ì§€ë§Œ ê³„ì† ì§„í–‰)
    }

    // effectiveTenantId ê²°ì •: ìš”ì²­í•œ tenantId ë˜ëŠ” í•™ìƒì˜ ì‹¤ì œ tenant_id
    const effectiveTenantId = tenantId || student.tenant_id;
    
    if (!effectiveTenantId) {
      return NextResponse.json(
        { error: "Tenant ID not found for student" },
        { status: 400 }
      );
    }

    // 2) termId ê²°ì • ë¡œì§
    // ìš°ì„ ìˆœìœ„: termId íŒŒë¼ë¯¸í„° > grade+semester ì¡°í•© > ìµœê·¼ í•™ê¸°
    let effectiveTermId: string | null = termIdParam || null;
    let grade: number | null = null;
    let semester: number | null = null;

    if (!effectiveTermId && gradeParam && semesterParam) {
      // grade, semesterê°€ ìˆìœ¼ë©´ student_termsì—ì„œ termId ì¡°íšŒ
      grade = parseInt(gradeParam);
      semester = parseInt(semesterParam);

      const { data: termData, error: termError } = await supabase
        .from("student_terms")
        .select("id, grade, semester, school_year")
        .eq("student_id", studentId)
        .eq("grade", grade)
        .eq("semester", semester)
        .order("school_year", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (termError) {
        console.error("[api/score-dashboard] student_terms ì¡°íšŒ ì‹¤íŒ¨", termError);
      } else if (termData) {
        effectiveTermId = termData.id;
        grade = termData.grade;
        semester = termData.semester;
      }
    }

    // termIdë¥¼ ì°¾ì§€ ëª»í–ˆê³  grade, semesterë„ ì—†ìœ¼ë©´ ìµœê·¼ í•™ê¸° ì¡°íšŒ
    if (!effectiveTermId && (!grade || !semester)) {
      const { data: recentTerm } = await supabase
        .from("student_terms")
        .select("id, grade, semester, school_year")
        .eq("student_id", studentId)
        .order("school_year", { ascending: false })
        .order("grade", { ascending: false })
        .order("semester", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (recentTerm) {
        effectiveTermId = recentTerm.id;
        grade = recentTerm.grade;
        semester = recentTerm.semester;
      } else {
        // ê¸°ë³¸ê°’: í•™ìƒì˜ í˜„ì¬ í•™ë…„, 1í•™ê¸°
        grade = student.grade || 2;
        semester = 1;
      }
    }

    console.log("[api/score-dashboard] ì…ë ¥ íŒŒë¼ë¯¸í„°:", {
      tenantId,
      termIdParam,
      gradeParam,
      semesterParam,
      effectiveTermId,
      grade,
      semester,
    });

    // curriculum_revision_idëŠ” í™œì„±í™”ëœ ìµœì‹  êµìœ¡ê³¼ì • ì‚¬ìš©
    const { data: activeRevision } = await supabase
      .from("curriculum_revisions")
      .select("id")
      .eq("is_active", true)
      .order("year", { ascending: false })
      .limit(1)
      .maybeSingle();

    const curriculumRevisionId = activeRevision?.id || null;

    // 3) ë‚´ì‹  ë¶„ì„ (effectiveTermId ê¸°ì¤€)
    const internal = await getInternalAnalysis(
      effectiveTenantId,
      studentId,
      effectiveTermId || undefined
    );

    // ë‚´ì‹  ë°ì´í„° ê°œìˆ˜ í™•ì¸
    let internalCountQuery = supabase
      .from("student_internal_scores")
      .select("*", { count: "exact", head: true })
      .eq("tenant_id", effectiveTenantId)
      .eq("student_id", studentId);
    
    if (effectiveTermId) {
      internalCountQuery = internalCountQuery.eq("student_term_id", effectiveTermId);
    }
    
    const { count: internalCount } = await internalCountQuery;
    console.log("[api/score-dashboard] ë‚´ì‹  ë°ì´í„° ê°œìˆ˜:", internalCount);

    // 3-1) ë‚´ì‹  ë°±ë¶„ìœ„ í™˜ì‚°
    const internalPct =
      internal.totalGpa != null && curriculumRevisionId
        ? await getInternalPercentile(curriculumRevisionId, internal.totalGpa)
        : null;

    // 4) ëª¨ì˜ê³ ì‚¬ ë¶„ì„ (ìµœê·¼ ëª¨ì˜ ê¸°ì¤€, termIdì™€ ë¬´ê´€)
    const mock = await getMockAnalysis(effectiveTenantId, studentId);
    
    // ëª¨ì˜ê³ ì‚¬ ë°ì´í„° ê°œìˆ˜ í™•ì¸
    const { count: mockCount } = await supabase
      .from("student_mock_scores")
      .select("*", { count: "exact", head: true })
      .eq("tenant_id", effectiveTenantId)
      .eq("student_id", studentId);

    console.log("[api/score-dashboard] ëª¨ì˜ê³ ì‚¬ ë°ì´í„° ê°œìˆ˜:", mockCount);
    console.log("[api/score-dashboard] ëª¨ì˜ê³ ì‚¬ ë¶„ì„ ê²°ê³¼:", {
      recentExam: mock.recentExam,
      avgPercentile: mock.avgPercentile,
      totalStdScore: mock.totalStdScore,
      best3GradeSum: mock.best3GradeSum,
    });

    // 4-1) í•™êµ ìœ í˜• ì¡°íšŒ (school_property)
    let schoolProperty: string | null = null;
    if (student.school_id && (student.school_type === "MIDDLE" || student.school_type === "HIGH")) {
      // school_idëŠ” text íƒ€ì…ì´ì§€ë§Œ, school_info.idëŠ” integerì´ë¯€ë¡œ ë³€í™˜ í•„ìš”
      // "SCHOOL_" ì ‘ë‘ì‚¬ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ íŒŒì‹±
      let schoolInfoId: number | null = null;
      
      if (student.school_id.startsWith("SCHOOL_")) {
        // í†µí•© ID í˜•ì‹: "SCHOOL_123"
        const idStr = student.school_id.replace("SCHOOL_", "");
        schoolInfoId = parseInt(idStr, 10);
      } else {
        // ì§ì ‘ ID í˜•ì‹: "123"
        schoolInfoId = parseInt(student.school_id, 10);
      }
      
      if (schoolInfoId && !isNaN(schoolInfoId)) {
        const { data: schoolInfo, error: schoolInfoError } = await supabase
          .from("school_info")
          .select("school_property")
          .eq("id", schoolInfoId)
          .maybeSingle();

        if (schoolInfoError) {
          console.error("[api/score-dashboard] school_info ì¡°íšŒ ì‹¤íŒ¨", schoolInfoError);
        } else if (schoolInfo) {
          schoolProperty = schoolInfo.school_property;
        }
      }
    }

    // 5) ì „ëµ ë¶„ì„
    const strategy = analyzeAdmissionStrategy(
      internalPct,
      mock.avgPercentile,
      internal.zIndex
    );

    // 6) ì‘ë‹µ ì¡°ë¦½
    const response: ScoreDashboardResponse = {
      studentProfile: {
        id: student.id,
        name: student.name,
        grade: student.grade,
        class: student.class ? parseInt(student.class) : null,
        schoolType: schoolProperty, // school_info.school_property ê°’
        schoolYear: new Date().getFullYear(), // í˜„ì¬ ì—°ë„ ì‚¬ìš©
        termGrade: grade,
        semester: semester,
      },
      internalAnalysis: {
        totalGpa: internal.totalGpa,
        zIndex: internal.zIndex,
        subjectStrength: internal.subjectStrength,
      },
      mockAnalysis: mock,
      strategyResult: strategy,
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error("[api/score-dashboard] ì—ëŸ¬ ë°œìƒ", error);
    return NextResponse.json(
      {
        error: "Internal server error",
        message: error instanceof Error ? error.message : String(error),
      },
      { status: 500 }
    );
  }
}
</file>

<file path="subject-groups/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getSubjectGroups, getSubjectGroupsWithSubjects } from "@/lib/data/subjects";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const curriculumRevisionId = searchParams.get("curriculum_revision_id") || undefined;
    const includeSubjects = searchParams.get("include_subjects") === "true";

    if (!includeSubjects) {
      // êµê³¼ë§Œ ì¡°íšŒ
      const groups = await getSubjectGroups(curriculumRevisionId);
      
      console.log("[api/subject-groups] êµê³¼ ì¡°íšŒ ê²°ê³¼:", {
        curriculumRevisionId,
        count: groups.length,
        groups: groups.map((g) => ({ id: g.id, name: g.name })),
      });

      return NextResponse.json({
        success: true,
        data: groups || [],
      });
    }

    // êµê³¼ì™€ ê³¼ëª©ì„ í•¨ê»˜ ì¡°íšŒ
    const groupsWithSubjects = await getSubjectGroupsWithSubjects(curriculumRevisionId);

    console.log("[api/subject-groups] êµê³¼ ë° ê³¼ëª© ì¡°íšŒ ê²°ê³¼:", {
      curriculumRevisionId,
      count: groupsWithSubjects.length,
      groupsWithSubjects: groupsWithSubjects.map((g) => ({
        id: g.id,
        name: g.name,
        subjectCount: g.subjects?.length || 0,
      })),
    });

    return NextResponse.json({
      success: true,
      data: groupsWithSubjects,
    });
  } catch (error) {
    console.error("[api/subject-groups] ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "êµê³¼ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="subjects/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getSubjectsByGroup } from "@/lib/data/subjects";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const subjectGroupId = searchParams.get("subject_group_id") || undefined;

    if (!subjectGroupId) {
      return NextResponse.json(
        {
          success: false,
          error: "subject_group_idê°€ í•„ìš”í•©ë‹ˆë‹¤.",
        },
        { status: 400 }
      );
    }

    const subjects = await getSubjectsByGroup(subjectGroupId);

    console.log("[api/subjects] ê³¼ëª© ì¡°íšŒ ê²°ê³¼:", {
      subjectGroupId,
      count: subjects.length,
      subjects: subjects.map((s) => ({ id: s.id, name: s.name })),
    });

    return NextResponse.json({
      success: true,
      data: subjects,
    });
  } catch (error) {
    console.error("[api/subjects] ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "ê³¼ëª© ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="tenants/[id]/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiNoContent,
  apiForbidden,
  apiNotFound,
  apiValidationError,
  handleApiError,
} from "@/lib/api";

type Tenant = {
  id: string;
  name: string;
  type: string;
  status?: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * í…Œë„ŒíŠ¸ ìˆ˜ì • API
 * PUT /api/tenants/[id]
 *
 * @body { name: string, type?: string }
 * @returns
 * ì„±ê³µ: { success: true, data: Tenant }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { userId, role } = await getCurrentUserRole();

    console.log("[api/tenants] ìˆ˜ì • ìš”ì²­:", { id, userId, role });

    // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if (!userId || role !== "superadmin") {
      return apiForbidden("Super Adminë§Œ ê¸°ê´€ì„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    const body = await request.json();
    const { name, type, status } = body;

    // ì…ë ¥ ê²€ì¦
    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return apiValidationError("ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.", {
        name: ["ê¸°ê´€ëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."],
      });
    }

    // Super Adminì€ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return handleApiError(
        new Error("SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."),
        "[api/tenants] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨"
      );
    }

    // ë¨¼ì € í…Œë„ŒíŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const { data: existingTenant, error: checkError } = await adminClient
      .from("tenants")
      .select("id")
      .eq("id", id)
      .maybeSingle();

    console.log("[api/tenants] í…Œë„ŒíŠ¸ í™•ì¸ ê²°ê³¼:", {
      id,
      existingTenant,
      checkError: checkError ? {
        code: checkError.code,
        message: checkError.message,
        details: checkError.details,
      } : null,
    });

    if (checkError) {
      console.error("[api/tenants] í…Œë„ŒíŠ¸ í™•ì¸ ì—ëŸ¬:", checkError);
      return handleApiError(checkError, "[api/tenants] í…Œë„ŒíŠ¸ í™•ì¸ ì‹¤íŒ¨");
    }

    if (!existingTenant) {
      // ëª¨ë“  í…Œë„ŒíŠ¸ ID í™•ì¸ (ë””ë²„ê¹…ìš©)
      const { data: allTenants } = await adminClient
        .from("tenants")
        .select("id, name");
      console.log("[api/tenants] í˜„ì¬ ì¡´ì¬í•˜ëŠ” í…Œë„ŒíŠ¸:", allTenants);
      return apiNotFound("í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    // í…Œë„ŒíŠ¸ ì—…ë°ì´íŠ¸
    const updateData: { name: string; type: string; status?: string; updated_at: string } = {
      name: name.trim(),
      type: type || "academy",
      updated_at: new Date().toISOString(),
    };

    // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸ í›„ ì—…ë°ì´íŠ¸
    try {
      const { error: testError } = await adminClient
        .from("tenants")
        .select("status")
        .limit(1);
      
      if (!testError && status !== undefined) {
        updateData.status = status;
      }
    } catch (e) {
      // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    const { data, error } = await adminClient
      .from("tenants")
      .update(updateData)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      // PGRST116 ì—ëŸ¬ ì²˜ë¦¬: ê²°ê³¼ê°€ 0ê°œ í–‰ì¼ ë•Œ
      if (error.code === "PGRST116") {
        return apiNotFound("í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      }
      return handleApiError(error, "[api/tenants] ìˆ˜ì • ì‹¤íŒ¨");
    }

    if (!data) {
      return apiNotFound("ê¸°ê´€ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    return apiSuccess(data as Tenant);
  } catch (error) {
    return handleApiError(error, "[api/tenants] ìˆ˜ì • ì˜¤ë¥˜");
  }
}

/**
 * í…Œë„ŒíŠ¸ ì‚­ì œ API
 * DELETE /api/tenants/[id]
 *
 * @returns
 * ì„±ê³µ: { success: true, data: null }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { userId, role } = await getCurrentUserRole();

    // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if (!userId || role !== "superadmin") {
      return apiForbidden("Super Adminë§Œ ê¸°ê´€ì„ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    // Super Adminì€ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return handleApiError(
        new Error("SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."),
        "[api/tenants] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨"
      );
    }

    // ë¨¼ì € í…Œë„ŒíŠ¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const { data: existingTenant, error: checkError } = await adminClient
      .from("tenants")
      .select("id")
      .eq("id", id)
      .maybeSingle();

    if (checkError) {
      return handleApiError(checkError, "[api/tenants] í…Œë„ŒíŠ¸ í™•ì¸ ì‹¤íŒ¨");
    }

    if (!existingTenant) {
      return apiNotFound("í•´ë‹¹ ê¸°ê´€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    // í…Œë„ŒíŠ¸ ì‚­ì œ
    const { error } = await adminClient
      .from("tenants")
      .delete()
      .eq("id", id);

    if (error) {
      return handleApiError(error, "[api/tenants] ì‚­ì œ ì‹¤íŒ¨");
    }

    return apiNoContent();
  } catch (error) {
    return handleApiError(error, "[api/tenants] ì‚­ì œ ì˜¤ë¥˜");
  }
}
</file>

<file path="tenants/route.ts">
import { NextRequest } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import { createSupabaseAdminClient } from "@/lib/supabase/admin";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import {
  apiSuccess,
  apiCreated,
  apiForbidden,
  apiValidationError,
  handleApiError,
} from "@/lib/api";

type Tenant = {
  id: string;
  name: string;
  type: string;
  status?: string | null;
  created_at: string;
  updated_at: string;
};

/**
 * í…Œë„ŒíŠ¸ ëª©ë¡ ì¡°íšŒ API
 * GET /api/tenants
 *
 * @returns
 * ì„±ê³µ: { success: true, data: Tenant[] }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET() {
  try {
    const { userId, role } = await getCurrentUserRole();

    // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if (!userId || role !== "superadmin") {
      return apiForbidden("Super Adminë§Œ ê¸°ê´€ ëª©ë¡ì„ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    // Super Adminì€ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return handleApiError(
        new Error("SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."),
        "[api/tenants] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨"
      );
    }

    // status ì»¬ëŸ¼ì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    let selectQuery = adminClient
      .from("tenants")
      .select("id, name, type, created_at, updated_at");

    // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸ í›„ ì¶”ê°€
    try {
      const { error: testError } = await adminClient
        .from("tenants")
        .select("status")
        .limit(1);
      
      if (!testError) {
        selectQuery = adminClient
          .from("tenants")
          .select("id, name, type, status, created_at, updated_at");
      }
    } catch (e) {
      // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    const { data, error } = await selectQuery.order("created_at", { ascending: false });

    if (error) {
      return handleApiError(error, "[api/tenants] ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨");
    }

    return apiSuccess((data as Tenant[]) ?? []);
  } catch (error) {
    return handleApiError(error, "[api/tenants] ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜");
  }
}

/**
 * í…Œë„ŒíŠ¸ ìƒì„± API
 * POST /api/tenants
 *
 * @body { name: string, type?: string }
 * @returns
 * ì„±ê³µ: { success: true, data: Tenant }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function POST(request: NextRequest) {
  try {
    const { userId, role } = await getCurrentUserRole();

    // Super Adminë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if (!userId || role !== "superadmin") {
      return apiForbidden("Super Adminë§Œ ê¸°ê´€ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }

    const body = await request.json();
    const { name, type } = body;

    // ì…ë ¥ ê²€ì¦
    if (!name || typeof name !== "string" || name.trim().length === 0) {
      return apiValidationError("ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.", {
        name: ["ê¸°ê´€ëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."],
      });
    }

    // Super Adminì€ Admin Client ì‚¬ìš© (RLS ìš°íšŒ)
    const adminClient = createSupabaseAdminClient();
    if (!adminClient) {
      return handleApiError(
        new Error("SUPABASE_SERVICE_ROLE_KEY í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."),
        "[api/tenants] Admin í´ë¼ì´ì–¸íŠ¸ ìƒì„± ì‹¤íŒ¨"
      );
    }

    // status ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸
    let insertData: { name: string; type: string; status?: string } = {
      name: name.trim(),
      type: type || "academy",
    };

    try {
      const { error: testError } = await adminClient
        .from("tenants")
        .select("status")
        .limit(1);
      
      if (!testError) {
        insertData.status = "active"; // ê¸°ë³¸ê°’: active
      }
    } catch (e) {
      // status ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
    }

    const { data, error } = await adminClient
      .from("tenants")
      .insert(insertData)
      .select()
      .single();

    if (error) {
      return handleApiError(error, "[api/tenants] ìƒì„± ì‹¤íŒ¨");
    }

    return apiCreated(data as Tenant);
  } catch (error) {
    return handleApiError(error, "[api/tenants] ìƒì„± ì˜¤ë¥˜");
  }
}
</file>

<file path="terms/[type]/route.ts">
import { NextResponse } from "next/server";
import { getActiveTermsContent } from "@/lib/data/termsContents";
import type { TermsContentType } from "@/lib/types/terms";

export const dynamic = "force-dynamic";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ type: string }> }
) {
  try {
    const { type } = await params;

    // ì•½ê´€ ìœ í˜• ê²€ì¦
    if (!["terms", "privacy", "marketing"].includes(type)) {
      return NextResponse.json(
        { error: "Invalid terms type" },
        { status: 400 }
      );
    }

    const contentType = type as TermsContentType;
    const content = await getActiveTermsContent(contentType);

    if (!content) {
      return NextResponse.json(
        { error: "Terms content not found" },
        { status: 404 }
      );
    }

    // ìºì‹± í—¤ë” ì„¤ì • (5ë¶„)
    return NextResponse.json(
      {
        id: content.id,
        content_type: content.content_type,
        version: content.version,
        title: content.title,
        content: content.content,
        updated_at: content.updated_at,
      },
      {
        headers: {
          "Cache-Control": "public, s-maxage=300, stale-while-revalidate=600",
        },
      }
    );
  } catch (error) {
    console.error("[api/terms] ì•½ê´€ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="today/plans/route.ts">
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import {
  apiSuccess,
  apiUnauthorized,
  handleApiError,
} from "@/lib/api";
import { getTodayPlans, type TodayPlansResponse } from "@/lib/data/todayPlans";
import { perfTime } from "@/lib/utils/perfLog";

const ISO_DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

function normalizeIsoDate(value: string | null): string | null {
  if (!value || !ISO_DATE_REGEX.test(value)) {
    return null;
  }

  const date = new Date(value + "T00:00:00Z");
  return Number.isNaN(date.getTime()) ? null : value;
}

export const dynamic = "force-dynamic";

/**
 * ì˜¤ëŠ˜ì˜ í”Œëœ ì¡°íšŒ API
 * GET /api/today/plans?date=YYYY-MM-DD&camp=true&includeProgress=true
 *
 * @returns
 * ì„±ê³µ: { success: true, data: TodayPlansResponse }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: Request) {
  const totalTimer = perfTime("[todayPlans] total");
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      totalTimer.end();
      return apiUnauthorized();
    }

    const tenantContext = await getTenantContext();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayDate = today.toISOString().slice(0, 10);

    const { searchParams } = new URL(request.url);
    const requestedDateParam = normalizeIsoDate(searchParams.get("date"));
    const targetDate = requestedDateParam ?? todayDate;
    const isCampMode = searchParams.get("camp") === "true";
    const includeProgress = searchParams.get("includeProgress") !== "false"; // Default: true
    const noCache = searchParams.get("noCache") === "true"; // Allow cache bypass
    const useCache = !noCache; // Default: true (use cache)
    const cacheTtlSeconds = parseInt(searchParams.get("cacheTtl") || "120", 10); // Default: 120 seconds

    // Call the shared getTodayPlans function
    // This function contains all the DB queries, enrich logic, and todayProgress calculation
    const data = await getTodayPlans({
      studentId: user.userId,
      tenantId: tenantContext?.tenantId || null,
      date: targetDate,
      camp: isCampMode,
      includeProgress,
      narrowQueries: true, // Always use narrow queries for API endpoint
      useCache,
      cacheTtlSeconds,
    });

    totalTimer.end();
    return apiSuccess<TodayPlansResponse>(data);
  } catch (error) {
    totalTimer.end();
    return handleApiError(error, "[api/today/plans] ì˜¤ë¥˜");
  }
}
</file>

<file path="today/progress/route.ts">
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { calculateTodayProgress } from "@/lib/metrics/todayProgress";
import {
  apiSuccess,
  apiUnauthorized,
  handleApiError,
} from "@/lib/api";

const ISO_DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

function normalizeIsoDate(value: string | null): string | null {
  if (!value || !ISO_DATE_REGEX.test(value)) {
    return null;
  }

  const date = new Date(`${value}T00:00:00Z`);
  return Number.isNaN(date.getTime()) ? null : value;
}

export const dynamic = "force-dynamic";

type TodayProgressResponse = {
  planDate: string;
  progress: Awaited<ReturnType<typeof calculateTodayProgress>>;
};

/**
 * ì˜¤ëŠ˜ì˜ ì„±ì·¨ë„ ì¡°íšŒ API
 * GET /api/today/progress?date=YYYY-MM-DD
 *
 * @returns
 * ì„±ê³µ: { success: true, data: TodayProgressResponse }
 * ì—ëŸ¬: { success: false, error: { code, message } }
 */
export async function GET(request: Request) {
  try {
    const user = await getCurrentUser();
    if (!user || user.role !== "student") {
      return apiUnauthorized();
    }

    const tenantContext = await getTenantContext();

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayDate = today.toISOString().slice(0, 10);

    const { searchParams } = new URL(request.url);
    const requestedDateParam = normalizeIsoDate(searchParams.get("date"));
    const targetDate = requestedDateParam ?? todayDate;

    const progress = await calculateTodayProgress(
      user.userId,
      tenantContext?.tenantId || null,
      targetDate
    );

    return apiSuccess<TodayProgressResponse>({
      planDate: targetDate,
      progress,
    });
  } catch (error) {
    return handleApiError(error, "[api/today/progress] ì˜¤ë¥˜");
  }
}
</file>

<file path="global/configs/adminCategories.ts">
/**
 * ê´€ë¦¬ì ì˜ì—­ ì¹´í…Œê³ ë¦¬ ì„¤ì •
 */

import type { NavigationCategory } from "../types";

export const adminCategories: NavigationCategory[] = [
  {
    id: "admin-dashboard",
    label: "ëŒ€ì‹œë³´ë“œ",
    icon: "ğŸ“Š",
    items: [
      {
        id: "admin-dashboard-main",
        label: "ëŒ€ì‹œë³´ë“œ",
        href: "/admin/dashboard",
        icon: "ğŸ“Š",
      },
    ],
  },
  {
    id: "admin-students",
    label: "í•™ìƒ ê´€ë¦¬",
    icon: "ğŸ‘¥",
    items: [
      {
        id: "admin-students-list",
        label: "í•™ìƒ ëª©ë¡",
        href: "/admin/students",
        icon: "ğŸ‘¥",
      },
      {
        id: "admin-students-attendance",
        label: "ì¶œì„ ê´€ë¦¬",
        href: "/admin/attendance",
        icon: "âœ“",
      },
      {
        id: "admin-attendance-qr-code",
        label: "QR ì½”ë“œ ìƒì„±",
        href: "/admin/attendance/qr-code",
        icon: "ğŸ“±",
      },
      {
        id: "admin-attendance-settings",
        label: "ì¶œì„ ìœ„ì¹˜ ì„¤ì •",
        href: "/admin/attendance/settings",
        icon: "ğŸ“",
      },
      {
        id: "admin-parent-links",
        label: "í•™ë¶€ëª¨ ì—°ê²° ê´€ë¦¬",
        href: "/admin/parent-links",
        icon: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§",
      },
    ],
  },
  {
    id: "admin-consulting",
    label: "ìƒë‹´ ë…¸íŠ¸",
    icon: "ğŸ“",
    items: [
      {
        id: "admin-consulting-list",
        label: "ìƒë‹´ ë…¸íŠ¸",
        href: "/admin/consulting",
        icon: "ğŸ“",
      },
    ],
  },
  {
    id: "admin-communication",
    label: "SMS ê´€ë¦¬",
    icon: "ğŸ“±",
    items: [
      {
        id: "admin-sms-send",
        label: "SMS ë°œì†¡",
        href: "/admin/sms/send",
        icon: "ğŸ“¤",
      },
      {
        id: "admin-sms-logs",
        label: "SMS ë°œì†¡ ì´ë ¥",
        href: "/admin/sms/results",
        icon: "ğŸ“±",
      },
    ],
  },
  {
    id: "admin-reports",
    label: "ë¦¬í¬íŠ¸",
    icon: "ğŸ“„",
    items: [
      {
        id: "admin-reports-list",
        label: "ë¦¬í¬íŠ¸",
        href: "/admin/reports",
        icon: "ğŸ“„",
      },
    ],
  },
  {
    id: "admin-compare",
    label: "ë¹„êµ ë¶„ì„",
    icon: "ğŸ“ˆ",
    items: [
      {
        id: "admin-compare-main",
        label: "ë¹„êµ ë¶„ì„",
        href: "/admin/compare",
        icon: "ğŸ“ˆ",
      },
    ],
  },
  {
    id: "admin-master-content",
    label: "ì„œë¹„ìŠ¤ ë§ˆìŠ¤í„°",
    icon: "ğŸ“š",
    items: [
      {
        id: "admin-content-metadata",
        label: "ì½˜í…ì¸  ë©”íƒ€ë°ì´í„°",
        href: "/admin/content-metadata",
        icon: "ğŸ“‹",
      },
      {
        id: "admin-subjects",
        label: "êµê³¼/ê³¼ëª© ê´€ë¦¬",
        href: "/admin/subjects",
        icon: "ğŸ“š",
      },
      {
        id: "admin-master-books",
        label: "êµì¬ ê´€ë¦¬",
        href: "/admin/master-books",
        icon: "ğŸ“–",
      },
      {
        id: "admin-master-lectures",
        label: "ê°•ì˜ ê´€ë¦¬",
        href: "/admin/master-lectures",
        icon: "ğŸ§",
      },
      {
        id: "admin-schools",
        label: "í•™êµ ê´€ë¦¬",
        href: "/admin/schools",
        icon: "ğŸ«",
      },
    ],
  },
  {
    id: "admin-time-management",
    label: "ì‹œê°„ ê´€ë¦¬",
    icon: "â°",
    items: [
      {
        id: "admin-time-management-main",
        label: "ì‹œê°„ ê´€ë¦¬",
        href: "/admin/time-management",
        icon: "â°",
      },
    ],
  },
  {
    id: "admin-camp",
    label: "ìº í”„ ê´€ë¦¬",
    icon: "ğŸ•ï¸",
    items: [
      {
        id: "admin-camp-templates",
        label: "ìº í”„ í…œí”Œë¦¿",
        href: "/admin/camp-templates",
        icon: "ğŸ•ï¸",
      },
    ],
  },
  {
    id: "admin-settings",
    label: "ì„¤ì •",
    icon: "âš™ï¸",
    items: [
      {
        id: "admin-settings-main",
        label: "ì„¤ì •",
        href: "/admin/settings",
        icon: "âš™ï¸",
      },
      {
        id: "admin-tenant-settings",
        label: "ê¸°ê´€ ì„¤ì •",
        href: "/admin/tenant/settings",
        icon: "ğŸ¢",
        roles: ["admin"], // adminë§Œ ì ‘ê·¼
      },
      {
        id: "admin-scheduler-settings",
        label: "ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì •",
        href: "/admin/settings/scheduler",
        icon: "ğŸ“…",
        roles: ["admin"], // adminë§Œ ì ‘ê·¼
      },
      {
        id: "admin-recommendation-settings",
        label: "ì¶”ì²œ ì‹œìŠ¤í…œ ì„¤ì •",
        href: "/admin/recommendation-settings",
        icon: "ğŸ¯",
        roles: ["admin"], // adminë§Œ ì ‘ê·¼
      },
      {
        id: "admin-tenant-users",
        label: "ê¸°ê´€ë³„ ì‚¬ìš©ì ê´€ë¦¬",
        href: "/admin/tenant/users",
        icon: "ğŸ‘¥",
        roles: ["admin"], // adminë§Œ ì ‘ê·¼
      },
      {
        id: "admin-tools",
        label: "ë„êµ¬",
        href: "/admin/tools",
        icon: "ğŸ› ï¸",
      },
    ],
  },
];
</file>

<file path="global/configs/parentCategories.ts">
/**
 * í•™ë¶€ëª¨ ì˜ì—­ ì¹´í…Œê³ ë¦¬ ì„¤ì •
 */

import type { NavigationCategory } from "../types";

export const parentCategories: NavigationCategory[] = [
  {
    id: "parent-dashboard",
    label: "ëŒ€ì‹œë³´ë“œ",
    icon: "ğŸ“Š",
    items: [
      {
        id: "parent-dashboard-main",
        label: "ëŒ€ì‹œë³´ë“œ",
        href: "/parent/dashboard",
        icon: "ğŸ“Š",
      },
    ],
  },
  {
    id: "parent-reports",
    label: "ë¦¬í¬íŠ¸",
    icon: "ğŸ“„",
    items: [
      {
        id: "parent-reports-weekly",
        label: "ì£¼ê°„ ë¦¬í¬íŠ¸",
        href: "/parent/report/weekly",
        icon: "ğŸ“…",
      },
      {
        id: "parent-reports-monthly",
        label: "ì›”ê°„ ë¦¬í¬íŠ¸",
        href: "/parent/report/monthly",
        icon: "ğŸ“†",
      },
    ],
  },
  {
    id: "parent-performance",
    label: "ì„±ê³¼",
    icon: "ğŸ“ˆ",
    items: [
      {
        id: "parent-scores",
        label: "ì„±ì ",
        href: "/parent/scores",
        icon: "ğŸ“ˆ",
      },
      {
        id: "parent-goals",
        label: "ëª©í‘œ",
        href: "/parent/goals",
        icon: "ğŸ¯",
      },
      {
        id: "parent-history",
        label: "ì´ë ¥",
        href: "/parent/history",
        icon: "ğŸ“œ",
      },
    ],
  },
  {
    id: "parent-settings",
    label: "ì„¤ì •",
    icon: "âš™ï¸",
    items: [
      {
        id: "parent-settings-main",
        label: "ì„¤ì •",
        href: "/parent/settings",
        icon: "âš™ï¸",
      },
    ],
  },
];
</file>

<file path="global/configs/studentCategories.ts">
/**
 * í•™ìƒ ì˜ì—­ ì¹´í…Œê³ ë¦¬ ì„¤ì •
 */

import type { NavigationCategory } from "../types";

export const studentCategories: NavigationCategory[] = [
  {
    id: "dashboard",
    label: "ëŒ€ì‹œë³´ë“œ",
    icon: "ğŸ“Š",
    items: [
      {
        id: "dashboard-main",
        label: "ëŒ€ì‹œë³´ë“œ",
        href: "/dashboard",
        icon: "ğŸ“Š",
      },
    ],
  },
  {
    id: "camp",
    label: "ìº í”„ ê´€ë¦¬",
    icon: "ğŸ•ï¸",
    items: [
      {
        id: "camp-list",
        label: "ìº í”„ ëª©ë¡",
        href: "/camp",
        icon: "ğŸ“‹",
      },
      {
        id: "camp-calendar",
        label: "ìº í”„ í”Œëœ ìº˜ë¦°ë”",
        href: "/camp/calendar",
        icon: "ğŸ—“ï¸",
      },
      {
        id: "camp-today",
        label: "ìº í”„ í•™ìŠµê´€ë¦¬",
        href: "/camp/today",
        icon: "ğŸ“…",
      },
    ],
  },
  {
    id: "plan",
    label: "í”Œëœ ê´€ë¦¬",
    icon: "ğŸ“‹",
    items: [
      {
        id: "plan-list",
        label: "í”Œëœ ëª©ë¡",
        href: "/plan",
        icon: "ğŸ“‹",
      },
      {
        id: "plan-calendar",
        label: "í”Œëœ ìº˜ë¦°ë”",
        href: "/plan/calendar",
        icon: "ğŸ—“ï¸",
      },
      {
        id: "plan-today",
        label: "í•™ìŠµ ê´€ë¦¬",
        href: "/today",
        icon: "ğŸ“…",
      },
    ],
  },
  {
    id: "contents",
    label: "ì½˜í…ì¸  ê´€ë¦¬",
    icon: "ğŸ“š",
    items: [
      {
        id: "contents-list",
        label: "ì½˜í…ì¸ ",
        href: "/contents",
        icon: "ğŸ“š",
      },
    ],
  },
  {
    id: "time",
    label: "ì‹œê°„ ê´€ë¦¬",
    icon: "â°",
    items: [
      {
        id: "blocks-sets",
        label: "ë¸”ë¡ ì„¸íŠ¸",
        href: "/blocks?tab=blocks",
        icon: "ğŸ“…",
        queryParams: { tab: "blocks" },
      },
      {
        id: "blocks-exclusions",
        label: "í•™ìŠµ ì œì™¸ ì¼ì •",
        href: "/blocks?tab=exclusions",
        icon: "ğŸ—“ï¸",
        queryParams: { tab: "exclusions" },
      },
      {
        id: "blocks-academy",
        label: "í•™ì› ì¼ì •",
        href: "/blocks?tab=academy",
        icon: "ğŸ«",
        queryParams: { tab: "academy" },
      },
    ],
  },
  {
    id: "scores",
    label: "ì„±ì  ê´€ë¦¬",
    icon: "ğŸ“",
    items: [
      {
        id: "scores-dashboard",
        label: "ì„±ì  ëŒ€ì‹œë³´ë“œ",
        href: "/scores/dashboard/unified",
        icon: "ğŸ“Š",
      },
      {
        id: "scores-input-internal",
        label: "ë‚´ì‹  ì„±ì  ì…ë ¥",
        href: "/scores/input?tab=internal",
        icon: "âœï¸",
        queryParams: { tab: "internal" },
      },
      {
        id: "scores-input-mock",
        label: "ëª¨ì˜ê³ ì‚¬ ì„±ì  ì…ë ¥",
        href: "/scores/input?tab=mock",
        icon: "ğŸ“",
        queryParams: { tab: "mock" },
      },
      {
        id: "scores-analysis",
        label: "ìƒì„¸ ë¶„ì„ ë³´ê¸°",
        href: "/scores/analysis",
        icon: "ğŸ“ˆ",
      },
    ],
  },
  {
    id: "attendance",
    label: "ì¶œì„ ê´€ë¦¬",
    icon: "âœ…",
    items: [
      {
        id: "attendance-check-in",
        label: "ì¶œì„ ì²´í¬",
        href: "/attendance/check-in",
        icon: "âœ…",
      },
    ],
  },
  {
    id: "reports",
    label: "í•™ìŠµ ë¦¬í¬íŠ¸",
    icon: "ğŸ“Š",
    items: [
      {
        id: "reports-weekly",
        label: "ì£¼ê°„ ë¦¬í¬íŠ¸",
        href: "/reports?period=weekly",
        icon: "ğŸ“…",
        queryParams: { period: "weekly" },
      },
      {
        id: "reports-monthly",
        label: "ì›”ê°„ ë¦¬í¬íŠ¸",
        href: "/reports?period=monthly",
        icon: "ğŸ“†",
        queryParams: { period: "monthly" },
      },
      {
        id: "reports-weekly-detail",
        label: "ìƒì„¸ ì£¼ê°„ ë¦¬í¬íŠ¸",
        href: "/report/weekly",
        icon: "ğŸ“ˆ",
      },
      {
        id: "reports-monthly-detail",
        label: "ìƒì„¸ ì›”ê°„ ë¦¬í¬íŠ¸",
        href: "/report/monthly",
        icon: "ğŸ“Š",
      },
    ],
  },
  {
    id: "settings",
    label: "ì„¤ì •",
    icon: "âš™ï¸",
    items: [
      {
        id: "settings-profile",
        label: "í”„ë¡œí•„",
        href: "/settings",
        icon: "ğŸ‘¤",
      },
      {
        id: "settings-notifications",
        label: "ì•Œë¦¼ ì„¤ì •",
        href: "/settings/notifications",
        icon: "ğŸ””",
      },
      {
        id: "settings-devices",
        label: "ë¡œê·¸ì¸ ê¸°ê¸° ê´€ë¦¬",
        href: "/settings/devices",
        icon: "ğŸ“±",
      },
      {
        id: "settings-account",
        label: "ê³„ì • ê´€ë¦¬",
        href: "/settings/account",
        icon: "ğŸ”",
      },
    ],
  },
];
</file>

<file path="global/configs/superadminCategories.ts">
/**
 * Super Admin ì˜ì—­ ì¹´í…Œê³ ë¦¬ ì„¤ì •
 */

import type { NavigationCategory } from "../types";

export const superadminCategories: NavigationCategory[] = [
  {
    id: "superadmin-dashboard",
    label: "ëŒ€ì‹œë³´ë“œ",
    icon: "ğŸ“Š",
    items: [
      {
        id: "superadmin-dashboard-main",
        label: "ëŒ€ì‹œë³´ë“œ",
        href: "/superadmin/dashboard",
        icon: "ğŸ“Š",
      },
    ],
  },
  {
    id: "superadmin-tenants",
    label: "ê¸°ê´€ ê´€ë¦¬",
    icon: "ğŸ›ï¸",
    items: [
      {
        id: "superadmin-tenants-main",
        label: "ê¸°ê´€ ê´€ë¦¬",
        href: "/superadmin/tenants",
        icon: "ğŸ›ï¸",
      },
    ],
  },
  {
    id: "superadmin-users",
    label: "ì‚¬ìš©ì ê´€ë¦¬",
    icon: "ğŸ‘¥",
    items: [
      {
        id: "superadmin-admin-users",
        label: "ê´€ë¦¬ì ê³„ì •",
        href: "/superadmin/admin-users",
        icon: "ğŸ‘¤",
      },
      {
        id: "superadmin-unverified-users",
        label: "ë¯¸ì¸ì¦ ê°€ì… ê´€ë¦¬",
        href: "/superadmin/unverified-users",
        icon: "âœ‰ï¸",
      },
      {
        id: "superadmin-tenantless-users",
        label: "í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì",
        href: "/superadmin/tenantless-users",
        icon: "ğŸ”—",
      },
    ],
  },
  {
    id: "superadmin-settings",
    label: "ì„¤ì •",
    icon: "âš™ï¸",
    items: [
      {
        id: "superadmin-settings-main",
        label: "ì„¤ì •",
        href: "/superadmin/settings",
        icon: "âš™ï¸",
      },
      {
        id: "superadmin-curriculum-settings",
        label: "êµìœ¡ê³¼ì • ì„¤ì •",
        href: "/superadmin/curriculum-settings",
        icon: "ğŸ“š",
      },
      {
        id: "superadmin-terms-management",
        label: "ì•½ê´€ ê´€ë¦¬",
        href: "/superadmin/terms-management",
        icon: "ğŸ“„",
      },
    ],
  },
];
</file>

<file path="global/Breadcrumbs.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/cn";
import { getBreadcrumbChain } from "./resolveActiveCategory";
import { getAllNavigationItems, type NavigationRole } from "./categoryConfig";
import { useBreadcrumbLabels } from "@/lib/components/BreadcrumbContext";

type BreadcrumbsProps = {
  role: NavigationRole;
  className?: string;
  // ë™ì  í˜ì´ì§€ì—ì„œ ì¶”ê°€ ì •ë³´ ì „ë‹¬ (ì˜ˆ: ì±… ì œëª©, í•™ìƒ ì´ë¦„ ë“±)
  dynamicLabels?: Record<string, string>;
};

export function Breadcrumbs({ role, className, dynamicLabels: propDynamicLabels }: BreadcrumbsProps) {
  const pathname = usePathname();
  const contextLabels = useBreadcrumbLabels();
  // propsë¡œ ì „ë‹¬ëœ ë¼ë²¨ì´ ìš°ì„ , ì—†ìœ¼ë©´ Contextì—ì„œ ê°€ì ¸ì˜´
  const dynamicLabels = propDynamicLabels || contextLabels || {};
  const chain = getBreadcrumbChain(pathname || "", role);
  const allItems = getAllNavigationItems(role);

  // ë™ì  ë¼ë²¨ ì ìš© (ì˜ˆ: /contents/books/[id] â†’ ì±… ì œëª©)
  const enrichedChain = chain.map((item) => {
    // ë™ì  ë¼ë²¨ì´ ì œê³µëœ ê²½ìš° ì ìš©
    if (dynamicLabels && dynamicLabels[item.href]) {
      return {
        ...item,
        label: dynamicLabels[item.href],
      };
    }

    // "ìƒì„¸ë³´ê¸°" ë¼ë²¨ì„ ë” êµ¬ì²´ì ìœ¼ë¡œ ë³€ê²½ ì‹œë„
    if (item.label === "ìƒì„¸ë³´ê¸°") {
      // ê²½ë¡œ íŒ¨í„´ ë¶„ì„í•˜ì—¬ ë” êµ¬ì²´ì ì¸ ë¼ë²¨ ìƒì„±
      const pathSegments = item.href.split("/").filter(Boolean);
      
      // /contents/books/[id] â†’ ì±… ì œëª© ë˜ëŠ” "êµì¬"
      if (pathSegments.includes("books") && pathSegments.includes("contents")) {
        // ë™ì  ë¼ë²¨ì´ ì œê³µëœ ê²½ìš° ì‚¬ìš© (ì˜ˆ: ì±… ì œëª©)
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        // ë™ì  ë¼ë²¨ì´ ì—†ìœ¼ë©´ "êµì¬" í‘œì‹œ (ì¶”í›„ ë™ì ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥)
        return { ...item, label: "êµì¬" };
      }
      // /contents/lectures/[id] â†’ "ê°•ì˜ ìƒì„¸"
      if (pathSegments.includes("lectures") && pathSegments.includes("contents")) {
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        return { ...item, label: "ê°•ì˜" };
      }
      // /plan/[id] â†’ "í”Œëœ ìƒì„¸"
      if (pathSegments.includes("plan") && pathSegments.length === 2) {
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        return { ...item, label: "í”Œëœ ìƒì„¸" };
      }
      // /plan/[id]/edit â†’ "í”Œëœ ìˆ˜ì •"
      if (pathSegments.includes("plan") && pathSegments.includes("edit")) {
        return { ...item, label: "í”Œëœ ìˆ˜ì •" };
      }
      // /contents/books/[id]/edit â†’ "ì±… ìˆ˜ì •"
      if (pathSegments.includes("books") && pathSegments.includes("edit")) {
        return { ...item, label: "ì±… ìˆ˜ì •" };
      }
      // /contents/lectures/[id]/edit â†’ "ê°•ì˜ ìˆ˜ì •"
      if (pathSegments.includes("lectures") && pathSegments.includes("edit")) {
        return { ...item, label: "ê°•ì˜ ìˆ˜ì •" };
      }
      // /goals/[id] â†’ "ëª©í‘œ ìƒì„¸"
      if (pathSegments.includes("goals") && pathSegments.length === 2) {
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        return { ...item, label: "ëª©í‘œ ìƒì„¸" };
      }
      // /scores/[id] â†’ "ì„±ì  ìƒì„¸"
      if (pathSegments.includes("scores") && pathSegments.length === 2) {
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        return { ...item, label: "ì„±ì  ìƒì„¸" };
      }
      // /admin/students/[id] â†’ "í•™ìƒ ìƒì„¸"
      if (pathSegments.includes("students") && pathSegments.includes("admin")) {
        if (dynamicLabels && dynamicLabels[item.href]) {
          return { ...item, label: dynamicLabels[item.href] };
        }
        return { ...item, label: "í•™ìƒ ìƒì„¸" };
      }
    }

    return item;
  });

  // breadcrumbì´ ì—†ìœ¼ë©´ ë Œë”ë§í•˜ì§€ ì•ŠìŒ
  if (enrichedChain.length === 0) {
    return null;
  }

  return (
    <nav
      className={cn(
        "flex items-center gap-1 overflow-x-auto px-4 py-2 text-sm text-gray-600 bg-gray-50 border-b border-gray-100",
        className
      )}
      aria-label="Breadcrumb"
    >
      <ol className="flex items-center gap-1 flex-wrap max-w-full">
        {enrichedChain.map((item, index) => (
          <li key={`${item.href}-${index}`} className="flex items-center gap-1 flex-shrink-0">
            {index > 0 && (
              <span className="text-gray-400" aria-hidden="true">
                /
              </span>
            )}
            {index === enrichedChain.length - 1 ? (
              // ë§ˆì§€ë§‰ í•­ëª©ì€ í˜„ì¬ í˜ì´ì§€ (ë¹„í™œì„±í™”)
              <span
                className="font-medium text-gray-900 truncate max-w-[150px] sm:max-w-[200px]"
                aria-current="page"
              >
                {item.label}
              </span>
            ) : (
              // ë‚˜ë¨¸ì§€ í•­ëª©ì€ ë§í¬
              <Link
                href={item.href}
                className="hover:text-gray-900 truncate max-w-[150px] sm:max-w-[200px] transition"
              >
                {item.label}
              </Link>
            )}
          </li>
        ))}
      </ol>
    </nav>
  );
}
</file>

<file path="global/categoryConfig.ts">
/**
 * ì „ì—­ ì¹´í…Œê³ ë¦¬ ë„¤ë¹„ê²Œì´ì…˜ ì„¤ì •
 * ì—­í• ë³„(í•™ìƒ/ê´€ë¦¬ì/í•™ë¶€ëª¨) ì¹´í…Œê³ ë¦¬ êµ¬ì¡°ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 */

import type { NavigationRole, NavigationItem, NavigationCategory } from "./types";
import { studentCategories } from "./configs/studentCategories";
import { adminCategories } from "./configs/adminCategories";
import { parentCategories } from "./configs/parentCategories";
import { superadminCategories } from "./configs/superadminCategories";

// íƒ€ì… ì¬export (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
export type { NavigationRole, NavigationItem, NavigationCategory } from "./types";

/**
 * ì—­í• ë³„ ì¹´í…Œê³ ë¦¬ ì„¤ì • ë§µ
 */
export const categoryConfig: Record<NavigationRole, NavigationCategory[]> = {
  student: studentCategories,
  admin: adminCategories,
  parent: parentCategories,
  superadmin: superadminCategories,
  consultant: adminCategories, // consultantëŠ” adminê³¼ ë™ì¼í•œ ì¹´í…Œê³ ë¦¬ ì‚¬ìš©
};

/**
 * ì—­í• ë³„ ì¹´í…Œê³ ë¦¬ ì„¤ì • ì¡°íšŒ
 */
export function getCategoriesForRole(
  role: NavigationRole
): NavigationCategory[] {
  return categoryConfig[role] || [];
}

/**
 * ëª¨ë“  ì¹´í…Œê³ ë¦¬ ì•„ì´í…œ í”Œë« ëª©ë¡ ìƒì„± (ê²€ìƒ‰/í•„í„°ë§ ìš©)
 */
export function getAllNavigationItems(role: NavigationRole): NavigationItem[] {
  const categories = getCategoriesForRole(role);
  const items: NavigationItem[] = [];

  function collectItems(
    items: NavigationItem[],
    categoryItems: NavigationItem[]
  ) {
    for (const item of categoryItems) {
      // ì—­í•  ì²´í¬
      if (item.roles && !item.roles.includes(role)) {
        continue;
      }
      items.push(item);
      if (item.children) {
        collectItems(items, item.children);
      }
    }
  }

  for (const category of categories) {
    collectItems(items, category.items);
  }

  return items;
}
</file>

<file path="global/CategoryNav.tsx">
"use client";

import Link from "next/link";
import { usePathname, useSearchParams } from "next/navigation";
import { useState, useEffect, useMemo } from "react";
import { cn } from "@/lib/cn";
import { getCategoriesForRole, type NavigationRole, type NavigationCategory, type NavigationItem } from "./categoryConfig";
import { resolveActiveCategory, isCategoryPath, isItemActive, type ActiveCategoryInfo } from "./resolveActiveCategory";
import { useSidebar } from "@/components/layout/SidebarContext";
import { isCampMode, ensurePathname, getActiveCategoryWithCampMode } from "@/lib/navigation/utils";

type CategoryNavProps = {
  role: NavigationRole;
  className?: string;
};

export function CategoryNav({ role, className }: CategoryNavProps) {
  const { isCollapsed } = useSidebar();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const safePathname = ensurePathname(pathname);
  
  // categories ë©”ëª¨ì´ì œì´ì…˜ (roleì´ ë³€ê²½ë  ë•Œë§Œ ì¬ê³„ì‚°)
  const categories = useMemo(
    () => getCategoriesForRole(role),
    [role]
  );
  
  // campMode ë©”ëª¨ì´ì œì´ì…˜ (pathname, searchParams ë³€ê²½ ì‹œë§Œ ì¬ê³„ì‚°)
  const campMode = useMemo(
    () => isCampMode(pathname, searchParams),
    [pathname, searchParams]
  );
  
  // í™œì„± ì¹´í…Œê³ ë¦¬ ì •ë³´ë¥¼ ê³„ì‚° (useMemoë¡œ ê°’ ì§ì ‘ ê³„ì‚°)
  const activeCategoryInfo = useMemo((): ActiveCategoryInfo | null => {
    return getActiveCategoryWithCampMode(
      safePathname,
      role,
      searchParams,
      categories,
      campMode
    );
  }, [safePathname, role, campMode, categories, searchParams]);
  
  // ì´ˆê¸° ìƒíƒœ ì„¤ì • (ì´ˆê¸°í™” í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì§ì ‘ ê³„ì‚°)
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(() => {
    // ì´ˆê¸° ë Œë”ë§ ì‹œ ì§ì ‘ ê³„ì‚° (SSR ì•ˆì „)
    const initialCampMode = isCampMode(pathname, searchParams);
    const active = getActiveCategoryWithCampMode(
      safePathname,
      role,
      searchParams,
      categories,
      initialCampMode
    );
    return new Set(active ? [active.category.id] : [categories[0]?.id].filter(Boolean));
  });

  // pathname ë³€ê²½ ì‹œ í™œì„± ì¹´í…Œê³ ë¦¬ ìë™ í™•ì¥
  useEffect(() => {
    if (activeCategoryInfo) {
      setExpandedCategories((prev) => {
        if (prev.has(activeCategoryInfo.category.id)) return prev;
        return new Set([...prev, activeCategoryInfo.category.id]);
      });
    }
  }, [activeCategoryInfo]);

  const toggleCategory = (categoryId: string) => {
    setExpandedCategories((prev) => {
      const next = new Set(prev);
      if (next.has(categoryId)) {
        next.delete(categoryId);
      } else {
        next.add(categoryId);
      }
      return next;
    });
  };

  const isCategoryActive = (category: NavigationCategory): boolean => {
    // activeCategoryInfoë¥¼ í™œìš©í•˜ì—¬ ì¤‘ë³µ ì œê±°
    if (activeCategoryInfo) {
      return activeCategoryInfo.category.id === category.id;
    }
    return isCategoryPath(safePathname, category, searchParams);
  };

  return (
    <nav className={cn("flex flex-col gap-1", className)}>
      {categories.map((category) => {
        const isActive = isCategoryActive(category);
        const isExpanded = expandedCategories.has(category.id);
        
        // í•˜ìœ„ ë©”ë‰´ê°€ 1ê°œì¸ ê²½ìš° ë°”ë¡œ ë§í¬ë¡œ ì²˜ë¦¬
        const singleItem = category.items.length === 1 && !category.items[0].children;
        const singleItemHref = singleItem ? category.items[0].href : null;
        const singleItemActive = singleItem ? isItemActive(safePathname, category.items[0], searchParams) : false;

        return (
          <div key={category.id} className="flex flex-col gap-1">
            {/* í•˜ìœ„ ë©”ë‰´ê°€ 1ê°œì¸ ê²½ìš°: ì¹´í…Œê³ ë¦¬ ìì²´ë¥¼ ë§í¬ë¡œ */}
            {singleItem ? (
              <Link
                href={singleItemHref!}
                className={cn(
                  "flex w-full items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition",
                  isCollapsed && "justify-center px-2",
                  singleItemActive
                    ? "bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300"
                    : "text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-800 hover:text-gray-900 dark:hover:text-gray-100"
                )}
                title={isCollapsed ? category.label : undefined}
              >
                {category.icon && <span>{category.icon}</span>}
                <span className={cn("transition-opacity", isCollapsed && "opacity-0 w-0 overflow-hidden")}>
                  {category.label}
                </span>
              </Link>
            ) : (
              <>
                {/* ì¹´í…Œê³ ë¦¬ í—¤ë” */}
                <button
                  onClick={() => toggleCategory(category.id)}
                  className={cn(
                    "flex w-full items-center justify-between rounded-lg px-3 py-2 text-sm font-medium transition",
                    isCollapsed && "justify-center px-2",
                    isActive
                      ? "bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300"
                      : "text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-800 hover:text-gray-900 dark:hover:text-gray-100"
                  )}
                  title={isCollapsed ? category.label : undefined}
                >
                  <div className="flex items-center gap-2">
                    {category.icon && <span>{category.icon}</span>}
                    <span className={cn("transition-opacity", isCollapsed && "opacity-0 w-0 overflow-hidden")}>
                      {category.label}
                    </span>
                  </div>
                  {!isCollapsed && (
                  <svg
                    className={cn(
                        "h-4 w-4 transition-transform flex-shrink-0",
                      isExpanded ? "rotate-180" : ""
                    )}
                    fill="none"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path d="M19 9l-7 7-7-7" />
                  </svg>
                  )}
                </button>

                {/* ì¹´í…Œê³ ë¦¬ ì•„ì´í…œë“¤ */}
                {isExpanded && !isCollapsed && (
                  <div className="flex flex-col gap-1 pl-4">
                    {category.items.map((item) => {
                      // ì—­í•  ì²´í¬
                      if (item.roles && !item.roles.includes(role)) {
                        return null;
                      }

                      const itemActive = isItemActive(safePathname, item, searchParams);

                      return (
                        <div key={item.id}>
                          {/* ë©”ì¸ ì•„ì´í…œ */}
                          <Link
                            href={item.href}
                            className={cn(
                              "flex items-center gap-3 rounded-lg px-3 py-2 text-sm font-medium transition",
                              itemActive
                                ? "bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300"
                                : "text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-800 hover:text-gray-900 dark:hover:text-gray-100"
                            )}
                          >
                            {item.icon && <span>{item.icon}</span>}
                            <span>{item.label}</span>
                          </Link>

                          {/* Children ì•„ì´í…œ (ì˜ˆ: ì½˜í…ì¸  > êµì¬ > ë“±ë¡) */}
                          {item.children && item.children.length > 0 && (
                            <div className="flex flex-col gap-1 pl-6">
                              {item.children.map((child) => {
                                const childActive = isItemActive(safePathname, child, searchParams);
                                return (
                                  <Link
                                    key={child.id}
                                    href={child.href}
                                    className={cn(
                                      "flex items-center gap-2 rounded-lg px-3 py-1.5 text-xs font-medium transition",
                                      childActive
                                        ? "bg-indigo-100 dark:bg-indigo-900/40 text-indigo-800 dark:text-indigo-200"
                                        : "text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-800 hover:text-gray-900 dark:hover:text-gray-100"
                                    )}
                                  >
                                    {child.icon && <span className="text-xs">{child.icon}</span>}
                                    <span>{child.label}</span>
                                  </Link>
                                );
                              })}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                )}
              </>
            )}
          </div>
        );
      })}
    </nav>
  );
}
</file>

<file path="global/resolveActiveCategory.ts">
/**
 * í˜„ì¬ ê²½ë¡œì— ëŒ€í•œ í™œì„± ì¹´í…Œê³ ë¦¬ ë° ì•„ì´í…œ í™•ì¸
 */

import type {
  NavigationCategory,
  NavigationItem,
  NavigationRole,
} from "./categoryConfig";
import { getCategoriesForRole } from "./categoryConfig";

export type ActiveCategoryInfo = {
  category: NavigationCategory;
  activeItem: NavigationItem | null;
  isCategoryActive: boolean;
};

/**
 * hrefì—ì„œ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¥¼ ë¶„ë¦¬í•˜ì—¬ pathnameê³¼ queryParamsë¡œ ë°˜í™˜
 */
function parseHref(href: string): { pathname: string; queryParams: Record<string, string> } {
  const [pathname, queryString] = href.split("?");
  const queryParams: Record<string, string> = {};
  
  if (queryString) {
    const params = new URLSearchParams(queryString);
    params.forEach((value, key) => {
      queryParams[key] = value;
    });
  }
  
  return { pathname: pathname || href, queryParams };
}

/**
 * ë‘ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ê°ì²´ê°€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
 */
function matchQueryParams(
  currentParams: URLSearchParams | null,
  itemQueryParams?: Record<string, string>
): boolean {
  // itemì— queryParamsê°€ ì—†ìœ¼ë©´ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë§¤ì¹­ ë¶ˆí•„ìš”
  if (!itemQueryParams || Object.keys(itemQueryParams).length === 0) {
    return true;
  }
  
  // currentParamsê°€ ì—†ìœ¼ë©´ itemì— queryParamsê°€ ìˆìœ¼ë©´ ë§¤ì¹­ ì‹¤íŒ¨
  if (!currentParams) {
    return false;
  }
  
  // itemì˜ ëª¨ë“  queryParamsê°€ currentParamsì— ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
  for (const [key, value] of Object.entries(itemQueryParams)) {
    if (currentParams.get(key) !== value) {
      return false;
    }
  }
  
  return true;
}

/**
 * ê²½ë¡œê°€ íŠ¹ì • hrefì™€ ë§¤ì¹­ë˜ëŠ”ì§€ í™•ì¸
 */
function isPathActive(
  pathname: string,
  href: string,
  exactMatch: boolean = false,
  searchParams?: URLSearchParams | null,
  itemQueryParams?: Record<string, string>
): boolean {
  // hrefì—ì„œ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë¶„ë¦¬
  const { pathname: hrefPathname, queryParams: hrefQueryParams } = parseHref(href);
  
  // pathname ë§¤ì¹­ í™•ì¸
  let pathnameMatches = false;
  if (exactMatch) {
    pathnameMatches = pathname === hrefPathname;
  } else {
    pathnameMatches = pathname === hrefPathname || pathname.startsWith(`${hrefPathname}/`);
  }
  
  if (!pathnameMatches) {
    return false;
  }
  
  // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ” ê²½ìš° ë§¤ì¹­ í™•ì¸
  const hasQueryParams = itemQueryParams && Object.keys(itemQueryParams).length > 0;
  const hasHrefQueryParams = Object.keys(hrefQueryParams).length > 0;
  
  if (hasQueryParams || hasHrefQueryParams) {
    // itemQueryParamsê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ hrefì—ì„œ íŒŒì‹±í•œ ê²ƒ ì‚¬ìš©
    const paramsToMatch = itemQueryParams || hrefQueryParams;
    return matchQueryParams(searchParams || null, paramsToMatch);
  }
  
  return true;
}

/**
 * íŠ¹ì • ì•„ì´í…œì´ í˜„ì¬ ê²½ë¡œì™€ í™œì„± ìƒíƒœì¸ì§€ í™•ì¸
 */
export function isItemActive(
  pathname: string,
  item: NavigationItem,
  searchParams?: URLSearchParams | null
): boolean {
  // hrefì—ì„œ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë¶„ë¦¬
  const { pathname: itemPathname } = parseHref(item.href);
  
  // ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•˜ëŠ” ê²½ìš°
  if (item.exactMatch) {
    return isPathActive(pathname, item.href, true, searchParams, item.queryParams);
  }

  // startsWith ë§¤ì¹­
  if (isPathActive(pathname, item.href, false, searchParams, item.queryParams)) {
    return true;
  }

  // ë™ì  ë¼ìš°íŠ¸ ë§¤ì¹­ (childrenì´ ìˆëŠ” ê²½ìš°, ë™ì  ì„¸ê·¸ë¨¼íŠ¸ í¬í•¨ ê²½ë¡œ ê²€ì‚¬)
  if (item.children) {
    for (const child of item.children) {
      if (isItemActive(pathname, child, searchParams)) {
        return true;
      }
    }
  }

  // ë™ì  ì„¸ê·¸ë¨¼íŠ¸ íŒ¨í„´ ë§¤ì¹­ (ì˜ˆ: /contents/books/[id] í˜•íƒœ)
  // hrefì— [id] ê°™ì€ íŒ¨í„´ì´ ìˆê±°ë‚˜, pathnameì´ ë¶€ëª¨ ê²½ë¡œì˜ í•˜ìœ„ ê²½ë¡œì¸ ê²½ìš°
  const itemSegments = itemPathname.split("/").filter(Boolean);
  const pathSegments = pathname.split("/").filter(Boolean);
  
  // ë¶€ëª¨ ê²½ë¡œ ë§¤ì¹­ í™•ì¸ (itemPathnameì´ pathnameì˜ ë¶€ëª¨ ê²½ë¡œì¸ì§€)
  if (pathSegments.length > itemSegments.length) {
    let matches = true;
    for (let i = 0; i < itemSegments.length; i++) {
      if (itemSegments[i] !== pathSegments[i]) {
        matches = false;
        break;
      }
    }
    
    if (matches) {
      // ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ê°€ UUIDë‚˜ ê¸´ ID í˜•íƒœì¸ì§€ í™•ì¸
      const lastSegment = pathSegments[pathSegments.length - 1];
      const isDynamicSegment = 
        lastSegment.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) ||
        lastSegment.length > 15;
      
      if (isDynamicSegment) {
        // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ” ê²½ìš° ë§¤ì¹­ í™•ì¸
        if (item.queryParams && Object.keys(item.queryParams).length > 0) {
          return matchQueryParams(searchParams || null, item.queryParams);
        }
        return true;
      }
    }
  }

  return false;
}

/**
 * ì¹´í…Œê³ ë¦¬ ë‚´ í™œì„± ì•„ì´í…œ ì°¾ê¸°
 */
function findActiveItemInCategory(
  pathname: string,
  category: NavigationCategory,
  searchParams?: URLSearchParams | null
): NavigationItem | null {
  for (const item of category.items) {
    // ì—­í•  ì²´í¬ëŠ” í˜¸ì¶œë¶€ì—ì„œ ì²˜ë¦¬ (ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœ ë§¤ì¹­ë§Œ)

    // ì§ì ‘ ë§¤ì¹­
    if (isItemActive(pathname, item, searchParams)) {
      return item;
    }

    // children ê²€ìƒ‰
    if (item.children) {
      for (const child of item.children) {
        if (isItemActive(pathname, child, searchParams)) {
          return item; // ë¶€ëª¨ ì•„ì´í…œ ë°˜í™˜
        }
      }
    }
  }

  return null;
}

/**
 * í˜„ì¬ ê²½ë¡œì— ëŒ€í•œ í™œì„± ì¹´í…Œê³ ë¦¬ ë° ì•„ì´í…œ í™•ì¸
 */
export function resolveActiveCategory(
  pathname: string,
  role: NavigationRole,
  searchParams?: URLSearchParams | null
): ActiveCategoryInfo | null {
  const categories = getCategoriesForRole(role);

  for (const category of categories) {
    const activeItem = findActiveItemInCategory(pathname, category, searchParams);

    if (activeItem) {
      return {
        category,
        activeItem,
        isCategoryActive: true,
      };
    }

    // ì¹´í…Œê³ ë¦¬ ìì²´ê°€ í™œì„±í™”ëœ ê²½ìš° (ì¹´í…Œê³ ë¦¬ì˜ ê¸°ë³¸ ê²½ë¡œì™€ ì¼ì¹˜)
    const categoryPath = category.items[0]?.href;
    if (categoryPath) {
      const { pathname: categoryPathname, queryParams: categoryQueryParams } = parseHref(categoryPath);
      if (isPathActive(pathname, categoryPath, false, searchParams, categoryQueryParams)) {
        return {
          category,
          activeItem: category.items[0],
          isCategoryActive: true,
        };
      }
    }
  }

  // í™œì„± ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°
  return null;
}

/**
 * íŠ¹ì • ê²½ë¡œê°€ ì¹´í…Œê³ ë¦¬ì˜ í•˜ìœ„ ê²½ë¡œì¸ì§€ í™•ì¸
 */
export function isCategoryPath(
  pathname: string,
  category: NavigationCategory,
  searchParams?: URLSearchParams | null
): boolean {
  for (const item of category.items) {
    if (isPathActive(pathname, item.href, false, searchParams, item.queryParams)) {
      return true;
    }
    if (item.children) {
      for (const child of item.children) {
        if (isPathActive(pathname, child.href, false, searchParams, child.queryParams)) {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * Breadcrumbs ìƒì„±ì„ ìœ„í•œ ê²½ë¡œ ì²´ì¸ ìƒì„±
 */
export function getBreadcrumbChain(
  pathname: string,
  role: NavigationRole
): Array<{ label: string; href: string }> {
  const chain: Array<{ label: string; href: string }> = [];
  const categories = getCategoriesForRole(role);

  // í™ˆ ì¶”ê°€ (ì—­í• ë³„)
  const homeHref =
    role === "student"
      ? "/dashboard"
      : role === "admin" || role === "consultant"
      ? "/admin/dashboard"
      : role === "superadmin"
      ? "/superadmin/dashboard"
      : "/parent/dashboard";
  const homeLabel =
    role === "student"
      ? "í™ˆ"
      : role === "admin" || role === "consultant"
      ? "ê´€ë¦¬ì í™ˆ"
      : role === "superadmin"
      ? "Super Admin í™ˆ"
      : "í•™ë¶€ëª¨ í™ˆ";
  chain.push({ label: homeLabel, href: homeHref });

  // íŠ¹ë³„ ì²˜ë¦¬: /contents/books/new, /contents/lectures/new (ì •í™•í•œ ë§¤ì¹­ë³´ë‹¤ ë¨¼ì € ì²˜ë¦¬)
  if (
    pathname === "/contents/books/new" ||
    pathname === "/contents/lectures/new"
  ) {
    // ì½˜í…ì¸  ê´€ë¦¬ ì¶”ê°€
    chain.push({ label: "ì½˜í…ì¸  ê´€ë¦¬", href: "/contents" });
    // ë“±ë¡ í˜ì´ì§€ ì¶”ê°€
    const label =
      pathname === "/contents/books/new" ? "ì±… ë“±ë¡í•˜ê¸°" : "ê°•ì˜ ë“±ë¡í•˜ê¸°";
    chain.push({ label, href: pathname });
    return chain;
  }

  // ëª¨ë“  ì•„ì´í…œ í”Œë« ë¦¬ìŠ¤íŠ¸ ìƒì„± (ë§¤ì¹­ìš©)
  const allItems: Array<{
    category: NavigationCategory;
    item: NavigationItem;
    child?: NavigationItem;
  }> = [];
  for (const category of categories) {
    for (const item of category.items) {
      allItems.push({ category, item });
      if (item.children) {
        for (const child of item.children) {
          allItems.push({ category, item, child });
        }
      }
    }
  }

  // ì •í™•í•œ ë§¤ì¹­ ì°¾ê¸° (ê°€ì¥ êµ¬ì²´ì ì¸ ê²½ë¡œë¶€í„°)
  const sortedItems = allItems.sort((a, b) => {
    const aPath = a.child?.href || a.item.href;
    const bPath = b.child?.href || b.item.href;
    return bPath.split("/").length - aPath.split("/").length;
  });

  for (const { category, item, child } of sortedItems) {
    const itemPath = child?.href || item.href;

    // ì •í™•í•œ ê²½ë¡œ ë§¤ì¹­
    if (isPathActive(pathname, itemPath)) {
      // í•˜ìœ„ ë©”ë‰´ê°€ 1ê°œì´ê³  childrenì´ ì—†ëŠ” ê²½ìš°: ì¹´í…Œê³ ë¦¬ ë¼ë²¨ë§Œ ì‚¬ìš© (ì•„ì´í…œ ë¼ë²¨ ê±´ë„ˆë›°ê¸°)
      const singleItem =
        category.items.length === 1 && !category.items[0].children;

      if (singleItem) {
        // ì¹´í…Œê³ ë¦¬ ë¼ë²¨ë§Œ ì¶”ê°€
        const categoryHref = category.items[0]?.href || item.href;
        if (
          chain.length === 1 ||
          chain[chain.length - 1].href !== categoryHref
        ) {
          chain.push({ label: category.label, href: categoryHref });
        }
      } else {
        // ì¹´í…Œê³ ë¦¬ ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€)
        const categoryHref = category.items[0]?.href || item.href;
        if (
          chain.length === 1 ||
          chain[chain.length - 1].href !== categoryHref
        ) {
          chain.push({ label: category.label, href: categoryHref });
        }

        // ì•„ì´í…œ ì¶”ê°€
        if (child) {
          chain.push({ label: item.label, href: item.href });
          chain.push({ label: child.label, href: child.href });
        } else {
          chain.push({ label: item.label, href: item.href });
        }
      }

      return chain;
    }
  }

  // ë™ì  ë¼ìš°íŠ¸ ë§¤ì¹­ (ì •í™•í•œ ë§¤ì¹­ì´ ì—†ëŠ” ê²½ìš°)
  for (const { category, item } of sortedItems) {
    // childrenì´ ìˆëŠ” ì•„ì´í…œë§Œ ë™ì  ë¼ìš°íŠ¸ë¡œ ì²˜ë¦¬
    if (item.children) continue;

    if (matchesDynamicRoute(pathname, item.href)) {
      // í•˜ìœ„ ë©”ë‰´ê°€ 1ê°œì´ê³  childrenì´ ì—†ëŠ” ê²½ìš°: ì¹´í…Œê³ ë¦¬ ë¼ë²¨ë§Œ ì‚¬ìš©
      const singleItem =
        category.items.length === 1 && !category.items[0].children;

      if (singleItem) {
        // ì¹´í…Œê³ ë¦¬ ë¼ë²¨ë§Œ ì¶”ê°€
        const categoryHref = category.items[0]?.href || item.href;
        if (
          chain.length === 1 ||
          chain[chain.length - 1].href !== categoryHref
        ) {
          chain.push({ label: category.label, href: categoryHref });
        }
      } else {
        // ì¹´í…Œê³ ë¦¬ ì¶”ê°€
        const categoryHref = category.items[0]?.href || item.href;
        if (
          chain.length === 1 ||
          chain[chain.length - 1].href !== categoryHref
        ) {
          chain.push({ label: category.label, href: categoryHref });
        }

        // ì•„ì´í…œ ì¶”ê°€
        chain.push({ label: item.label, href: item.href });
      }

      // ë™ì  ë¼ìš°íŠ¸ì´ë¯€ë¡œ ë§ˆì§€ë§‰ì— ìƒì„¸ ë¼ë²¨ ì¶”ê°€
      chain.push({ label: "ìƒì„¸ë³´ê¸°", href: pathname });

      return chain;
    }
  }

  // ë§¤ì¹­ë˜ì§€ ì•ŠëŠ” ê²½ìš°, ê²½ë¡œ ì„¸ê·¸ë¨¼íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ìƒì„±
  const segments = pathname.split("/").filter(Boolean);
  let currentPath = "";

  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];

    // UUIDë‚˜ ê¸´ ID í˜•íƒœì¸ ê²½ìš° ìŠ¤í‚µ (ë™ì  ì„¸ê·¸ë¨¼íŠ¸)
    if (
      segment.match(
        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
      ) ||
      segment.length > 20
    ) {
      // ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ì¸ ê²½ìš° "ìƒì„¸ë³´ê¸°" ì¶”ê°€
      if (i === segments.length - 1) {
        chain.push({ label: "ìƒì„¸ë³´ê¸°", href: pathname });
      }
      continue;
    }

    // /contents/books/[id], /contents/lectures/[id] ë“±ì˜ ê²½ìš°
    // booksë‚˜ lectures ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ê±´ë„ˆë›°ê³  /contentsë¡œ ì§ì ‘ ì—°ê²°
    if (segment === "books" || segment === "lectures") {
      // /contentsê°€ ì•„ì§ ì¶”ê°€ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¶”ê°€
      if (!chain.some((c) => c.href === "/contents")) {
        chain.push({ label: "ì½˜í…ì¸  ê´€ë¦¬", href: "/contents" });
      }
      // books/lectures ì„¸ê·¸ë¨¼íŠ¸ëŠ” ìŠ¤í‚µí•˜ê³  ë‹¤ìŒìœ¼ë¡œ
      continue;
    }

    currentPath += `/${segment}`;
    const label = getSegmentLabel(segment, role);

    // ì´ë¯¸ ì²´ì¸ì— ì¶”ê°€ëœ í•­ëª©ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì¶”ê°€
    if (!chain.some((c) => c.href === currentPath)) {
      chain.push({ label, href: currentPath });
    }
  }

  return chain;
}

/**
 * ë™ì  ë¼ìš°íŠ¸ íŒ¨í„´ê³¼ ê²½ë¡œ ë§¤ì¹­
 * ì˜ˆ: /contents/books â†’ /contents/books/[id] ë§¤ì¹­
 */
function matchesDynamicRoute(pathname: string, basePath: string): boolean {
  // basePathê°€ íŒ¨í„´ì´ ì•„ë‹Œ ì‹¤ì œ ê²½ë¡œì¸ ê²½ìš°, í•˜ìœ„ ë™ì  ë¼ìš°íŠ¸ì¸ì§€ í™•ì¸
  const baseSegments = basePath.split("/").filter(Boolean);
  const pathSegments = pathname.split("/").filter(Boolean);

  // basePathë³´ë‹¤ ê¸¸ê±°ë‚˜ ê°™ì•„ì•¼ í•¨
  if (pathSegments.length < baseSegments.length) {
    return false;
  }

  // ì•ë¶€ë¶„ ì„¸ê·¸ë¨¼íŠ¸ê°€ ëª¨ë‘ ì¼ì¹˜í•´ì•¼ í•¨
  for (let i = 0; i < baseSegments.length; i++) {
    if (baseSegments[i] !== pathSegments[i]) {
      return false;
    }
  }

  // ë™ì¼í•œ ê²½ë¡œë©´ false (ë™ì  ë¼ìš°íŠ¸ê°€ ì•„ë‹˜)
  if (pathSegments.length === baseSegments.length) {
    return false;
  }

  // ì¶”ê°€ ì„¸ê·¸ë¨¼íŠ¸ê°€ ìˆëŠ” ê²½ìš°, ë§ˆì§€ë§‰ì´ ID í˜•íƒœì¸ì§€ í™•ì¸
  if (pathSegments.length > baseSegments.length) {
    const lastSegment = pathSegments[pathSegments.length - 1];
    // UUID ë˜ëŠ” ê¸´ ID í˜•íƒœ
    if (lastSegment.match(/^[0-9a-f-]{8,}$/i) || lastSegment.length > 15) {
      return true;
    }
  }

  return false;
}

/**
 * ê²½ë¡œ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ í•œê¸€ ë¼ë²¨ë¡œ ë³€í™˜
 */
function getSegmentLabel(segment: string, role: NavigationRole): string {
  const labelMap: Record<NavigationRole, Record<string, string>> = {
    student: {
      dashboard: "ëŒ€ì‹œë³´ë“œ",
      today: "ì˜¤ëŠ˜ í•™ìŠµ",
      plan: "í”Œëœ ê´€ë¦¬",
      contents: "ì½˜í…ì¸  ê´€ë¦¬",
      books: "êµì¬",
      lectures: "ê°•ì˜",
      custom: "ì»¤ìŠ¤í…€",
      analysis: "í•™ìŠµ ë¶„ì„",
      scores: "ì„±ì  ê´€ë¦¬",
      reports: "ë¦¬í¬íŠ¸",
      scheduler: "ìŠ¤ì¼€ì¤„ëŸ¬",
      blocks: "ì‹œê°„ ê´€ë¦¬",
      time: "ì‹œê°„ ê´€ë¦¬",
      new: "ë“±ë¡",
      edit: "ìˆ˜ì •",
    },
    admin: {
      admin: "ê´€ë¦¬ì",
      dashboard: "ëŒ€ì‹œë³´ë“œ",
      students: "í•™ìƒ ê´€ë¦¬",
      consulting: "ìƒë‹´ ë…¸íŠ¸",
      attendance: "ì¶œì„ ê´€ë¦¬",
      sms: "SMS ë°œì†¡ ì´ë ¥",
      reports: "ë¦¬í¬íŠ¸",
      compare: "ë¹„êµ ë¶„ì„",
      settings: "ì„¤ì •",
      tenant: "ê¸°ê´€ ì„¤ì •",
      tools: "ë„êµ¬",
      superadmin: "Super Admin",
      tenants: "ê¸°ê´€ ê´€ë¦¬",
      subjects: "êµê³¼/ê³¼ëª© ê´€ë¦¬",
      schools: "í•™êµ ê´€ë¦¬",
    },
    consultant: {
      admin: "ê´€ë¦¬ì",
      dashboard: "ëŒ€ì‹œë³´ë“œ",
      students: "í•™ìƒ ê´€ë¦¬",
      consulting: "ìƒë‹´ ë…¸íŠ¸",
      attendance: "ì¶œì„ ê´€ë¦¬",
      sms: "SMS ë°œì†¡ ì´ë ¥",
      reports: "ë¦¬í¬íŠ¸",
      compare: "ë¹„êµ ë¶„ì„",
      settings: "ì„¤ì •",
      tenant: "ê¸°ê´€ ì„¤ì •",
      tools: "ë„êµ¬",
      superadmin: "Super Admin",
      tenants: "ê¸°ê´€ ê´€ë¦¬",
      subjects: "êµê³¼/ê³¼ëª© ê´€ë¦¬",
      schools: "í•™êµ ê´€ë¦¬",
    },
    superadmin: {
      superadmin: "Super Admin",
      dashboard: "ëŒ€ì‹œë³´ë“œ",
      tenants: "ê¸°ê´€ ê´€ë¦¬",
      "admin-users": "ê´€ë¦¬ì ê³„ì •",
      "unverified-users": "ë¯¸ì¸ì¦ ê°€ì… ê´€ë¦¬",
      "tenantless-users": "í…Œë„ŒíŠ¸ ë¯¸í• ë‹¹ ì‚¬ìš©ì",
      settings: "ì„¤ì •",
    },
    parent: {
      parent: "í•™ë¶€ëª¨",
      dashboard: "ëŒ€ì‹œë³´ë“œ",
      report: "ë¦¬í¬íŠ¸",
      reports: "ë¦¬í¬íŠ¸",
      weekly: "ì£¼ê°„ ë¦¬í¬íŠ¸",
      monthly: "ì›”ê°„ ë¦¬í¬íŠ¸",
      scores: "ì„±ì ",
      history: "ì´ë ¥",
      settings: "ì„¤ì •",
    },
  };

  return labelMap[role]?.[segment] || segment;
}
</file>

<file path="global/types.ts">
/**
 * ë„¤ë¹„ê²Œì´ì…˜ íƒ€ì… ì •ì˜
 */

export type NavigationRole = "student" | "admin" | "parent" | "superadmin" | "consultant";

export type NavigationItem = {
  id: string;
  label: string;
  href: string;
  icon?: string;
  children?: NavigationItem[];
  roles?: NavigationRole[]; // íŠ¹ì • ì—­í• ë§Œ ì ‘ê·¼ ê°€ëŠ¥ (ì—†ìœ¼ë©´ ëª¨ë“  ì—­í• )
  exactMatch?: boolean; // ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í™œì„±í™” (ê¸°ë³¸ê°’: false, startsWith)
  queryParams?: Record<string, string>; // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë§¤ì¹­ìš© (ì˜ˆ: { tab: "blocks" })
};

export type NavigationCategory = {
  id: string;
  label: string;
  icon?: string;
  items: NavigationItem[];
  roles?: NavigationRole[];
};
</file>

<file path="PageContainer.tsx">
import { ReactNode } from "react";
import { getContainerClass, type LAYOUT_WIDTHS } from "@/lib/constants/layout";
import { cn } from "@/lib/cn";

type PageContainerProps = {
  children: ReactNode;
  widthType?: keyof typeof LAYOUT_WIDTHS;
  padding?: "sm" | "md" | "lg";
  className?: string;
};

/**
 * í˜ì´ì§€ ì»¨í…Œì´ë„ˆ ì»´í¬ë„ŒíŠ¸
 * 
 * ì¼ê´€ëœ ë ˆì´ì•„ì›ƒ ë„ˆë¹„ì™€ íŒ¨ë”©ì„ ì œê³µí•©ë‹ˆë‹¤.
 * Spacing-First ì •ì±…ì„ ì¤€ìˆ˜í•˜ë©°, getContainerClass ìœ í‹¸ë¦¬í‹°ë¥¼ í™œìš©í•©ë‹ˆë‹¤.
 * 
 * @example
 * <PageContainer widthType="FORM">
 *   <div className="flex flex-col gap-6">
 *     <PageHeader title="í”„ë¡œí•„" />
 *     <FormContent />
 *   </div>
 * </PageContainer>
 */
export default function PageContainer({
  children,
  widthType = "LIST",
  padding = "md",
  className,
}: PageContainerProps) {
  return (
    <section className={cn(getContainerClass(widthType, padding), className)}>
      {children}
    </section>
  );
}
</file>

<file path="PageHeader.tsx">
import { ReactNode } from "react";
import { cn } from "@/lib/cn";

type PageHeaderProps = {
  title: string;
  description?: string;
  action?: ReactNode;
  className?: string;
  level?: "h1" | "h2";
};

/**
 * í˜ì´ì§€ í—¤ë” ì»´í¬ë„ŒíŠ¸
 * 
 * ì¼ê´€ëœ í˜ì´ì§€ ì œëª© í‘œì‹œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * Spacing-First ì •ì±…ì„ ì¤€ìˆ˜í•˜ë©°, gapì„ ì‚¬ìš©í•˜ì—¬ ìš”ì†Œ ê°„ ê°„ê²©ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * 
 * @example
 * <PageHeader 
 *   title="í•™ìƒ ìƒì„¸" 
 *   description="í•™ìƒ ì •ë³´ë¥¼ í™•ì¸í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤"
 * />
 */
export function PageHeader({
  title,
  description,
  action,
  className,
  level = "h1",
}: PageHeaderProps) {
  const HeadingTag = level;

  return (
    <div className={cn("flex flex-col gap-2", className)}>
      <div className="flex items-start justify-between gap-4">
        <div className="flex flex-col gap-2 flex-1 min-w-0">
          <HeadingTag className="text-h1 text-gray-900 dark:text-gray-100">{title}</HeadingTag>
          {description && (
            <p className="text-body-2 text-gray-600 dark:text-gray-400">{description}</p>
          )}
        </div>
        {action && <div className="flex-shrink-0">{action}</div>}
      </div>
    </div>
  );
}
</file>

<file path="RoleBasedLayout.tsx">
"use client";

import { ReactNode, Suspense } from "react";
import { CategoryNav } from "@/components/navigation/global/CategoryNav";
import { Breadcrumbs } from "@/components/navigation/global/Breadcrumbs";
import { SignOutButton } from "@/app/_components/SignOutButton";
import { ThemeToggle } from "@/components/ui/ThemeToggle";
import { useSidebar } from "./SidebarContext";
import { ChevronLeft, ChevronRight, Menu, X } from "lucide-react";
import { cn } from "@/lib/cn";
import { mapRoleForNavigation } from "@/lib/navigation/utils";

type RoleBasedLayoutProps = {
  role: "student" | "admin" | "parent" | "consultant" | "superadmin";
  children: ReactNode;
  dashboardHref: string;
  roleLabel: string;
  showSidebar?: boolean;
  wrapper?: (children: ReactNode) => ReactNode;
  tenantInfo?: {
    name: string;
    type?: string;
  } | null;
};

function SidebarContent({
  role,
  dashboardHref,
  roleLabel,
  tenantInfo,
}: {
  role: RoleBasedLayoutProps["role"];
  dashboardHref: string;
  roleLabel: string;
  tenantInfo?: RoleBasedLayoutProps["tenantInfo"];
}) {
  const { isCollapsed, toggleCollapse } = useSidebar();

  return (
    <>
      {/* ë¡œê³  ë° ì»¨íŠ¸ë¡¤ */}
      <div className="border-b border-gray-200 dark:border-gray-700 p-4">
        {isCollapsed ? (
          <div className="flex flex-col items-center gap-3">
            <a
              href={dashboardHref}
              className="flex items-center justify-center w-10 h-10 text-lg rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
              aria-label="TimeLevelUp"
              title="TimeLevelUp"
            >
              <span>â±ï¸</span>
            </a>
            {/* í™•ì¥ ë²„íŠ¼ - ë” í¬ê³  ëˆˆì— ë„ê²Œ */}
            <button
              onClick={toggleCollapse}
              className="group relative w-full flex items-center justify-center p-3 rounded-lg bg-indigo-50 dark:bg-indigo-900/30 hover:bg-indigo-100 dark:hover:bg-indigo-900/50 text-indigo-700 dark:text-indigo-300 transition-colors border border-indigo-200 dark:border-indigo-800"
              aria-label="ë©”ë‰´ í¼ì¹˜ê¸°"
              title="ë©”ë‰´ í¼ì¹˜ê¸°"
            >
              <ChevronRight className="w-6 h-6 flex-shrink-0 text-indigo-700 dark:text-indigo-300" strokeWidth={2.5} />
              {/* íˆ´íŒ */}
              <div className="pointer-events-none absolute left-full ml-2 top-1/2 -translate-y-1/2 hidden w-24 rounded-lg bg-gray-900 dark:bg-gray-100 px-3 py-2 text-xs text-white dark:text-gray-900 opacity-0 shadow-lg transition-opacity group-hover:block group-hover:opacity-100 whitespace-nowrap z-50">
                ë©”ë‰´ í¼ì¹˜ê¸°
                <div className="absolute right-full top-1/2 -translate-y-1/2">
                  <div className="border-4 border-transparent border-r-gray-900 dark:border-r-gray-100"></div>
                </div>
              </div>
            </button>
          </div>
        ) : (
          <div className="flex items-center justify-between gap-2">
            <a
              href={dashboardHref}
              className="flex items-center gap-2 text-lg font-semibold text-gray-900 dark:text-gray-100"
            >
              <span>â±ï¸</span>
              <span>TimeLevelUp</span>
              <span className="text-xs text-gray-500 dark:text-gray-400">{roleLabel}</span>
            </a>
            <button
              onClick={toggleCollapse}
              className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
              aria-label="ì¶•ì†Œ"
              title="ì¶•ì†Œ"
            >
              <ChevronLeft className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>

      {/* ê¸°ê´€ ì •ë³´ (Superadmin ì œì™¸ ëª¨ë“  ì—­í• ) */}
      {tenantInfo && role !== "superadmin" && (
        <div className="border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 px-4 py-3">
          <div className="flex items-center gap-2">
            <span className="text-sm flex-shrink-0">ğŸ¢</span>
            <div
              className={cn(
                "flex-1 min-w-0 transition-opacity",
                isCollapsed && "opacity-0 w-0 overflow-hidden"
              )}
            >
              <div className="text-sm font-semibold text-gray-900 dark:text-gray-100 truncate">
                {tenantInfo.name}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* ì¹´í…Œê³ ë¦¬ ë„¤ë¹„ê²Œì´ì…˜ */}
      <div className="p-4">
        <CategoryNav
          role={mapRoleForNavigation(role)}
        />
      </div>

      {/* í•˜ë‹¨ ë§í¬ */}
      <div className="border-t border-gray-200 dark:border-gray-700 p-4">
        <div className={cn("transition-opacity", isCollapsed && "opacity-0")}>
          <div className="flex items-center justify-between gap-2">
            <SignOutButton />
            <ThemeToggle />
          </div>
        </div>
      </div>
    </>
  );
}

function MobileSidebar({
  role,
  dashboardHref,
  roleLabel,
  tenantInfo,
}: {
  role: RoleBasedLayoutProps["role"];
  dashboardHref: string;
  roleLabel: string;
  tenantInfo?: RoleBasedLayoutProps["tenantInfo"];
}) {
  const { isMobileOpen, toggleMobile, closeMobile } = useSidebar();

  return (
    <>
      {/* í–„ë²„ê±° ë²„íŠ¼ */}
      <button
        onClick={toggleMobile}
        className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors md:hidden"
        aria-label="ë©”ë‰´ ì—´ê¸°"
      >
        <Menu className="w-6 h-6" />
      </button>

      {/* ì˜¤ë²„ë ˆì´ */}
      {isMobileOpen && (
        <div
          className="fixed inset-0 bg-black/50 z-40 md:hidden"
          onClick={closeMobile}
          aria-hidden="true"
        />
      )}

      {/* ë“œë¡œì–´ */}
      <aside
        className={cn(
          "fixed top-0 left-0 h-full w-64 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 z-50 transform transition-transform duration-300 ease-in-out md:hidden overflow-y-auto",
          isMobileOpen ? "translate-x-0" : "-translate-x-full"
        )}
      >
        <div className="sticky top-0 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4 z-10">
          <div className="flex items-center justify-between gap-2">
              <a
                href={dashboardHref}
                className="flex items-center gap-2 text-lg font-semibold text-gray-900 dark:text-gray-100"
              >
                <span>â±ï¸</span>
                <span>TimeLevelUp</span>
                <span className="ml-2 text-xs text-gray-500 dark:text-gray-400">{roleLabel}</span>
              </a>
            <button
              onClick={closeMobile}
              className="p-1.5 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
              aria-label="ë©”ë‰´ ë‹«ê¸°"
            >
              <X className="w-5 h-5" />
            </button>
          </div>
            </div>

        {/* ê¸°ê´€ ì •ë³´ */}
            {tenantInfo && role !== "superadmin" && (
              <div className="border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 px-4 py-3">
                <div className="flex items-center gap-2">
                  <span className="text-sm">ğŸ¢</span>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-semibold text-gray-900 dark:text-gray-100 truncate">
                      {tenantInfo.name}
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* ì¹´í…Œê³ ë¦¬ ë„¤ë¹„ê²Œì´ì…˜ */}
            <div className="p-4">
          <CategoryNav
            role={mapRoleForNavigation(role)}
          />
            </div>

            {/* í•˜ë‹¨ ë§í¬ */}
            <div className="border-t border-gray-200 dark:border-gray-700 p-4">
              <div className="flex items-center justify-between gap-2">
                <SignOutButton />
                <ThemeToggle />
              </div>
            </div>
      </aside>
    </>
  );
}

export function RoleBasedLayout({
  role,
  children,
  dashboardHref,
  roleLabel,
  showSidebar = true,
  wrapper,
  tenantInfo,
}: RoleBasedLayoutProps) {
  const { isCollapsed } = useSidebar();

  const content = (
    <div className="flex min-h-screen bg-gray-50 dark:bg-gray-900">
      {/* ì‚¬ì´ë“œë°” ë„¤ë¹„ê²Œì´ì…˜ (ë°ìŠ¤í¬í†±) */}
      {showSidebar && (
        <aside
          className={cn(
            "hidden md:block border-r border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 transition-all duration-300 ease-in-out",
            isCollapsed ? "w-16" : "w-64"
          )}
        >
          <div className="sticky top-0 h-screen overflow-y-auto">
            <SidebarContent
              role={role}
              dashboardHref={dashboardHref}
              roleLabel={roleLabel}
              tenantInfo={tenantInfo}
            />
          </div>
        </aside>
      )}

      {/* ë©”ì¸ ì½˜í…ì¸  */}
      <main id="main-content" className="flex-1 flex flex-col">
        {/* ìƒë‹¨ ë„¤ë¹„ê²Œì´ì…˜ (ëª¨ë°”ì¼ìš©) */}
        {showSidebar && (
          <nav className="md:hidden sticky top-0 z-50 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
            <div className="flex flex-col gap-2 p-4">
              <div className="flex items-center justify-between">
                <a
                  href={dashboardHref}
                  className="flex items-center gap-2 text-lg font-semibold text-gray-900 dark:text-gray-100"
                >
                  <span>â±ï¸</span>
                  <span>TimeLevelUp</span>
                  <span className="text-xs text-gray-500 dark:text-gray-400">{roleLabel}</span>
                </a>
                <MobileSidebar
                  role={role}
                  dashboardHref={dashboardHref}
                  roleLabel={roleLabel}
                  tenantInfo={tenantInfo}
                />
              </div>
              {/* ê¸°ê´€ ì •ë³´ (ëª¨ë°”ì¼ - Superadmin ì œì™¸ ëª¨ë“  ì—­í• ) */}
              {tenantInfo && role !== "superadmin" && (
                <div className="rounded-lg bg-gray-50 dark:bg-gray-800 px-3 py-2">
                  <div className="flex items-center gap-2">
                    <span className="text-sm">ğŸ¢</span>
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-semibold text-gray-900 dark:text-gray-100 truncate">
                        {tenantInfo.name}
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </nav>
        )}

        {/* Breadcrumbs */}
        {showSidebar && (
          <Suspense fallback={null}>
            <Breadcrumbs role={mapRoleForNavigation(role)} />
          </Suspense>
        )}

        {/* í˜ì´ì§€ ì½˜í…ì¸  - suppressHydrationWarningìœ¼ë¡œ hydration ë¶ˆì¼ì¹˜ ë°©ì§€ */}
        <div className="flex-1" suppressHydrationWarning>
          {children}
        </div>
      </main>
    </div>
  );

  return wrapper ? wrapper(content) : content;
}
</file>

<file path="SidebarContext.tsx">
"use client";

import { createContext, useContext, useState, useEffect, ReactNode } from "react";

type SidebarContextType = {
  isCollapsed: boolean;
  isPinned: boolean;
  toggleCollapse: () => void;
  togglePin: () => void;
  isMobileOpen: boolean;
  toggleMobile: () => void;
  closeMobile: () => void;
};

const SidebarContext = createContext<SidebarContextType | undefined>(undefined);

const STORAGE_KEYS = {
  COLLAPSED: "sidebar-collapsed",
  PINNED: "sidebar-pinned",
} as const;

/**
 * ëª¨ë°”ì¼ í™˜ê²½ ê°ì§€ (768px ë¯¸ë§Œ)
 */
function isMobileDevice(): boolean {
  if (typeof window === "undefined") return false;
  return window.innerWidth < 768;
}

/**
 * ê¸°ë³¸ collapsed ìƒíƒœ ê²°ì •
 * - ì›¹ í™˜ê²½(í° í™”ë©´): í¼ì¹¨ ê¸°ë³¸ (false)
 * - ëª¨ë°”ì¼ í™˜ê²½: ì ‘í˜ ê¸°ë³¸ (true)
 */
function getDefaultCollapsed(): boolean {
  if (typeof window === "undefined") return false;
  
  // localStorageì— ì €ì¥ëœ ê°’ì´ ìˆìœ¼ë©´ ì‚¬ìš©
  const stored = localStorage.getItem(STORAGE_KEYS.COLLAPSED);
  if (stored !== null) {
    return stored === "true";
  }
  
  // ì €ì¥ëœ ê°’ì´ ì—†ìœ¼ë©´ ë””ë°”ì´ìŠ¤ íƒ€ì…ì— ë”°ë¼ ê¸°ë³¸ê°’ ì„¤ì •
  return isMobileDevice();
}

export function SidebarProvider({ children }: { children: ReactNode }) {
  const [isCollapsed, setIsCollapsed] = useState<boolean>(getDefaultCollapsed);

  const [isPinned, setIsPinned] = useState<boolean>(() => {
    if (typeof window === "undefined") return true;
    const stored = localStorage.getItem(STORAGE_KEYS.PINNED);
    return stored !== "false"; // ê¸°ë³¸ê°’ì€ true
  });

  const [isMobileOpen, setIsMobileOpen] = useState<boolean>(false);

  // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ëª¨ë°”ì¼/ë°ìŠ¤í¬í†± ì „í™˜ ì²˜ë¦¬
  useEffect(() => {
    const handleResize = () => {
      // ëª¨ë°”ì¼ë¡œ ì „í™˜ë˜ë©´ ì ‘í˜ ìƒíƒœë¡œ, ë°ìŠ¤í¬í†±ìœ¼ë¡œ ì „í™˜ë˜ë©´ í¼ì¹¨ ìƒíƒœë¡œ
      // ë‹¨, ì‚¬ìš©ìê°€ ìˆ˜ë™ìœ¼ë¡œ ë³€ê²½í•œ ê²½ìš°ëŠ” ìœ ì§€
      const stored = localStorage.getItem(STORAGE_KEYS.COLLAPSED);
      if (stored === null) {
        // ì €ì¥ëœ ê°’ì´ ì—†ì„ ë•Œë§Œ ìë™ìœ¼ë¡œ ì¡°ì •
        setIsCollapsed(isMobileDevice());
      }
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.COLLAPSED, String(isCollapsed));
  }, [isCollapsed]);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.PINNED, String(isPinned));
  }, [isPinned]);

  const toggleCollapse = () => {
    setIsCollapsed((prev) => !prev);
  };

  const togglePin = () => {
    setIsPinned((prev) => !prev);
  };

  const toggleMobile = () => {
    setIsMobileOpen((prev) => !prev);
  };

  const closeMobile = () => {
    setIsMobileOpen(false);
  };

  return (
    <SidebarContext.Provider
      value={{
        isCollapsed,
        isPinned,
        toggleCollapse,
        togglePin,
        isMobileOpen,
        toggleMobile,
        closeMobile,
      }}
    >
      {children}
    </SidebarContext.Provider>
  );
}

export function useSidebar() {
  const context = useContext(SidebarContext);
  if (context === undefined) {
    throw new Error("useSidebar must be used within a SidebarProvider");
  }
  return context;
}
</file>

<file path="SkipLink.tsx">
"use client";

import Link from "next/link";

/**
 * ìŠ¤í‚µ ë§í¬ ì»´í¬ë„ŒíŠ¸
 * í‚¤ë³´ë“œ ì‚¬ìš©ìê°€ ë©”ì¸ ì½˜í…ì¸ ë¡œ ë°”ë¡œ ì´ë™í•  ìˆ˜ ìˆë„ë¡ í•¨
 */
export function SkipLink() {
  return (
    <Link
      href="#main-content"
      className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-primary-600 focus:text-white focus:rounded-lg focus:font-semibold focus:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
    >
      ë©”ì¸ ì½˜í…ì¸ ë¡œ ê±´ë„ˆë›°ê¸°
    </Link>
  );
}
</file>

<file path="attendance/index.ts">
/**
 * Attendance ë„ë©”ì¸ ê³µê°œ API
 */

export * from "./types";
export * as attendanceRepository from "./repository";
export * as attendanceService from "./service";
</file>

<file path="attendance/repository.ts">
/**
 * Attendance ë„ë©”ì¸ Repository
 * ì¶œì„ ê¸°ë¡ ë°ì´í„° ì ‘ê·¼
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getSupabaseClientForRLSBypass } from "@/lib/supabase/clientSelector";
import type {
  AttendanceRecord,
  CreateAttendanceRecordInput,
  UpdateAttendanceRecordInput,
  AttendanceFilters,
} from "./types";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

/**
 * í•™ìƒ IDì™€ ë‚ ì§œë¡œ ì¶œì„ ê¸°ë¡ ì¡°íšŒ
 */
export async function findAttendanceByStudentAndDate(
  studentId: string,
  date: string
): Promise<AttendanceRecord | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("attendance_records")
    .select("*")
    .eq("student_id", studentId)
    .eq("attendance_date", date)
    .maybeSingle<AttendanceRecord>();

  if (error && error.code !== "PGRST116") {
    throw error;
  }

  return data ?? null;
}

/**
 * ì¶œì„ ê¸°ë¡ ìƒì„±
 * RLS ì •ì±… ìš°íšŒë¥¼ ìœ„í•´ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
 */
export async function insertAttendanceRecord(
  tenantId: string,
  input: CreateAttendanceRecordInput
): Promise<AttendanceRecord> {
  // RLS ì •ì±… ìš°íšŒë¥¼ ìœ„í•´ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
  const supabase = await getSupabaseClientForRLSBypass({
    forceAdmin: false,
    fallbackToServer: true,
  });

  if (!supabase) {
    throw new Error("Supabase client uninitialized");
  }

  const { data, error } = await supabase
    .from("attendance_records")
    .insert({
      tenant_id: tenantId,
      student_id: input.student_id,
      attendance_date: input.attendance_date,
      check_in_time: input.check_in_time ?? null,
      check_out_time: input.check_out_time ?? null,
      check_in_method: input.check_in_method ?? null,
      check_out_method: input.check_out_method ?? null,
      status: input.status ?? "present",
      notes: input.notes ?? null,
    })
    .select()
    .single<AttendanceRecord>();

  if (error) {
    // ì—ëŸ¬ ìƒì„¸ ì •ë³´ ë¡œê¹… ì¶”ê°€
    console.error("[attendance/repository] ì¶œì„ ê¸°ë¡ ìƒì„± ì‹¤íŒ¨", {
      message: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
      tenantId,
      input,
    });
    throw error;
  }

  return data;
}

/**
 * ì¶œì„ ê¸°ë¡ ìˆ˜ì •
 * RLS ì •ì±… ìš°íšŒë¥¼ ìœ„í•´ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
 */
export async function updateAttendanceRecord(
  recordId: string,
  input: UpdateAttendanceRecordInput
): Promise<AttendanceRecord> {
  // RLS ì •ì±… ìš°íšŒë¥¼ ìœ„í•´ Admin í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
  const supabase = await getSupabaseClientForRLSBypass({
    forceAdmin: false,
    fallbackToServer: true,
  });

  const updateData: Partial<AttendanceRecord> = {};

  if (input.check_in_time !== undefined) {
    updateData.check_in_time = input.check_in_time;
  }
  if (input.check_out_time !== undefined) {
    updateData.check_out_time = input.check_out_time;
  }
  if (input.check_in_method !== undefined) {
    updateData.check_in_method = input.check_in_method;
  }
  if (input.check_out_method !== undefined) {
    updateData.check_out_method = input.check_out_method;
  }
  if (input.status !== undefined) {
    updateData.status = input.status;
  }
  if (input.notes !== undefined) {
    updateData.notes = input.notes;
  }

  if (!supabase) {
    throw new Error("Supabase client uninitialized");
  }

  const { data, error } = await supabase
    .from("attendance_records")
    .update(updateData)
    .eq("id", recordId)
    .select()
    .single<AttendanceRecord>();

  if (error) {
    // ì—ëŸ¬ ìƒì„¸ ì •ë³´ ë¡œê¹… ì¶”ê°€
    console.error("[attendance/repository] ì¶œì„ ê¸°ë¡ ìˆ˜ì • ì‹¤íŒ¨", {
      message: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
      recordId,
      input,
    });
    throw error;
  }

  return data;
}

/**
 * ì¶œì„ ê¸°ë¡ ì‚­ì œ
 */
export async function deleteAttendanceRecord(
  recordId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("attendance_records")
    .delete()
    .eq("id", recordId);

  if (error) {
    throw error;
  }
}

/**
 * ê¸°ê°„ë³„ ì¶œì„ ê¸°ë¡ ì¡°íšŒ
 */
export async function findAttendanceRecordsByDateRange(
  filters: AttendanceFilters,
  tenantId?: string | null
): Promise<AttendanceRecord[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("attendance_records")
    .select("*")
    .order("attendance_date", { ascending: false })
    .order("check_in_time", { ascending: false });

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters.student_id) {
    query = query.eq("student_id", filters.student_id);
  }

  if (filters.start_date) {
    query = query.gte("attendance_date", filters.start_date);
  }

  if (filters.end_date) {
    query = query.lte("attendance_date", filters.end_date);
  }

  if (filters.status) {
    query = query.eq("status", filters.status);
  }

  const { data, error } = await query;

  if (error) {
    // ì—ëŸ¬ ìƒì„¸ ì •ë³´ ë¡œê¹…
    console.error("[attendance/repository] ì¶œì„ ê¸°ë¡ ì¡°íšŒ ì‹¤íŒ¨", {
      message: error.message,
      code: error.code,
      details: error.details,
      hint: error.hint,
    });
    throw error;
  }

  return (data as AttendanceRecord[]) ?? [];
}

/**
 * í•™ìƒë³„ ì¶œì„ ê¸°ë¡ ì¡°íšŒ
 */
export async function findAttendanceRecordsByStudent(
  studentId: string,
  startDate?: string,
  endDate?: string
): Promise<AttendanceRecord[]> {
  return findAttendanceRecordsByDateRange({
    student_id: studentId,
    start_date: startDate,
    end_date: endDate,
  });
}
</file>

<file path="attendance/service.ts">
/**
 * Attendance ë„ë©”ì¸ Service
 * ì¶œì„ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
 */

import * as repository from "./repository";
import type {
  AttendanceRecord,
  CreateAttendanceRecordInput,
  UpdateAttendanceRecordInput,
  AttendanceStatistics,
  AttendanceFilters,
  ValidationResult,
  ValidationError,
} from "./types";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { AppError, ErrorCode } from "@/lib/errors";

/**
 * ì¶œì„ ê¸°ë¡ ìƒì„± ë˜ëŠ” ìˆ˜ì •
 */
export async function recordAttendance(
  input: CreateAttendanceRecordInput
): Promise<AttendanceRecord> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "ê¸°ê´€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  // ê¸°ì¡´ ê¸°ë¡ í™•ì¸
  const existing = await repository.findAttendanceByStudentAndDate(
    input.student_id,
    input.attendance_date
  );

  // í†µí•© ê²€ì¦ ìˆ˜í–‰
  const validation = await validateAttendanceRecord(input, existing);
  if (!validation.valid) {
    // ì²« ë²ˆì§¸ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì‚¬ìš©í•˜ì—¬ AppError ìƒì„±
    const firstError = validation.errors[0];
    throw new AppError(
      firstError.message,
      ErrorCode.VALIDATION_ERROR,
      400,
      true,
      {
        validationErrors: validation.errors,
      }
    );
  }

  if (existing) {
    // ê¸°ì¡´ ê¸°ë¡ ìˆ˜ì •
    return repository.updateAttendanceRecord(existing.id, {
      check_in_time: input.check_in_time,
      check_out_time: input.check_out_time,
      check_in_method: input.check_in_method,
      check_out_method: input.check_out_method,
      status: input.status,
      notes: input.notes,
    });
  } else {
    // ìƒˆ ê¸°ë¡ ìƒì„±
    return repository.insertAttendanceRecord(tenantContext.tenantId, input);
  }
}

/**
 * ì¶œì„ ê¸°ë¡ ì¡°íšŒ
 */
export async function getAttendanceRecords(
  filters: AttendanceFilters
): Promise<AttendanceRecord[]> {
  const tenantContext = await getTenantContext();

  return repository.findAttendanceRecordsByDateRange(
    filters,
    tenantContext?.tenantId ?? null
  );
}

/**
 * í•™ìƒë³„ ì¶œì„ ê¸°ë¡ ì¡°íšŒ
 */
export async function getAttendanceByStudent(
  studentId: string,
  startDate?: string,
  endDate?: string
): Promise<AttendanceRecord[]> {
  return repository.findAttendanceRecordsByStudent(
    studentId,
    startDate,
    endDate
  );
}

/**
 * ì¶œì„ í†µê³„ ê³„ì‚°
 */
export async function calculateAttendanceStats(
  studentId: string,
  startDate?: string,
  endDate?: string
): Promise<AttendanceStatistics> {
  const records = await repository.findAttendanceRecordsByStudent(
    studentId,
    startDate,
    endDate
  );

  const totalDays = records.length;
  const presentCount = records.filter((r) => r.status === "present").length;
  const absentCount = records.filter((r) => r.status === "absent").length;
  const lateCount = records.filter((r) => r.status === "late").length;
  const earlyLeaveCount = records.filter(
    (r) => r.status === "early_leave"
  ).length;
  const excusedCount = records.filter((r) => r.status === "excused").length;

  const attendanceRate =
    totalDays > 0 ? (presentCount / totalDays) * 100 : 0;
  const lateRate = totalDays > 0 ? (lateCount / totalDays) * 100 : 0;
  const absentRate = totalDays > 0 ? (absentCount / totalDays) * 100 : 0;

  return {
    total_days: totalDays,
    present_count: presentCount,
    absent_count: absentCount,
    late_count: lateCount,
    early_leave_count: earlyLeaveCount,
    excused_count: excusedCount,
    attendance_rate: Math.round(attendanceRate * 100) / 100,
    late_rate: Math.round(lateRate * 100) / 100,
    absent_rate: Math.round(absentRate * 100) / 100,
  };
}

/**
 * ì¶œì„ ê¸°ë¡ ì‚­ì œ
 */
export async function deleteAttendanceRecord(
  recordId: string
): Promise<void> {
  await repository.deleteAttendanceRecord(recordId);
}

// ============================================
// ê²€ì¦ í•¨ìˆ˜
// ============================================

/**
 * ì…ì‹¤/í‡´ì‹¤ ì‹œê°„ ê²€ì¦
 */
export function validateAttendanceTimes(
  record: AttendanceRecord | CreateAttendanceRecordInput | UpdateAttendanceRecordInput,
  existingRecord?: AttendanceRecord | null
): ValidationResult {
  const errors: ValidationError[] = [];
  const now = new Date();

  // check_in_timeê³¼ check_out_time ì¶”ì¶œ
  const checkInTime =
    "check_in_time" in record ? record.check_in_time : null;
  const checkOutTime =
    "check_out_time" in record ? record.check_out_time : null;

  // 1. check_out_timeì´ ìˆìœ¼ë©´ check_in_timeë„ ìˆì–´ì•¼ í•¨
  if (checkOutTime && !checkInTime) {
    // ê¸°ì¡´ ê¸°ë¡ì˜ ì…ì‹¤ ì‹œê°„ í™•ì¸
    const existingCheckInTime = existingRecord?.check_in_time;
    if (!existingCheckInTime) {
      errors.push({
        field: "check_out_time",
        message: "í‡´ì‹¤ ì‹œê°„ì´ ìˆìœ¼ë©´ ì…ì‹¤ ì‹œê°„ë„ í•„ìš”í•©ë‹ˆë‹¤.",
        code: "CHECK_OUT_WITHOUT_CHECK_IN",
      });
    }
  }

  // 2. check_in_timeê³¼ check_out_timeì´ ëª¨ë‘ ìˆìœ¼ë©´ ì‹œê°„ ìˆœì„œ ê²€ì¦
  // ì…ë ¥ê°’ì— ì—†ìœ¼ë©´ ê¸°ì¡´ ê¸°ë¡ì˜ ê°’ì„ ì‚¬ìš©
  const finalCheckInTime = checkInTime ?? existingRecord?.check_in_time ?? null;
  const finalCheckOutTime = checkOutTime ?? null;

  if (finalCheckInTime && finalCheckOutTime) {
    const checkIn = new Date(finalCheckInTime);
    const checkOut = new Date(finalCheckOutTime);

    // check_in_timeì´ check_out_timeë³´ë‹¤ ì´ì „ì´ì–´ì•¼ í•¨
    if (checkIn >= checkOut) {
      errors.push({
        field: "check_out_time",
        message: "í‡´ì‹¤ ì‹œê°„ì€ ì…ì‹¤ ì‹œê°„ë³´ë‹¤ ì´í›„ì—¬ì•¼ í•©ë‹ˆë‹¤.",
        code: "CHECK_OUT_BEFORE_CHECK_IN",
      });
    }

    // ê°™ì€ ë‚ ì§œì¸ì§€ í™•ì¸ (íƒ€ì„ì¡´ ê³ ë ¤)
    const checkInDate = checkIn.toISOString().slice(0, 10);
    const checkOutDate = checkOut.toISOString().slice(0, 10);
    if (checkInDate !== checkOutDate) {
      errors.push({
        field: "check_out_time",
        message: "ì…ì‹¤ê³¼ í‡´ì‹¤ì€ ê°™ì€ ë‚ ì§œì—¬ì•¼ í•©ë‹ˆë‹¤.",
        code: "DIFFERENT_DATE",
      });
    }
  }

  // 3. ë¯¸ë˜ ì‹œê°„ ê²€ì¦
  if (checkInTime) {
    const checkIn = new Date(checkInTime);
    if (checkIn > now) {
      errors.push({
        field: "check_in_time",
        message: "ì…ì‹¤ ì‹œê°„ì€ ë¯¸ë˜ ì‹œê°„ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        code: "FUTURE_CHECK_IN_TIME",
      });
    }
  }

  if (checkOutTime) {
    const checkOut = new Date(checkOutTime);
    if (checkOut > now) {
      errors.push({
        field: "check_out_time",
        message: "í‡´ì‹¤ ì‹œê°„ì€ ë¯¸ë˜ ì‹œê°„ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        code: "FUTURE_CHECK_OUT_TIME",
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * ì…ì‹¤/í‡´ì‹¤ ë°©ë²• ì¼ê´€ì„± ê²€ì¦
 */
export function validateAttendanceMethodConsistency(
  record: AttendanceRecord | CreateAttendanceRecordInput | UpdateAttendanceRecordInput,
  existingRecord?: AttendanceRecord | null
): ValidationResult {
  const errors: ValidationError[] = [];

  // check_in_methodì™€ check_out_method ì¶”ì¶œ
  const checkInMethod =
    "check_in_method" in record ? record.check_in_method : null;
  const checkOutMethod =
    "check_out_method" in record ? record.check_out_method : null;

  // check_out_methodê°€ ìˆìœ¼ë©´ check_in_methodë„ ìˆì–´ì•¼ í•¨
  if (checkOutMethod && !checkInMethod) {
    // ê¸°ì¡´ ê¸°ë¡ì˜ ì…ì‹¤ ë°©ë²• í™•ì¸
    const existingCheckInMethod = existingRecord?.check_in_method;
    if (!existingCheckInMethod) {
      errors.push({
        field: "check_out_method",
        message: "í‡´ì‹¤ ë°©ë²•ì´ ìˆìœ¼ë©´ ì…ì‹¤ ë°©ë²•ë„ í•„ìš”í•©ë‹ˆë‹¤.",
        code: "CHECK_OUT_METHOD_WITHOUT_CHECK_IN_METHOD",
      });
    }
  }

  // ì…ë ¥ê°’ì— ì—†ìœ¼ë©´ ê¸°ì¡´ ê¸°ë¡ì˜ ê°’ì„ ì‚¬ìš©
  const finalCheckInMethod = checkInMethod ?? existingRecord?.check_in_method ?? null;

  // QR ì…ì‹¤ì¸ ê²½ìš° í‡´ì‹¤ë„ QRì´ì–´ì•¼ í•¨
  if (finalCheckInMethod === "qr" && checkOutMethod && checkOutMethod !== "qr") {
    errors.push({
      field: "check_out_method",
      message: "QR ì½”ë“œë¡œ ì…ì‹¤í•œ ê²½ìš° í‡´ì‹¤ë„ QR ì½”ë“œë¡œ í•´ì•¼ í•©ë‹ˆë‹¤.",
      code: "QR_CHECK_IN_REQUIRES_QR_CHECK_OUT",
    });
  }

  // ìœ„ì¹˜ ì…ì‹¤ì¸ ê²½ìš° í‡´ì‹¤ì€ ìœ„ì¹˜ ë˜ëŠ” ìˆ˜ë™ ê°€ëŠ¥
  if (
    finalCheckInMethod === "location" &&
    checkOutMethod &&
    checkOutMethod !== "location" &&
    checkOutMethod !== "manual"
  ) {
    errors.push({
      field: "check_out_method",
      message: "ìœ„ì¹˜ ê¸°ë°˜ ì…ì‹¤ì¸ ê²½ìš° í‡´ì‹¤ì€ ìœ„ì¹˜ ê¸°ë°˜ ë˜ëŠ” ìˆ˜ë™ìœ¼ë¡œ í•´ì•¼ í•©ë‹ˆë‹¤.",
      code: "LOCATION_CHECK_IN_INVALID_CHECK_OUT",
    });
  }

  // ìˆ˜ë™ ì…ì‹¤ì¸ ê²½ìš° í‡´ì‹¤ì€ ìˆ˜ë™ ê°€ëŠ¥ (ë‹¤ë¥¸ ë°©ë²•ë„ í—ˆìš©í•  ìˆ˜ ìˆìœ¼ë‚˜ ì¼ê´€ì„±ì„ ìœ„í•´ ìˆ˜ë™ ê¶Œì¥)
  // ì´ ê²€ì¦ì€ ì„ íƒì‚¬í•­ì´ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬
  // if (checkInMethod === "manual" && checkOutMethod && checkOutMethod !== "manual") {
  //   errors.push({
  //     field: "check_out_method",
  //     message: "ìˆ˜ë™ ì…ì‹¤ì¸ ê²½ìš° í‡´ì‹¤ë„ ìˆ˜ë™ìœ¼ë¡œ í•´ì•¼ í•©ë‹ˆë‹¤.",
  //     code: "MANUAL_CHECK_IN_REQUIRES_MANUAL_CHECK_OUT",
  //   });
  // }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ ê²€ì¦
 */
export async function validateNoDuplicateAttendance(
  studentId: string,
  date: string,
  input: CreateAttendanceRecordInput | UpdateAttendanceRecordInput,
  existingRecord?: AttendanceRecord | null
): Promise<ValidationResult> {
  const errors: ValidationError[] = [];

  // ê¸°ì¡´ ê¸°ë¡ì´ ìˆìœ¼ë©´ ì¤‘ë³µ ì²´í¬
  if (existingRecord) {
    // ì…ë ¥ê°’ì—ì„œ check_in_timeê³¼ check_out_time ì¶”ì¶œ
    const inputCheckInTime =
      "check_in_time" in input ? input.check_in_time : undefined;
    const inputCheckOutTime =
      "check_out_time" in input ? input.check_out_time : undefined;

    // ì…ì‹¤ ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œì—ë§Œ ì¤‘ë³µ ì²´í¬ ìˆ˜í–‰
    if (inputCheckInTime !== undefined && existingRecord.check_in_time) {
      errors.push({
        field: "check_in_time",
        message: "ì´ë¯¸ ì…ì‹¤ ê¸°ë¡ì´ ìˆìŠµë‹ˆë‹¤.",
        code: "DUPLICATE_CHECK_IN",
      });
    }

    // í‡´ì‹¤ ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œì—ë§Œ ì¤‘ë³µ ì²´í¬ ìˆ˜í–‰
    if (inputCheckOutTime !== undefined && existingRecord.check_out_time) {
      errors.push({
        field: "check_out_time",
        message: "ì´ë¯¸ í‡´ì‹¤ ê¸°ë¡ì´ ìˆìŠµë‹ˆë‹¤.",
        code: "DUPLICATE_CHECK_OUT",
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * í†µí•© ê²€ì¦ í•¨ìˆ˜
 */
export async function validateAttendanceRecord(
  input: CreateAttendanceRecordInput | UpdateAttendanceRecordInput,
  existingRecord?: AttendanceRecord | null
): Promise<ValidationResult> {
  const errors: ValidationError[] = [];

  // 1. ì‹œê°„ ê²€ì¦ (ê¸°ì¡´ ê¸°ë¡ ì •ë³´ ì „ë‹¬)
  const timeValidation = validateAttendanceTimes(input, existingRecord);
  if (!timeValidation.valid) {
    errors.push(...timeValidation.errors);
  }

  // 2. ë°©ë²• ì¼ê´€ì„± ê²€ì¦ (ê¸°ì¡´ ê¸°ë¡ ì •ë³´ ì „ë‹¬)
  const methodValidation = validateAttendanceMethodConsistency(input, existingRecord);
  if (!methodValidation.valid) {
    errors.push(...methodValidation.errors);
  }

  // 3. ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ ê²€ì¦ (CreateAttendanceRecordInputì¸ ê²½ìš°ë§Œ)
  if ("student_id" in input && "attendance_date" in input) {
    const duplicateValidation = await validateNoDuplicateAttendance(
      input.student_id,
      input.attendance_date,
      input,
      existingRecord
    );
    if (!duplicateValidation.valid) {
      errors.push(...duplicateValidation.errors);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
</file>

<file path="attendance/statistics.ts">
/**
 * ì¶œì„ í†µê³„ ë°ì´í„° ì¡°íšŒ í•¨ìˆ˜
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { getTenantContext } from "@/lib/tenant/getTenantContext";

export type AttendanceChartData = {
  date: string;
  present: number;
  absent: number;
  late: number;
  early_leave: number;
  excused: number;
};

export type MethodStatistics = {
  method: "manual" | "qr" | "location" | "auto";
  count: number;
  percentage: number;
};

export type TimeDistribution = {
  hour: number;
  count: number;
};

/**
 * ì¼ë³„ ì¶œì„ í†µê³„ ì¡°íšŒ
 */
export async function getDailyAttendanceStats(
  startDate: string,
  endDate: string,
  studentId?: string
): Promise<AttendanceChartData[]> {
  const supabase = await createSupabaseServerClient();
  const tenantContext = await getTenantContext();
  
  if (!tenantContext?.tenantId) {
    return [];
  }
  
  let query = supabase
    .from("attendance_records")
    .select("attendance_date, status")
    .eq("tenant_id", tenantContext.tenantId)
    .gte("attendance_date", startDate)
    .lte("attendance_date", endDate)
    .order("attendance_date", { ascending: true });
  
  if (studentId) {
    query = query.eq("student_id", studentId);
  }
  
  const { data } = await query;
  
  // ë‚ ì§œë³„ë¡œ ê·¸ë£¹í™”
  const grouped = new Map<string, AttendanceChartData>();
  
  (data || []).forEach((record) => {
    const date = record.attendance_date;
    if (!grouped.has(date)) {
      grouped.set(date, {
        date,
        present: 0,
        absent: 0,
        late: 0,
        early_leave: 0,
        excused: 0,
      });
    }
    
    const stats = grouped.get(date)!;
    switch (record.status) {
      case "present":
        stats.present++;
        break;
      case "absent":
        stats.absent++;
        break;
      case "late":
        stats.late++;
        break;
      case "early_leave":
        stats.early_leave++;
        break;
      case "excused":
        stats.excused++;
        break;
    }
  });
  
  return Array.from(grouped.values());
}

/**
 * ì…ì‹¤ ë°©ë²•ë³„ í†µê³„ ì¡°íšŒ
 */
export async function getCheckInMethodStats(
  startDate: string,
  endDate: string,
  studentId?: string
): Promise<MethodStatistics[]> {
  const supabase = await createSupabaseServerClient();
  const tenantContext = await getTenantContext();
  
  if (!tenantContext?.tenantId) {
    return [];
  }
  
  let query = supabase
    .from("attendance_records")
    .select("check_in_method")
    .eq("tenant_id", tenantContext.tenantId)
    .gte("attendance_date", startDate)
    .lte("attendance_date", endDate)
    .not("check_in_method", "is", null);
  
  if (studentId) {
    query = query.eq("student_id", studentId);
  }
  
  const { data } = await query;
  
  const methodCounts = new Map<string, number>();
  let total = 0;
  
  (data || []).forEach((record) => {
    const method = record.check_in_method;
    if (method) {
      methodCounts.set(method, (methodCounts.get(method) || 0) + 1);
      total++;
    }
  });
  
  return Array.from(methodCounts.entries()).map(([method, count]) => ({
    method: method as "manual" | "qr" | "location" | "auto",
    count,
    percentage: total > 0 ? (count / total) * 100 : 0,
  }));
}

/**
 * ì‹œê°„ëŒ€ë³„ ì…ì‹¤ ë¶„í¬ ì¡°íšŒ
 */
export async function getCheckInTimeDistribution(
  startDate: string,
  endDate: string,
  studentId?: string
): Promise<TimeDistribution[]> {
  const supabase = await createSupabaseServerClient();
  const tenantContext = await getTenantContext();
  
  if (!tenantContext?.tenantId) {
    return [];
  }
  
  let query = supabase
    .from("attendance_records")
    .select("check_in_time")
    .eq("tenant_id", tenantContext.tenantId)
    .gte("attendance_date", startDate)
    .lte("attendance_date", endDate)
    .not("check_in_time", "is", null);
  
  if (studentId) {
    query = query.eq("student_id", studentId);
  }
  
  const { data } = await query;
  
  const hourCounts = new Map<number, number>();
  
  (data || []).forEach((record) => {
    if (record.check_in_time) {
      const hour = new Date(record.check_in_time).getHours();
      hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
    }
  });
  
  // 0-23ì‹œê¹Œì§€ ëª¨ë“  ì‹œê°„ëŒ€ í¬í•¨
  const distribution: TimeDistribution[] = [];
  for (let hour = 0; hour < 24; hour++) {
    distribution.push({
      hour,
      count: hourCounts.get(hour) || 0,
    });
  }
  
  return distribution;
}

/**
 * í•™ìƒë³„ ì¶œì„ë¥  ë­í‚¹ ì¡°íšŒ
 */
export async function getStudentAttendanceRanking(
  startDate: string,
  endDate: string,
  limit: number = 10
): Promise<Array<{ student_id: string; student_name: string; attendance_rate: number }>> {
  const supabase = await createSupabaseServerClient();
  const tenantContext = await getTenantContext();
  
  if (!tenantContext?.tenantId) {
    return [];
  }
  
  // ì¶œì„ ê¸°ë¡ ì¡°íšŒ
  const { data: records } = await supabase
    .from("attendance_records")
    .select("student_id, status")
    .eq("tenant_id", tenantContext.tenantId)
    .gte("attendance_date", startDate)
    .lte("attendance_date", endDate);
  
  if (!records || records.length === 0) {
    return [];
  }
  
  // í•™ìƒë³„ í†µê³„ ê³„ì‚°
  const studentStats = new Map<string, { total: number; present: number }>();
  
  records.forEach((record) => {
    const stats = studentStats.get(record.student_id) || { total: 0, present: 0 };
    stats.total++;
    if (record.status === "present") {
      stats.present++;
    }
    studentStats.set(record.student_id, stats);
  });
  
  // í•™ìƒ ì •ë³´ ì¡°íšŒ
  const studentIds = Array.from(studentStats.keys());
  const { data: students } = await supabase
    .from("students")
    .select("id, name")
    .in("id", studentIds);
  
  const studentMap = new Map(
    (students || []).map((s) => [s.id, s.name || "ì´ë¦„ ì—†ìŒ"])
  );
  
  // ì¶œì„ë¥  ê³„ì‚° ë° ì •ë ¬
  const ranking = Array.from(studentStats.entries())
    .map(([studentId, stats]) => ({
      student_id: studentId,
      student_name: studentMap.get(studentId) || "ì´ë¦„ ì—†ìŒ",
      attendance_rate: stats.total > 0 ? (stats.present / stats.total) * 100 : 0,
    }))
    .sort((a, b) => b.attendance_rate - a.attendance_rate)
    .slice(0, limit);
  
  return ranking;
}
</file>

<file path="attendance/types.ts">
/**
 * Attendance ë„ë©”ì¸ íƒ€ì… ì •ì˜
 */

// ============================================
// ì¶œì„ ìƒíƒœ
// ============================================

export type AttendanceStatus =
  | "present"
  | "absent"
  | "late"
  | "early_leave"
  | "excused";

export const ATTENDANCE_STATUS_LABELS: Record<AttendanceStatus, string> = {
  present: "ì¶œì„",
  absent: "ê²°ì„",
  late: "ì§€ê°",
  early_leave: "ì¡°í‡´",
  excused: "ê³µê²°",
};

// ============================================
// ì…ì‹¤/í‡´ì‹¤ ë°©ë²•
// ============================================

export type CheckMethod = "manual" | "qr" | "location" | "auto";

export const CHECK_METHOD_LABELS: Record<CheckMethod, string> = {
  manual: "ìˆ˜ë™",
  qr: "QRì½”ë“œ",
  location: "ìœ„ì¹˜ê¸°ë°˜",
  auto: "ìë™",
};

// ============================================
// ì¶œì„ ê¸°ë¡
// ============================================

export type AttendanceRecord = {
  id: string;
  tenant_id: string;
  student_id: string;
  attendance_date: string; // YYYY-MM-DD
  check_in_time: string | null; // ISO 8601
  check_out_time: string | null; // ISO 8601
  check_in_method: CheckMethod | null;
  check_out_method: CheckMethod | null;
  status: AttendanceStatus;
  notes: string | null;
  created_at: string;
  updated_at: string;
};

// ============================================
// ì¶œì„ ê¸°ë¡ ìƒì„±/ìˆ˜ì • ì…ë ¥
// ============================================

export type CreateAttendanceRecordInput = {
  student_id: string;
  attendance_date: string; // YYYY-MM-DD
  check_in_time?: string | null; // ISO 8601
  check_out_time?: string | null; // ISO 8601
  check_in_method?: CheckMethod | null;
  check_out_method?: CheckMethod | null;
  status?: AttendanceStatus;
  notes?: string | null;
};

export type UpdateAttendanceRecordInput = {
  check_in_time?: string | null;
  check_out_time?: string | null;
  check_in_method?: CheckMethod | null;
  check_out_method?: CheckMethod | null;
  status?: AttendanceStatus;
  notes?: string | null;
};

// ============================================
// ì¶œì„ í†µê³„
// ============================================

export type AttendanceStatistics = {
  total_days: number;
  present_count: number;
  absent_count: number;
  late_count: number;
  early_leave_count: number;
  excused_count: number;
  attendance_rate: number; // ì¶œì„ë¥  (%)
  late_rate: number; // ì§€ê°ë¥  (%)
  absent_rate: number; // ê²°ì„ë¥  (%)
};

// ============================================
// ì¶œì„ ì¡°íšŒ í•„í„°
// ============================================

export type AttendanceFilters = {
  student_id?: string;
  start_date?: string; // YYYY-MM-DD
  end_date?: string; // YYYY-MM-DD
  status?: AttendanceStatus;
};

// ============================================
// ê²€ì¦ ê²°ê³¼
// ============================================

export type ValidationError = {
  field: string;
  message: string;
  code: string;
};

export type ValidationResult = {
  valid: boolean;
  errors: ValidationError[];
};
</file>

<file path="auth/index.ts">
/**
 * Auth ë„ë©”ì¸ Public API
 *
 * ì¸ì¦/ì¸ê°€ ê´€ë ¨ ê¸°ëŠ¥ì„ í†µí•©í•©ë‹ˆë‹¤:
 * - ì‚¬ìš©ì ì¸ì¦
 * - ì—­í•  í™•ì¸
 * - ì„¸ì…˜ ê´€ë¦¬
 * - í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸
 */

// í˜„ì¬ ì‚¬ìš©ì ì •ë³´ re-export
export {
  getCurrentUser,
  type CurrentUser,
} from "@/lib/auth/getCurrentUser";

// ì—­í•  í™•ì¸ re-export
export {
  getCurrentUserRole,
  type UserRole,
} from "@/lib/auth/getCurrentUserRole";

// í•™ìƒ ì¸ì¦ ìš”êµ¬ re-export
export {
  requireStudentAuth,
} from "@/lib/auth/requireStudentAuth";

// ì„¸ì…˜ ê´€ë¦¬ re-export
export {
  getUserSessions,
  saveUserSession,
  revokeSession,
  revokeAllOtherSessions,
  updateLastActive,
  type UserSession,
} from "@/lib/auth/sessionManager";

// Rate limit ì²˜ë¦¬ re-export
export {
  isRateLimitError,
  retryWithBackoff,
} from "@/lib/auth/rateLimitHandler";

// í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸ re-export
export {
  getTenantContext,
  type TenantContext,
} from "@/lib/tenant/getTenantContext";

export {
  requireTenantContext,
} from "@/lib/tenant/requireTenantContext";

/**
 * í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš:
 *
 * 1. types.ts ì¶”ê°€
 *    - User, Session, Role íƒ€ì… í†µí•©
 *
 * 2. actions.ts í†µí•©
 *    - app/actions/auth.ts
 *    - ë¡œê·¸ì¸, ë¡œê·¸ì•„ì›ƒ, íšŒì›ê°€ì… ì•¡ì…˜
 *
 * 3. middleware.ts ê³ ë ¤
 *    - ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ ë¡œì§ í†µí•©
 */
</file>

<file path="block/index.ts">
/**
 * Block ë„ë©”ì¸ Public API
 *
 * ì‹œê°„ ë¸”ë¡/ì‹œê°„í‘œ ê´€ë ¨ ê¸°ëŠ¥ì„ í†µí•©í•©ë‹ˆë‹¤:
 * - ë¸”ë¡ ì„¸íŠ¸ ê´€ë¦¬
 * - ì‹œê°„ ë¸”ë¡ CRUD
 * - ë¸”ë¡ í†µê³„
 */

// ë¸”ë¡ ì„¸íŠ¸ re-export
export {
  fetchBlockSetsWithBlocks,
  type BlockSetWithBlocks,
} from "@/lib/data/blockSets";

// ë¸”ë¡ ìœ í‹¸ë¦¬í‹° re-export
export {
  calculateBlockStatistics,
  calculateDayDistribution,
  calculateTimeDistribution,
  calculateHourlyDistribution,
  isValidBlock,
  findInvalidBlocks,
} from "@/lib/blocks/statistics";

export {
  calculateAutoTimeRange,
  createManualTimeRange,
} from "@/lib/blocks/timeRange";

export {
  checkBlockOverlap,
  calculateBlockDuration,
} from "@/lib/blocks/validation";

/**
 * í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš:
 *
 * 1. types.ts ì¶”ê°€
 *    - BlockSet, Block, TimeRange íƒ€ì… í†µí•©
 *
 * 2. validation.ts ì¶”ê°€
 *    - ë¸”ë¡ ì„¸íŠ¸ ìƒì„±/ìˆ˜ì • ìŠ¤í‚¤ë§ˆ
 *
 * 3. actions.ts í†µí•©
 *    - app/actions/blocks.ts
 *    - app/actions/blockSets.ts
 */
</file>

<file path="camp/index.ts">
/**
 * Camp ë„ë©”ì¸ Public API
 */

// Types
export * from "./types";

// í–¥í›„ ì¶”ê°€ ì˜ˆì •:
// export * as service from "./service";
// export * from "./actions";
</file>

<file path="camp/types.ts">
/**
 * Camp ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type {
  Tables,
  TablesInsert,
  TablesUpdate,
  Enums,
} from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * ìº í”„ í…œí”Œë¦¿ íƒ€ì…
 */
export type CampTemplate = Tables<"camp_templates">;

/**
 * ìº í”„ í…œí”Œë¦¿ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type CampTemplateInsert = TablesInsert<"camp_templates">;

/**
 * ìº í”„ í…œí”Œë¦¿ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type CampTemplateUpdate = TablesUpdate<"camp_templates">;

/**
 * ìº í”„ ì´ˆëŒ€ íƒ€ì…
 */
export type CampInvitation = Tables<"camp_invitations">;

/**
 * ìº í”„ ì´ˆëŒ€ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type CampInvitationInsert = TablesInsert<"camp_invitations">;

/**
 * ìº í”„ ì´ˆëŒ€ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type CampInvitationUpdate = TablesUpdate<"camp_invitations">;

// ============================================
// Enum íƒ€ì…
// ============================================

/**
 * ìº í”„ í”„ë¡œê·¸ë¨ ìœ í˜•
 */
export type CampProgramType = Enums<"camp_program_type">;

/**
 * ìº í”„ í…œí”Œë¦¿ ìƒíƒœ
 */
export type CampTemplateStatus = Enums<"camp_template_status">;

/**
 * ìº í”„ ì´ˆëŒ€ ìƒíƒœ
 */
export type CampInvitationStatus = Enums<"camp_invitation_status">;

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ìš© íƒ€ì…
// ============================================

/**
 * ìº í”„ í…œí”Œë¦¿ ì¡°íšŒ í•„í„°
 */
export type GetCampTemplatesFilter = {
  tenantId: string;
  status?: CampTemplateStatus | CampTemplateStatus[];
  programType?: CampProgramType;
};

/**
 * ìº í”„ ì´ˆëŒ€ ì¡°íšŒ í•„í„°
 */
export type GetCampInvitationsFilter = {
  tenantId?: string;
  studentId?: string;
  templateId?: string;
  status?: CampInvitationStatus | CampInvitationStatus[];
};

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * ìº í”„ í…œí”Œë¦¿ ì•¡ì…˜ ê²°ê³¼
 */
export type CampTemplateActionResult = {
  success: boolean;
  error?: string;
  templateId?: string;
  template?: CampTemplate;
};

/**
 * ìº í”„ ì´ˆëŒ€ ì•¡ì…˜ ê²°ê³¼
 */
export type CampInvitationActionResult = {
  success: boolean;
  error?: string;
  invitationId?: string;
  invitation?: CampInvitation;
};
</file>

<file path="content/index.ts">
/**
 * Content ë„ë©”ì¸ Public API
 *
 * ì½˜í…ì¸  ê´€ë ¨ ê¸°ëŠ¥ì„ í†µí•©í•©ë‹ˆë‹¤:
 * - ë§ˆìŠ¤í„° ì½˜í…ì¸  (ê´€ë¦¬ìê°€ ë“±ë¡í•œ ê³µìš© ì½˜í…ì¸ )
 * - í•™ìƒ ì½˜í…ì¸  (í•™ìƒì´ ë“±ë¡í•œ ê°œì¸ ì½˜í…ì¸ )
 * - ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° (ì¶œíŒì‚¬, í”Œë«í¼ ë“±)
 */

// ë§ˆìŠ¤í„° ì½˜í…ì¸  re-export
export {
  searchMasterBooks,  // ë³€ê²½: getMasterBooks â†’ searchMasterBooks
  searchMasterLectures,  // ë³€ê²½: getMasterLectures â†’ searchMasterLectures
  getMasterBookById,
  getMasterLectureById,
  searchContentMasters,  // ë³€ê²½: searchMasterContents â†’ searchContentMasters
} from "@/lib/data/contentMasters";

// í•™ìƒ ì½˜í…ì¸  re-export
export {
  getBooks,
  getLectures,
  getCustomContents,
  createBook,
  createLecture,
  createCustomContent,
  updateBook,
  updateLecture,
  updateCustomContent,
  deleteBook,
  deleteLecture,
  deleteCustomContent,
  type Book,
  type Lecture,
  type CustomContent,
} from "@/lib/data/studentContents";

// ì½˜í…ì¸  ë©”íƒ€ë°ì´í„° re-export
export {
  getPublishers,
  getPlatforms,
  getCurriculumRevisions,
  getSubjectCategories,
} from "@/lib/data/contentMetadata";

/**
 * í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš:
 *
 * 1. types.ts ì¶”ê°€
 *    - Book, Lecture, CustomContent íƒ€ì… í†µí•©
 *    - MasterContent íƒ€ì… í†µí•©
 *
 * 2. validation.ts ì¶”ê°€
 *    - ì½˜í…ì¸  ìƒì„±/ìˆ˜ì • ìŠ¤í‚¤ë§ˆ
 *
 * 3. actions.ts í†µí•©
 *    - app/(student)/actions/contentActions.ts
 *    - app/(student)/actions/contentDetailsActions.ts
 *    - app/(student)/actions/contentMasterActions.ts
 *    - app/(student)/actions/masterContentActions.ts
 *    - app/(admin)/actions/contentMetadataActions.ts
 */
</file>

<file path="goal/index.ts">
/**
 * Goal ë„ë©”ì¸ Public API
 *
 * ëª©í‘œ ê´€ë ¨ ê¸°ëŠ¥ì„ í†µí•©í•©ë‹ˆë‹¤:
 * - í•™ìŠµ ëª©í‘œ CRUD
 * - ëª©í‘œ ì§„í–‰ë¥  ì¶”ì 
 * - ëª©í‘œ ë‹¬ì„± ë¶„ì„
 */

// ë°ì´í„° ì¡°íšŒ í•¨ìˆ˜ re-export
export {
  createGoal,
  updateGoal,
  deleteGoal,
  getGoalById,
  getGoalsForStudent,
  recordGoalProgress,
  getGoalProgressList,
} from "@/lib/data/studentGoals";

// ëª©í‘œ ê´€ë ¨ ì¿¼ë¦¬ re-export
export {
  getAllGoals,
  getActiveGoals,
  getGoalProgress,
} from "@/lib/goals/queries";

// ëª©í‘œ ê³„ì‚° ìœ í‹¸ë¦¬í‹° re-export
export {
  calculateGoalProgress,
  getGoalStatusLabel,
  getGoalTypeLabel,
  getGoalTypeColor,
  type Goal,
  type GoalProgress,
  type GoalProgressResult,
} from "@/lib/goals/calc";

/**
 * í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš:
 *
 * 1. types.ts ì¶”ê°€
 *    - Goal, GoalProgress íƒ€ì… í†µí•©
 *
 * 2. validation.ts ì¶”ê°€
 *    - ëª©í‘œ ìƒì„±/ìˆ˜ì • ìŠ¤í‚¤ë§ˆ
 *
 * 3. actions.ts í†µí•©
 *    - app/(student)/actions/goalActions.ts
 *    - app/actions/goals.ts (re-export ì •ë¦¬)
 */
</file>

<file path="plan/index.ts">
/**
 * Plan ë„ë©”ì¸ Public API
 *
 * ì™¸ë¶€ì—ì„œëŠ” ì´ íŒŒì¼ì„ í†µí•´ì„œë§Œ plan ë„ë©”ì¸ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
 */

// Types
export * from "./types";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export * as service from "./service";

// RepositoryëŠ” ì™¸ë¶€ì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ (serviceë¥¼ í†µí•´ ì ‘ê·¼)

/**
 * ì‚¬ìš© ì˜ˆì‹œ:
 *
 * // í”Œëœ ê·¸ë£¹ ì¡°íšŒ
 * import { plan } from "@/lib/domains";
 * const groups = await plan.service.getPlanGroups({ studentId: "..." });
 *
 * // ì˜¤ëŠ˜ í”Œëœ ì¡°íšŒ
 * const todayPlans = await plan.service.getTodayPlans(studentId);
 *
 * // í”Œëœ ì§„í–‰ë¥  ê³„ì‚°
 * const progress = plan.service.calculatePlanProgress(plans);
 */
</file>

<file path="plan/repository.ts">
/**
 * Plan ë„ë©”ì¸ Repository
 *
 * ì´ íŒŒì¼ì€ ìˆœìˆ˜í•œ ë°ì´í„° ì ‘ê·¼ë§Œì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * ê¸°ì¡´ lib/data/planGroups.ts, lib/data/studentPlans.tsì˜
 * ë°ì´í„° ì ‘ê·¼ ë¡œì§ì„ ì¶”ì¶œí–ˆìŠµë‹ˆë‹¤.
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type {
  PlanGroup,
  Plan,
  PlanContent,
  PlanExclusion,
  AcademySchedule,
} from "@/lib/types/plan";
import type { PlanGroupFilters, StudentPlanFilters } from "./types";

// ============================================
// Plan Group Repository
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ
 */
export async function findPlanGroups(
  filters: PlanGroupFilters
): Promise<PlanGroup[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("plan_groups")
    .select(
      "id,tenant_id,student_id,name,plan_purpose,scheduler_type,scheduler_options,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
    )
    .eq("student_id", filters.studentId);

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.status) {
    if (Array.isArray(filters.status)) {
      query = query.in("status", filters.status);
    } else {
      query = query.eq("status", filters.status);
    }
  }

  if (filters.planPurpose) {
    query = query.eq("plan_purpose", filters.planPurpose);
  }

  if (filters.dateRange) {
    query = query
      .gte("period_start", filters.dateRange.start)
      .lte("period_end", filters.dateRange.end);
  }

  if (!filters.includeDeleted) {
    query = query.is("deleted_at", null);
  }

  const { data, error } = await query.order("created_at", { ascending: false });

  if (error) throw error;
  return (data as PlanGroup[]) ?? [];
}

/**
 * í”Œëœ ê·¸ë£¹ IDë¡œ ì¡°íšŒ
 */
export async function findPlanGroupById(
  groupId: string,
  studentId: string,
  tenantId?: string | null
): Promise<PlanGroup | null> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("plan_groups")
    .select(
      "id,tenant_id,student_id,name,plan_purpose,scheduler_type,scheduler_options,period_start,period_end,target_date,block_set_id,status,deleted_at,daily_schedule,subject_constraints,additional_period_reallocation,non_study_time_blocks,plan_type,camp_template_id,camp_invitation_id,created_at,updated_at"
    )
    .eq("id", groupId)
    .eq("student_id", studentId)
    .is("deleted_at", null);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  const { data, error } = await query.maybeSingle();

  if (error) throw error;
  return data as PlanGroup | null;
}

/**
 * í”Œëœ ê·¸ë£¹ ìƒì„±
 */
export async function insertPlanGroup(
  data: Partial<PlanGroup>
): Promise<PlanGroup> {
  const supabase = await createSupabaseServerClient();

  const { data: created, error } = await supabase
    .from("plan_groups")
    .insert(data)
    .select()
    .single();

  if (error) throw error;
  return created as PlanGroup;
}

/**
 * í”Œëœ ê·¸ë£¹ ìˆ˜ì •
 */
export async function updatePlanGroupById(
  groupId: string,
  studentId: string,
  updates: Partial<PlanGroup>
): Promise<PlanGroup> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("plan_groups")
    .update(updates)
    .eq("id", groupId)
    .eq("student_id", studentId)
    .select()
    .single();

  if (error) throw error;
  return data as PlanGroup;
}

/**
 * í”Œëœ ê·¸ë£¹ ì‚­ì œ (soft delete)
 */
export async function softDeletePlanGroup(
  groupId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("plan_groups")
    .update({ deleted_at: new Date().toISOString() })
    .eq("id", groupId)
    .eq("student_id", studentId);

  if (error) throw error;
}

// ============================================
// Plan Content Repository
// ============================================

/**
 * í”Œëœ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ
 */
export async function findPlanContents(
  planGroupId: string
): Promise<PlanContent[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("plan_contents")
    .select("*")
    .eq("plan_group_id", planGroupId)
    .order("display_order", { ascending: true });

  if (error) throw error;
  return (data as PlanContent[]) ?? [];
}

/**
 * í”Œëœ ì½˜í…ì¸  ì¼ê´„ ìƒì„±
 */
export async function insertPlanContents(
  contents: Array<Partial<PlanContent>>
): Promise<PlanContent[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("plan_contents")
    .insert(contents)
    .select();

  if (error) throw error;
  return (data as PlanContent[]) ?? [];
}

/**
 * í”Œëœ ì½˜í…ì¸  ì‚­ì œ (plan_group_id ê¸°ì¤€)
 */
export async function deletePlanContentsByGroupId(
  planGroupId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("plan_contents")
    .delete()
    .eq("plan_group_id", planGroupId);

  if (error) throw error;
}

// ============================================
// Student Plan Repository
// ============================================

/**
 * í•™ìƒ í”Œëœ ëª©ë¡ ì¡°íšŒ
 */
export async function findStudentPlans(
  filters: StudentPlanFilters
): Promise<Plan[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_plan")
    .select(
      "id,tenant_id,student_id,plan_date,block_index,content_type,content_id,chapter,planned_start_page_or_time,planned_end_page_or_time,completed_amount,progress,is_reschedulable,plan_group_id,start_time,end_time,actual_start_time,actual_end_time,total_duration_seconds,paused_duration_seconds,pause_count,plan_number,sequence,day_type,week,day,is_partial,is_continued,content_title,content_subject,content_subject_category,content_category,memo,created_at,updated_at"
    )
    .eq("student_id", filters.studentId);

  if (filters.tenantId) {
    query = query.eq("tenant_id", filters.tenantId);
  }

  if (filters.planDate) {
    const planDateStr = filters.planDate.slice(0, 10);
    query = query.eq("plan_date", planDateStr);
  } else if (filters.dateRange) {
    const startStr = filters.dateRange.start.slice(0, 10);
    const endStr = filters.dateRange.end.slice(0, 10);
    query = query.gte("plan_date", startStr).lte("plan_date", endStr);
  }

  if (filters.contentType) {
    query = query.eq("content_type", filters.contentType);
  }

  if (filters.planGroupIds && filters.planGroupIds.length > 0) {
    query = query.in("plan_group_id", filters.planGroupIds);
  }

  const { data, error } = await query
    .order("plan_date", { ascending: true })
    .order("block_index", { ascending: true });

  if (error) throw error;
  return (data as Plan[]) ?? [];
}

/**
 * í•™ìƒ í”Œëœ ë‹¨ê±´ ì¡°íšŒ
 */
export async function findStudentPlanById(
  planId: string,
  studentId: string
): Promise<Plan | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_plan")
    .select("*")
    .eq("id", planId)
    .eq("student_id", studentId)
    .maybeSingle();

  if (error) throw error;
  return data as Plan | null;
}

/**
 * í•™ìƒ í”Œëœ ìƒì„±
 */
export async function insertStudentPlan(
  plan: Partial<Plan>
): Promise<string> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_plan")
    .insert(plan)
    .select("id")
    .single();

  if (error) throw error;
  return data.id;
}

/**
 * í•™ìƒ í”Œëœ ì¼ê´„ ìƒì„±
 */
export async function insertStudentPlans(
  plans: Array<Partial<Plan>>
): Promise<string[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_plan")
    .insert(plans)
    .select("id");

  if (error) throw error;
  return (data ?? []).map((p) => p.id);
}

/**
 * í•™ìƒ í”Œëœ ìˆ˜ì •
 */
export async function updateStudentPlanById(
  planId: string,
  studentId: string,
  updates: Partial<Plan>
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_plan")
    .update(updates)
    .eq("id", planId)
    .eq("student_id", studentId);

  if (error) throw error;
}

/**
 * í•™ìƒ í”Œëœ ì‚­ì œ
 */
export async function deleteStudentPlanById(
  planId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_plan")
    .delete()
    .eq("id", planId)
    .eq("student_id", studentId);

  if (error) throw error;
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ëª¨ë“  í”Œëœ ì‚­ì œ
 */
export async function deleteStudentPlansByGroupId(
  planGroupId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_plan")
    .delete()
    .eq("plan_group_id", planGroupId)
    .eq("student_id", studentId);

  if (error) throw error;
}

// ============================================
// Plan Exclusion Repository
// ============================================

/**
 * ì œì™¸ì¼ ëª©ë¡ ì¡°íšŒ
 */
export async function findPlanExclusions(
  studentId: string,
  tenantId?: string | null
): Promise<PlanExclusion[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("plan_exclusions")
    .select("*")
    .eq("student_id", studentId);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  const { data, error } = await query.order("exclusion_date", {
    ascending: true,
  });

  if (error) throw error;
  return (data as PlanExclusion[]) ?? [];
}

/**
 * ì œì™¸ì¼ ìƒì„±
 */
export async function insertPlanExclusion(
  exclusion: Partial<PlanExclusion>
): Promise<PlanExclusion> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("plan_exclusions")
    .insert(exclusion)
    .select()
    .single();

  if (error) throw error;
  return data as PlanExclusion;
}

/**
 * ì œì™¸ì¼ ì‚­ì œ
 */
export async function deletePlanExclusionById(
  exclusionId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("plan_exclusions")
    .delete()
    .eq("id", exclusionId)
    .eq("student_id", studentId);

  if (error) throw error;
}

// ============================================
// Academy Schedule Repository
// ============================================

/**
 * í•™ì› ì¼ì • ëª©ë¡ ì¡°íšŒ
 */
export async function findAcademySchedules(
  studentId: string,
  tenantId?: string | null
): Promise<AcademySchedule[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("academy_schedules")
    .select("*")
    .eq("student_id", studentId);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  const { data, error } = await query
    .order("day_of_week", { ascending: true })
    .order("start_time", { ascending: true });

  if (error) throw error;
  return (data as AcademySchedule[]) ?? [];
}
</file>

<file path="plan/service.ts">
/**
 * Plan ë„ë©”ì¸ Service
 *
 * ì´ íŒŒì¼ì€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - ë°ì´í„° ë³€í™˜ ë° ê°€ê³µ
 * - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ì ìš©
 * - Repository í˜¸ì¶œ ë° ì—ëŸ¬ ì²˜ë¦¬
 */

import * as repository from "./repository";
import type {
  PlanGroup,
  Plan,
  PlanContent,
  PlanExclusion,
  AcademySchedule,
} from "@/lib/types/plan";
import type {
  PlanGroupFilters,
  StudentPlanFilters,
  PlanGroupCreateResult,
  PlanGroupUpdateResult,
  PlanActionResult,
} from "./types";

// ============================================
// Plan Group Service
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ
 */
export async function getPlanGroups(
  filters: PlanGroupFilters
): Promise<PlanGroup[]> {
  try {
    return await repository.findPlanGroups(filters);
  } catch (error) {
    console.error("[plan/service] í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * í”Œëœ ê·¸ë£¹ ë‹¨ê±´ ì¡°íšŒ
 */
export async function getPlanGroupById(
  groupId: string,
  studentId: string,
  tenantId?: string | null
): Promise<PlanGroup | null> {
  try {
    return await repository.findPlanGroupById(groupId, studentId, tenantId);
  } catch (error) {
    console.error("[plan/service] í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * í”Œëœ ê·¸ë£¹ ìƒì„±
 */
export async function createPlanGroup(
  data: Partial<PlanGroup>
): Promise<PlanGroupCreateResult> {
  try {
    // í•„ìˆ˜ í•„ë“œ ê²€ì¦
    if (!data.student_id) {
      return { success: false, error: "í•™ìƒ IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    if (!data.period_start || !data.period_end) {
      return { success: false, error: "í•™ìŠµ ê¸°ê°„ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ê¸°ê°„ ìœ íš¨ì„± ê²€ì¦
    if (new Date(data.period_start) > new Date(data.period_end)) {
      return { success: false, error: "ì‹œì‘ì¼ì´ ì¢…ë£Œì¼ë³´ë‹¤ ëŠ¦ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    const planGroup = await repository.insertPlanGroup(data);
    return { success: true, planGroupId: planGroup.id, planGroup: planGroup as any };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ê·¸ë£¹ ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "í”Œëœ ê·¸ë£¹ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ê·¸ë£¹ ìˆ˜ì •
 */
export async function updatePlanGroup(
  groupId: string,
  studentId: string,
  updates: Partial<PlanGroup>
): Promise<PlanGroupUpdateResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findPlanGroupById(groupId, studentId);
    if (!existing) {
      return { success: false, error: "í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    // ê¸°ê°„ ìœ íš¨ì„± ê²€ì¦
    const periodStart = updates.period_start || existing.period_start;
    const periodEnd = updates.period_end || existing.period_end;
    if (new Date(periodStart) > new Date(periodEnd)) {
      return { success: false, error: "ì‹œì‘ì¼ì´ ì¢…ë£Œì¼ë³´ë‹¤ ëŠ¦ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    const planGroup = await repository.updatePlanGroupById(
      groupId,
      studentId,
      updates
    );
    return { success: true, planGroup: planGroup as any };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ê·¸ë£¹ ìˆ˜ì • ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "í”Œëœ ê·¸ë£¹ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ê·¸ë£¹ ì‚­ì œ (soft delete)
 */
export async function deletePlanGroup(
  groupId: string,
  studentId: string
): Promise<PlanGroupUpdateResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findPlanGroupById(groupId, studentId);
    if (!existing) {
      return { success: false, error: "í”Œëœ ê·¸ë£¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.softDeletePlanGroup(groupId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ê·¸ë£¹ ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "í”Œëœ ê·¸ë£¹ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ê·¸ë£¹ ìƒíƒœ ë³€ê²½
 */
export async function updatePlanGroupStatus(
  groupId: string,
  studentId: string,
  status: string
): Promise<PlanGroupUpdateResult> {
  // ìƒíƒœ ì „ì´ ê·œì¹™ ê²€ì¦
  const validStatuses = [
    "draft",
    "saved",
    "active",
    "paused",
    "completed",
    "cancelled",
  ];
  if (!validStatuses.includes(status)) {
    return { success: false, error: "ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœì…ë‹ˆë‹¤." };
  }

  return updatePlanGroup(groupId, studentId, { status: status as any });
}

// ============================================
// Plan Content Service
// ============================================

/**
 * í”Œëœ ì½˜í…ì¸  ëª©ë¡ ì¡°íšŒ
 */
export async function getPlanContents(
  planGroupId: string
): Promise<PlanContent[]> {
  try {
    return await repository.findPlanContents(planGroupId);
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì½˜í…ì¸  ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * í”Œëœ ì½˜í…ì¸  ì¼ê´„ ì €ì¥ (ê¸°ì¡´ ì‚­ì œ í›„ ìƒˆë¡œ ìƒì„±)
 */
export async function savePlanContents(
  planGroupId: string,
  contents: Array<Partial<PlanContent>>
): Promise<{ success: boolean; error?: string }> {
  try {
    // ê¸°ì¡´ ì½˜í…ì¸  ì‚­ì œ
    await repository.deletePlanContentsByGroupId(planGroupId);

    // ìƒˆ ì½˜í…ì¸  ìƒì„±
    if (contents.length > 0) {
      const contentsWithGroupId = contents.map((c, index) => ({
        ...c,
        plan_group_id: planGroupId,
        display_order: c.display_order ?? index,
      }));
      await repository.insertPlanContents(contentsWithGroupId);
    }

    return { success: true };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì½˜í…ì¸  ì €ì¥ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "í”Œëœ ì½˜í…ì¸  ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

// ============================================
// Student Plan Service
// ============================================

/**
 * í•™ìƒ í”Œëœ ëª©ë¡ ì¡°íšŒ
 */
export async function getStudentPlans(
  filters: StudentPlanFilters
): Promise<Plan[]> {
  try {
    return await repository.findStudentPlans(filters);
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * í•™ìƒ í”Œëœ ë‹¨ê±´ ì¡°íšŒ
 */
export async function getStudentPlanById(
  planId: string,
  studentId: string
): Promise<Plan | null> {
  try {
    return await repository.findStudentPlanById(planId, studentId);
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * í•™ìƒ í”Œëœ ìƒì„±
 */
export async function createStudentPlan(
  plan: Partial<Plan>
): Promise<PlanActionResult> {
  try {
    if (!plan.student_id) {
      return { success: false, error: "í•™ìƒ IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    if (!plan.plan_date) {
      return { success: false, error: "í”Œëœ ë‚ ì§œê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const planId = await repository.insertStudentPlan(plan);
    return { success: true, planId };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í•™ìƒ í”Œëœ ì¼ê´„ ìƒì„±
 */
export async function createStudentPlans(
  plans: Array<Partial<Plan>>
): Promise<{ success: boolean; error?: string; planIds?: string[] }> {
  try {
    if (plans.length === 0) {
      return { success: true, planIds: [] };
    }

    const planIds = await repository.insertStudentPlans(plans);
    return { success: true, planIds };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì¼ê´„ ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "í”Œëœ ì¼ê´„ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í•™ìƒ í”Œëœ ìˆ˜ì •
 */
export async function updateStudentPlan(
  planId: string,
  studentId: string,
  updates: Partial<Plan>
): Promise<PlanActionResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findStudentPlanById(planId, studentId);
    if (!existing) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.updateStudentPlanById(planId, studentId, updates);
    return { success: true, planId };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ìˆ˜ì • ì‹¤íŒ¨:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í•™ìƒ í”Œëœ ì‚­ì œ
 */
export async function deleteStudentPlan(
  planId: string,
  studentId: string
): Promise<PlanActionResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findStudentPlanById(planId, studentId);
    if (!existing) {
      return { success: false, error: "í”Œëœì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.deleteStudentPlanById(planId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "í”Œëœ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * í”Œëœ ê·¸ë£¹ì˜ ëª¨ë“  í”Œëœ ì‚­ì œ
 */
export async function deleteStudentPlansByGroupId(
  planGroupId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await repository.deleteStudentPlansByGroupId(planGroupId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[plan/service] í”Œëœ ì¼ê´„ ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "í”Œëœ ì¼ê´„ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

// ============================================
// Plan Exclusion Service
// ============================================

/**
 * ì œì™¸ì¼ ëª©ë¡ ì¡°íšŒ
 */
export async function getPlanExclusions(
  studentId: string,
  tenantId?: string | null
): Promise<PlanExclusion[]> {
  try {
    return await repository.findPlanExclusions(studentId, tenantId);
  } catch (error) {
    console.error("[plan/service] ì œì™¸ì¼ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ì œì™¸ì¼ ìƒì„±
 */
export async function createPlanExclusion(
  exclusion: Partial<PlanExclusion>
): Promise<{ success: boolean; error?: string; exclusion?: PlanExclusion }> {
  try {
    if (!exclusion.student_id) {
      return { success: false, error: "í•™ìƒ IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    if (!exclusion.exclusion_date) {
      return { success: false, error: "ì œì™¸ì¼ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    const created = await repository.insertPlanExclusion(exclusion);
    return { success: true, exclusion: created };
  } catch (error) {
    console.error("[plan/service] ì œì™¸ì¼ ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì œì™¸ì¼ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ì œì™¸ì¼ ì‚­ì œ
 */
export async function deletePlanExclusion(
  exclusionId: string,
  studentId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await repository.deletePlanExclusionById(exclusionId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[plan/service] ì œì™¸ì¼ ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì œì™¸ì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

// ============================================
// Academy Schedule Service
// ============================================

/**
 * í•™ì› ì¼ì • ëª©ë¡ ì¡°íšŒ
 */
export async function getAcademySchedules(
  studentId: string,
  tenantId?: string | null
): Promise<AcademySchedule[]> {
  try {
    return await repository.findAcademySchedules(studentId, tenantId);
  } catch (error) {
    console.error("[plan/service] í•™ì› ì¼ì • ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
// ============================================

/**
 * íŠ¹ì • ë‚ ì§œì— í™œì„±í™”ëœ í”Œëœ ê·¸ë£¹ ì¡°íšŒ
 */
export async function getActivePlanGroupsForDate(
  studentId: string,
  date: string,
  tenantId?: string | null
): Promise<PlanGroup[]> {
  try {
    const planGroups = await repository.findPlanGroups({
      studentId,
      tenantId,
      status: ["active", "saved"],
    });

    return planGroups.filter((group) => {
      const start = new Date(group.period_start);
      const end = new Date(group.period_end);
      const targetDate = new Date(date);
      return targetDate >= start && targetDate <= end;
    });
  } catch (error) {
    console.error("[plan/service] í™œì„± í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ì˜¤ëŠ˜ ë‚ ì§œì˜ í”Œëœ ì¡°íšŒ
 */
export async function getTodayPlans(
  studentId: string,
  tenantId?: string | null
): Promise<Plan[]> {
  const today = new Date().toISOString().slice(0, 10);
  return getStudentPlans({
    studentId,
    tenantId,
    planDate: today,
  });
}

/**
 * í”Œëœ ì§„í–‰ë¥  ê³„ì‚°
 */
export function calculatePlanProgress(plans: Plan[]): number {
  if (plans.length === 0) return 0;

  const completedCount = plans.filter(
    (plan) => plan.progress != null && plan.progress >= 100
  ).length;

  return Math.round((completedCount / plans.length) * 100);
}
</file>

<file path="plan/types.ts">
/**
 * Plan ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type {
  Tables,
  TablesInsert,
  TablesUpdate,
  Enums,
  Json,
} from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ íƒ€ì…
 */
export type PlanGroup = Tables<"plan_groups">;

/**
 * í”Œëœ ê·¸ë£¹ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type PlanGroupInsert = TablesInsert<"plan_groups">;

/**
 * í”Œëœ ê·¸ë£¹ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type PlanGroupUpdate = TablesUpdate<"plan_groups">;

/**
 * í•™ìƒ í”Œëœ íƒ€ì…
 */
export type StudentPlan = Tables<"student_plan">;

/**
 * í•™ìƒ í”Œëœ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type StudentPlanInsert = TablesInsert<"student_plan">;

/**
 * í•™ìƒ í”Œëœ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type StudentPlanUpdate = TablesUpdate<"student_plan">;

/**
 * í”Œëœ ì½˜í…ì¸  íƒ€ì…
 */
export type PlanContent = Tables<"plan_contents">;

/**
 * í”Œëœ ì½˜í…ì¸  ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type PlanContentInsert = TablesInsert<"plan_contents">;

/**
 * í”Œëœ ì½˜í…ì¸  ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type PlanContentUpdate = TablesUpdate<"plan_contents">;

/**
 * í”Œëœ ì œì™¸ì¼ íƒ€ì…
 */
export type PlanExclusion = Tables<"plan_exclusions">;

/**
 * í”Œëœ ì œì™¸ì¼ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type PlanExclusionInsert = TablesInsert<"plan_exclusions">;

/**
 * í”Œëœ ì œì™¸ì¼ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type PlanExclusionUpdate = TablesUpdate<"plan_exclusions">;

/**
 * ë¸”ë¡ ì„¸íŠ¸ íƒ€ì…
 */
export type BlockSet = Tables<"block_sets">;

/**
 * ë¸”ë¡ ì„¸íŠ¸ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type BlockSetInsert = TablesInsert<"block_sets">;

/**
 * ë¸”ë¡ ì„¸íŠ¸ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type BlockSetUpdate = TablesUpdate<"block_sets">;

/**
 * ë¸”ë¡ íƒ€ì…
 */
export type Block = Tables<"blocks">;

/**
 * ë¸”ë¡ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type BlockInsert = TablesInsert<"blocks">;

/**
 * ë¸”ë¡ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type BlockUpdate = TablesUpdate<"blocks">;

/**
 * í•™ì› íƒ€ì…
 */
export type Academy = Tables<"academies">;

/**
 * í•™ì› ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type AcademyInsert = TablesInsert<"academies">;

/**
 * í•™ì› ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type AcademyUpdate = TablesUpdate<"academies">;

/**
 * í•™ì› ì¼ì • íƒ€ì…
 */
export type AcademySchedule = Tables<"academy_schedules">;

/**
 * í•™ì› ì¼ì • ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type AcademyScheduleInsert = TablesInsert<"academy_schedules">;

/**
 * í•™ì› ì¼ì • ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type AcademyScheduleUpdate = TablesUpdate<"academy_schedules">;

// ============================================
// Enum íƒ€ì…
// ============================================

/**
 * ì½˜í…ì¸  íƒ€ì…
 */
export type ContentType = Enums<"content_type">;

/**
 * í”Œëœ íƒ€ì…
 */
export type PlanType = Enums<"plan_type">;

// ============================================
// JSONB í•„ë“œ íƒ€ì… (ìŠ¤í‚¤ë§ˆì—ì„œ íŒŒìƒ)
// ============================================

/**
 * ì¼ë³„ ìŠ¤ì¼€ì¤„ ì •ë³´
 */
export type DailyScheduleInfo = {
  date: string;
  day_type: "í•™ìŠµì¼" | "ë³µìŠµì¼" | "ì§€ì •íœ´ì¼" | "íœ´ê°€" | "ê°œì¸ì¼ì •";
  study_hours: number;
  time_slots?: Array<{
    type: "í•™ìŠµì‹œê°„" | "ì ì‹¬ì‹œê°„" | "í•™ì›ì¼ì •" | "ì´ë™ì‹œê°„" | "ììœ¨í•™ìŠµ";
    start: string;
    end: string;
    label?: string;
  }>;
  exclusion?: {
    exclusion_date: string;
    exclusion_type: string;
    reason?: string | null;
  } | null;
  academy_schedules?: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    academy_name?: string;
    subject?: string;
    travel_time?: number;
  }>;
};

/**
 * ìŠ¤ì¼€ì¤„ëŸ¬ ì˜µì…˜
 */
export type SchedulerOptions = {
  weak_subject_focus?: "low" | "medium" | "high" | boolean;
  study_days?: number;
  review_days?: number;
};

/**
 * êµê³¼ ì œì•½ ì¡°ê±´
 */
export type SubjectConstraints = {
  required_subjects?: Array<{
    subject_group_id: string;
    subject_category: string;
    min_count: number;
    subjects_by_curriculum?: Array<{
      curriculum_revision_id: string;
      subject_id?: string;
      subject_name?: string;
    }>;
  }>;
  excluded_subjects?: string[];
  constraint_handling: "strict" | "warning" | "auto_fix";
};

/**
 * ì¶”ê°€ ê¸°ê°„ ì¬ë°°ì¹˜ ì„¤ì •
 */
export type AdditionalPeriodReallocation = {
  period_start: string;
  period_end: string;
  type: "additional_review";
  original_period_start: string;
  original_period_end: string;
  subjects?: string[];
  review_of_review_factor?: number;
};

/**
 * í•™ìŠµ ì‹œê°„ ì œì™¸ í•­ëª©
 */
export type NonStudyTimeBlock = {
  type: "ì•„ì¹¨ì‹ì‚¬" | "ì ì‹¬ì‹ì‚¬" | "ì €ë…ì‹ì‚¬" | "ìˆ˜ë©´" | "ê¸°íƒ€";
  start_time: string;
  end_time: string;
  day_of_week?: number[];
  description?: string;
};

/**
 * í•™ìŠµ ì‹œê°„ ì„¤ì •
 */
export type StudyHours = {
  start_time: string;
  end_time: string;
};

/**
 * ììœ¨í•™ìŠµ ì‹œê°„ ì„¤ì •
 */
export type SelfStudyHours = {
  enabled: boolean;
  start_time: string;
  end_time: string;
  allow_on_holiday?: boolean;
};

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ìš© íƒ€ì…
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ ì¡°íšŒ í•„í„°
 */
export type PlanGroupFilters = {
  studentId: string;
  tenantId?: string | null;
  status?: string | string[];
  planPurpose?: string;
  dateRange?: {
    start: string;
    end: string;
  };
  includeDeleted?: boolean;
};

/**
 * í•™ìƒ í”Œëœ ì¡°íšŒ í•„í„°
 */
export type StudentPlanFilters = {
  studentId: string;
  tenantId?: string | null;
  dateRange?: {
    start: string;
    end: string;
  };
  planDate?: string;
  contentType?: ContentType;
  planGroupIds?: string[];
};

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * í”Œëœ ê·¸ë£¹ ìƒì„± ê²°ê³¼
 */
export type PlanGroupCreateResult = {
  success: boolean;
  error?: string;
  planGroupId?: string;
  planGroup?: PlanGroup;
};

/**
 * í”Œëœ ê·¸ë£¹ ìˆ˜ì • ê²°ê³¼
 */
export type PlanGroupUpdateResult = {
  success: boolean;
  error?: string;
  planGroup?: PlanGroup;
};

/**
 * í”Œëœ ì•¡ì…˜ ê²°ê³¼
 */
export type PlanActionResult = {
  success: boolean;
  error?: string;
  planId?: string;
};

// ============================================
// ë ˆê±°ì‹œ íƒ€ì… ë³„ì¹­ (í•˜ìœ„ í˜¸í™˜ì„±)
// ============================================

/**
 * Plan íƒ€ì… ë³„ì¹­ (StudentPlanê³¼ ë™ì¼)
 * @deprecated StudentPlan ì‚¬ìš© ê¶Œì¥
 */
export type Plan = StudentPlan;

// ============================================
// lib/types/plan.ts íƒ€ì… re-export (í•˜ìœ„ í˜¸í™˜ì„±)
// ============================================

export type {
  PlanPurpose,
  PlanStatus,
  SchedulerType,
  ExclusionType,
  StudentLevel,
  StudyReviewCycle,
  TimeSettings,
  DurationInfo,
  ReviewInfo,
  AllocationType,
  SplitInfo,
  ReallocationInfo,
  SubjectAllocation,
  PlanGroupCreationData,
  PlanContentInput,
  PlanExclusionInput,
  AcademyInput,
  AcademyScheduleInput,
  PlanFilters,
  PlanStatusTransition,
  // ìº í”„ ê´€ë ¨
  CampTemplate,
  CampInvitation,
  CampProgramType,
  CampInvitationStatus,
  // ì½˜í…ì¸  ê´€ë ¨
  ContentMaster,
  MasterBook,
  MasterLecture,
  BookDetail,
  LectureEpisode,
} from "@/lib/types/plan";
</file>

<file path="qrCode/index.ts">
/**
 * QR Code ë„ë©”ì¸ Public API
 *
 * ì™¸ë¶€ì—ì„œëŠ” ì´ íŒŒì¼ì„ í†µí•´ì„œë§Œ qrCode ë„ë©”ì¸ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
 */

// Types
export type { QRCodeRecord } from "@/lib/services/qrCodeService";

// Repository (ë°ì´í„° ì ‘ê·¼)
export * as repository from "./repository";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export * as service from "./service";
</file>

<file path="qrCode/repository.ts">
/**
 * QR Code ë„ë©”ì¸ Repository
 *
 * ì´ íŒŒì¼ì€ ìˆœìˆ˜í•œ ë°ì´í„° ì ‘ê·¼ë§Œì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - Supabase ì¿¼ë¦¬ë§Œ ìˆ˜í–‰
 * - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—†ìŒ
 * - ì—ëŸ¬ëŠ” ìƒìœ„ ë ˆì´ì–´ì—ì„œ ì²˜ë¦¬
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { QRCodeRecord } from "@/lib/services/qrCodeService";

/**
 * QR ì½”ë“œ ìƒì„±
 */
export async function createQRCode(
  tenantId: string,
  qrData: string,
  qrCodeUrl: string | null,
  expiresAt: Date,
  createdBy: string
): Promise<QRCodeRecord> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("attendance_qr_codes")
    .insert({
      tenant_id: tenantId,
      qr_data: qrData,
      qr_code_url: qrCodeUrl,
      is_active: true,
      expires_at: expiresAt.toISOString(),
      created_by: createdBy,
      usage_count: 0,
    })
    .select()
    .single();

  if (error) throw error;
  return data as QRCodeRecord;
}

/**
 * í™œì„± QR ì½”ë“œ ì¡°íšŒ
 */
export async function getActiveQRCode(
  tenantId: string
): Promise<QRCodeRecord | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("attendance_qr_codes")
    .select("*")
    .eq("tenant_id", tenantId)
    .eq("is_active", true)
    .gt("expires_at", new Date().toISOString())
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (error) throw error;
  return data as QRCodeRecord | null;
}

/**
 * QR ì½”ë“œ IDë¡œ ì¡°íšŒ
 */
export async function getQRCodeById(
  qrCodeId: string,
  tenantId: string
): Promise<QRCodeRecord | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("attendance_qr_codes")
    .select("*")
    .eq("id", qrCodeId)
    .eq("tenant_id", tenantId)
    .maybeSingle();

  if (error) throw error;
  return data as QRCodeRecord | null;
}

/**
 * í…Œë„ŒíŠ¸ì˜ ëª¨ë“  í™œì„± QR ì½”ë“œ ë¹„í™œì„±í™”
 */
export async function deactivateAllActiveQRCodes(
  tenantId: string,
  deactivatedBy: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("attendance_qr_codes")
    .update({
      is_active: false,
      deactivated_at: new Date().toISOString(),
      deactivated_by: deactivatedBy,
    })
    .eq("tenant_id", tenantId)
    .eq("is_active", true);

  if (error) throw error;
}

/**
 * íŠ¹ì • QR ì½”ë“œ ë¹„í™œì„±í™”
 */
export async function deactivateQRCode(
  qrCodeId: string,
  tenantId: string,
  deactivatedBy: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("attendance_qr_codes")
    .update({
      is_active: false,
      deactivated_at: new Date().toISOString(),
      deactivated_by: deactivatedBy,
    })
    .eq("id", qrCodeId)
    .eq("tenant_id", tenantId);

  if (error) throw error;
}

/**
 * QR ì½”ë“œ ì‚¬ìš© í†µê³„ ì—…ë°ì´íŠ¸
 */
export async function incrementQRCodeUsage(
  qrCodeId: string,
  tenantId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  // ë¨¼ì € í˜„ì¬ ê°’ì„ ì¡°íšŒ
  const { data: current, error: fetchError } = await supabase
    .from("attendance_qr_codes")
    .select("usage_count")
    .eq("id", qrCodeId)
    .eq("tenant_id", tenantId)
    .single();

  if (fetchError) throw fetchError;
  if (!current) throw new Error("QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");

  // ì‚¬ìš© íšŸìˆ˜ ì¦ê°€ ë° ë§ˆì§€ë§‰ ì‚¬ìš© ì‹œê°„ ì—…ë°ì´íŠ¸
  const { error: updateError } = await supabase
    .from("attendance_qr_codes")
    .update({
      usage_count: (current.usage_count || 0) + 1,
      last_used_at: new Date().toISOString(),
    })
    .eq("id", qrCodeId)
    .eq("tenant_id", tenantId);

  if (updateError) throw updateError;
}

/**
 * QR ì½”ë“œ ì´ë ¥ ì¡°íšŒ
 */
export async function getQRCodeHistory(
  tenantId: string,
  limit: number = 50
): Promise<QRCodeRecord[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("attendance_qr_codes")
    .select("*")
    .eq("tenant_id", tenantId)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) throw error;
  return (data as QRCodeRecord[]) ?? [];
}
</file>

<file path="qrCode/service.ts">
/**
 * QR Code ë„ë©”ì¸ Service
 * QR ì½”ë“œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
 */

import * as repository from "./repository";
import { getTenantContext } from "@/lib/tenant/getTenantContext";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { AppError, ErrorCode } from "@/lib/errors";
import type { QRCodeRecord } from "@/lib/services/qrCodeService";

/**
 * QR ì½”ë“œ ìƒì„± (ê¸°ì¡´ í™œì„± QR ì½”ë“œ ìë™ ë¹„í™œì„±í™”)
 */
export async function createQRCode(
  qrData: string,
  qrCodeUrl: string | null,
  expiresAt: Date
): Promise<QRCodeRecord> {
  const tenantContext = await getTenantContext();
  const user = await getCurrentUser();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  if (!user) {
    throw new AppError(
      "ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.UNAUTHORIZED,
      401,
      true
    );
  }

  // ê¸°ì¡´ í™œì„± QR ì½”ë“œ ë¹„í™œì„±í™”
  await repository.deactivateAllActiveQRCodes(
    tenantContext.tenantId,
    user.userId
  );

  // ìƒˆ QR ì½”ë“œ ìƒì„±
  return repository.createQRCode(
    tenantContext.tenantId,
    qrData,
    qrCodeUrl,
    expiresAt,
    user.userId
  );
}

/**
 * í™œì„± QR ì½”ë“œ ì¡°íšŒ
 */
export async function getActiveQRCode(): Promise<QRCodeRecord | null> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  return repository.getActiveQRCode(tenantContext.tenantId);
}

/**
 * QR ì½”ë“œ IDë¡œ ì¡°íšŒ ë° ê²€ì¦
 */
export async function getQRCodeById(qrCodeId: string): Promise<QRCodeRecord> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  const qrCode = await repository.getQRCodeById(
    qrCodeId,
    tenantContext.tenantId
  );

  if (!qrCode) {
    throw new AppError(
      "QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  return qrCode;
}

/**
 * QR ì½”ë“œ ê²€ì¦ ë° ì‚¬ìš© í†µê³„ ì—…ë°ì´íŠ¸
 */
export async function verifyAndUpdateQRCode(
  qrCodeId: string
): Promise<QRCodeRecord> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  const qrCode = await repository.getQRCodeById(
    qrCodeId,
    tenantContext.tenantId
  );

  if (!qrCode) {
    throw new AppError(
      "QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  // í™œì„± ìƒíƒœ í™•ì¸
  if (!qrCode.is_active) {
    throw new AppError(
      "QR ì½”ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  // ë§Œë£Œ ì‹œê°„ í™•ì¸
  const expiresAt = new Date(qrCode.expires_at);
  const now = new Date();

  if (now > expiresAt) {
    throw new AppError(
      "QR ì½”ë“œê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
      ErrorCode.VALIDATION_ERROR,
      400,
      true
    );
  }

  // í…Œë„ŒíŠ¸ ì¼ì¹˜ í™•ì¸
  if (qrCode.tenant_id !== tenantContext.tenantId) {
    throw new AppError(
      "ë‹¤ë¥¸ í•™ì›ì˜ QR ì½”ë“œì…ë‹ˆë‹¤.",
      ErrorCode.VALIDATION_ERROR,
      403,
      true
    );
  }

  // ì‚¬ìš© í†µê³„ ì—…ë°ì´íŠ¸
  await repository.incrementQRCodeUsage(qrCodeId, tenantContext.tenantId);

  // ì—…ë°ì´íŠ¸ëœ QR ì½”ë“œ ë°˜í™˜
  const updatedQRCode = await repository.getQRCodeById(
    qrCodeId,
    tenantContext.tenantId
  );

  if (!updatedQRCode) {
    throw new AppError(
      "QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  return updatedQRCode;
}

/**
 * QR ì½”ë“œ ë¹„í™œì„±í™”
 */
export async function deactivateQRCode(qrCodeId: string): Promise<void> {
  const tenantContext = await getTenantContext();
  const user = await getCurrentUser();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  if (!user) {
    throw new AppError(
      "ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.UNAUTHORIZED,
      401,
      true
    );
  }

  // QR ì½”ë“œ ì¡´ì¬ í™•ì¸
  const qrCode = await repository.getQRCodeById(
    qrCodeId,
    tenantContext.tenantId
  );

  if (!qrCode) {
    throw new AppError(
      "QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  // ë¹„í™œì„±í™”
  await repository.deactivateQRCode(
    qrCodeId,
    tenantContext.tenantId,
    user.userId
  );
}

/**
 * QR ì½”ë“œ ì´ë ¥ ì¡°íšŒ
 */
export async function getQRCodeHistory(
  limit: number = 50
): Promise<QRCodeRecord[]> {
  const tenantContext = await getTenantContext();

  if (!tenantContext?.tenantId) {
    throw new AppError(
      "í…Œë„ŒíŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      ErrorCode.NOT_FOUND,
      404,
      true
    );
  }

  return repository.getQRCodeHistory(tenantContext.tenantId, limit);
}
</file>

<file path="school/actions.ts">
"use server";

/**
 * School ë„ë©”ì¸ Server Actions
 *
 * ì´ íŒŒì¼ì€ Server Actionsë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - ê¶Œí•œ ê²€ì‚¬
 * - FormData íŒŒì‹±
 * - Service í˜¸ì¶œ
 * - Cache ë¬´íš¨í™”
 *
 * ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ service.tsì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 */

import { revalidatePath } from "next/cache";
import { getCurrentUserRole } from "@/lib/auth/getCurrentUserRole";
import { createSchoolSchema, updateSchoolSchema } from "./validation";
import * as service from "./service";
import { parseFormString, parseFormStringOrNull } from "@/lib/utils/formData";
import type {
  School,
  Region,
  SchoolType,
  SchoolSimple,
  SchoolActionResult,
} from "./types";
import { toLegacySchool } from "./types";

// ============================================
// ì¡°íšŒ Actions (ëª¨ë“  ì‚¬ìš©ì ì ‘ê·¼ ê°€ëŠ¥)
// ============================================

/**
 * í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getSchoolsAction(options?: {
  regionId?: string;
  type?: SchoolType;
}): Promise<School[]> {
  const schools = await service.getAllSchools(
    options
      ? {
          region: options.regionId,
          schoolType: options.type,
        }
      : undefined
  );
  return schools.map(toLegacySchool);
}

/**
 * í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function getSchoolByIdAction(
  schoolId: string
): Promise<School | null> {
  const school = await service.getSchoolByUnifiedId(schoolId);
  return school ? toLegacySchool(school) : null;
}

/**
 * í•™êµëª…ìœ¼ë¡œ ì¡°íšŒ
 */
export async function getSchoolByNameAction(
  name: string,
  type?: SchoolType
): Promise<School | null> {
  const school = await service.getSchoolByName(name, type);
  return school ? toLegacySchool(school) : null;
}

/**
 * í•™êµ ê²€ìƒ‰ (ê°„ì†Œí™”ëœ ì‘ë‹µ)
 */
export async function searchSchoolsAction(
  query: string,
  type?: SchoolType
): Promise<SchoolSimple[]> {
  return service.searchSchools({
    query,
    schoolType: type,
  });
}

/**
 * ì§€ì—­ ëª©ë¡ ì¡°íšŒ
 */
export async function getRegionsAction(): Promise<Region[]> {
  return service.getAllRegions();
}

/**
 * ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByLevelAction(
  level: 1 | 2 | 3
): Promise<Region[]> {
  return service.getRegionsByLevel(level);
}

/**
 * ìƒìœ„ ì§€ì—­ë³„ í•˜ìœ„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByParentAction(
  parentId: string
): Promise<Region[]> {
  return service.getRegionsByParent(parentId);
}

// ============================================
// ê´€ë¦¬ì ì „ìš© Actions (admin, consultantë§Œ)
// ============================================

/**
 * í•™êµ ìƒì„± (ê´€ë¦¬ì ì „ìš©)
 */
export async function createSchoolAction(
  formData: FormData
): Promise<SchoolActionResult> {
  // ê¶Œí•œ í™•ì¸
  const { role } = await getCurrentUserRole();
  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤." };
  }

  // FormData íŒŒì‹±
  const rawData = {
    name: parseFormString(formData.get("name")),
    type: parseFormString(formData.get("type")) as SchoolType,
    region_id: parseFormStringOrNull(formData.get("region_id")),
    address: parseFormStringOrNull(formData.get("address")),
    postal_code: parseFormStringOrNull(formData.get("postal_code")),
    address_detail: parseFormStringOrNull(formData.get("address_detail")),
    city: parseFormStringOrNull(formData.get("city")),
    district: parseFormStringOrNull(formData.get("district")),
    phone: parseFormStringOrNull(formData.get("phone")),
    category: parseFormStringOrNull(formData.get("category")) as any,
    university_type: parseFormStringOrNull(
      formData.get("university_type")
    ) as any,
    university_ownership: parseFormStringOrNull(
      formData.get("university_ownership")
    ) as any,
    campus_name: parseFormStringOrNull(formData.get("campus_name")),
  };

  // ê²€ì¦
  const validation = createSchoolSchema.safeParse(rawData);
  if (!validation.success) {
    const firstError = validation.error.issues[0];
    return {
      success: false,
      error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
    };
  }

  // Service í˜¸ì¶œ (deprecated: ì½ê¸° ì „ìš©)
  const result = await service.createSchool();

  // Cache ë¬´íš¨í™”
  if (result.success) {
    revalidatePath("/admin/schools");
  }

  return result;
}

/**
 * í•™êµ ìˆ˜ì • (ê´€ë¦¬ì ì „ìš©)
 */
export async function updateSchoolAction(
  formData: FormData
): Promise<SchoolActionResult> {
  // ê¶Œí•œ í™•ì¸
  const { role } = await getCurrentUserRole();
  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤." };
  }

  // FormData íŒŒì‹±
  const rawData = {
    id: parseFormString(formData.get("id")),
    name: parseFormString(formData.get("name")),
    type: parseFormString(formData.get("type")) as SchoolType,
    region_id: parseFormStringOrNull(formData.get("region_id")),
    address: parseFormStringOrNull(formData.get("address")),
    postal_code: parseFormStringOrNull(formData.get("postal_code")),
    address_detail: parseFormStringOrNull(formData.get("address_detail")),
    city: parseFormStringOrNull(formData.get("city")),
    district: parseFormStringOrNull(formData.get("district")),
    phone: parseFormStringOrNull(formData.get("phone")),
    category: parseFormStringOrNull(formData.get("category")) as any,
    university_type: parseFormStringOrNull(
      formData.get("university_type")
    ) as any,
    university_ownership: parseFormStringOrNull(
      formData.get("university_ownership")
    ) as any,
    campus_name: parseFormStringOrNull(formData.get("campus_name")),
  };

  // ê²€ì¦
  const validation = updateSchoolSchema.safeParse(rawData);
  if (!validation.success) {
    const firstError = validation.error.issues[0];
    return {
      success: false,
      error: firstError?.message || "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
    };
  }

  // Service í˜¸ì¶œ (deprecated: ì½ê¸° ì „ìš©)
  const result = await service.updateSchool();

  // Cache ë¬´íš¨í™”
  if (result.success) {
    revalidatePath("/admin/schools");
    revalidatePath(`/admin/schools/${validation.data.id}`);
  }

  return result;
}

/**
 * í•™êµ ì‚­ì œ (ê´€ë¦¬ì ì „ìš©)
 */
export async function deleteSchoolAction(
  schoolId: string
): Promise<SchoolActionResult> {
  // ê¶Œí•œ í™•ì¸
  const { role } = await getCurrentUserRole();
  if (role !== "admin" && role !== "consultant") {
    return { success: false, error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤." };
  }

  // Service í˜¸ì¶œ (deprecated: ì½ê¸° ì „ìš©)
  const result = await service.deleteSchool();

  // Cache ë¬´íš¨í™”
  if (result.success) {
    revalidatePath("/admin/schools");
  }

  return result;
}

// ============================================
// í•™ìƒìš© Actions
// ============================================

/**
 * í•™êµ ìë™ ë“±ë¡ (í•™ìƒìš©)
 */
export async function autoRegisterSchoolAction(
  name: string,
  type: SchoolType,
  region?: string | null
): Promise<SchoolSimple | null> {
  // deprecated: ì½ê¸° ì „ìš©
  return service.autoRegisterSchool();
}
</file>

<file path="school/index.ts">
/**
 * School ë„ë©”ì¸ Public API
 *
 * ì™¸ë¶€ì—ì„œëŠ” ì´ íŒŒì¼ì„ í†µí•´ì„œë§Œ school ë„ë©”ì¸ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
 */

// Types
export * from "./types";

// Validation Schemas
export * from "./validation";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export * as service from "./service";

// Server Actions
export {
  // ì¡°íšŒ Actions
  getSchoolsAction,
  getSchoolByIdAction,
  getSchoolByNameAction,
  searchSchoolsAction,
  getRegionsAction,
  getRegionsByLevelAction,
  getRegionsByParentAction,
  // ê´€ë¦¬ì Actions
  createSchoolAction,
  updateSchoolAction,
  deleteSchoolAction,
  // í•™ìƒ Actions
  autoRegisterSchoolAction,
} from "./actions";

// RepositoryëŠ” ì™¸ë¶€ì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ (serviceë¥¼ í†µí•´ ì ‘ê·¼)
</file>

<file path="school/repository.ts">
/**
 * School ë„ë©”ì¸ Repository
 *
 * ìƒˆ í…Œì´ë¸” êµ¬ì¡°:
 * - school_info: ì¤‘Â·ê³ ë“±í•™êµ
 * - universities: ëŒ€í•™êµ
 * - university_campuses: ëŒ€í•™êµ ìº í¼ìŠ¤
 * - all_schools_view: í†µí•© ì¡°íšŒ VIEW
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type {
  SchoolType,
  SchoolInfo,
  University,
  UniversityCampus,
  UniversityWithCampus,
  AllSchoolsView,
  Region,
  GetSchoolsOptions,
  SearchSchoolsOptions,
} from "./types";

// ============================================
// Region Repository
// ============================================

/**
 * ëª¨ë“  í™œì„± ì§€ì—­ ì¡°íšŒ
 */
export async function findAllRegions(): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) throw error;
  return (data as Region[]) ?? [];
}

/**
 * ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ
 */
export async function findRegionsByLevel(level: 1 | 2 | 3): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("level", level)
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) throw error;
  return (data as Region[]) ?? [];
}

/**
 * ìƒìœ„ ì§€ì—­ë³„ í•˜ìœ„ ì§€ì—­ ì¡°íšŒ
 */
export async function findRegionsByParent(parentId: string): Promise<Region[]> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("parent_id", parentId)
    .eq("is_active", true)
    .order("display_order", { ascending: true })
    .order("name", { ascending: true });

  if (error) throw error;
  return (data as Region[]) ?? [];
}

/**
 * ì§€ì—­ IDë¡œ ì¡°íšŒ
 */
export async function findRegionById(regionId: string): Promise<Region | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("regions")
    .select("*")
    .eq("id", regionId)
    .maybeSingle();

  if (error) throw error;
  return data as Region | null;
}

// ============================================
// í†µí•© í•™êµ Repository (all_schools_view)
// ============================================

/**
 * í†µí•© í•™êµ ëª©ë¡ ì¡°íšŒ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ)
 */
export async function findAllSchools(options?: GetSchoolsOptions): Promise<AllSchoolsView[]> {
  // lib/data/schools.tsì˜ getAllSchoolsë¥¼ ì‚¬ìš©
  const { getAllSchools } = await import("@/lib/data/schools");
  return getAllSchools(options);
}

/**
 * í†µí•© í•™êµ ê²€ìƒ‰ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ)
 */
export async function searchSchools(options: SearchSchoolsOptions): Promise<AllSchoolsView[]> {
  // lib/data/schools.tsì˜ searchAllSchoolsë¥¼ ì‚¬ìš©í•˜ê³  AllSchoolsViewë¡œ ë³€í™˜
  const { searchAllSchools, getSchoolByUnifiedId } = await import("@/lib/data/schools");
  const simpleResults = await searchAllSchools(options);
  
  // SchoolSimpleì„ AllSchoolsViewë¡œ ë³€í™˜
  const results: AllSchoolsView[] = [];
  for (const simple of simpleResults) {
    const full = await getSchoolByUnifiedId(simple.id);
    if (full) {
      results.push(full);
    }
  }
  
  return results;
}

/**
 * í†µí•© í•™êµ IDë¡œ ì¡°íšŒ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ)
 */
export async function findSchoolByUnifiedId(unifiedId: string): Promise<AllSchoolsView | null> {
  // lib/data/schools.tsì˜ getSchoolByUnifiedIdë¥¼ ì‚¬ìš©
  const { getSchoolByUnifiedId } = await import("@/lib/data/schools");
  return getSchoolByUnifiedId(unifiedId);
}

/**
 * í•™êµëª…ìœ¼ë¡œ ì¡°íšŒ (ê° í…Œì´ë¸” ì§ì ‘ ì¡°íšŒ)
 */
export async function findSchoolByName(
  name: string,
  schoolType?: SchoolType
): Promise<AllSchoolsView | null> {
  // lib/data/schools.tsì˜ searchAllSchoolsë¥¼ ì‚¬ìš©
  const { searchAllSchools, getSchoolByUnifiedId } = await import("@/lib/data/schools");
  const results = await searchAllSchools({
    query: name,
    schoolType,
    limit: 1,
  });
  
  if (results.length === 0) return null;
  
  return getSchoolByUnifiedId(results[0].id);
}

// ============================================
// ì¤‘Â·ê³ ë“±í•™êµ Repository (school_info)
// ============================================

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function findSchoolInfoList(options?: {
  schoolLevel?: "ì¤‘" | "ê³ ";
  region?: string;
  limit?: number;
}): Promise<SchoolInfo[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("school_info")
    .select("*")
    .eq("closed_flag", "N");

  if (options?.schoolLevel) {
    query = query.eq("school_level", options.schoolLevel);
  }

  if (options?.region) {
    query = query.ilike("region", `%${options.region}%`);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("school_name", { ascending: true });

  if (error) throw error;
  return (data as SchoolInfo[]) ?? [];
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function findSchoolInfoById(id: number): Promise<SchoolInfo | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("school_info")
    .select("*")
    .eq("id", id)
    .maybeSingle();

  if (error) throw error;
  return data as SchoolInfo | null;
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ê²€ìƒ‰
 */
export async function searchSchoolInfo(
  query: string,
  schoolLevel?: "ì¤‘" | "ê³ ",
  limit = 50
): Promise<SchoolInfo[]> {
  const supabase = await createSupabaseServerClient();

  let dbQuery = supabase
    .from("school_info")
    .select("*")
    .eq("closed_flag", "N")
    .ilike("school_name", `%${query}%`);

  if (schoolLevel) {
    dbQuery = dbQuery.eq("school_level", schoolLevel);
  }

  const { data, error } = await dbQuery
    .limit(limit)
    .order("school_name", { ascending: true });

  if (error) throw error;
  return (data as SchoolInfo[]) ?? [];
}

// ============================================
// ëŒ€í•™êµ Repository (universities, university_campuses)
// ============================================

/**
 * ëŒ€í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function findUniversities(options?: {
  establishmentType?: string;
  universityType?: string;
  limit?: number;
}): Promise<University[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase.from("universities").select("*");

  if (options?.establishmentType) {
    query = query.eq("establishment_type", options.establishmentType);
  }

  if (options?.universityType) {
    query = query.eq("university_type", options.universityType);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("name_kor", { ascending: true });

  if (error) throw error;
  return (data as University[]) ?? [];
}

/**
 * ëŒ€í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function findUniversityById(id: number): Promise<University | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("universities")
    .select("*")
    .eq("id", id)
    .maybeSingle();

  if (error) throw error;
  return data as University | null;
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ ëª©ë¡ ì¡°íšŒ
 */
export async function findUniversityCampuses(options?: {
  universityId?: number;
  region?: string;
  limit?: number;
}): Promise<UniversityWithCampus[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities(*)
    `)
    .eq("campus_status", "ê¸°ì¡´");

  if (options?.universityId) {
    query = query.eq("university_id", options.universityId);
  }

  if (options?.region) {
    query = query.ilike("region", `%${options.region}%`);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  const { data, error } = await query.order("campus_name", { ascending: true });

  if (error) throw error;
  return (data as UniversityWithCampus[]) ?? [];
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ IDë¡œ ì¡°íšŒ
 */
export async function findUniversityCampusById(id: number): Promise<UniversityWithCampus | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities(*)
    `)
    .eq("id", id)
    .maybeSingle();

  if (error) throw error;
  return data as UniversityWithCampus | null;
}

/**
 * ëŒ€í•™êµ/ìº í¼ìŠ¤ ê²€ìƒ‰
 */
export async function searchUniversityCampuses(
  query: string,
  limit = 50
): Promise<UniversityWithCampus[]> {
  const supabase = await createSupabaseServerClient();

  // ìº í¼ìŠ¤ëª… ë˜ëŠ” ëŒ€í•™ëª…ìœ¼ë¡œ ê²€ìƒ‰
  const { data, error } = await supabase
    .from("university_campuses")
    .select(`
      *,
      university:universities(*)
    `)
    .eq("campus_status", "ê¸°ì¡´")
    .ilike("campus_name", `%${query}%`)
    .limit(limit)
    .order("campus_name", { ascending: true });

  if (error) throw error;
  return (data as UniversityWithCampus[]) ?? [];
}
</file>

<file path="school/service.ts">
/**
 * School ë„ë©”ì¸ Service
 *
 * ìƒˆ í…Œì´ë¸” êµ¬ì¡°:
 * - school_info: ì¤‘Â·ê³ ë“±í•™êµ (ì½ê¸° ì „ìš©)
 * - universities: ëŒ€í•™êµ (ì½ê¸° ì „ìš©)
 * - university_campuses: ëŒ€í•™êµ ìº í¼ìŠ¤ (ì½ê¸° ì „ìš©)
 * - all_schools_view: í†µí•© ì¡°íšŒ VIEW
 *
 * ì£¼ì˜: ìƒˆ í…Œì´ë¸”ë“¤ì€ ì™¸ë¶€ ë°ì´í„°(ë‚˜ì´ìŠ¤ ë“±) ê¸°ë°˜ìœ¼ë¡œ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.
 * CRUD ì‘ì—…ì´ í•„ìš”í•œ ê²½ìš° ë³„ë„ ê´€ë¦¬ í…Œì´ë¸”ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
 */

import * as repository from "./repository";
import type {
  SchoolType,
  SchoolTypeKor,
  Region,
  AllSchoolsView,
  SchoolSimple,
  SchoolInfo,
  University,
  UniversityWithCampus,
  GetSchoolsOptions,
  SearchSchoolsOptions,
  SchoolActionResult,
  SCHOOL_TYPE_MAP,
  toSchoolSimple,
  parseSchoolId,
} from "./types";

// ìƒìˆ˜
const SCHOOL_TYPE_MAP_INTERNAL: Record<SchoolType, SchoolTypeKor> = {
  MIDDLE: "ì¤‘í•™êµ",
  HIGH: "ê³ ë“±í•™êµ",
  UNIVERSITY: "ëŒ€í•™êµ",
};

const SCHOOL_TYPE_REVERSE_MAP_INTERNAL: Record<SchoolTypeKor, SchoolType> = {
  "ì¤‘í•™êµ": "MIDDLE",
  "ê³ ë“±í•™êµ": "HIGH",
  "ëŒ€í•™êµ": "UNIVERSITY",
};

// ============================================
// Region Service
// ============================================

/**
 * ëª¨ë“  í™œì„± ì§€ì—­ ì¡°íšŒ
 */
export async function getAllRegions(): Promise<Region[]> {
  try {
    return await repository.findAllRegions();
  } catch (error) {
    console.error("[school/service] ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByLevel(level: 1 | 2 | 3): Promise<Region[]> {
  try {
    return await repository.findRegionsByLevel(level);
  } catch (error) {
    console.error("[school/service] ë ˆë²¨ë³„ ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ìƒìœ„ ì§€ì—­ì˜ í•˜ìœ„ ì§€ì—­ ì¡°íšŒ
 */
export async function getRegionsByParent(parentId: string): Promise<Region[]> {
  try {
    return await repository.findRegionsByParent(parentId);
  } catch (error) {
    console.error("[school/service] í•˜ìœ„ ì§€ì—­ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ì§€ì—­ ID ìœ íš¨ì„± ê²€ì¦
 */
export async function isValidRegionId(regionId: string): Promise<boolean> {
  try {
    const region = await repository.findRegionById(regionId);
    return region !== null;
  } catch (error) {
    console.error("[school/service] ì§€ì—­ ê²€ì¦ ì‹¤íŒ¨:", error);
    return false;
  }
}

/**
 * ì§€ì—­ëª…ìœ¼ë¡œ ì§€ì—­ ID ì°¾ê¸°
 */
export async function findRegionIdByName(regionName: string): Promise<string | null> {
  try {
    const regions = await repository.findAllRegions();
    const matchedRegion = regions.find((r) => r.name === regionName);
    return matchedRegion?.id ?? null;
  } catch (error) {
    console.error("[school/service] ì§€ì—­ ID ê²€ìƒ‰ ì‹¤íŒ¨:", error);
    return null;
  }
}

// ============================================
// í†µí•© í•™êµ Service
// ============================================

/**
 * í†µí•© í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getAllSchools(options?: GetSchoolsOptions): Promise<AllSchoolsView[]> {
  try {
    return await repository.findAllSchools(options);
  } catch (error) {
    console.error("[school/service] í•™êµ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * í†µí•© í•™êµ ê²€ìƒ‰
 */
export async function searchSchools(options: SearchSchoolsOptions): Promise<SchoolSimple[]> {
  try {
    const schools = await repository.searchSchools(options);
    return schools.map((s) => ({
      id: s.id,
      name: s.name,
      schoolType: s.school_type,
      region: s.region,
      sourceTable: s.source_table,
      sourceId: s.source_id,
    }));
  } catch (error) {
    console.error("[school/service] í•™êµ ê²€ìƒ‰ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * í†µí•© í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function getSchoolByUnifiedId(unifiedId: string): Promise<AllSchoolsView | null> {
  try {
    return await repository.findSchoolByUnifiedId(unifiedId);
  } catch (error) {
    console.error("[school/service] í•™êµ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * í•™êµëª…ìœ¼ë¡œ ì¡°íšŒ
 */
export async function getSchoolByName(
  name: string,
  schoolType?: SchoolType
): Promise<AllSchoolsView | null> {
  try {
    return await repository.findSchoolByName(name, schoolType);
  } catch (error) {
    console.error("[school/service] í•™êµëª… ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

// ============================================
// ì¤‘Â·ê³ ë“±í•™êµ Service
// ============================================

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getSchoolInfoList(options?: {
  schoolLevel?: "ì¤‘" | "ê³ ";
  region?: string;
  limit?: number;
}): Promise<SchoolInfo[]> {
  try {
    return await repository.findSchoolInfoList(options);
  } catch (error) {
    console.error("[school/service] ì¤‘Â·ê³ ë“±í•™êµ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ IDë¡œ ì¡°íšŒ
 */
export async function getSchoolInfoById(id: number): Promise<SchoolInfo | null> {
  try {
    return await repository.findSchoolInfoById(id);
  } catch (error) {
    console.error("[school/service] ì¤‘Â·ê³ ë“±í•™êµ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ê²€ìƒ‰
 */
export async function searchSchoolInfo(
  query: string,
  schoolLevel?: "ì¤‘" | "ê³ ",
  limit = 50
): Promise<SchoolInfo[]> {
  try {
    return await repository.searchSchoolInfo(query, schoolLevel, limit);
  } catch (error) {
    console.error("[school/service] ì¤‘Â·ê³ ë“±í•™êµ ê²€ìƒ‰ ì‹¤íŒ¨:", error);
    return [];
  }
}

// ============================================
// ëŒ€í•™êµ Service
// ============================================

/**
 * ëŒ€í•™êµ ëª©ë¡ ì¡°íšŒ
 */
export async function getUniversities(options?: {
  establishmentType?: string;
  universityType?: string;
  limit?: number;
}): Promise<University[]> {
  try {
    return await repository.findUniversities(options);
  } catch (error) {
    console.error("[school/service] ëŒ€í•™êµ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ ëª©ë¡ ì¡°íšŒ
 */
export async function getUniversityCampuses(options?: {
  universityId?: number;
  region?: string;
  limit?: number;
}): Promise<UniversityWithCampus[]> {
  try {
    return await repository.findUniversityCampuses(options);
  } catch (error) {
    console.error("[school/service] ëŒ€í•™êµ ìº í¼ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ IDë¡œ ì¡°íšŒ
 */
export async function getUniversityCampusById(id: number): Promise<UniversityWithCampus | null> {
  try {
    return await repository.findUniversityCampusById(id);
  } catch (error) {
    console.error("[school/service] ëŒ€í•™êµ ìº í¼ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * ëŒ€í•™êµ/ìº í¼ìŠ¤ ê²€ìƒ‰
 */
export async function searchUniversityCampuses(
  query: string,
  limit = 50
): Promise<UniversityWithCampus[]> {
  try {
    return await repository.searchUniversityCampuses(query, limit);
  } catch (error) {
    console.error("[school/service] ëŒ€í•™êµ ê²€ìƒ‰ ì‹¤íŒ¨:", error);
    return [];
  }
}

// ============================================
// í•˜ìœ„ í˜¸í™˜ì„± í•¨ìˆ˜ (Deprecated)
// ============================================

/**
 * @deprecated ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.
 * í•™êµ CRUD ì‘ì—…ì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */
export async function createSchool(): Promise<SchoolActionResult> {
  console.warn("[school/service] createSchoolì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.");
  return {
    success: false,
    error: "í•™êµ ë°ì´í„°ëŠ” ì™¸ë¶€ ë°ì´í„°(ë‚˜ì´ìŠ¤ ë“±) ê¸°ë°˜ìœ¼ë¡œ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.",
  };
}

/**
 * @deprecated ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.
 * í•™êµ CRUD ì‘ì—…ì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */
export async function updateSchool(): Promise<SchoolActionResult> {
  console.warn("[school/service] updateSchoolì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.");
  return {
    success: false,
    error: "í•™êµ ë°ì´í„°ëŠ” ì™¸ë¶€ ë°ì´í„°(ë‚˜ì´ìŠ¤ ë“±) ê¸°ë°˜ìœ¼ë¡œ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.",
  };
}

/**
 * @deprecated ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.
 * í•™êµ CRUD ì‘ì—…ì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */
export async function deleteSchool(): Promise<SchoolActionResult> {
  console.warn("[school/service] deleteSchoolì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.");
  return {
    success: false,
    error: "í•™êµ ë°ì´í„°ëŠ” ì™¸ë¶€ ë°ì´í„°(ë‚˜ì´ìŠ¤ ë“±) ê¸°ë°˜ìœ¼ë¡œ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.",
  };
}

/**
 * @deprecated ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.
 */
export async function autoRegisterSchool(): Promise<SchoolSimple | null> {
  console.warn("[school/service] autoRegisterSchoolì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒˆ í…Œì´ë¸”ì€ ì½ê¸° ì „ìš©ì…ë‹ˆë‹¤.");
  return null;
}

/**
 * @deprecated checkDuplicateSchoolì€ ë” ì´ìƒ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
 */
export async function checkDuplicateSchool(): Promise<boolean> {
  console.warn("[school/service] checkDuplicateSchoolì€ ë” ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
  return false;
}
</file>

<file path="school/types.ts">
/**
 * School ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * ìƒˆ í…Œì´ë¸” êµ¬ì¡° ê¸°ë°˜:
 * - school_info: ì¤‘Â·ê³ ë“±í•™êµ
 * - universities: ëŒ€í•™êµ
 * - university_campuses: ëŒ€í•™êµ ìº í¼ìŠ¤
 * - all_schools_view: í†µí•© ì¡°íšŒ VIEW
 */

// ============================================
// í•™êµ ìœ í˜• Enum
// ============================================

/**
 * í•™êµ ìœ í˜• (í†µí•©)
 */
export type SchoolType = "MIDDLE" | "HIGH" | "UNIVERSITY";

/**
 * í•™êµ ìœ í˜• (í•œê¸€)
 */
export type SchoolTypeKor = "ì¤‘í•™êµ" | "ê³ ë“±í•™êµ" | "ëŒ€í•™êµ";

/**
 * í•™êµ ìœ í˜• ë§¤í•‘
 */
export const SCHOOL_TYPE_MAP: Record<SchoolType, SchoolTypeKor> = {
  MIDDLE: "ì¤‘í•™êµ",
  HIGH: "ê³ ë“±í•™êµ",
  UNIVERSITY: "ëŒ€í•™êµ",
};

export const SCHOOL_TYPE_REVERSE_MAP: Record<SchoolTypeKor, SchoolType> = {
  "ì¤‘í•™êµ": "MIDDLE",
  "ê³ ë“±í•™êµ": "HIGH",
  "ëŒ€í•™êµ": "UNIVERSITY",
};

// ============================================
// ì¤‘Â·ê³ ë“±í•™êµ íƒ€ì… (school_info)
// ============================================

/**
 * ì¤‘Â·ê³ ë“±í•™êµ ì •ë³´ (school_info í…Œì´ë¸”)
 */
export type SchoolInfo = {
  id: number;
  district_id: number | null;
  region: string | null;
  school_code: string;
  school_name: string;
  school_level: "ì¤‘" | "ê³ ";
  establishment_type: string | null; // "êµ­ë¦½" | "ê³µë¦½" | "ì‚¬ë¦½"
  school_property: string | null;
  branch_flag: string | null;
  establishment_form: string | null;
  postal_code: string | null;
  addr_road: string | null;
  addr_detail: string | null;
  address_full: string | null;
  latitude: number | null;
  longitude: number | null;
  phone_number: string | null;
  fax_number: string | null;
  homepage_url: string | null;
  coeducation_type: string | null;
  closed_flag: string | null;
  closed_date: string | null;
  temporary_close_flag: string | null;
  created_at: string;
};

// ============================================
// ëŒ€í•™êµ íƒ€ì… (universities, university_campuses)
// ============================================

/**
 * ëŒ€í•™êµ ê¸°ë³¸ ì •ë³´ (universities í…Œì´ë¸”)
 */
export type University = {
  id: number;
  university_code: string;
  name_kor: string;
  name_eng: string | null;
  name_chi: string | null;
  establishment_type: string | null; // "êµ­ë¦½" | "ì‚¬ë¦½"
  corporation_name: string | null;
  legal_basis: string | null;
  university_type: string | null; // "ëŒ€í•™", "ì „ë¬¸ëŒ€í•™", "íŠ¹ìˆ˜ëŒ€í•™ì›" ë“±
  status: string | null;
  homepage_url: string | null;
  president_name: string | null;
  founded_date: string | null;
  created_at: string;
};

/**
 * ëŒ€í•™êµ ìº í¼ìŠ¤ ì •ë³´ (university_campuses í…Œì´ë¸”)
 */
export type UniversityCampus = {
  id: number;
  university_id: number;
  campus_type: string | null; // "ë³¸êµ" | "ì œ2ìº í¼ìŠ¤" ë“±
  campus_name: string;
  region: string | null;
  address_kor: string | null;
  address_eng: string | null;
  address_chi: string | null;
  postal_code: string | null;
  phone_number: string | null;
  fax_number: string | null;
  campus_status: string | null;
  created_at: string;
};

/**
 * ëŒ€í•™êµ + ìº í¼ìŠ¤ JOIN ê²°ê³¼
 */
export type UniversityWithCampus = UniversityCampus & {
  university: University;
};

// ============================================
// í†µí•© íƒ€ì… (all_schools_view)
// ============================================

/**
 * í†µí•© í•™êµ ì •ë³´ (all_schools_view)
 */
export type AllSchoolsView = {
  id: string; // "SCHOOL_123" ë˜ëŠ” "UNIV_456" í˜•ì‹
  school_type: SchoolType;
  name: string;
  code: string | null;
  region: string | null;
  address: string | null;
  postal_code: string | null;
  phone: string | null;
  website: string | null;
  establishment_type: string | null;
  campus_name: string | null; // ëŒ€í•™êµë§Œ
  university_type: string | null; // ëŒ€í•™êµë§Œ
  source_table: "school_info" | "university_campuses";
  source_id: number;
  latitude: number | null;
  longitude: number | null;
  created_at: string;
};

// ============================================
// ì„œë¹„ìŠ¤/APIìš© íƒ€ì…
// ============================================

/**
 * í•™êµ ê²€ìƒ‰ ê²°ê³¼ (ê°„ì†Œí™”)
 */
export type SchoolSimple = {
  id: string; // í†µí•© ID ("SCHOOL_123" ë˜ëŠ” "UNIV_456")
  name: string;
  schoolType: SchoolType;
  region: string | null;
  sourceTable: "school_info" | "university_campuses";
  sourceId: number;
};

/**
 * í•™êµ ê²€ìƒ‰ ì˜µì…˜
 */
export type SearchSchoolsOptions = {
  query?: string;
  schoolType?: SchoolType;
  region?: string;
  limit?: number;
};

/**
 * í•™êµ ì¡°íšŒ ì˜µì…˜
 */
export type GetSchoolsOptions = {
  schoolType?: SchoolType;
  region?: string;
  includeInactive?: boolean;
  limit?: number;
  offset?: number;
};

/**
 * í•™êµ ì•¡ì…˜ ê²°ê³¼
 */
export type SchoolActionResult<T = unknown> = {
  success: boolean;
  error?: string;
  data?: T;
};

// ============================================
// Region íƒ€ì… (ê¸°ì¡´ ìœ ì§€)
// ============================================

/**
 * ì§€ì—­ ì •ë³´
 */
export type Region = {
  id: string;
  name: string;
  parent_id: string | null;
  level: number; // 1: ì‹œ/ë„, 2: ì‹œ/êµ°/êµ¬, 3: ì/ë©´/ë™
  code: string | null;
  display_order: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
};

// ============================================
// Deprecated íƒ€ì… (í•˜ìœ„ í˜¸í™˜ì„±)
// ============================================

/**
 * @deprecated ìƒˆ íƒ€ì… AllSchoolsView ë˜ëŠ” SchoolSimple ì‚¬ìš©
 */
export type School = {
  id: string;
  name: string;
  type: SchoolTypeKor;
  region: string | null;
  address?: string | null;
  phone?: string | null;
};

/**
 * ê¸°ì¡´ íƒ€ì… â†’ ìƒˆ íƒ€ì… ë³€í™˜ í—¬í¼
 */
export function toSchoolSimple(school: AllSchoolsView): SchoolSimple {
  return {
    id: school.id,
    name: school.name,
    schoolType: school.school_type,
    region: school.region,
    sourceTable: school.source_table,
    sourceId: school.source_id,
  };
}

/**
 * ìƒˆ íƒ€ì… â†’ ê¸°ì¡´ íƒ€ì… ë³€í™˜ í—¬í¼ (í•˜ìœ„ í˜¸í™˜ì„±)
 */
export function toLegacySchool(school: AllSchoolsView): School {
  return {
    id: school.id,
    name: school.name,
    type: SCHOOL_TYPE_MAP[school.school_type],
    region: school.region,
    address: school.address,
    phone: school.phone,
  };
}

/**
 * í†µí•© IDì—ì„œ source ì •ë³´ ì¶”ì¶œ
 */
export function parseSchoolId(id: string): {
  sourceTable: "school_info" | "university_campuses";
  sourceId: number;
} | null {
  if (id.startsWith("SCHOOL_")) {
    const sourceId = parseInt(id.replace("SCHOOL_", ""), 10);
    if (!isNaN(sourceId)) {
      return { sourceTable: "school_info", sourceId };
    }
  } else if (id.startsWith("UNIV_")) {
    const sourceId = parseInt(id.replace("UNIV_", ""), 10);
    if (!isNaN(sourceId)) {
      return { sourceTable: "university_campuses", sourceId };
    }
  }
  return null;
}
</file>

<file path="school/validation.ts">
/**
 * School ë„ë©”ì¸ ê²€ì¦ ìŠ¤í‚¤ë§ˆ
 */

import { z } from "zod";

// ============================================
// ê¸°ë³¸ í•„ë“œ ìŠ¤í‚¤ë§ˆ
// ============================================

export const schoolTypeSchema = z.enum(["ì¤‘í•™êµ", "ê³ ë“±í•™êµ", "ëŒ€í•™êµ"]);

export const highSchoolCategorySchema = z.enum([
  "ì¼ë°˜ê³ ",
  "íŠ¹ëª©ê³ ",
  "ìì‚¬ê³ ",
  "íŠ¹ì„±í™”ê³ ",
]);

export const universityTypeSchema = z.enum(["4ë…„ì œ", "2ë…„ì œ"]);

export const universityOwnershipSchema = z.enum(["êµ­ë¦½", "ì‚¬ë¦½"]);

export const postalCodeSchema = z
  .string()
  .regex(/^\d{5,6}$/, "ìš°í¸ë²ˆí˜¸ëŠ” 5ìë¦¬ ë˜ëŠ” 6ìë¦¬ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
  .optional()
  .nullable();

// ============================================
// í•™êµ ìƒì„± ìŠ¤í‚¤ë§ˆ
// ============================================

// base schema (extendë¥¼ ìœ„í•´ ë¶„ë¦¬)
const schoolBaseSchema = z.object({
  name: z.string().min(1, "í•™êµëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”").max(100, "í•™êµëª…ì€ 100ì ì´ë‚´ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  type: schoolTypeSchema,
  region_id: z.string().uuid().optional().nullable(),
  address: z.string().max(200).optional().nullable(),
  postal_code: postalCodeSchema,
  address_detail: z.string().max(100).optional().nullable(),
  city: z.string().max(50).optional().nullable(),
  district: z.string().max(50).optional().nullable(),
  phone: z.string().max(20).optional().nullable(),
  // ê³ ë“±í•™êµ ì†ì„±
  category: highSchoolCategorySchema.optional().nullable(),
  // ëŒ€í•™êµ ì†ì„±
  university_type: universityTypeSchema.optional().nullable(),
  university_ownership: universityOwnershipSchema.optional().nullable(),
  campus_name: z.string().max(50).optional().nullable(),
});

export const createSchoolSchema = schoolBaseSchema
  .refine(
    (data) => {
      // ê³ ë“±í•™êµê°€ ì•„ë‹Œ ê²½ìš° categoryëŠ” nullì´ì–´ì•¼ í•¨
      if (data.type !== "ê³ ë“±í•™êµ" && data.category) {
        return false;
      }
      return true;
    },
    {
      message: "ê³ ë“±í•™êµ ìœ í˜•ì€ ê³ ë“±í•™êµì—ë§Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
      path: ["category"],
    }
  )
  .refine(
    (data) => {
      // ëŒ€í•™êµê°€ ì•„ë‹Œ ê²½ìš° ëŒ€í•™êµ ì†ì„±ì€ nullì´ì–´ì•¼ í•¨
      if (data.type !== "ëŒ€í•™êµ" && (data.university_type || data.university_ownership || data.campus_name)) {
        return false;
      }
      return true;
    },
    {
      message: "ëŒ€í•™êµ ì†ì„±ì€ ëŒ€í•™êµì—ë§Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
      path: ["university_type"],
    }
  );

// ============================================
// í•™êµ ìˆ˜ì • ìŠ¤í‚¤ë§ˆ
// ============================================

export const updateSchoolSchema = schoolBaseSchema
  .extend({
    id: z.string().uuid("ì˜¬ë°”ë¥¸ ID í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤"),
  })
  .refine(
    (data) => {
      // ê³ ë“±í•™êµê°€ ì•„ë‹Œ ê²½ìš° categoryëŠ” nullì´ì–´ì•¼ í•¨
      if (data.type !== "ê³ ë“±í•™êµ" && data.category) {
        return false;
      }
      return true;
    },
    {
      message: "ê³ ë“±í•™êµ ìœ í˜•ì€ ê³ ë“±í•™êµì—ë§Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
      path: ["category"],
    }
  )
  .refine(
    (data) => {
      // ëŒ€í•™êµê°€ ì•„ë‹Œ ê²½ìš° ëŒ€í•™êµ ì†ì„±ì€ nullì´ì–´ì•¼ í•¨
      if (data.type !== "ëŒ€í•™êµ" && (data.university_type || data.university_ownership || data.campus_name)) {
        return false;
      }
      return true;
    },
    {
      message: "ëŒ€í•™êµ ì†ì„±ì€ ëŒ€í•™êµì—ë§Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
      path: ["university_type"],
    }
  );

// ============================================
// íƒ€ì… ì¶”ë¡ 
// ============================================

export type CreateSchoolFormData = z.infer<typeof createSchoolSchema>;
export type UpdateSchoolFormData = z.infer<typeof updateSchoolSchema>;
</file>

<file path="score/actions.ts">
"use server";

/**
 * Score ë„ë©”ì¸ Server Actions
 *
 * ì´ íŒŒì¼ì€ Server Actionsë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - ê¶Œí•œ ê²€ì‚¬
 * - FormData íŒŒì‹±
 * - Service í˜¸ì¶œ
 * - Cache ë¬´íš¨í™”
 */

import { revalidatePath } from "next/cache";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import * as service from "./service";
import { parseFormString, parseFormNumberOrNull } from "@/lib/utils/formData";
import type {
  SchoolScore,
  MockScore,
  GetSchoolScoresFilter,
  GetMockScoresFilter,
  ScoreActionResult,
} from "./types";

// ============================================
// ë‚´ì‹  ì„±ì  Actions
// ============================================

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ
 */
export async function getSchoolScoresAction(
  studentId: string,
  tenantId?: string | null,
  filters?: GetSchoolScoresFilter
): Promise<SchoolScore[]> {
  return service.getSchoolScores(studentId, tenantId, filters);
}

/**
 * ë‚´ì‹  ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function getSchoolScoreByIdAction(
  scoreId: string,
  studentId: string
): Promise<SchoolScore | null> {
  return service.getSchoolScoreById(scoreId, studentId);
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„±
 */
export async function createSchoolScoreAction(
  formData: FormData
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const input = {
    tenant_id: parseFormString(formData.get("tenant_id")) || null,
    student_id: parseFormString(formData.get("student_id")) || user.userId,
    grade: parseFormNumberOrNull(formData.get("grade")) || 1,
    semester: parseFormNumberOrNull(formData.get("semester")) || 1,
    subject_group_id: parseFormString(formData.get("subject_group_id")) || null,
    subject_id: parseFormString(formData.get("subject_id")) || null,
    subject_type_id: parseFormString(formData.get("subject_type_id")) || null,
    subject_group: parseFormString(formData.get("subject_group")) || null,
    subject_type: parseFormString(formData.get("subject_type")) || null,
    subject_name: parseFormString(formData.get("subject_name")) || null,
    credit_hours: parseFormNumberOrNull(formData.get("credit_hours")),
    raw_score: parseFormNumberOrNull(formData.get("raw_score")),
    subject_average: parseFormNumberOrNull(formData.get("subject_average")),
    standard_deviation: parseFormNumberOrNull(
      formData.get("standard_deviation")
    ),
    grade_score: parseFormNumberOrNull(formData.get("grade_score")),
    total_students: parseFormNumberOrNull(formData.get("total_students")),
    rank_grade: parseFormNumberOrNull(formData.get("rank_grade")),
  };

  const result = await service.createSchoolScore(input);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì •
 */
export async function updateSchoolScoreAction(
  formData: FormData
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const scoreId = parseFormString(formData.get("id"));
  const studentId = parseFormString(formData.get("student_id")) || user.userId;

  if (!scoreId) {
    return { success: false, error: "ì„±ì  IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const updates = {
    grade: parseFormNumberOrNull(formData.get("grade")) || undefined,
    semester: parseFormNumberOrNull(formData.get("semester")) || undefined,
    subject_group_id:
      parseFormString(formData.get("subject_group_id")) || undefined,
    subject_id: parseFormString(formData.get("subject_id")) || undefined,
    subject_type_id:
      parseFormString(formData.get("subject_type_id")) || undefined,
    subject_group: parseFormString(formData.get("subject_group")) || undefined,
    subject_type: parseFormString(formData.get("subject_type")) || undefined,
    subject_name: parseFormString(formData.get("subject_name")) || undefined,
    credit_hours: parseFormNumberOrNull(formData.get("credit_hours")),
    raw_score: parseFormNumberOrNull(formData.get("raw_score")),
    subject_average: parseFormNumberOrNull(formData.get("subject_average")),
    standard_deviation: parseFormNumberOrNull(
      formData.get("standard_deviation")
    ),
    grade_score: parseFormNumberOrNull(formData.get("grade_score")),
    total_students: parseFormNumberOrNull(formData.get("total_students")),
    rank_grade: parseFormNumberOrNull(formData.get("rank_grade")),
  };

  const result = await service.updateSchoolScore(scoreId, studentId, updates);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

/**
 * ë‚´ì‹  ì„±ì  ì‚­ì œ
 */
export async function deleteSchoolScoreAction(
  scoreId: string,
  studentId?: string
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const targetStudentId = studentId || user.userId;
  const result = await service.deleteSchoolScore(scoreId, targetStudentId);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

// ============================================
// ëª¨ì˜ê³ ì‚¬ ì„±ì  Actions
// ============================================

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ëª©ë¡ ì¡°íšŒ
 */
export async function getMockScoresAction(
  studentId: string,
  tenantId?: string | null,
  filters?: GetMockScoresFilter
): Promise<MockScore[]> {
  return service.getMockScores(studentId, tenantId, filters);
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function getMockScoreByIdAction(
  scoreId: string,
  studentId: string
): Promise<MockScore | null> {
  return service.getMockScoreById(scoreId, studentId);
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„±
 */
export async function createMockScoreAction(
  formData: FormData
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  // exam_dateì™€ exam_title ê°€ì ¸ì˜¤ê¸°
  const examDate =
    parseFormString(formData.get("exam_date")) ||
    new Date().toISOString().split("T")[0];
  const examTitle =
    parseFormString(formData.get("exam_title")) ||
    parseFormString(formData.get("exam_type")) ||
    "ëª¨ì˜ê³ ì‚¬";

  // curriculum_revision_id ê°€ì ¸ì˜¤ê¸°
  const { getActiveCurriculumRevision } = await import("@/lib/data/subjects");
  const curriculumRevision = await getActiveCurriculumRevision();
  if (!curriculumRevision) {
    return {
      success: false,
      error: "ê°œì •êµìœ¡ê³¼ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.",
    };
  }

  const input = {
    tenant_id:
      parseFormString(formData.get("tenant_id")) || user.tenantId || "",
    student_id: parseFormString(formData.get("student_id")) || user.userId,
    exam_date: examDate,
    exam_title: examTitle,
    grade: parseFormNumberOrNull(formData.get("grade")) || 1,
    subject_id: parseFormString(formData.get("subject_id")) || "",
    subject_group_id: parseFormString(formData.get("subject_group_id")) || "",
    curriculum_revision_id: curriculumRevision.id,
    raw_score: parseFormNumberOrNull(formData.get("raw_score")),
    standard_score: parseFormNumberOrNull(formData.get("standard_score")),
    percentile: parseFormNumberOrNull(formData.get("percentile")),
    grade_score: parseFormNumberOrNull(formData.get("grade_score")),
    semester: parseFormNumberOrNull(formData.get("semester")) ?? undefined,
  };

  const result = await service.createMockScore(input);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì •
 */
export async function updateMockScoreAction(
  formData: FormData
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const scoreId = parseFormString(formData.get("id"));
  const studentId = parseFormString(formData.get("student_id")) || user.userId;

  if (!scoreId) {
    return { success: false, error: "ì„±ì  IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const updates = {
    grade: parseFormNumberOrNull(formData.get("grade")) || undefined,
    exam_type: parseFormString(formData.get("exam_type")) || undefined,
    subject_group_id:
      parseFormString(formData.get("subject_group_id")) || undefined,
    subject_id: parseFormString(formData.get("subject_id")) || undefined,
    subject_type_id:
      parseFormString(formData.get("subject_type_id")) || undefined,
    subject_group: parseFormString(formData.get("subject_group")) || undefined,
    subject_name: parseFormString(formData.get("subject_name")) || undefined,
    raw_score: parseFormNumberOrNull(formData.get("raw_score")),
    standard_score: parseFormNumberOrNull(formData.get("standard_score")),
    percentile: parseFormNumberOrNull(formData.get("percentile")),
    grade_score: parseFormNumberOrNull(formData.get("grade_score")),
    exam_round: parseFormString(formData.get("exam_round")) || undefined,
  };

  const result = await service.updateMockScore(scoreId, studentId, updates);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ
 */
export async function deleteMockScoreAction(
  scoreId: string,
  studentId?: string
): Promise<ScoreActionResult> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤." };
  }

  const targetStudentId = studentId || user.userId;
  const result = await service.deleteMockScore(scoreId, targetStudentId);

  if (result.success) {
    revalidatePath("/scores");
    revalidatePath("/dashboard");
  }

  return result;
}

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ Actions
// ============================================

/**
 * í‰ê·  ë“±ê¸‰ ì¡°íšŒ
 */
export async function getAverageGradeAction(
  studentId: string,
  tenantId?: string | null
): Promise<{ schoolAvg: number | null; mockAvg: number | null }> {
  return service.calculateAverageGrade(studentId, tenantId);
}

/**
 * ê³¼ëª©ë³„ ì„±ì  ì¶”ì´ ì¡°íšŒ
 */
export async function getScoreTrendAction(
  studentId: string,
  subjectGroupId: string,
  tenantId?: string | null
): Promise<{
  school: SchoolScore[];
  mock: MockScore[];
}> {
  return service.getScoreTrendBySubject(studentId, subjectGroupId, tenantId);
}
</file>

<file path="score/index.ts">
/**
 * Score ë„ë©”ì¸ Public API
 *
 * ì™¸ë¶€ì—ì„œëŠ” ì´ íŒŒì¼ì„ í†µí•´ì„œë§Œ score ë„ë©”ì¸ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
 */

// Types
export * from "./types";

// Validation Schemas
export * from "./validation";

// Service (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
export * as service from "./service";

// Server Actions
export {
  // ë‚´ì‹  ì„±ì  Actions
  getSchoolScoresAction,
  getSchoolScoreByIdAction,
  createSchoolScoreAction,
  updateSchoolScoreAction,
  deleteSchoolScoreAction,
  // ëª¨ì˜ê³ ì‚¬ ì„±ì  Actions
  getMockScoresAction,
  getMockScoreByIdAction,
  createMockScoreAction,
  updateMockScoreAction,
  deleteMockScoreAction,
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ Actions
  getAverageGradeAction,
  getScoreTrendAction,
} from "./actions";

// RepositoryëŠ” ì™¸ë¶€ì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ (serviceë¥¼ í†µí•´ ì ‘ê·¼)
</file>

<file path="score/repository.ts">
/**
 * Score ë„ë©”ì¸ Repository
 *
 * ì´ íŒŒì¼ì€ ìˆœìˆ˜í•œ ë°ì´í„° ì ‘ê·¼ë§Œì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - Supabase ì¿¼ë¦¬ë§Œ ìˆ˜í–‰
 * - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—†ìŒ
 * - ì—ëŸ¬ëŠ” ìƒìœ„ ë ˆì´ì–´ì—ì„œ ì²˜ë¦¬
 */

import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  getOrCreateStudentTerm,
  calculateSchoolYear,
} from "@/lib/data/studentTerms";
import type {
  InternalScore,
  MockScore,
  GetSchoolScoresFilter,
  GetMockScoresFilter,
  CreateInternalScoreInput,
  UpdateInternalScoreInput,
  CreateMockScoreInput,
  UpdateMockScoreInput,
  // ë ˆê±°ì‹œ íƒ€ì… (í•˜ìœ„ í˜¸í™˜ì„±)
  SchoolScore,
  CreateSchoolScoreInput,
  UpdateSchoolScoreInput,
} from "./types";

// ============================================
// ë‚´ì‹  ì„±ì  Repository
// ============================================

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ (ì •ê·œí™” ë²„ì „)
 */
export async function findInternalScores(
  studentId: string,
  tenantId: string,
  filters?: GetSchoolScoresFilter
): Promise<InternalScore[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_internal_scores")
    .select("*")
    .eq("student_id", studentId)
    .eq("tenant_id", tenantId);

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.semester) {
    query = query.eq("semester", filters.semester);
  }

  if (filters?.subjectGroupId) {
    query = query.eq("subject_group_id", filters.subjectGroupId);
  }

  const { data, error } = await query
    .order("grade", { ascending: true })
    .order("semester", { ascending: true })
    .order("created_at", { ascending: false });

  if (error) throw error;
  return (data as InternalScore[]) ?? [];
}

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ (ë ˆê±°ì‹œ)
 * @deprecated findInternalScoresë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export async function findSchoolScores(
  studentId: string,
  tenantId?: string | null,
  filters?: GetSchoolScoresFilter
): Promise<SchoolScore[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_school_scores")
    .select("*")
    .eq("student_id", studentId);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.semester) {
    query = query.eq("semester", filters.semester);
  }

  if (filters?.subjectGroupId) {
    query = query.eq("subject_group_id", filters.subjectGroupId);
  } else if (filters?.subjectGroup) {
    query = query.eq("subject_group", filters.subjectGroup);
  }

  const { data, error } = await query
    .order("grade", { ascending: true })
    .order("semester", { ascending: true })
    .order("created_at", { ascending: false });

  if (error) throw error;
  return (data as SchoolScore[]) ?? [];
}

/**
 * ë‚´ì‹  ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function findSchoolScoreById(
  scoreId: string,
  studentId: string
): Promise<SchoolScore | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_school_scores")
    .select("*")
    .eq("id", scoreId)
    .eq("student_id", studentId)
    .maybeSingle();

  if (error) throw error;
  return data as SchoolScore | null;
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± (ì •ê·œí™” ë²„ì „)
 *
 * student_termsë¥¼ ì¡°íšŒ/ìƒì„±í•˜ì—¬ student_term_idë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.
 */
export async function insertInternalScore(
  input: CreateInternalScoreInput & { school_year?: number }
): Promise<string> {
  const supabase = await createSupabaseServerClient();

  // school_year ê³„ì‚° (ì—†ìœ¼ë©´ í˜„ì¬ ë‚ ì§œ ê¸°ì¤€)
  const school_year = input.school_year ?? calculateSchoolYear();

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„±
  const student_term_id = await getOrCreateStudentTerm({
    tenant_id: input.tenant_id,
    student_id: input.student_id,
    school_year,
    grade: input.grade,
    semester: input.semester,
    curriculum_revision_id: input.curriculum_revision_id,
  });

  const payload = {
    tenant_id: input.tenant_id,
    student_id: input.student_id,
    student_term_id, // student_term_id ì¶”ê°€
    curriculum_revision_id: input.curriculum_revision_id,
    subject_group_id: input.subject_group_id,
    subject_type_id: input.subject_type_id,
    subject_id: input.subject_id,
    grade: input.grade,
    semester: input.semester,
    credit_hours: input.credit_hours,
    raw_score: input.raw_score ?? null,
    avg_score: input.avg_score ?? null,
    std_dev: input.std_dev ?? null,
    rank_grade: input.rank_grade ?? null,
    total_students: input.total_students ?? null,
  };

  const { data, error } = await supabase
    .from("student_internal_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error) throw error;
  return data.id;
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± (ë ˆê±°ì‹œ)
 * @deprecated insertInternalScoreë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export async function insertSchoolScore(
  input: CreateSchoolScoreInput
): Promise<string> {
  const supabase = await createSupabaseServerClient();

  const payload = {
    tenant_id: input.tenant_id ?? null,
    student_id: input.student_id,
    grade: input.grade,
    semester: input.semester,
    subject_group_id: input.subject_group_id ?? null,
    subject_id: input.subject_id ?? null,
    subject_type_id: input.subject_type_id ?? null,
    subject_group: input.subject_group ?? null,
    subject_type: input.subject_type ?? null,
    subject_name: input.subject_name ?? null,
    credit_hours: input.credit_hours ?? null,
    raw_score: input.raw_score ?? null,
    subject_average: input.subject_average ?? null,
    standard_deviation: input.standard_deviation ?? null,
    grade_score: input.grade_score ?? null,
    total_students: input.total_students ?? null,
    rank_grade: input.rank_grade ?? null,
  };

  const { data, error } = await supabase
    .from("student_school_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error) throw error;
  return data.id;
}

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì •
 */
export async function updateSchoolScoreById(
  scoreId: string,
  studentId: string,
  updates: UpdateSchoolScoreInput
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, unknown> = {};

  if (updates.grade !== undefined) payload.grade = updates.grade;
  if (updates.semester !== undefined) payload.semester = updates.semester;
  if (updates.subject_group_id !== undefined)
    payload.subject_group_id = updates.subject_group_id;
  if (updates.subject_id !== undefined) payload.subject_id = updates.subject_id;
  if (updates.subject_type_id !== undefined)
    payload.subject_type_id = updates.subject_type_id;
  if (updates.subject_group !== undefined)
    payload.subject_group = updates.subject_group;
  if (updates.subject_type !== undefined)
    payload.subject_type = updates.subject_type;
  if (updates.subject_name !== undefined)
    payload.subject_name = updates.subject_name;
  if (updates.credit_hours !== undefined)
    payload.credit_hours = updates.credit_hours;
  if (updates.raw_score !== undefined) payload.raw_score = updates.raw_score;
  if (updates.subject_average !== undefined)
    payload.subject_average = updates.subject_average;
  if (updates.standard_deviation !== undefined)
    payload.standard_deviation = updates.standard_deviation;
  if (updates.grade_score !== undefined)
    payload.grade_score = updates.grade_score;
  if (updates.total_students !== undefined)
    payload.total_students = updates.total_students;
  if (updates.rank_grade !== undefined) payload.rank_grade = updates.rank_grade;

  const { error } = await supabase
    .from("student_school_scores")
    .update(payload)
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error) throw error;
}

/**
 * ë‚´ì‹  ì„±ì  ì‚­ì œ
 */
export async function deleteSchoolScoreById(
  scoreId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_school_scores")
    .delete()
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error) throw error;
}

// ============================================
// ëª¨ì˜ê³ ì‚¬ ì„±ì  Repository
// ============================================

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ëª©ë¡ ì¡°íšŒ (ì •ê·œí™” ë²„ì „)
 */
export async function findMockScores(
  studentId: string,
  tenantId?: string | null,
  filters?: GetMockScoresFilter
): Promise<MockScore[]> {
  const supabase = await createSupabaseServerClient();

  let query = supabase
    .from("student_mock_scores")
    .select("*")
    .eq("student_id", studentId);

  if (tenantId) {
    query = query.eq("tenant_id", tenantId);
  }

  if (filters?.grade) {
    query = query.eq("grade", filters.grade);
  }

  if (filters?.examTitle) {
    query = query.eq("exam_title", filters.examTitle);
  }

  if (filters?.examDate) {
    query = query.eq("exam_date", filters.examDate);
  }

  if (filters?.subjectGroupId) {
    query = query.eq("subject_group_id", filters.subjectGroupId);
  }

  const { data, error } = await query
    .order("exam_date", { ascending: false })
    .order("created_at", { ascending: false });

  if (error) throw error;
  return (data as MockScore[]) ?? [];
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function findMockScoreById(
  scoreId: string,
  studentId: string
): Promise<MockScore | null> {
  const supabase = await createSupabaseServerClient();

  const { data, error } = await supabase
    .from("student_mock_scores")
    .select("*")
    .eq("id", scoreId)
    .eq("student_id", studentId)
    .maybeSingle();

  if (error) throw error;
  return data as MockScore | null;
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± (ì •ê·œí™” ë²„ì „)
 *
 * student_termsë¥¼ ì¡°íšŒ/ìƒì„±í•˜ì—¬ student_term_idë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.
 * exam_dateë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•™ë…„ë„ì™€ í•™ê¸°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
 */
export async function insertMockScore(
  input: CreateMockScoreInput & {
    curriculum_revision_id: string;
    semester?: number;
  }
): Promise<string> {
  const supabase = await createSupabaseServerClient();

  // exam_dateë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•™ë…„ë„ ê³„ì‚°
  const examDate = new Date(input.exam_date);
  const school_year = calculateSchoolYear(examDate);

  // í•™ê¸° ê³„ì‚° (ì—†ìœ¼ë©´ exam_date ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •: 3~8ì›” = 1í•™ê¸°, 9~2ì›” = 2í•™ê¸°)
  const semester =
    input.semester ??
    (examDate.getMonth() + 1 >= 3 && examDate.getMonth() + 1 <= 8 ? 1 : 2);

  // student_term ì¡°íšŒ ë˜ëŠ” ìƒì„± (ì‹¤íŒ¨ ì‹œ NULL í—ˆìš©)
  let student_term_id: string | null = null;
  try {
    student_term_id = await getOrCreateStudentTerm({
      tenant_id: input.tenant_id,
      student_id: input.student_id,
      school_year,
      grade: input.grade,
      semester,
      curriculum_revision_id: input.curriculum_revision_id,
    });
  } catch (error) {
    // ëª¨ì˜ê³ ì‚¬ ì„±ì ì˜ ê²½ìš° student_term_idê°€ ì—†ì–´ë„ ì €ì¥ ê°€ëŠ¥
    console.warn(
      "[domains/score/repository] student_term ì¡°íšŒ/ìƒì„± ì‹¤íŒ¨ (NULLë¡œ ì €ì¥)",
      error
    );
    // student_term_idëŠ” nullë¡œ ìœ ì§€
  }

  const payload = {
    tenant_id: input.tenant_id,
    student_id: input.student_id,
    student_term_id: student_term_id ?? null, // student_term_id (nullable)
    exam_date: input.exam_date,
    exam_title: input.exam_title,
    grade: input.grade,
    subject_id: input.subject_id,
    subject_group_id: input.subject_group_id,
    raw_score: input.raw_score ?? null,
    standard_score: input.standard_score ?? null,
    percentile: input.percentile ?? null,
    grade_score: input.grade_score ?? null,
  };

  const { data, error } = await supabase
    .from("student_mock_scores")
    .insert(payload)
    .select("id")
    .single();

  if (error) throw error;
  return data.id;
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì •
 */
export async function updateMockScoreById(
  scoreId: string,
  studentId: string,
  updates: UpdateMockScoreInput
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const payload: Record<string, unknown> = {};

  if (updates.grade !== undefined) payload.grade = updates.grade;
  if (updates.exam_date !== undefined) payload.exam_date = updates.exam_date;
  if (updates.exam_title !== undefined) payload.exam_title = updates.exam_title;
  if (updates.subject_group_id !== undefined)
    payload.subject_group_id = updates.subject_group_id;
  if (updates.subject_id !== undefined) payload.subject_id = updates.subject_id;
  if (updates.raw_score !== undefined) payload.raw_score = updates.raw_score;
  if (updates.standard_score !== undefined)
    payload.standard_score = updates.standard_score;
  if (updates.percentile !== undefined) payload.percentile = updates.percentile;
  if (updates.grade_score !== undefined)
    payload.grade_score = updates.grade_score;

  const { error } = await supabase
    .from("student_mock_scores")
    .update(payload)
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error) throw error;
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ
 */
export async function deleteMockScoreById(
  scoreId: string,
  studentId: string
): Promise<void> {
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from("student_mock_scores")
    .delete()
    .eq("id", scoreId)
    .eq("student_id", studentId);

  if (error) throw error;
}
</file>

<file path="score/service.ts">
/**
 * Score ë„ë©”ì¸ Service
 *
 * ì´ íŒŒì¼ì€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 * - ë°ì´í„° ë³€í™˜ ë° ê°€ê³µ
 * - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ì ìš©
 * - Repository í˜¸ì¶œ ë° ì—ëŸ¬ ì²˜ë¦¬
 */

import * as repository from "./repository";
import type {
  SchoolScore,
  MockScore,
  GetSchoolScoresFilter,
  GetMockScoresFilter,
  CreateSchoolScoreInput,
  UpdateSchoolScoreInput,
  CreateMockScoreInput,
  UpdateMockScoreInput,
  ScoreActionResult,
} from "./types";

// ============================================
// ë‚´ì‹  ì„±ì  Service
// ============================================

/**
 * ë‚´ì‹  ì„±ì  ëª©ë¡ ì¡°íšŒ
 */
export async function getSchoolScores(
  studentId: string,
  tenantId?: string | null,
  filters?: GetSchoolScoresFilter
): Promise<SchoolScore[]> {
  try {
    return await repository.findSchoolScores(studentId, tenantId, filters);
  } catch (error) {
    console.error("[score/service] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ë‚´ì‹  ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function getSchoolScoreById(
  scoreId: string,
  studentId: string
): Promise<SchoolScore | null> {
  try {
    return await repository.findSchoolScoreById(scoreId, studentId);
  } catch (error) {
    console.error("[score/service] ë‚´ì‹  ì„±ì  ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * ë‚´ì‹  ì„±ì  ìƒì„±
 */
export async function createSchoolScore(
  input: CreateSchoolScoreInput
): Promise<ScoreActionResult> {
  try {
    // í•„ìˆ˜ í•„ë“œ ê²€ì¦
    if (!input.student_id) {
      return { success: false, error: "í•™ìƒ IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    if (!input.grade || input.grade < 1 || input.grade > 3) {
      return { success: false, error: "ì˜¬ë°”ë¥¸ í•™ë…„ì„ ì…ë ¥í•˜ì„¸ìš”. (1-3)" };
    }

    if (!input.semester || input.semester < 1 || input.semester > 2) {
      return { success: false, error: "ì˜¬ë°”ë¥¸ í•™ê¸°ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (1-2)" };
    }

    // ë“±ê¸‰ ê²€ì¦
    if (
      input.grade_score !== undefined &&
      input.grade_score !== null &&
      (input.grade_score < 1 || input.grade_score > 9)
    ) {
      return { success: false, error: "ë“±ê¸‰ì€ 1-9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    const scoreId = await repository.insertSchoolScore(input);
    return { success: true, scoreId };
  } catch (error) {
    console.error("[score/service] ë‚´ì‹  ì„±ì  ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì •
 */
export async function updateSchoolScore(
  scoreId: string,
  studentId: string,
  updates: UpdateSchoolScoreInput
): Promise<ScoreActionResult> {
  try {
    // ë“±ê¸‰ ê²€ì¦
    if (
      updates.grade_score !== undefined &&
      updates.grade_score !== null &&
      (updates.grade_score < 1 || updates.grade_score > 9)
    ) {
      return { success: false, error: "ë“±ê¸‰ì€ 1-9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findSchoolScoreById(scoreId, studentId);
    if (!existing) {
      return { success: false, error: "ì„±ì ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.updateSchoolScoreById(scoreId, studentId, updates);
    return { success: true, scoreId };
  } catch (error) {
    console.error("[score/service] ë‚´ì‹  ì„±ì  ìˆ˜ì • ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ë‚´ì‹  ì„±ì  ì‚­ì œ
 */
export async function deleteSchoolScore(
  scoreId: string,
  studentId: string
): Promise<ScoreActionResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findSchoolScoreById(scoreId, studentId);
    if (!existing) {
      return { success: false, error: "ì„±ì ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.deleteSchoolScoreById(scoreId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[score/service] ë‚´ì‹  ì„±ì  ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

// ============================================
// ëª¨ì˜ê³ ì‚¬ ì„±ì  Service
// ============================================

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ëª©ë¡ ì¡°íšŒ
 */
export async function getMockScores(
  studentId: string,
  tenantId?: string | null,
  filters?: GetMockScoresFilter
): Promise<MockScore[]> {
  try {
    return await repository.findMockScores(studentId, tenantId, filters);
  } catch (error) {
    console.error("[score/service] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨:", error);
    return [];
  }
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ë‹¨ê±´ ì¡°íšŒ
 */
export async function getMockScoreById(
  scoreId: string,
  studentId: string
): Promise<MockScore | null> {
  try {
    return await repository.findMockScoreById(scoreId, studentId);
  } catch (error) {
    console.error("[score/service] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„±
 */
export async function createMockScore(
  input: CreateMockScoreInput
): Promise<ScoreActionResult> {
  try {
    // í•„ìˆ˜ í•„ë“œ ê²€ì¦
    if (!input.student_id) {
      return { success: false, error: "í•™ìƒ IDê°€ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    if (!input.grade || input.grade < 1 || input.grade > 3) {
      return { success: false, error: "ì˜¬ë°”ë¥¸ í•™ë…„ì„ ì…ë ¥í•˜ì„¸ìš”. (1-3)" };
    }

    if (!input.exam_date || !input.exam_title) {
      return { success: false, error: "ì‹œí—˜ ë‚ ì§œì™€ ì‹œí—˜ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤." };
    }

    // ë“±ê¸‰ ê²€ì¦
    if (
      input.grade_score !== undefined &&
      input.grade_score !== null &&
      (input.grade_score < 1 || input.grade_score > 9)
    ) {
      return { success: false, error: "ë“±ê¸‰ì€ 1-9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    // ë°±ë¶„ìœ„ ê²€ì¦
    if (
      input.percentile !== undefined &&
      input.percentile !== null &&
      (input.percentile < 0 || input.percentile > 100)
    ) {
      return { success: false, error: "ë°±ë¶„ìœ„ëŠ” 0-100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    const scoreId = await repository.insertMockScore(input);
    return { success: true, scoreId };
  } catch (error) {
    console.error("[score/service] ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì •
 */
export async function updateMockScore(
  scoreId: string,
  studentId: string,
  updates: UpdateMockScoreInput
): Promise<ScoreActionResult> {
  try {
    // ë“±ê¸‰ ê²€ì¦
    if (
      updates.grade_score !== undefined &&
      updates.grade_score !== null &&
      (updates.grade_score < 1 || updates.grade_score > 9)
    ) {
      return { success: false, error: "ë“±ê¸‰ì€ 1-9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    // ë°±ë¶„ìœ„ ê²€ì¦
    if (
      updates.percentile !== undefined &&
      updates.percentile !== null &&
      (updates.percentile < 0 || updates.percentile > 100)
    ) {
      return { success: false, error: "ë°±ë¶„ìœ„ëŠ” 0-100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤." };
    }

    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findMockScoreById(scoreId, studentId);
    if (!existing) {
      return { success: false, error: "ì„±ì ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.updateMockScoreById(scoreId, studentId, updates);
    return { success: true, scoreId };
  } catch (error) {
    console.error("[score/service] ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì • ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ
 */
export async function deleteMockScore(
  scoreId: string,
  studentId: string
): Promise<ScoreActionResult> {
  try {
    // ê¸°ì¡´ ë°ì´í„° í™•ì¸
    const existing = await repository.findMockScoreById(scoreId, studentId);
    if (!existing) {
      return { success: false, error: "ì„±ì ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
    }

    await repository.deleteMockScoreById(scoreId, studentId);
    return { success: true };
  } catch (error) {
    console.error("[score/service] ëª¨ì˜ê³ ì‚¬ ì„±ì  ì‚­ì œ ì‹¤íŒ¨:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "ì„±ì  ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
    };
  }
}

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
// ============================================

/**
 * í•™ìƒì˜ í‰ê·  ë“±ê¸‰ ê³„ì‚°
 */
export async function calculateAverageGrade(
  studentId: string,
  tenantId?: string | null
): Promise<{ schoolAvg: number | null; mockAvg: number | null }> {
  try {
    const [schoolScores, mockScores] = await Promise.all([
      repository.findSchoolScores(studentId, tenantId),
      repository.findMockScores(studentId, tenantId),
    ]);

    const schoolGrades = schoolScores
      .filter((s) => s.grade_score !== null && s.grade_score !== undefined)
      .map((s) => s.grade_score as number);

    const mockGrades = mockScores
      .filter((s) => s.grade_score !== null && s.grade_score !== undefined)
      .map((s) => s.grade_score as number);

    const schoolAvg =
      schoolGrades.length > 0
        ? schoolGrades.reduce((a, b) => a + b, 0) / schoolGrades.length
        : null;

    const mockAvg =
      mockGrades.length > 0
        ? mockGrades.reduce((a, b) => a + b, 0) / mockGrades.length
        : null;

    return { schoolAvg, mockAvg };
  } catch (error) {
    console.error("[score/service] í‰ê·  ë“±ê¸‰ ê³„ì‚° ì‹¤íŒ¨:", error);
    return { schoolAvg: null, mockAvg: null };
  }
}

/**
 * ê³¼ëª©ë³„ ì„±ì  ì¶”ì´ ì¡°íšŒ
 */
export async function getScoreTrendBySubject(
  studentId: string,
  subjectGroupId: string,
  tenantId?: string | null
): Promise<{
  school: SchoolScore[];
  mock: MockScore[];
}> {
  try {
    const [schoolScores, mockScores] = await Promise.all([
      repository.findSchoolScores(studentId, tenantId, { subjectGroupId }),
      repository.findMockScores(studentId, tenantId, { subjectGroupId }),
    ]);

    return {
      school: schoolScores,
      mock: mockScores,
    };
  } catch (error) {
    console.error("[score/service] ì„±ì  ì¶”ì´ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return { school: [], mock: [] };
  }
}
</file>

<file path="score/types.ts">
/**
 * Score ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type { Tables, TablesInsert, TablesUpdate } from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * ë‚´ì‹  ì„±ì  íƒ€ì… (ì •ê·œí™” ë²„ì „)
 */
export type InternalScore = Tables<"student_internal_scores">;

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type InternalScoreInsert = TablesInsert<"student_internal_scores">;

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type InternalScoreUpdate = TablesUpdate<"student_internal_scores">;

/**
 * ë‚´ì‹  ì„±ì  íƒ€ì… (ë ˆê±°ì‹œ - í•˜ìœ„ í˜¸í™˜ì„±)
 * @deprecated InternalScoreë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export type SchoolScore = Tables<"student_school_scores">;

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± ì…ë ¥ íƒ€ì… (ë ˆê±°ì‹œ)
 * @deprecated InternalScoreInsertë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export type SchoolScoreInsert = TablesInsert<"student_school_scores">;

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì • ì…ë ¥ íƒ€ì… (ë ˆê±°ì‹œ)
 * @deprecated InternalScoreUpdateë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export type SchoolScoreUpdate = TablesUpdate<"student_school_scores">;

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  íƒ€ì…
 */
export type MockScore = Tables<"student_mock_scores">;

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type MockScoreInsert = TablesInsert<"student_mock_scores">;

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type MockScoreUpdate = TablesUpdate<"student_mock_scores">;

// ============================================
// ë ˆê±°ì‹œ íƒ€ì… (í•˜ìœ„ í˜¸í™˜ì„±)
// ============================================

/**
 * í†µí•© ì„±ì  íƒ€ì… (legacy student_scores í…Œì´ë¸”)
 * @deprecated ë‚´ì‹ /ëª¨ì˜ê³ ì‚¬ ë³„ë„ í…Œì´ë¸” ì‚¬ìš© ê¶Œì¥
 */
export type StudentScore = {
  id: string;
  tenant_id?: string | null;
  student_id: string;
  subject_type: string;
  semester?: string | null;
  course: string;
  course_detail: string;
  raw_score: number;
  grade: number;
  score_type_detail?: string | null;
  test_date?: string | null;
  created_at?: string | null;
};

// ============================================
// ì¡°íšŒ í•„í„° íƒ€ì…
// ============================================

/**
 * ë‚´ì‹  ì„±ì  ì¡°íšŒ í•„í„°
 */
export type GetSchoolScoresFilter = {
  grade?: number;
  semester?: number;
  subjectGroup?: string;
  subjectGroupId?: string;
};

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ì¡°íšŒ í•„í„°
 */
export type GetMockScoresFilter = {
  grade?: number;
  examTitle?: string;
  examDate?: string;
  subjectGroup?: string;
  subjectGroupId?: string;
};

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ìš© ì…ë ¥ íƒ€ì…
// ============================================

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± ì…ë ¥ (ì„œë¹„ìŠ¤ìš© - ì •ê·œí™” ë²„ì „)
 */
export type CreateInternalScoreInput = {
  tenant_id: string;
  student_id: string;
  curriculum_revision_id: string;
  subject_group_id: string;
  subject_type_id: string;
  subject_id: string;
  grade: number;
  semester: number;
  credit_hours: number;
  raw_score?: number | null;
  avg_score?: number | null;
  std_dev?: number | null;
  rank_grade?: number | null;
  total_students?: number | null;
};

/**
 * ë‚´ì‹  ì„±ì  ìƒì„± ì…ë ¥ (ì„œë¹„ìŠ¤ìš© - ë ˆê±°ì‹œ)
 * @deprecated CreateInternalScoreInputì„ ì‚¬ìš©í•˜ì„¸ìš”
 */
export type CreateSchoolScoreInput = {
  tenant_id?: string | null;
  student_id: string;
  grade: number;
  semester: number;
  // FK í•„ë“œ
  subject_group_id?: string | null;
  subject_id?: string | null;
  subject_type_id?: string | null;
  // deprecated í…ìŠ¤íŠ¸ í•„ë“œ
  subject_group?: string | null;
  subject_type?: string | null;
  subject_name?: string | null;
  // ì„±ì  ì •ë³´
  credit_hours?: number | null;
  raw_score?: number | null;
  subject_average?: number | null;
  standard_deviation?: number | null;
  grade_score?: number | null;
  total_students?: number | null;
  rank_grade?: number | null;
};

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì • ì…ë ¥ (ì„œë¹„ìŠ¤ìš© - ì •ê·œí™” ë²„ì „)
 */
export type UpdateInternalScoreInput = Partial<
  Omit<InternalScore, "id" | "student_id" | "tenant_id" | "created_at" | "updated_at">
>;

/**
 * ë‚´ì‹  ì„±ì  ìˆ˜ì • ì…ë ¥ (ì„œë¹„ìŠ¤ìš© - ë ˆê±°ì‹œ)
 * @deprecated UpdateInternalScoreInputì„ ì‚¬ìš©í•˜ì„¸ìš”
 */
export type UpdateSchoolScoreInput = Partial<
  Omit<SchoolScore, "id" | "student_id" | "tenant_id" | "created_at" | "updated_at">
>;

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìƒì„± ì…ë ¥ (ì„œë¹„ìŠ¤ìš© - ì •ê·œí™” ë²„ì „)
 */
export type CreateMockScoreInput = {
  tenant_id: string;
  student_id: string;
  exam_date: string; // date í˜•ì‹: YYYY-MM-DD
  exam_title: string;
  grade: number;
  subject_id: string;
  subject_group_id: string;
  curriculum_revision_id: string; // student_term ìƒì„±ì— í•„ìš”
  raw_score?: number | null;
  standard_score?: number | null;
  percentile?: number | null;
  grade_score?: number | null;
  semester?: number; // í•™ê¸° (ì„ íƒì‚¬í•­, ì—†ìœ¼ë©´ exam_date ê¸°ì¤€ìœ¼ë¡œ ì¶”ì •)
};

/**
 * ëª¨ì˜ê³ ì‚¬ ì„±ì  ìˆ˜ì • ì…ë ¥ (ì„œë¹„ìŠ¤ìš©)
 */
export type UpdateMockScoreInput = Partial<
  Omit<MockScore, "id" | "student_id" | "tenant_id" | "created_at" | "updated_at">
>;

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * ì„±ì  ì•¡ì…˜ ê²°ê³¼
 */
export type ScoreActionResult = {
  success: boolean;
  error?: string;
  scoreId?: string;
};

// ============================================
// ëª¨ì˜ê³ ì‚¬ ìœ í˜• Enum
// ============================================

/**
 * ëª¨ì˜ê³ ì‚¬ ìœ í˜•
 */
export type MockExamType = "ìˆ˜ëŠ¥" | "í‰ê°€ì›" | "êµìœ¡ì²­" | "ì‚¬ì„¤";
</file>

<file path="score/validation.ts">
/**
 * Score ë„ë©”ì¸ ê²€ì¦ ìŠ¤í‚¤ë§ˆ
 */

import { z } from "zod";

// ============================================
// ê¸°ë³¸ í•„ë“œ ìŠ¤í‚¤ë§ˆ
// ============================================

export const gradeSchema = z
  .number()
  .int()
  .min(1, "í•™ë…„ì€ 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
  .max(3, "í•™ë…„ì€ 3 ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤");

export const semesterSchema = z
  .number()
  .int()
  .min(1, "í•™ê¸°ëŠ” 1 ë˜ëŠ” 2ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .max(2, "í•™ê¸°ëŠ” 1 ë˜ëŠ” 2ì—¬ì•¼ í•©ë‹ˆë‹¤");

export const gradeScoreSchema = z
  .number()
  .int()
  .min(1, "ë“±ê¸‰ì€ 1~9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .max(9, "ë“±ê¸‰ì€ 1~9 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤");

export const rawScoreSchema = z
  .number()
  .min(0, "ì›ì ìˆ˜ëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
  .optional()
  .nullable();

export const percentileSchema = z
  .number()
  .min(0, "ë°±ë¶„ìœ„ëŠ” 0~100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .max(100, "ë°±ë¶„ìœ„ëŠ” 0~100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .optional()
  .nullable();

export const examTypeSchema = z.enum(["ìˆ˜ëŠ¥", "í‰ê°€ì›", "êµìœ¡ì²­", "ì‚¬ì„¤"]);

// ============================================
// ë‚´ì‹  ì„±ì  ìŠ¤í‚¤ë§ˆ
// ============================================

export const createSchoolScoreSchema = z.object({
  grade: gradeSchema,
  semester: semesterSchema,
  // FK í•„ë“œ
  subject_group_id: z.string().uuid().optional().nullable(),
  subject_id: z.string().uuid().optional().nullable(),
  subject_type_id: z.string().uuid().optional().nullable(),
  // í…ìŠ¤íŠ¸ í•„ë“œ (deprecated but still validated)
  subject_group: z.string().min(1, "êµê³¼ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”").optional().nullable(),
  subject_type: z.string().optional().nullable(),
  subject_name: z.string().min(1, "ê³¼ëª©ì„ ì„ íƒí•´ì£¼ì„¸ìš”").optional().nullable(),
  credit_hours: z.number().positive("í•™ì ìˆ˜ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤").optional().nullable(),
  raw_score: z.number().min(0, "ì›ì ìˆ˜ëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
  subject_average: z.number().optional().nullable(),
  standard_deviation: z.number().optional().nullable(),
  grade_score: gradeScoreSchema,
  total_students: z.number().positive("ìˆ˜ê°•ììˆ˜ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤").optional().nullable(),
  rank_grade: gradeScoreSchema.optional().nullable(),
});

export const updateSchoolScoreSchema = createSchoolScoreSchema.partial();

// ============================================
// ëª¨ì˜ê³ ì‚¬ ì„±ì  ìŠ¤í‚¤ë§ˆ
// ============================================

// base schema (partialì„ ìœ„í•´ ë¶„ë¦¬)
const mockScoreBaseSchema = z.object({
  grade: gradeSchema,
  exam_type: z.string().min(1, "ì‹œí—˜ ìœ í˜•ì„ ì„ íƒí•´ì£¼ì„¸ìš”"),
  // FK í•„ë“œ
  subject_group_id: z.string().uuid().optional().nullable(),
  subject_id: z.string().uuid().optional().nullable(),
  subject_type_id: z.string().uuid().optional().nullable(),
  // í…ìŠ¤íŠ¸ í•„ë“œ (deprecated but still validated)
  subject_group: z.string().min(1, "êµê³¼ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”").optional().nullable(),
  subject_name: z.string().optional().nullable(),
  raw_score: rawScoreSchema,
  standard_score: z.number().optional().nullable(),
  percentile: percentileSchema,
  grade_score: gradeScoreSchema,
  exam_round: z.string().optional().nullable(),
});

export const createMockScoreSchema = mockScoreBaseSchema.refine(
  (data) => {
    // ì˜ì–´/í•œêµ­ì‚¬ê°€ ì•„ë‹Œ ê²½ìš° í‘œì¤€ì ìˆ˜, ë°±ë¶„ìœ„ í•„ìˆ˜ ì²´í¬ëŠ” actionì—ì„œ ìˆ˜í–‰
    return true;
  },
  {
    message: "í‘œì¤€ì ìˆ˜ì™€ ë°±ë¶„ìœ„ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.",
  }
);

export const updateMockScoreSchema = mockScoreBaseSchema.partial();

// ============================================
// íƒ€ì… ì¶”ë¡ 
// ============================================

export type CreateSchoolScoreFormData = z.infer<typeof createSchoolScoreSchema>;
export type UpdateSchoolScoreFormData = z.infer<typeof updateSchoolScoreSchema>;
export type CreateMockScoreFormData = z.infer<typeof createMockScoreSchema>;
export type UpdateMockScoreFormData = z.infer<typeof updateMockScoreSchema>;
</file>

<file path="student/index.ts">
/**
 * Student ë„ë©”ì¸ Public API
 */

// Types
export * from "./types";

// í–¥í›„ ì¶”ê°€ ì˜ˆì •:
// export * as service from "./service";
// export * from "./actions";
</file>

<file path="student/types.ts">
/**
 * Student ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type {
  Tables,
  TablesInsert,
  TablesUpdate,
} from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * í•™ìƒ íƒ€ì…
 */
export type Student = Tables<"students">;

/**
 * í•™ìƒ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type StudentInsert = TablesInsert<"students">;

/**
 * í•™ìƒ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type StudentUpdate = TablesUpdate<"students">;

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ìš© íƒ€ì…
// ============================================

/**
 * í•™ìƒ ì¡°íšŒ í•„í„°
 */
export type GetStudentsFilter = {
  tenantId: string;
  schoolId?: string;
  grade?: number;
};

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * í•™ìƒ ì•¡ì…˜ ê²°ê³¼
 */
export type StudentActionResult = {
  success: boolean;
  error?: string;
  studentId?: string;
  student?: Student;
};
</file>

<file path="subject/index.ts">
/**
 * Subject ë„ë©”ì¸ Public API
 */

// Types
export * from "./types";

// í–¥í›„ ì¶”ê°€ ì˜ˆì •:
// export * as service from "./service";
// export * from "./actions";
</file>

<file path="subject/types.ts">
/**
 * Subject ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type {
  Tables,
  TablesInsert,
  TablesUpdate,
} from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * êµê³¼ ê·¸ë£¹ íƒ€ì…
 */
export type SubjectGroup = Tables<"subject_groups">;

/**
 * êµê³¼ ê·¸ë£¹ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type SubjectGroupInsert = TablesInsert<"subject_groups">;

/**
 * êµê³¼ ê·¸ë£¹ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type SubjectGroupUpdate = TablesUpdate<"subject_groups">;

/**
 * ê³¼ëª© íƒ€ì…
 */
export type Subject = Tables<"subjects">;

/**
 * ê³¼ëª© ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type SubjectInsert = TablesInsert<"subjects">;

/**
 * ê³¼ëª© ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type SubjectUpdate = TablesUpdate<"subjects">;

/**
 * ê³¼ëª© êµ¬ë¶„ íƒ€ì…
 */
export type SubjectType = Tables<"subject_types">;

/**
 * ê³¼ëª© êµ¬ë¶„ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type SubjectTypeInsert = TablesInsert<"subject_types">;

/**
 * ê³¼ëª© êµ¬ë¶„ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type SubjectTypeUpdate = TablesUpdate<"subject_types">;

// ============================================
// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ìš© íƒ€ì…
// ============================================

/**
 * êµê³¼ ê·¸ë£¹ ì¡°íšŒ í•„í„°
 */
export type GetSubjectGroupsFilter = {
  tenantId?: string | null;
};

/**
 * ê³¼ëª© ì¡°íšŒ í•„í„°
 */
export type GetSubjectsFilter = {
  tenantId?: string | null;
  subjectGroupId?: string;
};

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * êµê³¼ ì•¡ì…˜ ê²°ê³¼
 */
export type SubjectActionResult = {
  success: boolean;
  error?: string;
  subjectId?: string;
  subject?: Subject;
};
</file>

<file path="tenant/index.ts">
/**
 * Tenant ë„ë©”ì¸ Public API
 */

// Types
export * from "./types";

// í–¥í›„ ì¶”ê°€ ì˜ˆì •:
// export * as service from "./service";
// export * from "./actions";
</file>

<file path="tenant/types.ts">
/**
 * Tenant ë„ë©”ì¸ íƒ€ì… ì •ì˜
 *
 * Supabase Database íƒ€ì…ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤.
 * @see lib/supabase/database.types.ts
 */

import type {
  Tables,
  TablesInsert,
  TablesUpdate,
} from "@/lib/supabase/database.types";

// ============================================
// Database íƒ€ì…ì—ì„œ íŒŒìƒëœ íƒ€ì…
// ============================================

/**
 * í…Œë„ŒíŠ¸ íƒ€ì…
 */
export type Tenant = Tables<"tenants">;

/**
 * í…Œë„ŒíŠ¸ ìƒì„± ì…ë ¥ íƒ€ì…
 */
export type TenantInsert = TablesInsert<"tenants">;

/**
 * í…Œë„ŒíŠ¸ ìˆ˜ì • ì…ë ¥ íƒ€ì…
 */
export type TenantUpdate = TablesUpdate<"tenants">;

// ============================================
// ì‘ë‹µ íƒ€ì…
// ============================================

/**
 * í…Œë„ŒíŠ¸ ì•¡ì…˜ ê²°ê³¼
 */
export type TenantActionResult = {
  success: boolean;
  error?: string;
  tenantId?: string;
  tenant?: Tenant;
};
</file>

<file path="index.ts">
/**
 * Domains Public API
 *
 * ëª¨ë“  ë„ë©”ì¸ ëª¨ë“ˆì„ ì¤‘ì•™ì—ì„œ exportí•©ë‹ˆë‹¤.
 *
 * @example
 * // ë„ë©”ì¸ ì „ì²´ import
 * import { school, score, plan, camp, student, subject, tenant } from "@/lib/domains";
 *
 * // ê°œë³„ íƒ€ì… import
 * import type { School, Region } from "@/lib/domains/school";
 * import type { SchoolScore, MockScore } from "@/lib/domains/score";
 * import type { PlanGroup, StudentPlan } from "@/lib/domains/plan";
 */

// School ë„ë©”ì¸
export * as school from "./school";

// Score ë„ë©”ì¸
export * as score from "./score";

// Plan ë„ë©”ì¸
export * as plan from "./plan";

// Camp ë„ë©”ì¸
export * as camp from "./camp";

// Student ë„ë©”ì¸
export * as student from "./student";

// Subject ë„ë©”ì¸
export * as subject from "./subject";

// Tenant ë„ë©”ì¸
export * as tenant from "./tenant";

// QR Code ë„ë©”ì¸
export * as qrCode from "./qrCode";

// ê¸°íƒ€ ë„ë©”ì¸ (í–¥í›„ ì¶”ê°€ ì˜ˆì •)
// export * as content from "./content";
// export * as goal from "./goal";
// export * as auth from "./auth";
// export * as block from "./block";
</file>

<file path="engine.ts">
import type { WeeklyMetricsData } from "./getWeeklyMetrics";

export type WeeklyCoaching = {
  highlights: string[]; // ì´ë²ˆì£¼ ì˜í•œ ì 
  warnings: string[]; // ì£¼ì˜í•  ì 
  nextWeekGuide: string[]; // ë‹¤ìŒì£¼ ê°€ì´ë“œ
  summary: string; // 1ì¤„ ìš”ì•½
};

/**
 * Rule-based Coaching Engine
 * ì£¼ê°„ ë©”íŠ¸ë¦­ì„ ê¸°ë°˜ìœ¼ë¡œ ì½”ì¹­ ë©”ì‹œì§€ ìƒì„±
 */
export function coachingEngine(metrics: WeeklyMetricsData): WeeklyCoaching {
  const highlights: string[] = [];
  const warnings: string[] = [];
  const nextWeekGuide: string[] = [];

  // ============================================
  // 1. HIGHLIGHTS (ì´ë²ˆì£¼ ì˜í•œ ì )
  // ============================================

  // í•™ìŠµì‹œê°„ ì§€ë‚œì£¼ ëŒ€ë¹„ +20% ì´ìƒ
  if (metrics.weeklyStudyTrend >= 20) {
    highlights.push("í•™ìŠµëŸ‰ì´ í¬ê²Œ ëŠ˜ì—ˆì–´ìš”! ì§€ë‚œì£¼ ëŒ€ë¹„ " + Math.abs(metrics.weeklyStudyTrend) + "% ì¦ê°€í–ˆìŠµë‹ˆë‹¤.");
  } else if (metrics.weeklyStudyTrend > 0) {
    highlights.push("í•™ìŠµëŸ‰ì´ ì§€ë‚œì£¼ë³´ë‹¤ ëŠ˜ì—ˆì–´ìš”! " + Math.abs(metrics.weeklyStudyTrend) + "% ì¦ê°€í–ˆìŠµë‹ˆë‹¤.");
  }

  // í”Œëœ ì‹¤í–‰ë¥  > 70%
  if (metrics.weeklyPlanCompletion >= 70) {
    highlights.push("ê³„íš ì‹¤í–‰ë ¥ì´ ë§¤ìš° ì¢‹ìŠµë‹ˆë‹¤. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ë¥¼ ë‹¬ì„±í–ˆì–´ìš”.");
  } else if (metrics.weeklyPlanCompletion >= 60) {
    highlights.push("ê³„íš ì‹¤í–‰ë ¥ì´ ì–‘í˜¸í•©ë‹ˆë‹¤. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ë¥¼ ë‹¬ì„±í–ˆì–´ìš”.");
  }

  // ëª©í‘œ ë‹¬ì„± 1ê°œ ì´ìƒ (ì§„í–‰ë¥  100%)
  if (metrics.weeklyGoalsProgress >= 100) {
    highlights.push("ëª©í‘œë¥¼ ì™„ì£¼í–ˆì–´ìš”! í›Œë¥­í•œ ì„±ê³¼ì…ë‹ˆë‹¤.");
  } else if (metrics.weeklyGoalsProgress >= 80) {
    highlights.push("ëª©í‘œ ë‹¬ì„±ë¥ ì´ ë†’ì•„ìš”! " + metrics.weeklyGoalsProgress + "% ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.");
  }

  // ì—°ì†ì„± ì ìˆ˜ ë†’ìŒ
  if (metrics.consistencyScore >= 80) {
    highlights.push("ë§¤ì¼ ê¾¸ì¤€íˆ í•™ìŠµí•˜ëŠ” ìŠµê´€ì´ ì˜ í˜•ì„±ë˜ì–´ ìˆì–´ìš”!");
  } else if (metrics.consistencyScore >= 60) {
    highlights.push("í•™ìŠµ ì—°ì†ì„±ì´ ì¢‹ì•„ìš”!");
  }

  // ì§‘ì¤‘ ì ìˆ˜ ë†’ìŒ
  if (metrics.focusScore >= 80) {
    highlights.push("ì§‘ì¤‘ë ¥ì´ ë›°ì–´ë‚˜ìš”! ê¸´ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ í•™ìŠµí•˜ê³  ìˆì–´ìš”.");
  } else if (metrics.focusScore >= 60) {
    highlights.push("ì§‘ì¤‘í•´ì„œ í•™ìŠµí•˜ëŠ” ëª¨ìŠµì´ ë³´ì—¬ìš”!");
  }

  // ============================================
  // 2. WARNINGS (ì£¼ì˜í•  ì )
  // ============================================

  // ì‹¤í–‰ë¥  < 40%
  if (metrics.weeklyPlanCompletion < 40 && metrics.weeklyPlanCompletion > 0) {
    warnings.push("ì´ë²ˆì£¼ëŠ” ê³„íš ëŒ€ë¹„ ì‹¤í–‰ì´ ë‚®ì•˜ì–´ìš”. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ì…ë‹ˆë‹¤.");
  }

  // í•™ìŠµì‹œê°„ ê¸‰ê°
  if (metrics.weeklyStudyTrend < -20) {
    warnings.push("í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ " + Math.abs(metrics.weeklyStudyTrend) + "% ê°ì†Œí–ˆì–´ìš”.");
  }

  // ì·¨ì•½ ê³¼ëª© í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (metrics.weakSubjects.length > 0) {
    warnings.push("ì·¨ì•½ ê³¼ëª© í•™ìŠµì´ ë¶€ì¡±í–ˆì–´ìš”. (" + metrics.weakSubjects.join(", ") + ")");
  }

  // Risk Levelì´ high
  if (metrics.riskLevel === "high") {
    warnings.push("ì§‘ì¤‘ ê´€ë¦¬ê°€ í•„ìš”í•œ ìƒíƒœì˜ˆìš”. í•™ìŠµ íŒ¨í„´ì„ ì ê²€í•´ë³´ì„¸ìš”.");
  } else if (metrics.riskLevel === "medium") {
    warnings.push("í•™ìŠµ ìƒíƒœë¥¼ ì£¼ì˜ ê¹Šê²Œ ê´€ì°°í•´ì•¼ í•´ìš”.");
  }

  // ì—°ì†ì„± ì ìˆ˜ ë‚®ìŒ
  if (metrics.consistencyScore < 40) {
    warnings.push("í•™ìŠµ ì—°ì†ì„±ì´ ë‚®ì•„ìš”. ë§¤ì¼ ì¡°ê¸ˆì”©ì´ë¼ë„ í•™ìŠµí•˜ëŠ” ìŠµê´€ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”.");
  }

  // ì§‘ì¤‘ ì ìˆ˜ ë‚®ìŒ
  if (metrics.focusScore < 40) {
    warnings.push("ì§‘ì¤‘ ì‹œê°„ì´ ì§§ì•„ìš”. ë” ê¸´ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ í•™ìŠµí•´ë³´ì„¸ìš”.");
  }

  // ëª©í‘œ ì§„í–‰ë¥  ì €ì¡°
  if (metrics.weeklyGoalsProgress < 30 && metrics.weeklyGoalsProgress > 0) {
    warnings.push("ëª©í‘œ ì§„í–‰ë¥ ì´ ë‚®ì•„ìš”. í˜„ì¬ " + metrics.weeklyGoalsProgress + "% ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.");
  }

  // ============================================
  // 3. NEXT WEEK GUIDE (ë‹¤ìŒì£¼ ê°€ì´ë“œ)
  // ============================================

  // ëª©í‘œ D-7 ì´í•˜ ì¡´ì¬ ì‹œ
  // (ì´ ì •ë³´ëŠ” metricsì— ì§ì ‘ í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì¶”ì²œ ì—”ì§„ ê²°ê³¼ë¥¼ í™œìš©)
  const urgentGoalRecommendations = metrics.recommendations.filter((rec) =>
    rec.includes("ëª©í‘œ") || rec.includes("ë§ˆê°") || rec.includes("D-")
  );
  if (urgentGoalRecommendations.length > 0) {
    nextWeekGuide.push("ë‹¤ìŒì£¼ëŠ” í•´ë‹¹ ëª©í‘œ ìš°ì„  ì§‘ì¤‘ì´ í•„ìš”í•´ìš”: " + urgentGoalRecommendations[0]);
  }

  // í”Œëœ ì‹¤í–‰ë¥  ë‚®ìŒ â†’ í”Œëœ ìˆ˜ ì¤„ì´ê¸° ì¶”ì²œ
  if (metrics.weeklyPlanCompletion < 50) {
    nextWeekGuide.push("í”Œëœ ìˆ˜ë¥¼ ì¤„ì´ê³  ì‹¤í–‰ ê°€ëŠ¥ì„±ì„ ë†’ì´ëŠ” ì£¼ê°„ ì „ëµì„ ì¶”ì²œí•´ìš”.");
  }

  // ì¶”ì²œ ì—”ì§„ì— 'í•™ìŠµ ë¹„ì¤‘ ì¡°ì •' í•­ëª© ìˆìœ¼ë©´ ë°˜ì˜
  const balanceRecommendations = metrics.recommendations.filter(
    (rec) => rec.includes("ë¹„ì¤‘") || rec.includes("ê· í˜•") || rec.includes("ì¡°ì •")
  );
  if (balanceRecommendations.length > 0) {
    nextWeekGuide.push(balanceRecommendations[0]);
  }

  // ì·¨ì•½ ê³¼ëª© í•™ìŠµ ê°•í™”
  if (metrics.weakSubjects.length > 0) {
    nextWeekGuide.push(
      "ì·¨ì•½ ê³¼ëª©(" + metrics.weakSubjects.join(", ") + ") í•™ìŠµ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”."
    );
  }

  // í•™ìŠµì‹œê°„ ë¶€ì¡± ì‹œ
  if (metrics.weeklyStudyMinutes < 5 * 60) {
    // 5ì‹œê°„ ë¯¸ë§Œ
    nextWeekGuide.push("ë‹¤ìŒì£¼ëŠ” í•™ìŠµ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”. í•˜ë£¨ ìµœì†Œ 1ì‹œê°„ ì´ìƒ í•™ìŠµì„ ëª©í‘œë¡œ í•´ë³´ì„¸ìš”.");
  }

  // ì—°ì†ì„± ê°œì„ 
  if (metrics.consistencyScore < 60) {
    nextWeekGuide.push("ë§¤ì¼ ì¡°ê¸ˆì”©ì´ë¼ë„ í•™ìŠµí•˜ëŠ” ìŠµê´€ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”. ì—°ì† í•™ìŠµì¼ì„ ëŠ˜ë ¤ê°€ìš”.");
  }

  // ì§‘ì¤‘ë ¥ ê°œì„ 
  if (metrics.focusScore < 60) {
    nextWeekGuide.push("ì§‘ì¤‘ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”. 30ë¶„ ì´ìƒ ì—°ì†ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ì„¸ì…˜ì„ ëŠ˜ë ¤ê°€ìš”.");
  }

  // ê¸°ë³¸ ê°€ì´ë“œ (ìœ„ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
  if (nextWeekGuide.length === 0) {
    nextWeekGuide.push("ì´ë²ˆì£¼ì²˜ëŸ¼ ê¾¸ì¤€íˆ í•™ìŠµì„ ì´ì–´ê°€ì„¸ìš”!");
  }

  // ============================================
  // 4. SUMMARY (1ì¤„ ìš”ì•½)
  // ============================================

  const summary = generateSummary(metrics);

  return {
    highlights: highlights.length > 0 ? highlights : ["ì´ë²ˆì£¼ë„ ìˆ˜ê³ í•˜ì…¨ì–´ìš”!"],
    warnings: warnings.length > 0 ? warnings : [],
    nextWeekGuide: nextWeekGuide.length > 0 ? nextWeekGuide : ["ë‹¤ìŒì£¼ë„ í™”ì´íŒ…!"],
    summary,
  };
}

/**
 * Summary ìƒì„± (1ì¤„ ìš”ì•½)
 * ì‹¤í–‰ë¥  + ëª©í‘œ + ì§‘ì¤‘ ì ìˆ˜ ê¸°ë°˜
 */
function generateSummary(metrics: WeeklyMetricsData): string {
  // ì‹¤í–‰ë¥  ê¸°ë°˜ í‰ê°€
  let executionRating = "";
  if (metrics.weeklyPlanCompletion >= 80) {
    executionRating = "ë§¤ìš° ìš°ìˆ˜í•œ";
  } else if (metrics.weeklyPlanCompletion >= 60) {
    executionRating = "ì–‘í˜¸í•œ";
  } else if (metrics.weeklyPlanCompletion >= 40) {
    executionRating = "ë³´í†µì˜";
  } else {
    executionRating = "ê°œì„ ì´ í•„ìš”í•œ";
  }

  // ëª©í‘œ ë‹¬ì„±ë¥  ê¸°ë°˜ í‰ê°€
  let goalRating = "";
  if (metrics.weeklyGoalsProgress >= 80) {
    goalRating = "ëª©í‘œ ë‹¬ì„±ë¥ ì´ ë†’ê³ ";
  } else if (metrics.weeklyGoalsProgress >= 50) {
    goalRating = "ëª©í‘œ ì§„í–‰ì´ ìˆœì¡°ë¡­ê³ ";
  } else if (metrics.weeklyGoalsProgress > 0) {
    goalRating = "ëª©í‘œ ì§„í–‰ì´ í•„ìš”í•˜ê³ ";
  } else {
    goalRating = "ëª©í‘œ ì„¤ì •ì´ í•„ìš”í•˜ê³ ";
  }

  // ì§‘ì¤‘ ì ìˆ˜ ê¸°ë°˜ í‰ê°€
  let focusRating = "";
  if (metrics.focusScore >= 70) {
    focusRating = "ì§‘ì¤‘ë ¥ì´ ë›°ì–´ë‚œ";
  } else if (metrics.focusScore >= 50) {
    focusRating = "ì§‘ì¤‘ë ¥ì´ ì–‘í˜¸í•œ";
  } else {
    focusRating = "ì§‘ì¤‘ë ¥ ê°œì„ ì´ í•„ìš”í•œ";
  }

  // Risk Level ê¸°ë°˜ í‰ê°€
  let riskNote = "";
  if (metrics.riskLevel === "high") {
    riskNote = " ì£¼ì˜ê°€ í•„ìš”í•´ìš”.";
  } else if (metrics.riskLevel === "medium") {
    riskNote = " ê´€ì‹¬ì´ í•„ìš”í•´ìš”.";
  } else {
    riskNote = " ì•ˆì •ì ì¸ ìƒíƒœì˜ˆìš”.";
  }

  // ìµœì¢… ìš”ì•½ ìƒì„±
  return `${executionRating} ì‹¤í–‰ë ¥ê³¼ ${goalRating} ${focusRating} í•™ìŠµ ìƒíƒœì…ë‹ˆë‹¤.${riskNote}`;
}
</file>

<file path="engine.ts">
import type { WeeklyMetricsData } from "./getWeeklyMetrics";

export type WeeklyCoaching = {
  highlights: string[]; // ì´ë²ˆì£¼ ì˜í•œ ì 
  warnings: string[]; // ì£¼ì˜í•  ì 
  nextWeekGuide: string[]; // ë‹¤ìŒì£¼ ê°€ì´ë“œ
  summary: string; // 1ì¤„ ìš”ì•½
};

/**
 * Rule-based Coaching Engine
 * ì£¼ê°„ ë©”íŠ¸ë¦­ì„ ê¸°ë°˜ìœ¼ë¡œ ì½”ì¹­ ë©”ì‹œì§€ ìƒì„±
 */
export function coachingEngine(metrics: WeeklyMetricsData): WeeklyCoaching {
  const highlights: string[] = [];
  const warnings: string[] = [];
  const nextWeekGuide: string[] = [];

  // ============================================
  // 1. HIGHLIGHTS (ì´ë²ˆì£¼ ì˜í•œ ì )
  // ============================================

  // í•™ìŠµì‹œê°„ ì§€ë‚œì£¼ ëŒ€ë¹„ +20% ì´ìƒ
  if (metrics.weeklyStudyTrend >= 20) {
    highlights.push("í•™ìŠµëŸ‰ì´ í¬ê²Œ ëŠ˜ì—ˆì–´ìš”! ì§€ë‚œì£¼ ëŒ€ë¹„ " + Math.abs(metrics.weeklyStudyTrend) + "% ì¦ê°€í–ˆìŠµë‹ˆë‹¤.");
  } else if (metrics.weeklyStudyTrend > 0) {
    highlights.push("í•™ìŠµëŸ‰ì´ ì§€ë‚œì£¼ë³´ë‹¤ ëŠ˜ì—ˆì–´ìš”! " + Math.abs(metrics.weeklyStudyTrend) + "% ì¦ê°€í–ˆìŠµë‹ˆë‹¤.");
  }

  // í”Œëœ ì‹¤í–‰ë¥  > 70%
  if (metrics.weeklyPlanCompletion >= 70) {
    highlights.push("ê³„íš ì‹¤í–‰ë ¥ì´ ë§¤ìš° ì¢‹ìŠµë‹ˆë‹¤. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ë¥¼ ë‹¬ì„±í–ˆì–´ìš”.");
  } else if (metrics.weeklyPlanCompletion >= 60) {
    highlights.push("ê³„íš ì‹¤í–‰ë ¥ì´ ì–‘í˜¸í•©ë‹ˆë‹¤. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ë¥¼ ë‹¬ì„±í–ˆì–´ìš”.");
  }

  // ëª©í‘œ ë‹¬ì„± 1ê°œ ì´ìƒ (ì§„í–‰ë¥  100%)
  if (metrics.weeklyGoalsProgress >= 100) {
    highlights.push("ëª©í‘œë¥¼ ì™„ì£¼í–ˆì–´ìš”! í›Œë¥­í•œ ì„±ê³¼ì…ë‹ˆë‹¤.");
  } else if (metrics.weeklyGoalsProgress >= 80) {
    highlights.push("ëª©í‘œ ë‹¬ì„±ë¥ ì´ ë†’ì•„ìš”! " + metrics.weeklyGoalsProgress + "% ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.");
  }

  // ì—°ì†ì„± ì ìˆ˜ ë†’ìŒ
  if (metrics.consistencyScore >= 80) {
    highlights.push("ë§¤ì¼ ê¾¸ì¤€íˆ í•™ìŠµí•˜ëŠ” ìŠµê´€ì´ ì˜ í˜•ì„±ë˜ì–´ ìˆì–´ìš”!");
  } else if (metrics.consistencyScore >= 60) {
    highlights.push("í•™ìŠµ ì—°ì†ì„±ì´ ì¢‹ì•„ìš”!");
  }

  // ì§‘ì¤‘ ì ìˆ˜ ë†’ìŒ
  if (metrics.focusScore >= 80) {
    highlights.push("ì§‘ì¤‘ë ¥ì´ ë›°ì–´ë‚˜ìš”! ê¸´ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ í•™ìŠµí•˜ê³  ìˆì–´ìš”.");
  } else if (metrics.focusScore >= 60) {
    highlights.push("ì§‘ì¤‘í•´ì„œ í•™ìŠµí•˜ëŠ” ëª¨ìŠµì´ ë³´ì—¬ìš”!");
  }

  // ============================================
  // 2. WARNINGS (ì£¼ì˜í•  ì )
  // ============================================

  // ì‹¤í–‰ë¥  < 40%
  if (metrics.weeklyPlanCompletion < 40 && metrics.weeklyPlanCompletion > 0) {
    warnings.push("ì´ë²ˆì£¼ëŠ” ê³„íš ëŒ€ë¹„ ì‹¤í–‰ì´ ë‚®ì•˜ì–´ìš”. ì‹¤í–‰ë¥  " + metrics.weeklyPlanCompletion + "%ì…ë‹ˆë‹¤.");
  }

  // í•™ìŠµì‹œê°„ ê¸‰ê°
  if (metrics.weeklyStudyTrend < -20) {
    warnings.push("í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ " + Math.abs(metrics.weeklyStudyTrend) + "% ê°ì†Œí–ˆì–´ìš”.");
  }

  // ì·¨ì•½ ê³¼ëª© í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (metrics.weakSubjects.length > 0) {
    warnings.push("ì·¨ì•½ ê³¼ëª© í•™ìŠµì´ ë¶€ì¡±í–ˆì–´ìš”. (" + metrics.weakSubjects.join(", ") + ")");
  }

  // Risk Levelì´ high
  if (metrics.riskLevel === "high") {
    warnings.push("ì§‘ì¤‘ ê´€ë¦¬ê°€ í•„ìš”í•œ ìƒíƒœì˜ˆìš”. í•™ìŠµ íŒ¨í„´ì„ ì ê²€í•´ë³´ì„¸ìš”.");
  } else if (metrics.riskLevel === "medium") {
    warnings.push("í•™ìŠµ ìƒíƒœë¥¼ ì£¼ì˜ ê¹Šê²Œ ê´€ì°°í•´ì•¼ í•´ìš”.");
  }

  // ì—°ì†ì„± ì ìˆ˜ ë‚®ìŒ
  if (metrics.consistencyScore < 40) {
    warnings.push("í•™ìŠµ ì—°ì†ì„±ì´ ë‚®ì•„ìš”. ë§¤ì¼ ì¡°ê¸ˆì”©ì´ë¼ë„ í•™ìŠµí•˜ëŠ” ìŠµê´€ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”.");
  }

  // ì§‘ì¤‘ ì ìˆ˜ ë‚®ìŒ
  if (metrics.focusScore < 40) {
    warnings.push("ì§‘ì¤‘ ì‹œê°„ì´ ì§§ì•„ìš”. ë” ê¸´ ì‹œê°„ ë™ì•ˆ ì§‘ì¤‘í•´ì„œ í•™ìŠµí•´ë³´ì„¸ìš”.");
  }

  // ëª©í‘œ ì§„í–‰ë¥  ì €ì¡°
  if (metrics.weeklyGoalsProgress < 30 && metrics.weeklyGoalsProgress > 0) {
    warnings.push("ëª©í‘œ ì§„í–‰ë¥ ì´ ë‚®ì•„ìš”. í˜„ì¬ " + metrics.weeklyGoalsProgress + "% ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.");
  }

  // ============================================
  // 3. NEXT WEEK GUIDE (ë‹¤ìŒì£¼ ê°€ì´ë“œ)
  // ============================================

  // ëª©í‘œ D-7 ì´í•˜ ì¡´ì¬ ì‹œ
  // (ì´ ì •ë³´ëŠ” metricsì— ì§ì ‘ í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì¶”ì²œ ì—”ì§„ ê²°ê³¼ë¥¼ í™œìš©)
  const urgentGoalRecommendations = metrics.recommendations.filter((rec) =>
    rec.includes("ëª©í‘œ") || rec.includes("ë§ˆê°") || rec.includes("D-")
  );
  if (urgentGoalRecommendations.length > 0) {
    nextWeekGuide.push("ë‹¤ìŒì£¼ëŠ” í•´ë‹¹ ëª©í‘œ ìš°ì„  ì§‘ì¤‘ì´ í•„ìš”í•´ìš”: " + urgentGoalRecommendations[0]);
  }

  // í”Œëœ ì‹¤í–‰ë¥  ë‚®ìŒ â†’ í”Œëœ ìˆ˜ ì¤„ì´ê¸° ì¶”ì²œ
  if (metrics.weeklyPlanCompletion < 50) {
    nextWeekGuide.push("í”Œëœ ìˆ˜ë¥¼ ì¤„ì´ê³  ì‹¤í–‰ ê°€ëŠ¥ì„±ì„ ë†’ì´ëŠ” ì£¼ê°„ ì „ëµì„ ì¶”ì²œí•´ìš”.");
  }

  // ì¶”ì²œ ì—”ì§„ì— 'í•™ìŠµ ë¹„ì¤‘ ì¡°ì •' í•­ëª© ìˆìœ¼ë©´ ë°˜ì˜
  const balanceRecommendations = metrics.recommendations.filter(
    (rec) => rec.includes("ë¹„ì¤‘") || rec.includes("ê· í˜•") || rec.includes("ì¡°ì •")
  );
  if (balanceRecommendations.length > 0) {
    nextWeekGuide.push(balanceRecommendations[0]);
  }

  // ì·¨ì•½ ê³¼ëª© í•™ìŠµ ê°•í™”
  if (metrics.weakSubjects.length > 0) {
    nextWeekGuide.push(
      "ì·¨ì•½ ê³¼ëª©(" + metrics.weakSubjects.join(", ") + ") í•™ìŠµ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”."
    );
  }

  // í•™ìŠµì‹œê°„ ë¶€ì¡± ì‹œ
  if (metrics.weeklyStudyMinutes < 5 * 60) {
    // 5ì‹œê°„ ë¯¸ë§Œ
    nextWeekGuide.push("ë‹¤ìŒì£¼ëŠ” í•™ìŠµ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”. í•˜ë£¨ ìµœì†Œ 1ì‹œê°„ ì´ìƒ í•™ìŠµì„ ëª©í‘œë¡œ í•´ë³´ì„¸ìš”.");
  }

  // ì—°ì†ì„± ê°œì„ 
  if (metrics.consistencyScore < 60) {
    nextWeekGuide.push("ë§¤ì¼ ì¡°ê¸ˆì”©ì´ë¼ë„ í•™ìŠµí•˜ëŠ” ìŠµê´€ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”. ì—°ì† í•™ìŠµì¼ì„ ëŠ˜ë ¤ê°€ìš”.");
  }

  // ì§‘ì¤‘ë ¥ ê°œì„ 
  if (metrics.focusScore < 60) {
    nextWeekGuide.push("ì§‘ì¤‘ ì‹œê°„ì„ ëŠ˜ë ¤ë³´ì„¸ìš”. 30ë¶„ ì´ìƒ ì—°ì†ìœ¼ë¡œ í•™ìŠµí•˜ëŠ” ì„¸ì…˜ì„ ëŠ˜ë ¤ê°€ìš”.");
  }

  // ê¸°ë³¸ ê°€ì´ë“œ (ìœ„ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
  if (nextWeekGuide.length === 0) {
    nextWeekGuide.push("ì´ë²ˆì£¼ì²˜ëŸ¼ ê¾¸ì¤€íˆ í•™ìŠµì„ ì´ì–´ê°€ì„¸ìš”!");
  }

  // ============================================
  // 4. SUMMARY (1ì¤„ ìš”ì•½)
  // ============================================

  const summary = generateSummary(metrics);

  return {
    highlights: highlights.length > 0 ? highlights : ["ì´ë²ˆì£¼ë„ ìˆ˜ê³ í•˜ì…¨ì–´ìš”!"],
    warnings: warnings.length > 0 ? warnings : [],
    nextWeekGuide: nextWeekGuide.length > 0 ? nextWeekGuide : ["ë‹¤ìŒì£¼ë„ í™”ì´íŒ…!"],
    summary,
  };
}

/**
 * Summary ìƒì„± (1ì¤„ ìš”ì•½)
 * ì‹¤í–‰ë¥  + ëª©í‘œ + ì§‘ì¤‘ ì ìˆ˜ ê¸°ë°˜
 */
function generateSummary(metrics: WeeklyMetricsData): string {
  // ì‹¤í–‰ë¥  ê¸°ë°˜ í‰ê°€
  let executionRating = "";
  if (metrics.weeklyPlanCompletion >= 80) {
    executionRating = "ë§¤ìš° ìš°ìˆ˜í•œ";
  } else if (metrics.weeklyPlanCompletion >= 60) {
    executionRating = "ì–‘í˜¸í•œ";
  } else if (metrics.weeklyPlanCompletion >= 40) {
    executionRating = "ë³´í†µì˜";
  } else {
    executionRating = "ê°œì„ ì´ í•„ìš”í•œ";
  }

  // ëª©í‘œ ë‹¬ì„±ë¥  ê¸°ë°˜ í‰ê°€
  let goalRating = "";
  if (metrics.weeklyGoalsProgress >= 80) {
    goalRating = "ëª©í‘œ ë‹¬ì„±ë¥ ì´ ë†’ê³ ";
  } else if (metrics.weeklyGoalsProgress >= 50) {
    goalRating = "ëª©í‘œ ì§„í–‰ì´ ìˆœì¡°ë¡­ê³ ";
  } else if (metrics.weeklyGoalsProgress > 0) {
    goalRating = "ëª©í‘œ ì§„í–‰ì´ í•„ìš”í•˜ê³ ";
  } else {
    goalRating = "ëª©í‘œ ì„¤ì •ì´ í•„ìš”í•˜ê³ ";
  }

  // ì§‘ì¤‘ ì ìˆ˜ ê¸°ë°˜ í‰ê°€
  let focusRating = "";
  if (metrics.focusScore >= 70) {
    focusRating = "ì§‘ì¤‘ë ¥ì´ ë›°ì–´ë‚œ";
  } else if (metrics.focusScore >= 50) {
    focusRating = "ì§‘ì¤‘ë ¥ì´ ì–‘í˜¸í•œ";
  } else {
    focusRating = "ì§‘ì¤‘ë ¥ ê°œì„ ì´ í•„ìš”í•œ";
  }

  // Risk Level ê¸°ë°˜ í‰ê°€
  let riskNote = "";
  if (metrics.riskLevel === "high") {
    riskNote = " ì£¼ì˜ê°€ í•„ìš”í•´ìš”.";
  } else if (metrics.riskLevel === "medium") {
    riskNote = " ê´€ì‹¬ì´ í•„ìš”í•´ìš”.";
  } else {
    riskNote = " ì•ˆì •ì ì¸ ìƒíƒœì˜ˆìš”.";
  }

  // ìµœì¢… ìš”ì•½ ìƒì„±
  return `${executionRating} ì‹¤í–‰ë ¥ê³¼ ${goalRating} ${focusRating} í•™ìŠµ ìƒíƒœì…ë‹ˆë‹¤.${riskNote}`;
}
</file>

<file path="getWeeklyMetrics.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudyTime, type StudyTimeMetrics } from "@/lib/metrics/getStudyTime";
import { getPlanCompletion, type PlanCompletionMetrics } from "@/lib/metrics/getPlanCompletion";
import { getGoalStatus, type GoalStatusMetrics } from "@/lib/metrics/getGoalStatus";
import { getWeakSubjects, type WeakSubjectMetrics } from "@/lib/metrics/getWeakSubjects";
import { getStudentRiskScore, type StudentRiskResult } from "@/lib/risk/engine";
import { getRecommendations, type Recommendations } from "@/lib/recommendations/engine";
import { getHistoryPattern, type HistoryPatternMetrics } from "@/lib/metrics/getHistoryPattern";
import { getSessionsByDateRange } from "@/lib/studySessions/queries";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type WeeklyMetricsData = {
  weeklyStudyMinutes: number; // ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ (ë¶„)
  weeklyStudyTrend: number; // ì§€ë‚œì£¼ ëŒ€ë¹„ ë³€í™”ìœ¨ (%)
  weeklyPlanCompletion: number; // ì‹¤í–‰ë¥  (%)
  weeklyGoalsProgress: number; // ëª©í‘œ ë‹¬ì„±ë¥  (%)
  weakSubjects: string[]; // ì·¨ì•½ ê³¼ëª© ëª©ë¡
  riskLevel: "low" | "medium" | "high"; // Risk Engine ê²°ê³¼
  recommendations: string[]; // ì¶”ì²œ ì—”ì§„ ê²°ê³¼
  consistencyScore: number; // ì´ë²ˆì£¼ ì—°ì†ì„± ì§€í‘œ (0-100)
  focusScore: number; // ì§‘ì¤‘ íƒ€ì´ë¨¸ í’ˆì§ˆ (0-100)
};

/**
 * ì£¼ê°„ ë©”íŠ¸ë¦­ ë°ì´í„° ìˆ˜ì§‘
 */
export async function getWeeklyMetrics(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<WeeklyMetricsData> {
  try {
    // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚° (ì›”ìš”ì¼ë¶€í„°)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const dayOfWeek = today.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);

    const todayDate = today.toISOString().slice(0, 10);

    // ëª¨ë“  ë©”íŠ¸ë¦­ ë³‘ë ¬ ì¡°íšŒ
    const [
      studyTime,
      planCompletion,
      goalStatus,
      weakSubjects,
      riskResult,
      recommendations,
      historyPattern,
      sessions,
    ] = await Promise.all([
      getStudyTime(supabase, studentId, weekStart, weekEnd),
      getPlanCompletion(supabase, studentId, weekStart, weekEnd),
      getGoalStatus(supabase, studentId, todayDate),
      getWeakSubjects(supabase, studentId, weekStart, weekEnd),
      getStudentRiskScore(supabase, studentId, { recordHistory: false }),
      getRecommendations(supabase, studentId),
      getHistoryPattern(supabase, studentId, todayDate),
      getSessionsByDateRange(
        supabase,
        studentId,
        weekStart.toISOString().slice(0, 10),
        weekEnd.toISOString().slice(0, 10)
      ),
    ]);

    // ì£¼ê°„ í•™ìŠµì‹œê°„
    const weeklyStudyMinutes = studyTime.thisWeekMinutes;
    const weeklyStudyTrend = studyTime.changePercent;

    // í”Œëœ ì‹¤í–‰ë¥ 
    const weeklyPlanCompletion = planCompletion.completionRate;

    // ëª©í‘œ ë‹¬ì„±ë¥ 
    const weeklyGoalsProgress = goalStatus.averageProgress;

    // ì·¨ì•½ ê³¼ëª©
    const weakSubjectsList = weakSubjects.weakSubjects;

    // Risk Level
    const riskLevel = riskResult.level;

    // ì¶”ì²œ ì—”ì§„ ê²°ê³¼ (ìƒìœ„ 5ê°œ)
    const allRecommendations = [
      ...recommendations.goals,
      ...recommendations.subjects,
      ...recommendations.studyPlan,
      ...recommendations.contents,
    ];
    const topRecommendations = allRecommendations.slice(0, 5);

    // Consistency Score ê³„ì‚° (ì´ë²ˆì£¼ ì—°ì†ì„±)
    const consistencyScore = calculateConsistencyScore(
      sessions,
      weekStart,
      weekEnd,
      historyPattern
    );

    // Focus Score ê³„ì‚° (ì§‘ì¤‘ íƒ€ì´ë¨¸ í’ˆì§ˆ)
    const focusScore = calculateFocusScore(sessions);

    return {
      weeklyStudyMinutes,
      weeklyStudyTrend,
      weeklyPlanCompletion,
      weeklyGoalsProgress,
      weakSubjects: weakSubjectsList,
      riskLevel,
      recommendations: topRecommendations,
      consistencyScore,
      focusScore,
    };
  } catch (error) {
    console.error("[coaching/getWeeklyMetrics] ì£¼ê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨", error);
    // ê¸°ë³¸ê°’ ë°˜í™˜
    return {
      weeklyStudyMinutes: 0,
      weeklyStudyTrend: 0,
      weeklyPlanCompletion: 0,
      weeklyGoalsProgress: 0,
      weakSubjects: [],
      riskLevel: "low",
      recommendations: [],
      consistencyScore: 0,
      focusScore: 0,
    };
  }
}

/**
 * Consistency Score ê³„ì‚° (0-100)
 * - ì´ë²ˆì£¼ í•™ìŠµì¼ ìˆ˜ ê¸°ë°˜
 * - ì—°ì† í•™ìŠµì¼ ìˆ˜ ê¸°ë°˜
 * - í”Œëœ ì™„ë£Œ ì¼ê´€ì„± ê¸°ë°˜
 */
function calculateConsistencyScore(
  sessions: Array<{ started_at?: string | null; duration_seconds?: number | null }>,
  weekStart: Date,
  weekEnd: Date,
  historyPattern: HistoryPatternMetrics
): number {
  // ì´ë²ˆì£¼ í•™ìŠµì¼ ìˆ˜ ê³„ì‚°
  const studyDays = new Set<string>();
  sessions.forEach((session) => {
    if (session.started_at && session.duration_seconds && session.duration_seconds > 0) {
      const date = new Date(session.started_at).toISOString().slice(0, 10);
      if (date >= weekStart.toISOString().slice(0, 10) && date <= weekEnd.toISOString().slice(0, 10)) {
        studyDays.add(date);
      }
    }
  });

  const studyDaysCount = studyDays.size;
  const totalDaysInWeek = 7;

  // í•™ìŠµì¼ ë¹„ìœ¨ (40%)
  const studyDaysRatio = (studyDaysCount / totalDaysInWeek) * 100;

  // ì—°ì† í•™ìŠµì¼ ì ìˆ˜ (30%)
  // ì´ë²ˆì£¼ ì—°ì† í•™ìŠµì¼ ìˆ˜ ê³„ì‚°
  let consecutiveDays = 0;
  const checkDate = new Date(weekEnd);
  for (let i = 0; i < 7; i++) {
    const dateStr = checkDate.toISOString().slice(0, 10);
    if (studyDays.has(dateStr)) {
      consecutiveDays++;
    } else {
      break;
    }
    checkDate.setDate(checkDate.getDate() - 1);
  }
  const consecutiveDaysScore = (consecutiveDays / 7) * 100;

  // í”Œëœ ì™„ë£Œ ì¼ê´€ì„± (30%)
  // ì—°ì† í”Œëœ ë¯¸ì™„ë£Œê°€ ì ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
  const planFailurePenalty = Math.min(100, historyPattern.consecutivePlanFailures * 20);
  const planConsistencyScore = Math.max(0, 100 - planFailurePenalty);

  // ìµœì¢… ì ìˆ˜ ê³„ì‚°
  const consistencyScore =
    studyDaysRatio * 0.4 + consecutiveDaysScore * 0.3 + planConsistencyScore * 0.3;

  return Math.round(Math.min(100, Math.max(0, consistencyScore)));
}

/**
 * Focus Score ê³„ì‚° (0-100)
 * - ì„¸ì…˜ í‰ê·  ê¸¸ì´ ê¸°ë°˜
 * - ê¸´ ì„¸ì…˜ ë¹„ìœ¨ ê¸°ë°˜
 * - ì„¸ì…˜ ë¹ˆë„ ê¸°ë°˜
 */
function calculateFocusScore(
  sessions: Array<{ duration_seconds?: number | null }>
): number {
  if (sessions.length === 0) {
    return 0;
  }

  const validSessions = sessions.filter(
    (s) => s.duration_seconds !== null && s.duration_seconds !== undefined && s.duration_seconds > 0
  );

  if (validSessions.length === 0) {
    return 0;
  }

  // í‰ê·  ì„¸ì…˜ ê¸¸ì´ (ë¶„)
  const totalMinutes = validSessions.reduce(
    (sum, s) => sum + (s.duration_seconds || 0) / 60,
    0
  );
  const avgSessionMinutes = totalMinutes / validSessions.length;

  // í‰ê·  ì„¸ì…˜ ê¸¸ì´ ì ìˆ˜ (40%)
  // 30ë¶„ ì´ìƒ = 100ì , 15ë¶„ = 50ì , 5ë¶„ = 0ì 
  const avgLengthScore = Math.min(100, Math.max(0, ((avgSessionMinutes - 5) / 25) * 100));

  // ê¸´ ì„¸ì…˜ ë¹„ìœ¨ (30ë¶„ ì´ìƒ) (30%)
  const longSessions = validSessions.filter((s) => (s.duration_seconds || 0) >= 30 * 60).length;
  const longSessionRatio = (longSessions / validSessions.length) * 100;

  // ì„¸ì…˜ ë¹ˆë„ ì ìˆ˜ (30%)
  // ì„¸ì…˜ì´ ë§ì„ìˆ˜ë¡ ì¢‹ìŒ (í•˜ë£¨ í‰ê·  2ê°œ ì´ìƒ = 100ì )
  const avgSessionsPerDay = validSessions.length / 7;
  const frequencyScore = Math.min(100, (avgSessionsPerDay / 2) * 100);

  // ìµœì¢… ì ìˆ˜ ê³„ì‚°
  const focusScore = avgLengthScore * 0.4 + longSessionRatio * 0.3 + frequencyScore * 0.3;

  return Math.round(Math.min(100, Math.max(0, focusScore)));
}
</file>

<file path="cache.ts">
type CacheEntry<T> = {
  data: T;
  timestamp: number;
};

const cache = new Map<string, CacheEntry<any>>();
const CACHE_TTL = 5 * 60 * 1000; // 5ë¶„ (ë°€ë¦¬ì´ˆ)

/**
 * ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ
 */
export function getCached<T>(key: string): T | null {
  const entry = cache.get(key);
  if (!entry) {
    return null;
  }

  const now = Date.now();
  if (now - entry.timestamp > CACHE_TTL) {
    // ìºì‹œ ë§Œë£Œ
    cache.delete(key);
    return null;
  }

  return entry.data as T;
}

/**
 * ìºì‹œì— ë°ì´í„° ì €ì¥
 */
export function setCached<T>(key: string, data: T): void {
  cache.set(key, {
    data,
    timestamp: Date.now(),
  });
}

/**
 * ìºì‹œ í‚¤ ìƒì„±
 */
export function getCacheKey(studentId: string): string {
  return `risk-${studentId}`;
}

/**
 * ìºì‹œ ì‚­ì œ
 */
export function clearCache(studentId?: string): void {
  if (studentId) {
    cache.delete(getCacheKey(studentId));
  } else {
    cache.clear();
  }
}
</file>

<file path="engine.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudyTime, type StudyTimeMetrics } from "@/lib/metrics/getStudyTime";
import { getPlanCompletion, type PlanCompletionMetrics } from "@/lib/metrics/getPlanCompletion";
import { getGoalStatus, type GoalStatusMetrics } from "@/lib/metrics/getGoalStatus";
import { getScoreTrend, type ScoreTrendMetrics } from "@/lib/metrics/getScoreTrend";
import { getWeakSubjects, type WeakSubjectMetrics } from "@/lib/metrics/getWeakSubjects";
import { getHistoryPattern, type HistoryPatternMetrics } from "@/lib/metrics/getHistoryPattern";
import { getCached, setCached, getCacheKey } from "./cache";
import { recordHistory } from "@/lib/history/record";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type StudentRiskResult = {
  studentId: string;
  riskScore: number; // 0~100
  level: "low" | "medium" | "high";
  reasons: string[]; // ìœ„í—˜ ìš”ì¸ ìƒì„¸ ì„¤ëª…
  metrics: {
    studyTime: StudyTimeMetrics;
    planCompletion: PlanCompletionMetrics;
    goalStatus: GoalStatusMetrics;
    scoreTrend: ScoreTrendMetrics;
    weakSubjects: WeakSubjectMetrics;
    historyPattern: HistoryPatternMetrics;
  };
};

export type WeeklyMetrics = {
  studyTime: StudyTimeMetrics;
  planCompletion: PlanCompletionMetrics;
  goalStatus: GoalStatusMetrics;
  scoreTrend: ScoreTrendMetrics;
  weakSubjects: WeakSubjectMetrics;
  historyPattern: HistoryPatternMetrics;
};

/**
 * ì£¼ê°„ ë©”íŠ¸ë¦­ ì¡°íšŒ
 */
export async function getWeeklyMetrics(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<WeeklyMetrics> {
  // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const dayOfWeek = today.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const weekStart = new Date(today);
  weekStart.setDate(today.getDate() + mondayOffset);
  weekStart.setHours(0, 0, 0, 0);
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekStart.getDate() + 6);
  weekEnd.setHours(23, 59, 59, 999);

  const todayDate = today.toISOString().slice(0, 10);

  // ëª¨ë“  ë©”íŠ¸ë¦­ ë³‘ë ¬ ì¡°íšŒ
  const [studyTime, planCompletion, goalStatus, scoreTrend, weakSubjects, historyPattern] =
    await Promise.all([
      getStudyTime(supabase, studentId, weekStart, weekEnd),
      getPlanCompletion(supabase, studentId, weekStart, weekEnd),
      getGoalStatus(supabase, studentId, todayDate),
      getScoreTrend(supabase, studentId),
      getWeakSubjects(supabase, studentId, weekStart, weekEnd),
      getHistoryPattern(supabase, studentId, todayDate),
    ]);

  return {
    studyTime,
    planCompletion,
    goalStatus,
    scoreTrend,
    weakSubjects,
    historyPattern,
  };
}

/**
 * ìœ„í—˜ ì ìˆ˜ ê³„ì‚° (Rule-based)
 */
export function calculateRiskScore(
  metrics: WeeklyMetrics,
  studentId: string
): StudentRiskResult {
  let riskScore = 0;
  const reasons: string[] = [];

  // 1) í•™ìŠµì‹œê°„ ê¸‰ê°
  const { thisWeekMinutes, lastWeekMinutes, changePercent } = metrics.studyTime;
  if (lastWeekMinutes > 0) {
    const ratio = thisWeekMinutes / lastWeekMinutes;
    if (ratio < 0.5) {
      riskScore += 25;
      reasons.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ ${Math.abs(changePercent)}% ê°ì†Œ (${thisWeekMinutes}ë¶„ â†’ ${lastWeekMinutes}ë¶„)`
      );
    } else if (ratio < 0.7) {
      riskScore += 15;
      reasons.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ ${Math.abs(changePercent)}% ê°ì†Œ (${thisWeekMinutes}ë¶„ â†’ ${lastWeekMinutes}ë¶„)`
      );
    }
  }

  // 2) ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (thisWeekMinutes < 5 * 60) {
    // 5ì‹œê°„ ë¯¸ë§Œ
    riskScore += 20;
    reasons.push(`ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ 5ì‹œê°„ ë¯¸ë§Œ (${Math.floor(thisWeekMinutes / 60)}ì‹œê°„)`);
  } else if (thisWeekMinutes < 10 * 60) {
    // 10ì‹œê°„ ë¯¸ë§Œ
    riskScore += 10;
    reasons.push(`ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ 10ì‹œê°„ ë¯¸ë§Œ (${Math.floor(thisWeekMinutes / 60)}ì‹œê°„)`);
  }

  // 3) í”Œëœ ì‹¤í–‰ë¥ 
  const { completionRate } = metrics.planCompletion;
  if (completionRate < 40) {
    riskScore += 20;
    reasons.push(`í”Œëœ ì‹¤í–‰ë¥ ì´ ${completionRate}%ë¡œ ë§¤ìš° ë‚®ìŒ`);
  } else if (completionRate < 60) {
    riskScore += 10;
    reasons.push(`í”Œëœ ì‹¤í–‰ë¥ ì´ ${completionRate}%ë¡œ ë‚®ìŒ`);
  }

  // 4) ëª©í‘œ ì§„í–‰ë¥  ì €ì¡°
  const { goalsNearDeadline, goalsVeryNearDeadline, lowProgressGoals, veryLowProgressGoals } =
    metrics.goalStatus;
  if (goalsNearDeadline >= 2 && lowProgressGoals >= 2) {
    riskScore += 20;
    reasons.push(
      `ëª©í‘œ ${goalsNearDeadline}ê°œê°€ ê³§ ë§ˆê°ì¸ë° ì§„í–‰ë¥ ì´ ì €ì¡°í•¨ (í‰ê·  ${metrics.goalStatus.averageProgress}%)`
    );
  } else if (goalsVeryNearDeadline >= 1 && veryLowProgressGoals >= 1) {
    riskScore += 15;
    reasons.push(
      `ëª©í‘œ ${goalsVeryNearDeadline}ê°œê°€ 3ì¼ ì´ë‚´ ë§ˆê°ì¸ë° ì§„í–‰ë¥ ì´ 50% ë¯¸ë§Œ`
    );
  }

  // 5) ì„±ì  í•˜ë½
  if (metrics.scoreTrend.hasDecliningTrend) {
    riskScore += 20;
    reasons.push(
      `ìµœê·¼ ëª¨ì˜ê³ ì‚¬/ë‚´ì‹  ë“±ê¸‰ì´ 2íšŒ ì—°ì† í•˜ë½í•œ ê³¼ëª©: ${metrics.scoreTrend.decliningSubjects.join(", ")}`
    );
  }
  if (metrics.scoreTrend.lowGradeSubjects.length > 0) {
    riskScore += 15;
    reasons.push(
      `7ë“±ê¸‰ ì´í•˜ ê³¼ëª©: ${metrics.scoreTrend.lowGradeSubjects.join(", ")}`
    );
  }

  // 6) ì·¨ì•½ ê³¼ëª©ì— í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (metrics.weakSubjects.weakSubjectStudyTimeRatio < 10 && metrics.weakSubjects.weakSubjects.length > 0) {
    riskScore += 10;
    reasons.push(
      `ì·¨ì•½ ê³¼ëª© í•™ìŠµì‹œê°„ì´ ì „ì²´ì˜ ${metrics.weakSubjects.weakSubjectStudyTimeRatio}%ë¡œ ë¶€ì¡±í•¨ (ì·¨ì•½ ê³¼ëª©: ${metrics.weakSubjects.weakSubjects.join(", ")})`
    );
  }

  // 7) íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ìœ„í—˜ ì‹ í˜¸
  if (metrics.historyPattern.consecutivePlanFailures >= 5) {
    riskScore += 20;
    reasons.push(
      `í”Œëœ ë¯¸ì™„ë£Œê°€ ${metrics.historyPattern.consecutivePlanFailures}íšŒ ì—°ì† ë°œìƒ`
    );
  }
  if (metrics.historyPattern.consecutiveNoStudyDays >= 3) {
    riskScore += 15;
    reasons.push(
      `í•™ìŠµì„¸ì…˜ì´ ì—†ëŠ” ë‚ ì´ ${metrics.historyPattern.consecutiveNoStudyDays}ì¼ ì—°ì† ë°œìƒ`
    );
  }

  // ìµœëŒ€ 100ìœ¼ë¡œ í´ë¨í”„
  riskScore = Math.min(100, riskScore);

  // ìœ„í—˜ ìˆ˜ì¤€ ê²°ì •
  let level: "low" | "medium" | "high";
  if (riskScore <= 30) {
    level = "low";
  } else if (riskScore <= 60) {
    level = "medium";
  } else {
    level = "high";
  }

  return {
    studentId,
    riskScore,
    level,
    reasons,
    metrics,
  };
}

/**
 * í•™ìƒ ìœ„í—˜ ì ìˆ˜ ì¡°íšŒ (ë©”ì¸ í•¨ìˆ˜, ìºì‹± í¬í•¨)
 */
export async function getStudentRiskScore(
  supabase: SupabaseServerClient,
  studentId: string,
  options?: { recordHistory?: boolean }
): Promise<StudentRiskResult> {
  // ìºì‹œ í™•ì¸
  const cacheKey = getCacheKey(studentId);
  const cached = getCached<StudentRiskResult>(cacheKey);
  if (cached) {
    return cached;
  }

  // ìºì‹œ ë¯¸ìŠ¤ ì‹œ ê³„ì‚°
  const metrics = await getWeeklyMetrics(supabase, studentId);
  const result = calculateRiskScore(metrics, studentId);

  // ìºì‹œ ì €ì¥
  setCached(cacheKey, result);

  // íˆìŠ¤í† ë¦¬ ê¸°ë¡ (ì˜µì…˜)
  if (options?.recordHistory !== false) {
    try {
      await recordHistory(supabase, studentId, "risk_evaluation", {
        riskScore: result.riskScore,
        level: result.level,
        reasons: result.reasons,
      });
    } catch (error) {
      // íˆìŠ¤í† ë¦¬ ê¸°ë¡ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ (ë©”ì¸ ê¸°ëŠ¥ì— ì˜í–¥ ì—†ìŒ)
      console.error("[risk/engine] íˆìŠ¤í† ë¦¬ ê¸°ë¡ ì‹¤íŒ¨", error);
    }
  }

  return result;
}
</file>

<file path="engine.ts">
import type { createSupabaseServerClient } from "@/lib/supabase/server";
import { getStudyTime, type StudyTimeMetrics } from "@/lib/metrics/getStudyTime";
import { getPlanCompletion, type PlanCompletionMetrics } from "@/lib/metrics/getPlanCompletion";
import { getGoalStatus, type GoalStatusMetrics } from "@/lib/metrics/getGoalStatus";
import { getScoreTrend, type ScoreTrendMetrics } from "@/lib/metrics/getScoreTrend";
import { getWeakSubjects, type WeakSubjectMetrics } from "@/lib/metrics/getWeakSubjects";
import { getHistoryPattern, type HistoryPatternMetrics } from "@/lib/metrics/getHistoryPattern";
import { getCached, setCached, getCacheKey } from "./cache";
import { recordHistory } from "@/lib/history/record";

type SupabaseServerClient = Awaited<
  ReturnType<typeof createSupabaseServerClient>
>;

export type StudentRiskResult = {
  studentId: string;
  riskScore: number; // 0~100
  level: "low" | "medium" | "high";
  reasons: string[]; // ìœ„í—˜ ìš”ì¸ ìƒì„¸ ì„¤ëª…
  metrics: {
    studyTime: StudyTimeMetrics;
    planCompletion: PlanCompletionMetrics;
    goalStatus: GoalStatusMetrics;
    scoreTrend: ScoreTrendMetrics;
    weakSubjects: WeakSubjectMetrics;
    historyPattern: HistoryPatternMetrics;
  };
};

export type WeeklyMetrics = {
  studyTime: StudyTimeMetrics;
  planCompletion: PlanCompletionMetrics;
  goalStatus: GoalStatusMetrics;
  scoreTrend: ScoreTrendMetrics;
  weakSubjects: WeakSubjectMetrics;
  historyPattern: HistoryPatternMetrics;
};

/**
 * ì£¼ê°„ ë©”íŠ¸ë¦­ ì¡°íšŒ
 */
export async function getWeeklyMetrics(
  supabase: SupabaseServerClient,
  studentId: string
): Promise<WeeklyMetrics> {
  // ì´ë²ˆ ì£¼ ë²”ìœ„ ê³„ì‚°
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const dayOfWeek = today.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const weekStart = new Date(today);
  weekStart.setDate(today.getDate() + mondayOffset);
  weekStart.setHours(0, 0, 0, 0);
  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekStart.getDate() + 6);
  weekEnd.setHours(23, 59, 59, 999);

  const todayDate = today.toISOString().slice(0, 10);

  // ëª¨ë“  ë©”íŠ¸ë¦­ ë³‘ë ¬ ì¡°íšŒ
  const [studyTime, planCompletion, goalStatus, scoreTrend, weakSubjects, historyPattern] =
    await Promise.all([
      getStudyTime(supabase, studentId, weekStart, weekEnd),
      getPlanCompletion(supabase, studentId, weekStart, weekEnd),
      getGoalStatus(supabase, studentId, todayDate),
      getScoreTrend(supabase, studentId),
      getWeakSubjects(supabase, studentId, weekStart, weekEnd),
      getHistoryPattern(supabase, studentId, todayDate),
    ]);

  return {
    studyTime,
    planCompletion,
    goalStatus,
    scoreTrend,
    weakSubjects,
    historyPattern,
  };
}

/**
 * ìœ„í—˜ ì ìˆ˜ ê³„ì‚° (Rule-based)
 */
export function calculateRiskScore(
  metrics: WeeklyMetrics,
  studentId: string
): StudentRiskResult {
  let riskScore = 0;
  const reasons: string[] = [];

  // 1) í•™ìŠµì‹œê°„ ê¸‰ê°
  const { thisWeekMinutes, lastWeekMinutes, changePercent } = metrics.studyTime;
  if (lastWeekMinutes > 0) {
    const ratio = thisWeekMinutes / lastWeekMinutes;
    if (ratio < 0.5) {
      riskScore += 25;
      reasons.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ ${Math.abs(changePercent)}% ê°ì†Œ (${thisWeekMinutes}ë¶„ â†’ ${lastWeekMinutes}ë¶„)`
      );
    } else if (ratio < 0.7) {
      riskScore += 15;
      reasons.push(
        `ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ ì§€ë‚œì£¼ ëŒ€ë¹„ ${Math.abs(changePercent)}% ê°ì†Œ (${thisWeekMinutes}ë¶„ â†’ ${lastWeekMinutes}ë¶„)`
      );
    }
  }

  // 2) ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (thisWeekMinutes < 5 * 60) {
    // 5ì‹œê°„ ë¯¸ë§Œ
    riskScore += 20;
    reasons.push(`ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ 5ì‹œê°„ ë¯¸ë§Œ (${Math.floor(thisWeekMinutes / 60)}ì‹œê°„)`);
  } else if (thisWeekMinutes < 10 * 60) {
    // 10ì‹œê°„ ë¯¸ë§Œ
    riskScore += 10;
    reasons.push(`ì´ë²ˆì£¼ í•™ìŠµì‹œê°„ì´ 10ì‹œê°„ ë¯¸ë§Œ (${Math.floor(thisWeekMinutes / 60)}ì‹œê°„)`);
  }

  // 3) í”Œëœ ì‹¤í–‰ë¥ 
  const { completionRate } = metrics.planCompletion;
  if (completionRate < 40) {
    riskScore += 20;
    reasons.push(`í”Œëœ ì‹¤í–‰ë¥ ì´ ${completionRate}%ë¡œ ë§¤ìš° ë‚®ìŒ`);
  } else if (completionRate < 60) {
    riskScore += 10;
    reasons.push(`í”Œëœ ì‹¤í–‰ë¥ ì´ ${completionRate}%ë¡œ ë‚®ìŒ`);
  }

  // 4) ëª©í‘œ ì§„í–‰ë¥  ì €ì¡°
  const { goalsNearDeadline, goalsVeryNearDeadline, lowProgressGoals, veryLowProgressGoals } =
    metrics.goalStatus;
  if (goalsNearDeadline >= 2 && lowProgressGoals >= 2) {
    riskScore += 20;
    reasons.push(
      `ëª©í‘œ ${goalsNearDeadline}ê°œê°€ ê³§ ë§ˆê°ì¸ë° ì§„í–‰ë¥ ì´ ì €ì¡°í•¨ (í‰ê·  ${metrics.goalStatus.averageProgress}%)`
    );
  } else if (goalsVeryNearDeadline >= 1 && veryLowProgressGoals >= 1) {
    riskScore += 15;
    reasons.push(
      `ëª©í‘œ ${goalsVeryNearDeadline}ê°œê°€ 3ì¼ ì´ë‚´ ë§ˆê°ì¸ë° ì§„í–‰ë¥ ì´ 50% ë¯¸ë§Œ`
    );
  }

  // 5) ì„±ì  í•˜ë½
  if (metrics.scoreTrend.hasDecliningTrend) {
    riskScore += 20;
    reasons.push(
      `ìµœê·¼ ëª¨ì˜ê³ ì‚¬/ë‚´ì‹  ë“±ê¸‰ì´ 2íšŒ ì—°ì† í•˜ë½í•œ ê³¼ëª©: ${metrics.scoreTrend.decliningSubjects.join(", ")}`
    );
  }
  if (metrics.scoreTrend.lowGradeSubjects.length > 0) {
    riskScore += 15;
    reasons.push(
      `7ë“±ê¸‰ ì´í•˜ ê³¼ëª©: ${metrics.scoreTrend.lowGradeSubjects.join(", ")}`
    );
  }

  // 6) ì·¨ì•½ ê³¼ëª©ì— í•™ìŠµì‹œê°„ ë¶€ì¡±
  if (metrics.weakSubjects.weakSubjectStudyTimeRatio < 10 && metrics.weakSubjects.weakSubjects.length > 0) {
    riskScore += 10;
    reasons.push(
      `ì·¨ì•½ ê³¼ëª© í•™ìŠµì‹œê°„ì´ ì „ì²´ì˜ ${metrics.weakSubjects.weakSubjectStudyTimeRatio}%ë¡œ ë¶€ì¡±í•¨ (ì·¨ì•½ ê³¼ëª©: ${metrics.weakSubjects.weakSubjects.join(", ")})`
    );
  }

  // 7) íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ìœ„í—˜ ì‹ í˜¸
  if (metrics.historyPattern.consecutivePlanFailures >= 5) {
    riskScore += 20;
    reasons.push(
      `í”Œëœ ë¯¸ì™„ë£Œê°€ ${metrics.historyPattern.consecutivePlanFailures}íšŒ ì—°ì† ë°œìƒ`
    );
  }
  if (metrics.historyPattern.consecutiveNoStudyDays >= 3) {
    riskScore += 15;
    reasons.push(
      `í•™ìŠµì„¸ì…˜ì´ ì—†ëŠ” ë‚ ì´ ${metrics.historyPattern.consecutiveNoStudyDays}ì¼ ì—°ì† ë°œìƒ`
    );
  }

  // ìµœëŒ€ 100ìœ¼ë¡œ í´ë¨í”„
  riskScore = Math.min(100, riskScore);

  // ìœ„í—˜ ìˆ˜ì¤€ ê²°ì •
  let level: "low" | "medium" | "high";
  if (riskScore <= 30) {
    level = "low";
  } else if (riskScore <= 60) {
    level = "medium";
  } else {
    level = "high";
  }

  return {
    studentId,
    riskScore,
    level,
    reasons,
    metrics,
  };
}

/**
 * í•™ìƒ ìœ„í—˜ ì ìˆ˜ ì¡°íšŒ (ë©”ì¸ í•¨ìˆ˜, ìºì‹± í¬í•¨)
 */
export async function getStudentRiskScore(
  supabase: SupabaseServerClient,
  studentId: string,
  options?: { recordHistory?: boolean }
): Promise<StudentRiskResult> {
  // ìºì‹œ í™•ì¸
  const cacheKey = getCacheKey(studentId);
  const cached = getCached<StudentRiskResult>(cacheKey);
  if (cached) {
    return cached;
  }

  // ìºì‹œ ë¯¸ìŠ¤ ì‹œ ê³„ì‚°
  const metrics = await getWeeklyMetrics(supabase, studentId);
  const result = calculateRiskScore(metrics, studentId);

  // ìºì‹œ ì €ì¥
  setCached(cacheKey, result);

  // íˆìŠ¤í† ë¦¬ ê¸°ë¡ (ì˜µì…˜)
  if (options?.recordHistory !== false) {
    try {
      await recordHistory(supabase, studentId, "risk_evaluation", {
        riskScore: result.riskScore,
        level: result.level,
        reasons: result.reasons,
      });
    } catch (error) {
      // íˆìŠ¤í† ë¦¬ ê¸°ë¡ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ (ë©”ì¸ ê¸°ëŠ¥ì— ì˜í–¥ ì—†ìŒ)
      console.error("[risk/engine] íˆìŠ¤í† ë¦¬ ê¸°ë¡ ì‹¤íŒ¨", error);
    }
  }

  return result;
}
</file>

<file path="analytics.ts">
/**
 * ì¬ì¡°ì • í†µê³„ ì§‘ê³„
 * 
 * ì¬ì¡°ì • ê¸°ëŠ¥ì˜ ì‚¬ìš© í†µê³„ë¥¼ ì§‘ê³„í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/analytics
 */

import type { SupabaseClient } from '@supabase/supabase-js';

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¬ì¡°ì • í†µê³„
 */
export interface RescheduleStats {
  totalRequests: number;
  averagePlansPerRequest: number;
  failureRate: number;
  averageProcessingTime: number;
  rollbackRate: number;
  period: 'day' | 'week' | 'month';
  startDate: string;
  endDate: string;
}

/**
 * ì¬ì¡°ì • í†µê³„ ìƒì„¸
 */
export interface RescheduleStatsDetail extends RescheduleStats {
  byStatus: {
    pending: number;
    completed: number;
    failed: number;
    rolled_back: number;
  };
  byDay: Array<{
    date: string;
    count: number;
    averagePlans: number;
  }>;
}

// ============================================
// í†µê³„ ì¡°íšŒ í•¨ìˆ˜
// ============================================

/**
 * ì¬ì¡°ì • í†µê³„ ì¡°íšŒ
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param tenantId í…Œë„ŒíŠ¸ ID
 * @param period ê¸°ê°„ ('day' | 'week' | 'month')
 * @returns ì¬ì¡°ì • í†µê³„
 */
export async function getRescheduleStats(
  supabase: SupabaseClient,
  tenantId: string,
  period: 'day' | 'week' | 'month' = 'day'
): Promise<RescheduleStats> {
  // ê¸°ê°„ ê³„ì‚°
  const now = new Date();
  const startDate = new Date();
  
  switch (period) {
    case 'day':
      startDate.setDate(now.getDate() - 1);
      break;
    case 'week':
      startDate.setDate(now.getDate() - 7);
      break;
    case 'month':
      startDate.setMonth(now.getMonth() - 1);
      break;
  }

  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = now.toISOString().split('T')[0];

  // ì¬ì¡°ì • ë¡œê·¸ ì¡°íšŒ
  const { data: logs, error } = await supabase
    .from('reschedule_log')
    .select('*')
    .eq('tenant_id', tenantId)
    .gte('created_at', startDateStr)
    .lte('created_at', endDateStr);

  if (error) {
    console.error('[analytics] ì¬ì¡°ì • ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨:', error);
    throw new Error(`í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  if (!logs || logs.length === 0) {
    return {
      totalRequests: 0,
      averagePlansPerRequest: 0,
      failureRate: 0,
      averageProcessingTime: 0,
      rollbackRate: 0,
      period,
      startDate: startDateStr,
      endDate: endDateStr,
    };
  }

  // í†µê³„ ê³„ì‚°
  const totalRequests = logs.length;
  const completed = logs.filter((l) => l.status === 'completed').length;
  const failed = logs.filter((l) => l.status === 'failed').length;
  const rolledBack = logs.filter((l) => l.status === 'rolled_back').length;

  const totalPlans = logs.reduce((sum, log) => {
    return sum + (log.plans_before_count || 0);
  }, 0);

  const averagePlansPerRequest = totalRequests > 0 ? totalPlans / totalRequests : 0;
  const failureRate = totalRequests > 0 ? (failed / totalRequests) * 100 : 0;
  const rollbackRate = completed > 0 ? (rolledBack / completed) * 100 : 0;

  // í‰ê·  ì²˜ë¦¬ ì‹œê°„ ê³„ì‚° (completed_at - created_at)
  const processingTimes: number[] = [];
  logs.forEach((log) => {
    if (log.status === 'completed' && log.created_at) {
      // TODO: completed_at ì»¬ëŸ¼ì´ ìˆë‹¤ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì¶”ì •
      const createdAt = new Date(log.created_at).getTime();
      const completedAt = new Date().getTime(); // ì„ì‹œë¡œ í˜„ì¬ ì‹œê°„ ì‚¬ìš©
      processingTimes.push((completedAt - createdAt) / 1000); // ì´ˆ ë‹¨ìœ„
    }
  });

  const averageProcessingTime =
    processingTimes.length > 0
      ? processingTimes.reduce((sum, time) => sum + time, 0) / processingTimes.length
      : 0;

  return {
    totalRequests,
    averagePlansPerRequest: Math.round(averagePlansPerRequest * 10) / 10,
    failureRate: Math.round(failureRate * 10) / 10,
    averageProcessingTime: Math.round(averageProcessingTime),
    rollbackRate: Math.round(rollbackRate * 10) / 10,
    period,
    startDate: startDateStr,
    endDate: endDateStr,
  };
}

/**
 * ì¬ì¡°ì • í†µê³„ ìƒì„¸ ì¡°íšŒ
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param tenantId í…Œë„ŒíŠ¸ ID
 * @param period ê¸°ê°„
 * @returns ì¬ì¡°ì • í†µê³„ ìƒì„¸
 */
export async function getRescheduleStatsDetail(
  supabase: SupabaseClient,
  tenantId: string,
  period: 'day' | 'week' | 'month' = 'day'
): Promise<RescheduleStatsDetail> {
  const basicStats = await getRescheduleStats(supabase, tenantId, period);

  // ê¸°ê°„ ê³„ì‚°
  const now = new Date();
  const startDate = new Date();
  
  switch (period) {
    case 'day':
      startDate.setDate(now.getDate() - 1);
      break;
    case 'week':
      startDate.setDate(now.getDate() - 7);
      break;
    case 'month':
      startDate.setMonth(now.getMonth() - 1);
      break;
  }

  const startDateStr = startDate.toISOString().split('T')[0];
  const endDateStr = now.toISOString().split('T')[0];

  // ì¬ì¡°ì • ë¡œê·¸ ì¡°íšŒ
  const { data: logs, error } = await supabase
    .from('reschedule_log')
    .select('*')
    .eq('tenant_id', tenantId)
    .gte('created_at', startDateStr)
    .lte('created_at', endDateStr);

  if (error) {
    throw new Error(`í†µê³„ ìƒì„¸ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
  }

  // ìƒíƒœë³„ ì§‘ê³„
  const byStatus = {
    pending: logs?.filter((l) => l.status === 'pending').length || 0,
    completed: logs?.filter((l) => l.status === 'completed').length || 0,
    failed: logs?.filter((l) => l.status === 'failed').length || 0,
    rolled_back: logs?.filter((l) => l.status === 'rolled_back').length || 0,
  };

  // ì¼ë³„ ì§‘ê³„
  const byDayMap = new Map<string, { count: number; totalPlans: number }>();
  
  logs?.forEach((log) => {
    const date = log.created_at.split('T')[0];
    const existing = byDayMap.get(date) || { count: 0, totalPlans: 0 };
    byDayMap.set(date, {
      count: existing.count + 1,
      totalPlans: existing.totalPlans + (log.plans_before_count || 0),
    });
  });

  const byDay = Array.from(byDayMap.entries())
    .map(([date, data]) => ({
      date,
      count: data.count,
      averagePlans: data.count > 0 ? Math.round((data.totalPlans / data.count) * 10) / 10 : 0,
    }))
    .sort((a, b) => a.date.localeCompare(b.date));

  return {
    ...basicStats,
    byStatus,
    byDay,
  };
}
</file>

<file path="autoSuggester.ts">
/**
 * ìë™ ì¬ì¡°ì • ì œì•ˆ ìƒì„±ê¸°
 * 
 * í•™ìŠµ ì§€ì—° ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì¬ì¡°ì • ì œì•ˆì„ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/autoSuggester
 */

import type { DelayAnalysis, DelaySeverity } from "./delayDetector";
import type { AdjustmentInput } from "./scheduleEngine";
import type { PlanContent } from "@/lib/types/plan";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¬ì¡°ì • ì œì•ˆ íƒ€ì…
 */
export type RescheduleSuggestionType =
  | "extend_deadline" // ê¸°í•œ ì—°ì¥
  | "increase_daily_load" // ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€
  | "reduce_content_range" // ì½˜í…ì¸  ë²”ìœ„ ì¶•ì†Œ
  | "replace_content" // ì½˜í…ì¸  êµì²´
  | "redistribute_plans"; // í”Œëœ ì¬ë¶„ë°°

/**
 * ì¬ì¡°ì • ì œì•ˆ
 */
export interface RescheduleSuggestion {
  /** ì œì•ˆ íƒ€ì… */
  type: RescheduleSuggestionType;
  /** ì œì•ˆ ìš°ì„ ìˆœìœ„ (1-5, ë†’ì„ìˆ˜ë¡ ìš°ì„ ) */
  priority: number;
  /** ì œì•ˆ ì œëª© */
  title: string;
  /** ì œì•ˆ ì„¤ëª… */
  description: string;
  /** ì œì•ˆ ì´ìœ  */
  reason: string;
  /** ì˜ˆìƒ íš¨ê³¼ */
  expectedImpact: string;
  /** ì ìš© ì‹œ í•„ìš”í•œ ì¡°ì • ëª©ë¡ */
  adjustments: AdjustmentInput[];
  /** ì˜í–¥ë°›ëŠ” ë‚ ì§œ ë²”ìœ„ */
  affectedDateRange: {
    from: string; // YYYY-MM-DD
    to: string; // YYYY-MM-DD
  } | null;
}

/**
 * ì œì•ˆ ìƒì„± ì…ë ¥
 */
export interface SuggestionInput {
  /** ì§€ì—° ë¶„ì„ ê²°ê³¼ */
  delayAnalysis: DelayAnalysis;
  /** í”Œëœ ê·¸ë£¹ ì½˜í…ì¸  ëª©ë¡ */
  contents: PlanContent[];
  /** í”Œëœ ê·¸ë£¹ ì‹œì‘ì¼ */
  startDate: string; // YYYY-MM-DD
  /** í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼ */
  endDate: string; // YYYY-MM-DD
}

// ============================================
// ì œì•ˆ ìƒì„± ë¡œì§
// ============================================

/**
 * ê¸°í•œ ì—°ì¥ ì œì•ˆ ìƒì„±
 */
function generateExtendDeadlineSuggestion(
  input: SuggestionInput
): RescheduleSuggestion | null {
  const { delayAnalysis } = input;
  if (delayAnalysis.delayDays <= 0) {
    return null;
  }

  const extensionDays = Math.ceil(delayAnalysis.delayDays * 1.2); // 20% ì—¬ìœ  ì¶”ê°€

  return {
    type: "extend_deadline",
    priority: delayAnalysis.severity === "critical" ? 5 : 4,
    title: "ê¸°í•œ ì—°ì¥",
    description: `í•™ìŠµ ì§€ì—°ì„ ê³ ë ¤í•˜ì—¬ ê¸°í•œì„ ${extensionDays}ì¼ ì—°ì¥í•˜ëŠ” ê²ƒì„ ì œì•ˆí•©ë‹ˆë‹¤.`,
    reason: `í˜„ì¬ ì•½ ${delayAnalysis.delayDays}ì¼ ì§€ì—°ë˜ì–´ ìˆìœ¼ë©°, ê³„íšëœ ê¸°í•œ ë‚´ ì™„ë£Œê°€ ì–´ë ¤ìš¸ ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.`,
    expectedImpact: `ê¸°í•œ ì—°ì¥ìœ¼ë¡œ ì—¬ìœ  ìˆëŠ” í•™ìŠµ ì¼ì •ì„ í™•ë³´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
    adjustments: [], // ê¸°í•œ ì—°ì¥ì€ í”Œëœ ê·¸ë£¹ ë ˆë²¨ ì¡°ì •ì´ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¹ˆ ë°°ì—´
    affectedDateRange: {
      from: input.endDate,
      to: new Date(
        new Date(input.endDate).getTime() +
          extensionDays * 24 * 60 * 60 * 1000
      )
        .toISOString()
        .slice(0, 10),
    },
  };
}

/**
 * ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€ ì œì•ˆ ìƒì„±
 */
function generateIncreaseDailyLoadSuggestion(
  input: SuggestionInput
): RescheduleSuggestion | null {
  const { delayAnalysis } = input;
  if (delayAnalysis.delayDays <= 0 || delayAnalysis.severity === "none") {
    return null;
  }

  const currentDailyPlans = delayAnalysis.details.dailyActualPlans;
  const requiredDailyPlans = delayAnalysis.details.dailyRequiredPlans;
  const increaseRatio = requiredDailyPlans > 0
    ? Math.max(1.1, requiredDailyPlans / currentDailyPlans)
    : 1.2;

  return {
    type: "increase_daily_load",
    priority: delayAnalysis.severity === "critical" ? 5 : 3,
    title: "ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€",
    description: `ì¼ì¼ í•™ìŠµëŸ‰ì„ ${Math.round((increaseRatio - 1) * 100)}% ì¦ê°€ì‹œí‚¤ëŠ” ê²ƒì„ ì œì•ˆí•©ë‹ˆë‹¤.`,
    reason: `í˜„ì¬ ì¼ì¼ í‰ê·  ${currentDailyPlans.toFixed(1)}ê°œ í”Œëœì„ ì™„ë£Œí•˜ê³  ìˆìœ¼ë‚˜, ê³„íš ëŒ€ë¹„ ${requiredDailyPlans.toFixed(1)}ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤.`,
    expectedImpact: `ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€ë¡œ ì§€ì—°ì„ ë”°ë¼ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
    adjustments: [], // ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬ ë ˆë²¨ ì¡°ì •ì´ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¹ˆ ë°°ì—´
    affectedDateRange: {
      from: input.startDate,
      to: input.endDate,
    },
  };
}

/**
 * ì½˜í…ì¸  ë²”ìœ„ ì¶•ì†Œ ì œì•ˆ ìƒì„±
 */
function generateReduceContentRangeSuggestion(
  input: SuggestionInput
): RescheduleSuggestion | null {
  const { delayAnalysis, contents } = input;
  if (delayAnalysis.severity === "none" || delayAnalysis.severity === "low") {
    return null;
  }

  if (contents.length === 0) {
    return null;
  }

  // ê°€ì¥ í° ë²”ìœ„ë¥¼ ê°€ì§„ ì½˜í…ì¸ ë¥¼ 10% ì¶•ì†Œ
  const adjustments: AdjustmentInput[] = contents
    .map((content) => {
      const contentId = content.id || content.content_id;
      const currentRange = content.end_range - content.start_range;
      const reductionRatio = 0.9; // 10% ì¶•ì†Œ
      const newRange = Math.max(1, Math.round(currentRange * reductionRatio));
      const center = (content.start_range + content.end_range) / 2;
      const newStart = Math.max(0, Math.round(center - newRange / 2));
      const newEnd = newStart + newRange;

      return {
        plan_content_id: contentId,
        change_type: "range" as const,
        before: {
          content_id: content.content_id,
          content_type: content.content_type,
          range: {
            start: content.start_range,
            end: content.end_range,
          },
        },
        after: {
          content_id: content.content_id,
          content_type: content.content_type,
          range: {
            start: newStart,
            end: newEnd,
          },
        },
      };
    })
    .slice(0, 3); // ìƒìœ„ 3ê°œë§Œ ì œì•ˆ

  if (adjustments.length === 0) {
    return null;
  }

  return {
    type: "reduce_content_range",
    priority: delayAnalysis.severity === "critical" ? 4 : 3,
    title: "ì½˜í…ì¸  ë²”ìœ„ ì¶•ì†Œ",
    description: `${adjustments.length}ê°œ ì½˜í…ì¸ ì˜ í•™ìŠµ ë²”ìœ„ë¥¼ 10% ì¶•ì†Œí•˜ëŠ” ê²ƒì„ ì œì•ˆí•©ë‹ˆë‹¤.`,
    reason: `í•™ìŠµ ì§€ì—°ì„ ë”°ë¼ì¡ê¸° ìœ„í•´ í•™ìŠµëŸ‰ì„ ì¡°ì •í•˜ëŠ” ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤.`,
    expectedImpact: `ë²”ìœ„ ì¶•ì†Œë¡œ í•™ìŠµ ë¶€ë‹´ì„ ì¤„ì´ê³  ì™„ë£Œ ê°€ëŠ¥ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
    adjustments,
    affectedDateRange: {
      from: input.startDate,
      to: input.endDate,
    },
  };
}

/**
 * í”Œëœ ì¬ë¶„ë°° ì œì•ˆ ìƒì„±
 */
function generateRedistributePlansSuggestion(
  input: SuggestionInput
): RescheduleSuggestion | null {
  const { delayAnalysis } = input;
  if (delayAnalysis.severity === "none" || delayAnalysis.severity === "low") {
    return null;
  }

  if (delayAnalysis.affectedDates.length === 0) {
    return null;
  }

  return {
    type: "redistribute_plans",
    priority: delayAnalysis.severity === "critical" ? 5 : 4,
    title: "í”Œëœ ì¬ë¶„ë°°",
    description: `ëˆ„ë½ëœ í”Œëœì„ ë¯¸ë˜ ë‚ ì§œë¡œ ì¬ë¶„ë°°í•˜ëŠ” ê²ƒì„ ì œì•ˆí•©ë‹ˆë‹¤.`,
    reason: `${delayAnalysis.affectedDates.length}ì¼ ë™ì•ˆ ë¯¸ì™„ë£Œ í”Œëœì´ ëˆ„ì ë˜ì—ˆìŠµë‹ˆë‹¤.`,
    expectedImpact: `ë¯¸ì™„ë£Œ í”Œëœì„ ì¬ë¶„ë°°í•˜ì—¬ í•™ìŠµ ê³„íšì„ ì •ìƒí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
    adjustments: [], // í”Œëœ ì¬ë¶„ë°°ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬ ë ˆë²¨ ì¡°ì •ì´ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¹ˆ ë°°ì—´
    affectedDateRange: {
      from: delayAnalysis.affectedDates[0],
      to: input.endDate,
    },
  };
}

/**
 * ìë™ ì¬ì¡°ì • ì œì•ˆ ìƒì„±
 * 
 * @param input ì œì•ˆ ìƒì„± ì…ë ¥
 * @returns ì¬ì¡°ì • ì œì•ˆ ëª©ë¡ (ìš°ì„ ìˆœìœ„ ìˆœ)
 */
export function generateRescheduleSuggestions(
  input: SuggestionInput
): RescheduleSuggestion[] {
  const suggestions: RescheduleSuggestion[] = [];

  // ì§€ì—°ì´ ì—†ìœ¼ë©´ ì œì•ˆí•˜ì§€ ì•ŠìŒ
  if (input.delayAnalysis.severity === "none") {
    return [];
  }

  // 1. ê¸°í•œ ì—°ì¥ ì œì•ˆ
  const extendSuggestion = generateExtendDeadlineSuggestion(input);
  if (extendSuggestion) {
    suggestions.push(extendSuggestion);
  }

  // 2. ì¼ì¼ í•™ìŠµëŸ‰ ì¦ê°€ ì œì•ˆ
  const increaseLoadSuggestion = generateIncreaseDailyLoadSuggestion(input);
  if (increaseLoadSuggestion) {
    suggestions.push(increaseLoadSuggestion);
  }

  // 3. ì½˜í…ì¸  ë²”ìœ„ ì¶•ì†Œ ì œì•ˆ
  const reduceRangeSuggestion = generateReduceContentRangeSuggestion(input);
  if (reduceRangeSuggestion) {
    suggestions.push(reduceRangeSuggestion);
  }

  // 4. í”Œëœ ì¬ë¶„ë°° ì œì•ˆ
  const redistributeSuggestion = generateRedistributePlansSuggestion(input);
  if (redistributeSuggestion) {
    suggestions.push(redistributeSuggestion);
  }

  // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬
  suggestions.sort((a, b) => b.priority - a.priority);

  return suggestions;
}
</file>

<file path="batchAdjuster.ts">
/**
 * ì¼ê´„ ì¡°ì •ê¸°
 * 
 * ì—¬ëŸ¬ ì½˜í…ì¸ ë¥¼ í•œ ë²ˆì— ì¡°ì •í•˜ëŠ” ë¡œì§ì„ ì œê³µí•©ë‹ˆë‹¤.
 * - ë¹„ìœ¨ ê¸°ë°˜ ë²”ìœ„ ì¡°ì •
 * - ì ˆëŒ€ê°’ ê¸°ë°˜ ë²”ìœ„ ì¡°ì •
 * - ì¼ê´„ ì½˜í…ì¸  êµì²´
 * 
 * @module lib/reschedule/batchAdjuster
 */

import type { PlanContent } from "@/lib/types/plan";
import type { AdjustmentInput } from "./scheduleEngine";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¼ê´„ ì¡°ì • íƒ€ì…
 */
export type BatchAdjustmentType = "ratio" | "absolute" | "replace";

/**
 * ì¼ê´„ ì¡°ì • ì„¤ì •
 */
export interface BatchAdjustmentConfig {
  type: BatchAdjustmentType;
  // ë¹„ìœ¨ ê¸°ë°˜ ì¡°ì •
  ratio?: number; // ì˜ˆ: 1.1 (10% ì¦ê°€), 0.9 (10% ê°ì†Œ)
  // ì ˆëŒ€ê°’ ê¸°ë°˜ ì¡°ì •
  absoluteChange?: number; // ì˜ˆ: +10 (10 ì¦ê°€), -5 (5 ê°ì†Œ)
  // ì½˜í…ì¸  êµì²´
  replacementMap?: Map<string, string>; // content_id -> new_content_id
}

// ============================================
// ì¼ê´„ ë²”ìœ„ ì¡°ì •
// ============================================

/**
 * ë¹„ìœ¨ ê¸°ë°˜ ë²”ìœ„ ì¡°ì •
 * 
 * @param contents ì¡°ì •í•  ì½˜í…ì¸  ëª©ë¡
 * @param ratio ì¡°ì • ë¹„ìœ¨ (1.0 = ë³€í™” ì—†ìŒ, 1.1 = 10% ì¦ê°€, 0.9 = 10% ê°ì†Œ)
 * @returns ì¡°ì •ëœ AdjustmentInput ëª©ë¡
 */
export function applyRatioAdjustment(
  contents: PlanContent[],
  ratio: number
): AdjustmentInput[] {
  const adjustments: AdjustmentInput[] = [];

  contents.forEach((content) => {
    const contentId = content.id || content.content_id;
    const currentRange = content.end_range - content.start_range;
    const newRange = Math.round(currentRange * ratio);
    const center = (content.start_range + content.end_range) / 2;
    const newStart = Math.max(0, Math.round(center - newRange / 2));
    const newEnd = newStart + newRange;

    adjustments.push({
      plan_content_id: contentId,
      change_type: "range",
      before: {
        content_id: content.content_id,
        content_type: content.content_type,
        range: {
          start: content.start_range,
          end: content.end_range,
        },
      },
      after: {
        content_id: content.content_id,
        content_type: content.content_type,
        range: {
          start: newStart,
          end: newEnd,
        },
      },
    });
  });

  return adjustments;
}

/**
 * ì ˆëŒ€ê°’ ê¸°ë°˜ ë²”ìœ„ ì¡°ì •
 * 
 * @param contents ì¡°ì •í•  ì½˜í…ì¸  ëª©ë¡
 * @param absoluteChange ì ˆëŒ€ê°’ ë³€í™” (ì–‘ìˆ˜ = ì¦ê°€, ìŒìˆ˜ = ê°ì†Œ)
 * @returns ì¡°ì •ëœ AdjustmentInput ëª©ë¡
 */
export function applyAbsoluteAdjustment(
  contents: PlanContent[],
  absoluteChange: number
): AdjustmentInput[] {
  const adjustments: AdjustmentInput[] = [];

  contents.forEach((content) => {
    const contentId = content.id || content.content_id;
    const currentRange = content.end_range - content.start_range;
    const newRange = Math.max(1, currentRange + absoluteChange);
    const center = (content.start_range + content.end_range) / 2;
    const newStart = Math.max(0, Math.round(center - newRange / 2));
    const newEnd = newStart + newRange;

    adjustments.push({
      plan_content_id: contentId,
      change_type: "range",
      before: {
        content_id: content.content_id,
        content_type: content.content_type,
        range: {
          start: content.start_range,
          end: content.end_range,
        },
      },
      after: {
        content_id: content.content_id,
        content_type: content.content_type,
        range: {
          start: newStart,
          end: newEnd,
        },
      },
    });
  });

  return adjustments;
}

/**
 * ì¼ê´„ ì½˜í…ì¸  êµì²´
 * 
 * @param contents ì¡°ì •í•  ì½˜í…ì¸  ëª©ë¡
 * @param replacementMap êµì²´ ë§¤í•‘ (content_id -> new_content_id)
 * @returns ì¡°ì •ëœ AdjustmentInput ëª©ë¡
 */
export function applyReplacementAdjustment(
  contents: PlanContent[],
  replacementMap: Map<string, string>
): AdjustmentInput[] {
  const adjustments: AdjustmentInput[] = [];

  contents.forEach((content) => {
    const contentId = content.id || content.content_id;
    const newContentId = replacementMap.get(content.content_id);

    if (!newContentId || newContentId === content.content_id) {
      return; // êµì²´í•  ì½˜í…ì¸ ê°€ ì—†ê±°ë‚˜ ë™ì¼í•˜ë©´ ìŠ¤í‚µ
    }

    adjustments.push({
      plan_content_id: contentId,
      change_type: "replace",
      before: {
        content_id: content.content_id,
        content_type: content.content_type,
        range: {
          start: content.start_range,
          end: content.end_range,
        },
      },
      after: {
        content_id: newContentId,
        content_type: content.content_type, // TODO: ì‹¤ì œ íƒ€ì… ì¡°íšŒ í•„ìš”
        range: {
          start: content.start_range,
          end: content.end_range,
        },
      },
    });
  });

  return adjustments;
}

/**
 * ì¼ê´„ ì¡°ì • ì ìš©
 * 
 * @param contents ì¡°ì •í•  ì½˜í…ì¸  ëª©ë¡
 * @param config ì¼ê´„ ì¡°ì • ì„¤ì •
 * @returns ì¡°ì •ëœ AdjustmentInput ëª©ë¡
 */
export function applyBatchAdjustment(
  contents: PlanContent[],
  config: BatchAdjustmentConfig
): AdjustmentInput[] {
  switch (config.type) {
    case "ratio":
      if (config.ratio === undefined) {
        throw new Error("ë¹„ìœ¨ ê¸°ë°˜ ì¡°ì •ì—ëŠ” ratioê°€ í•„ìš”í•©ë‹ˆë‹¤.");
      }
      return applyRatioAdjustment(contents, config.ratio);
    case "absolute":
      if (config.absoluteChange === undefined) {
        throw new Error("ì ˆëŒ€ê°’ ê¸°ë°˜ ì¡°ì •ì—ëŠ” absoluteChangeê°€ í•„ìš”í•©ë‹ˆë‹¤.");
      }
      return applyAbsoluteAdjustment(contents, config.absoluteChange);
    case "replace":
      if (!config.replacementMap) {
        throw new Error("ì½˜í…ì¸  êµì²´ì—ëŠ” replacementMapì´ í•„ìš”í•©ë‹ˆë‹¤.");
      }
      return applyReplacementAdjustment(contents, config.replacementMap);
    default:
      return [];
  }
}

/**
 * ì¼ê´„ ì¡°ì • ë¯¸ë¦¬ë³´ê¸°
 * 
 * @param contents ì¡°ì •í•  ì½˜í…ì¸  ëª©ë¡
 * @param config ì¼ê´„ ì¡°ì • ì„¤ì •
 * @returns ë¯¸ë¦¬ë³´ê¸° ì •ë³´
 */
export function previewBatchAdjustment(
  contents: PlanContent[],
  config: BatchAdjustmentConfig
): {
  affectedCount: number;
  totalRangeBefore: number;
  totalRangeAfter: number;
  rangeChange: number;
  sampleAdjustments: Array<{
    content_id: string;
    before: { start: number; end: number };
    after: { start: number; end: number };
  }>;
} {
  const adjustments = applyBatchAdjustment(contents, config);

  let totalRangeBefore = 0;
  let totalRangeAfter = 0;

  adjustments.forEach((adj) => {
    const beforeRange = adj.before.range.end - adj.before.range.start;
    const afterRange = adj.after.range.end - adj.after.range.start;
    totalRangeBefore += beforeRange;
    totalRangeAfter += afterRange;
  });

  const sampleAdjustments = adjustments.slice(0, 3).map((adj) => ({
    content_id: adj.before.content_id,
    before: adj.before.range,
    after: adj.after.range,
  }));

  return {
    affectedCount: adjustments.length,
    totalRangeBefore,
    totalRangeAfter,
    rangeChange: totalRangeAfter - totalRangeBefore,
    sampleAdjustments,
  };
}
</file>

<file path="batchProcessor.ts">
/**
 * ì¬ì¡°ì • Batch ì²˜ë¦¬ ìœ í‹¸ë¦¬í‹°
 * 
 * ëŒ€ëŸ‰ì˜ í”Œëœì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ Batch ìœ í‹¸ë¦¬í‹°ì…ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/batchProcessor
 */

import type { SupabaseClient } from '@supabase/supabase-js';

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * í”Œëœ ìƒì„± ì…ë ¥
 */
export interface CreatePlanInput {
  tenant_id?: string | null;
  student_id: string;
  plan_group_id: string | null;
  plan_date: string;
  block_index: number;
  content_type: 'book' | 'lecture' | 'custom';
  content_id: string;
  chapter?: string | null;
  planned_start_page_or_time?: number | null;
  planned_end_page_or_time?: number | null;
  completed_amount?: number | null;
  progress?: number | null;
  is_reschedulable?: boolean;
  start_time?: string | null;
  end_time?: string | null;
  actual_start_time?: string | null;
  actual_end_time?: string | null;
  total_duration_seconds?: number | null;
  paused_duration_seconds?: number | null;
  pause_count?: number | null;
  plan_number?: number | null;
  sequence?: number | null;
  memo?: string | null;
  day_type?: string | null;
  week?: number | null;
  day?: number | null;
  is_partial?: boolean | null;
  is_continued?: boolean | null;
  status?: string;
  is_active?: boolean;
  version_group_id?: string | null;
  version?: number;
  [key: string]: any;
}

/**
 * íˆìŠ¤í† ë¦¬ ìƒì„± ì…ë ¥
 */
export interface CreateHistoryInput {
  plan_id: string;
  plan_group_id: string;
  plan_data: any;
  content_id?: string | null;
  adjustment_type?: 'range' | 'replace' | 'full' | null;
  reschedule_log_id?: string | null;
  tenant_id?: string | null;
  created_by?: string | null;
}

// ============================================
// Batch ì²˜ë¦¬ í•¨ìˆ˜
// ============================================

/**
 * ëŒ€ëŸ‰ í”Œëœ ë¹„í™œì„±í™”
 * 
 * ì—¬ëŸ¬ í”Œëœì„ í•œ ë²ˆì— ë¹„í™œì„±í™”í•©ë‹ˆë‹¤.
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param planIds í”Œëœ ID ëª©ë¡
 * @returns ë¹„í™œì„±í™”ëœ í”Œëœ ìˆ˜
 */
export async function batchDeactivatePlans(
  supabase: SupabaseClient,
  planIds: string[]
): Promise<number> {
  if (planIds.length === 0) {
    return 0;
  }

  // SupabaseëŠ” í•œ ë²ˆì— ìµœëŒ€ 1000ê°œê¹Œì§€ ì—…ë°ì´íŠ¸ ê°€ëŠ¥
  const BATCH_SIZE = 1000;
  let totalUpdated = 0;

  for (let i = 0; i < planIds.length; i += BATCH_SIZE) {
    const batch = planIds.slice(i, i + BATCH_SIZE);
    
    const { data, error } = await supabase
      .from('student_plan')
      .update({
        is_active: false,
        status: 'canceled',
      })
      .in('id', batch)
      .select('id');

    if (error) {
      console.error(`[batchProcessor] í”Œëœ ë¹„í™œì„±í™” ì‹¤íŒ¨ (ë°°ì¹˜ ${i / BATCH_SIZE + 1}):`, error);
      throw new Error(`í”Œëœ ë¹„í™œì„±í™” ì‹¤íŒ¨: ${error.message}`);
    }

    totalUpdated += data?.length || 0;
  }

  return totalUpdated;
}

/**
 * ëŒ€ëŸ‰ í”Œëœ ìƒì„±
 * 
 * ì—¬ëŸ¬ í”Œëœì„ í•œ ë²ˆì— ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param plans í”Œëœ ë°ì´í„° ëª©ë¡
 * @returns ìƒì„±ëœ í”Œëœ ID ëª©ë¡
 */
export async function batchCreatePlans(
  supabase: SupabaseClient,
  plans: CreatePlanInput[]
): Promise<string[]> {
  if (plans.length === 0) {
    return [];
  }

  // SupabaseëŠ” í•œ ë²ˆì— ìµœëŒ€ 1000ê°œê¹Œì§€ INSERT ê°€ëŠ¥
  const BATCH_SIZE = 1000;
  const createdIds: string[] = [];

  for (let i = 0; i < plans.length; i += BATCH_SIZE) {
    const batch = plans.slice(i, i + BATCH_SIZE);
    
    const { data, error } = await supabase
      .from('student_plan')
      .insert(batch)
      .select('id');

    if (error) {
      console.error(`[batchProcessor] í”Œëœ ìƒì„± ì‹¤íŒ¨ (ë°°ì¹˜ ${i / BATCH_SIZE + 1}):`, error);
      throw new Error(`í”Œëœ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }

    if (data) {
      createdIds.push(...data.map((p) => p.id));
    }
  }

  return createdIds;
}

/**
 * ëŒ€ëŸ‰ íˆìŠ¤í† ë¦¬ ìƒì„±
 * 
 * ì—¬ëŸ¬ í”Œëœ íˆìŠ¤í† ë¦¬ë¥¼ í•œ ë²ˆì— ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param histories íˆìŠ¤í† ë¦¬ ë°ì´í„° ëª©ë¡
 * @returns ìƒì„±ëœ íˆìŠ¤í† ë¦¬ ID ëª©ë¡
 */
export async function batchCreateHistory(
  supabase: SupabaseClient,
  histories: CreateHistoryInput[]
): Promise<string[]> {
  if (histories.length === 0) {
    return [];
  }

  // SupabaseëŠ” í•œ ë²ˆì— ìµœëŒ€ 1000ê°œê¹Œì§€ INSERT ê°€ëŠ¥
  const BATCH_SIZE = 1000;
  const createdIds: string[] = [];

  for (let i = 0; i < histories.length; i += BATCH_SIZE) {
    const batch = histories.slice(i, i + BATCH_SIZE);
    
    const { data, error } = await supabase
      .from('plan_history')
      .insert(batch)
      .select('id');

    if (error) {
      console.error(`[batchProcessor] íˆìŠ¤í† ë¦¬ ìƒì„± ì‹¤íŒ¨ (ë°°ì¹˜ ${i / BATCH_SIZE + 1}):`, error);
      throw new Error(`íˆìŠ¤í† ë¦¬ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }

    if (data) {
      createdIds.push(...data.map((h) => h.id));
    }
  }

  return createdIds;
}

/**
 * ëŒ€ëŸ‰ í”Œëœ ì—…ë°ì´íŠ¸
 * 
 * ì—¬ëŸ¬ í”Œëœì„ í•œ ë²ˆì— ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param updates ì—…ë°ì´íŠ¸ ë°ì´í„° (planIdì™€ ì—…ë°ì´íŠ¸ í•„ë“œ)
 * @returns ì—…ë°ì´íŠ¸ëœ í”Œëœ ìˆ˜
 */
export async function batchUpdatePlans(
  supabase: SupabaseClient,
  updates: Array<{ planId: string; data: Partial<CreatePlanInput> }>
): Promise<number> {
  if (updates.length === 0) {
    return 0;
  }

  // ê°œë³„ ì—…ë°ì´íŠ¸ (SupabaseëŠ” WHERE INìœ¼ë¡œ ì—¬ëŸ¬ í–‰ì„ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•  ìˆ˜ ì—†ìŒ)
  // ë˜ëŠ” PostgreSQLì˜ UPDATE ... FROM êµ¬ë¬¸ ì‚¬ìš©
  // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•˜ê²Œ ê°œë³„ ì—…ë°ì´íŠ¸ë¡œ ì²˜ë¦¬
  let totalUpdated = 0;

  for (const update of updates) {
    const { error } = await supabase
      .from('student_plan')
      .update(update.data)
      .eq('id', update.planId);

    if (error) {
      console.error(`[batchProcessor] í”Œëœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (${update.planId}):`, error);
      continue; // ê°œë³„ ì‹¤íŒ¨ëŠ” ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ê³„ì† ì§„í–‰
    }

    totalUpdated++;
  }

  return totalUpdated;
}
</file>

<file path="conflictDetector.ts">
/**
 * ì¶©ëŒ ê°ì§€ê¸°
 * 
 * ì¬ì¡°ì • ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì¶©ëŒì„ ê°ì§€í•©ë‹ˆë‹¤.
 * - ì‹œê°„ ê²¹ì¹¨ ê°ì§€
 * - ê³¼ë¶€í•˜ ë‚ ì§œ ê°ì§€
 * 
 * @module lib/reschedule/conflictDetector
 */

import { parseISO, format } from "date-fns";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¶©ëŒ íƒ€ì…
 */
export type ConflictType = "time_overlap" | "overload" | "insufficient_time";

/**
 * ì¶©ëŒ ì •ë³´
 */
export interface Conflict {
  type: ConflictType;
  date: string; // YYYY-MM-DD
  severity: "low" | "medium" | "high";
  message: string;
  details?: {
    affectedPlans?: number;
    totalHours?: number;
    maxHours?: number;
    overlappingPlans?: Array<{
      plan_id: string;
      start_time: string;
      end_time: string;
    }>;
  };
}

/**
 * í”Œëœ ì •ë³´ (ì‹œê°„ í¬í•¨)
 */
export interface PlanWithTime {
  id: string;
  plan_date: string; // YYYY-MM-DD
  start_time: string | null; // HH:mm
  end_time: string | null; // HH:mm
  content_id: string;
  content_type: string;
}

// ============================================
// ì‹œê°„ ê²¹ì¹¨ ê°ì§€
// ============================================

/**
 * ì‹œê°„ì„ ë¶„ ë‹¨ìœ„ë¡œ ë³€í™˜
 */
function timeToMinutes(time: string): number {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
}

/**
 * ë‘ ì‹œê°„ ë²”ìœ„ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
 */
function isTimeOverlapping(
  start1: string,
  end1: string,
  start2: string,
  end2: string
): boolean {
  const start1Min = timeToMinutes(start1);
  const end1Min = timeToMinutes(end1);
  const start2Min = timeToMinutes(start2);
  const end2Min = timeToMinutes(end2);

  return !(end1Min <= start2Min || end2Min <= start1Min);
}

/**
 * ì‹œê°„ ê²¹ì¹¨ ì¶©ëŒ ê°ì§€
 * 
 * @param plans í”Œëœ ëª©ë¡ (ì‹œê°„ í¬í•¨)
 * @returns ì‹œê°„ ê²¹ì¹¨ ì¶©ëŒ ëª©ë¡
 */
export function detectTimeOverlaps(plans: PlanWithTime[]): Conflict[] {
  const conflicts: Conflict[] = [];
  const dateMap = new Map<string, PlanWithTime[]>();

  // ë‚ ì§œë³„ë¡œ ê·¸ë£¹í™”
  plans.forEach((plan) => {
    if (!plan.start_time || !plan.end_time) {
      return; // ì‹œê°„ ì •ë³´ê°€ ì—†ìœ¼ë©´ ìŠ¤í‚µ
    }

    if (!dateMap.has(plan.plan_date)) {
      dateMap.set(plan.plan_date, []);
    }
    dateMap.get(plan.plan_date)!.push(plan);
  });

  // ê° ë‚ ì§œë³„ë¡œ ì‹œê°„ ê²¹ì¹¨ í™•ì¸
  dateMap.forEach((datePlans, date) => {
    for (let i = 0; i < datePlans.length; i++) {
      for (let j = i + 1; j < datePlans.length; j++) {
        const plan1 = datePlans[i];
        const plan2 = datePlans[j];

        if (
          plan1.start_time &&
          plan1.end_time &&
          plan2.start_time &&
          plan2.end_time &&
          isTimeOverlapping(
            plan1.start_time,
            plan1.end_time,
            plan2.start_time,
            plan2.end_time
          )
        ) {
          conflicts.push({
            type: "time_overlap",
            date,
            severity: "high",
            message: `${format(new Date(date), "Mì›” dì¼")}ì— ì‹œê°„ ê²¹ì¹¨ì´ ë°œìƒí•©ë‹ˆë‹¤.`,
            details: {
              overlappingPlans: [
                {
                  plan_id: plan1.id,
                  start_time: plan1.start_time,
                  end_time: plan1.end_time,
                },
                {
                  plan_id: plan2.id,
                  start_time: plan2.start_time,
                  end_time: plan2.end_time,
                },
              ],
            },
          });
        }
      }
    }
  });

  return conflicts;
}

// ============================================
// ê³¼ë¶€í•˜ ê°ì§€
// ============================================

/**
 * ê³¼ë¶€í•˜ ì¶©ëŒ ê°ì§€
 * 
 * @param datePlansMap ë‚ ì§œë³„ í”Œëœ ëª©ë¡ ë§µ
 * @param maxHoursPerDay ì¼ì¼ ìµœëŒ€ í•™ìŠµ ì‹œê°„ (ê¸°ë³¸ê°’: 12ì‹œê°„)
 * @returns ê³¼ë¶€í•˜ ì¶©ëŒ ëª©ë¡
 */
export function detectOverloads(
  datePlansMap: Map<string, { totalHours: number; planCount: number }>,
  maxHoursPerDay: number = 12
): Conflict[] {
  const conflicts: Conflict[] = [];

  datePlansMap.forEach((data, date) => {
    if (data.totalHours > maxHoursPerDay) {
      const overloadRatio = data.totalHours / maxHoursPerDay;
      const severity: "low" | "medium" | "high" =
        overloadRatio >= 1.5 ? "high" : overloadRatio >= 1.2 ? "medium" : "low";

      conflicts.push({
        type: "overload",
        date,
        severity,
        message: `${format(new Date(date), "Mì›” dì¼")}ì— ì¼ì¼ í•™ìŠµ ì‹œê°„ì´ ê³¼ë¶€í•˜ì…ë‹ˆë‹¤ (${data.totalHours.toFixed(1)}ì‹œê°„ / ìµœëŒ€ ${maxHoursPerDay}ì‹œê°„).`,
        details: {
          affectedPlans: data.planCount,
          totalHours: data.totalHours,
          maxHours: maxHoursPerDay,
        },
      });
    }
  });

  return conflicts;
}

// ============================================
// í†µí•© ì¶©ëŒ ê°ì§€
// ============================================

/**
 * ëª¨ë“  ì¶©ëŒ ê°ì§€
 * 
 * @param plans í”Œëœ ëª©ë¡ (ì‹œê°„ í¬í•¨)
 * @param datePlansMap ë‚ ì§œë³„ í”Œëœ í†µê³„ ë§µ
 * @param maxHoursPerDay ì¼ì¼ ìµœëŒ€ í•™ìŠµ ì‹œê°„
 * @returns ëª¨ë“  ì¶©ëŒ ëª©ë¡
 */
export function detectAllConflicts(
  plans: PlanWithTime[],
  datePlansMap?: Map<string, { totalHours: number; planCount: number }>,
  maxHoursPerDay: number = 12
): Conflict[] {
  const conflicts: Conflict[] = [];

  // ì‹œê°„ ê²¹ì¹¨ ê°ì§€
  const timeOverlaps = detectTimeOverlaps(plans);
  conflicts.push(...timeOverlaps);

  // ê³¼ë¶€í•˜ ê°ì§€
  if (datePlansMap) {
    const overloads = detectOverloads(datePlansMap, maxHoursPerDay);
    conflicts.push(...overloads);
  }

  // ì‹¬ê°ë„ ìˆœìœ¼ë¡œ ì •ë ¬ (high -> medium -> low)
  conflicts.sort((a, b) => {
    const severityOrder = { high: 3, medium: 2, low: 1 };
    return severityOrder[b.severity] - severityOrder[a.severity];
  });

  return conflicts;
}
</file>

<file path="dateRangeAnalyzer.ts">
/**
 * ë‚ ì§œ ë²”ìœ„ ë¶„ì„ê¸°
 * 
 * ì¬ì¡°ì • ëŒ€ìƒ ì½˜í…ì¸ ì˜ ì˜í–¥ë°›ëŠ” ë‚ ì§œë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³  ì¶”ì²œ ë‚ ì§œ ë²”ìœ„ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/dateRangeAnalyzer
 */

import { parseISO, format, isAfter, isBefore, isSameDay, eachDayOfInterval, startOfDay } from "date-fns";
import { isReschedulable, isCompletedPlan } from "@/lib/utils/planStatusUtils";
import type { PlanContent } from "@/lib/types/plan";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ë‚ ì§œ ë²”ìœ„
 */
export interface DateRange {
  from: string; // YYYY-MM-DD
  to: string; // YYYY-MM-DD
}

/**
 * ì¶”ì²œ ë‚ ì§œ ë²”ìœ„
 */
export interface SuggestedDateRange {
  range: DateRange;
  reason: string;
  priority: number; // ë†’ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ
  affectedPlansCount: number;
  affectedDates: string[];
}

/**
 * í”Œëœ ì •ë³´ (ë‚ ì§œ í¬í•¨)
 */
export interface PlanWithDate {
  id: string;
  plan_date: string; // YYYY-MM-DD
  status: string | null;
  is_active: boolean | null;
  content_id: string;
}

// ============================================
// ì˜í–¥ë°›ëŠ” ë‚ ì§œ ê°ì§€
// ============================================

/**
 * ì¬ì¡°ì • ëŒ€ìƒ ì½˜í…ì¸ ì˜ ì˜í–¥ë°›ëŠ” ë‚ ì§œ ëª©ë¡ ì¶”ì¶œ
 * 
 * @param selectedContentIds ì„ íƒëœ ì½˜í…ì¸  ID ëª©ë¡
 * @param contents ì „ì²´ ì½˜í…ì¸  ëª©ë¡
 * @param existingPlans ê¸°ì¡´ í”Œëœ ëª©ë¡
 * @returns ì˜í–¥ë°›ëŠ” ë‚ ì§œ ëª©ë¡ (YYYY-MM-DD í˜•ì‹)
 */
export function getAffectedDates(
  selectedContentIds: Set<string>,
  contents: PlanContent[],
  existingPlans: PlanWithDate[]
): string[] {
  const affectedDates = new Set<string>();

  // ì„ íƒëœ ì½˜í…ì¸ ì˜ ID ëª©ë¡ ìƒì„±
  const selectedContentIdSet = new Set<string>();
  contents.forEach((content) => {
    const contentId = content.id || content.content_id;
    if (selectedContentIds.has(contentId)) {
      selectedContentIdSet.add(content.content_id);
    }
  });

  // ì„ íƒëœ ì½˜í…ì¸ ì˜ ì¬ì¡°ì • ê°€ëŠ¥í•œ í”Œëœ ë‚ ì§œ ìˆ˜ì§‘
  existingPlans.forEach((plan) => {
    if (
      selectedContentIdSet.has(plan.content_id) &&
      isReschedulable({
        status: (plan.status as any) || "pending",
        is_active: plan.is_active ?? true,
      })
    ) {
      affectedDates.add(plan.plan_date);
    }
  });

  return Array.from(affectedDates).sort();
}

/**
 * ì™„ë£Œëœ í”Œëœì´ ìˆëŠ” ë‚ ì§œ ëª©ë¡ ì¶”ì¶œ
 * 
 * @param existingPlans ê¸°ì¡´ í”Œëœ ëª©ë¡
 * @returns ì™„ë£Œëœ í”Œëœì´ ìˆëŠ” ë‚ ì§œ ëª©ë¡ (YYYY-MM-DD í˜•ì‹)
 */
export function getCompletedPlanDates(
  existingPlans: PlanWithDate[]
): Set<string> {
  const completedDates = new Set<string>();

  existingPlans.forEach((plan) => {
    if (
      isCompletedPlan({
        status: (plan.status as any) || "pending",
      })
    ) {
      completedDates.add(plan.plan_date);
    }
  });

  return completedDates;
}

// ============================================
// ë‚ ì§œ ë²”ìœ„ ê·¸ë£¹í™”
// ============================================

/**
 * ë‚ ì§œ ëª©ë¡ì„ ì—°ì†ëœ ë²”ìœ„ë¡œ ê·¸ë£¹í™”
 * 
 * @param dates ë‚ ì§œ ëª©ë¡ (YYYY-MM-DD í˜•ì‹, ì •ë ¬ë¨)
 * @returns ì—°ì†ëœ ë‚ ì§œ ë²”ìœ„ ëª©ë¡
 */
export function groupConsecutiveDates(dates: string[]): DateRange[] {
  if (dates.length === 0) {
    return [];
  }

  const ranges: DateRange[] = [];
  let currentStart = dates[0];
  let currentEnd = dates[0];

  for (let i = 1; i < dates.length; i++) {
    const currentDate = parseISO(dates[i]);
    const previousDate = parseISO(dates[i - 1]);
    const daysDiff = Math.floor(
      (currentDate.getTime() - previousDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysDiff === 1) {
      // ì—°ì†ëœ ë‚ ì§œ
      currentEnd = dates[i];
    } else {
      // ë¶ˆì—°ì† ë‚ ì§œ - í˜„ì¬ ë²”ìœ„ ì €ì¥í•˜ê³  ìƒˆ ë²”ìœ„ ì‹œì‘
      ranges.push({
        from: currentStart,
        to: currentEnd,
      });
      currentStart = dates[i];
      currentEnd = dates[i];
    }
  }

  // ë§ˆì§€ë§‰ ë²”ìœ„ ì €ì¥
  ranges.push({
    from: currentStart,
    to: currentEnd,
  });

  return ranges;
}

// ============================================
// ì¶”ì²œ ë‚ ì§œ ë²”ìœ„ ìƒì„±
// ============================================

/**
 * ìŠ¤ë§ˆíŠ¸ ë‚ ì§œ ë²”ìœ„ ì¶”ì²œ ìƒì„±
 * 
 * @param selectedContentIds ì„ íƒëœ ì½˜í…ì¸  ID ëª©ë¡
 * @param contents ì „ì²´ ì½˜í…ì¸  ëª©ë¡
 * @param existingPlans ê¸°ì¡´ í”Œëœ ëª©ë¡
 * @param groupPeriodStart í”Œëœ ê·¸ë£¹ ì‹œì‘ì¼
 * @param groupPeriodEnd í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼
 * @returns ì¶”ì²œ ë‚ ì§œ ë²”ìœ„ ëª©ë¡ (ìš°ì„ ìˆœìœ„ ìˆœ)
 */
export function generateDateRangeSuggestions(
  selectedContentIds: Set<string>,
  contents: PlanContent[],
  existingPlans: PlanWithDate[],
  groupPeriodStart: string,
  groupPeriodEnd: string
): SuggestedDateRange[] {
  const suggestions: SuggestedDateRange[] = [];

  // 1. ì˜í–¥ë°›ëŠ” ë‚ ì§œ ì¶”ì¶œ
  const affectedDates = getAffectedDates(
    selectedContentIds,
    contents,
    existingPlans
  );

  if (affectedDates.length === 0) {
    return suggestions;
  }

  // 2. ì™„ë£Œëœ í”Œëœ ë‚ ì§œ ì¶”ì¶œ
  const completedDates = getCompletedPlanDates(existingPlans);

  // 3. ì™„ë£Œëœ í”Œëœ ë‚ ì§œ ì œì™¸í•œ ì˜í–¥ë°›ëŠ” ë‚ ì§œ
  const reschedulableDates = affectedDates.filter(
    (date) => !completedDates.has(date)
  );

  if (reschedulableDates.length === 0) {
    return suggestions;
  }

  // 4. ì—°ì†ëœ ë‚ ì§œ ë²”ìœ„ë¡œ ê·¸ë£¹í™”
  const dateRanges = groupConsecutiveDates(reschedulableDates);

  // 5. ê° ë²”ìœ„ì— ëŒ€í•œ ì¶”ì²œ ìƒì„±
  dateRanges.forEach((range, index) => {
    const rangeDates = eachDayOfInterval({
      start: parseISO(range.from),
      end: parseISO(range.to),
    }).map((date) => format(date, "yyyy-MM-dd"));

    // ì˜í–¥ë°›ëŠ” í”Œëœ ìˆ˜ ê³„ì‚°
    const affectedPlansCount = existingPlans.filter((plan) =>
      rangeDates.includes(plan.plan_date) &&
      isReschedulable({
        status: (plan.status as any) || "pending",
        is_active: plan.is_active ?? true,
      })
    ).length;

    // ì¶”ì²œ ì´ìœ  ìƒì„±
    const daysCount = rangeDates.length;
    let reason = "";
    let priority = 0;

    if (daysCount === 1) {
      reason = "ë‹¨ì¼ ë‚ ì§œ ì¬ì¡°ì •";
      priority = 5;
    } else if (daysCount <= 7) {
      reason = `${daysCount}ì¼ ì—°ì† ì¬ì¡°ì • (${range.from} ~ ${range.to})`;
      priority = 8;
    } else if (daysCount <= 14) {
      reason = `${daysCount}ì¼ ì—°ì† ì¬ì¡°ì • (ì•½ ${Math.ceil(daysCount / 7)}ì£¼)`;
      priority = 7;
    } else {
      reason = `${daysCount}ì¼ ì—°ì† ì¬ì¡°ì • (ì•½ ${Math.ceil(daysCount / 7)}ì£¼)`;
      priority = 6;
    }

    suggestions.push({
      range,
      reason,
      priority,
      affectedPlansCount,
      affectedDates: rangeDates,
    });
  });

  // 6. ì „ì²´ ë²”ìœ„ ì¶”ì²œ ì¶”ê°€
  if (reschedulableDates.length > 0) {
    const allRangeStart = reschedulableDates[0];
    const allRangeEnd = reschedulableDates[reschedulableDates.length - 1];

    const allRangeDates = eachDayOfInterval({
      start: parseISO(allRangeStart),
      end: parseISO(allRangeEnd),
    }).map((date) => format(date, "yyyy-MM-dd"));

    const allAffectedPlansCount = existingPlans.filter((plan) =>
      reschedulableDates.includes(plan.plan_date) &&
      isReschedulable({
        status: (plan.status as any) || "pending",
        is_active: plan.is_active ?? true,
      })
    ).length;

    suggestions.push({
      range: {
        from: allRangeStart,
        to: allRangeEnd,
      },
      reason: `ëª¨ë“  ì˜í–¥ë°›ëŠ” ë‚ ì§œ (${reschedulableDates.length}ì¼)`,
      priority: 4,
      affectedPlansCount: allAffectedPlansCount,
      affectedDates: reschedulableDates,
    });
  }

  // 7. ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ìš°ì„ ìˆœìœ„ê°€ ë¨¼ì €)
  suggestions.sort((a, b) => b.priority - a.priority);

  return suggestions;
}

/**
 * ë¯¸ì™„ë£Œ í”Œëœë§Œ í¬í•¨í•˜ëŠ” ë‚ ì§œ ë²”ìœ„ ì¶”ì²œ
 * 
 * @param selectedContentIds ì„ íƒëœ ì½˜í…ì¸  ID ëª©ë¡
 * @param contents ì „ì²´ ì½˜í…ì¸  ëª©ë¡
 * @param existingPlans ê¸°ì¡´ í”Œëœ ëª©ë¡
 * @param groupPeriodStart í”Œëœ ê·¸ë£¹ ì‹œì‘ì¼
 * @param groupPeriodEnd í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼
 * @returns ì¶”ì²œ ë‚ ì§œ ë²”ìœ„ (ë¯¸ì™„ë£Œ í”Œëœë§Œ)
 */
export function suggestIncompletePlansRange(
  selectedContentIds: Set<string>,
  contents: PlanContent[],
  existingPlans: PlanWithDate[],
  groupPeriodStart: string,
  groupPeriodEnd: string
): SuggestedDateRange | null {
  const suggestions = generateDateRangeSuggestions(
    selectedContentIds,
    contents,
    existingPlans,
    groupPeriodStart,
    groupPeriodEnd
  );

  // ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì¶”ì²œ ë°˜í™˜
  return suggestions.length > 0 ? suggestions[0] : null;
}
</file>

<file path="delayDetector.ts">
/**
 * í•™ìŠµ ì§€ì—° ê°ì§€ê¸°
 * 
 * í”Œëœ ê·¸ë£¹ì˜ í•™ìŠµ ì§€ì—°ì„ ê°ì§€í•˜ê³  ë¶„ì„í•©ë‹ˆë‹¤.
 * - ê³„íš ëŒ€ë¹„ ì‹¤ì œ ì§„í–‰ë¥  ê³„ì‚°
 * - ì§€ì—° ì •ë„ ì¸¡ì •
 * - ì§€ì—° ì›ì¸ ë¶„ì„
 * 
 * @module lib/reschedule/delayDetector
 */

import { format, parseISO, differenceInDays, isBefore, isAfter, addDays, isValid } from "date-fns";
import type { Plan } from "@/lib/data/studentPlans";

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì§€ì—° ì‹¬ê°ë„
 */
export type DelaySeverity = "none" | "low" | "medium" | "high" | "critical";

/**
 * ì§€ì—° ì›ì¸
 */
export type DelayCause =
  | "low_completion_rate" // ë‚®ì€ ì™„ë£Œìœ¨
  | "missed_plans" // ë¯¸ì™„ë£Œ í”Œëœ ëˆ„ì 
  | "slow_progress" // ì§„í–‰ ì†ë„ ì €í•˜
  | "overload" // ê³¼ë¶€í•˜
  | "schedule_conflict"; // ì¼ì • ì¶©ëŒ

/**
 * ì§€ì—° ë¶„ì„ ê²°ê³¼
 */
export interface DelayAnalysis {
  /** ì§€ì—° ì‹¬ê°ë„ */
  severity: DelaySeverity;
  /** ì§€ì—° ì •ë„ (ì¼ ë‹¨ìœ„) */
  delayDays: number;
  /** ì§€ì—° ì›ì¸ ëª©ë¡ */
  causes: DelayCause[];
  /** ì§€ì—° ì„¤ëª… */
  description: string;
  /** ê³„íš ëŒ€ë¹„ ì‹¤ì œ ì§„í–‰ë¥  (%) */
  progressRate: number;
  /** ì˜ˆìƒ ì™„ë£Œì¼ */
  expectedCompletionDate: string | null;
  /** ì‹¤ì œ ì˜ˆìƒ ì™„ë£Œì¼ (ì§€ì—° ë°˜ì˜) */
  actualCompletionDate: string | null;
  /** ì˜í–¥ë°›ëŠ” ë‚ ì§œ ëª©ë¡ */
  affectedDates: string[];
  /** ìƒì„¸ ë¶„ì„ ë°ì´í„° */
  details: {
    totalPlans: number;
    completedPlans: number;
    missedPlans: number;
    averageCompletionRate: number;
    dailyRequiredPlans: number;
    dailyActualPlans: number;
  };
}

/**
 * í”Œëœ ê·¸ë£¹ ë¶„ì„ ì…ë ¥
 */
export interface PlanGroupAnalysisInput {
  /** í”Œëœ ëª©ë¡ */
  plans: Plan[];
  /** í”Œëœ ê·¸ë£¹ ì‹œì‘ì¼ */
  startDate: string; // YYYY-MM-DD
  /** í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼ */
  endDate: string; // YYYY-MM-DD
  /** í˜„ì¬ ë‚ ì§œ (ê¸°ë³¸ê°’: ì˜¤ëŠ˜) */
  currentDate?: string; // YYYY-MM-DD
}

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

/**
 * ë‚ ì§œ ìœ íš¨ì„± ê²€ì‚¬
 */
function isValidDate(date: Date): boolean {
  return date instanceof Date && isValid(date);
}

// ============================================
// ì§„í–‰ë¥  ê³„ì‚°
// ============================================

/**
 * í”Œëœ ì™„ë£Œ ì—¬ë¶€ í™•ì¸
 */
function isPlanCompleted(plan: Plan): boolean {
  // Plan íƒ€ì…ì— statusê°€ ì—†ìœ¼ë¯€ë¡œ, progressê°€ 100ì´ê±°ë‚˜ completed_amountê°€ planned_end_page_or_timeê³¼ ê°™ìœ¼ë©´ ì™„ë£Œë¡œ ê°„ì£¼
  const isProgressComplete = plan.progress === 100;
  const isAmountComplete = 
    plan.planned_end_page_or_time !== null &&
    plan.planned_end_page_or_time !== undefined &&
    plan.completed_amount !== null &&
    plan.completed_amount !== undefined &&
    plan.completed_amount >= plan.planned_end_page_or_time;
  
  // íƒ€ì… í™•ì¥: ì‹¤ì œ DBì—ì„œ ê°€ì ¸ì˜¨ í”Œëœì€ statusì™€ actual_end_timeì´ ìˆì„ ìˆ˜ ìˆìŒ
  const planWithStatus = plan as Plan & { 
    status?: string | null; 
    actual_end_time?: string | null;
  };
  
  return (
    isProgressComplete ||
    isAmountComplete ||
    planWithStatus.status === "completed" ||
    planWithStatus.actual_end_time !== null
  );
}

/**
 * í”Œëœ ì§„í–‰ë¥  ê³„ì‚°
 */
function calculatePlanProgress(plan: Plan): number {
  if (isPlanCompleted(plan)) {
    return 100;
  }

  if (!plan.planned_start_page_or_time || !plan.planned_end_page_or_time) {
    return 0;
  }

  const totalRange =
    plan.planned_end_page_or_time - plan.planned_start_page_or_time;
  if (totalRange <= 0) {
    return 0;
  }

  const completedRange = plan.completed_amount || 0;
  return Math.min(100, Math.round((completedRange / totalRange) * 100));
}

/**
 * ë‚ ì§œë³„ í”Œëœ í†µê³„ ê³„ì‚°
 */
function calculateDailyStats(plans: Plan[]): Map<
  string,
  {
    total: number;
    completed: number;
    inProgress: number;
    missed: number;
  }
> {
  const statsMap = new Map<
    string,
    {
      total: number;
      completed: number;
      inProgress: number;
      missed: number;
    }
  >();

  const today = format(new Date(), "yyyy-MM-dd");

  plans.forEach((plan) => {
    if (!plan.plan_date) {
      return;
    }

    const date = plan.plan_date;
    if (!statsMap.has(date)) {
      statsMap.set(date, {
        total: 0,
        completed: 0,
        inProgress: 0,
        missed: 0,
      });
    }

    const stats = statsMap.get(date)!;
    stats.total++;

    if (isPlanCompleted(plan)) {
      stats.completed++;
    } else if (plan.actual_start_time) {
      stats.inProgress++;
    } else {
      const parsedDate = parseISO(date);
      const parsedToday = parseISO(today);
      if (isValidDate(parsedDate) && isValidDate(parsedToday) && isBefore(parsedDate, parsedToday)) {
        // ê³¼ê±° ë‚ ì§œì˜ ë¯¸ì™„ë£Œ í”Œëœì€ ëˆ„ë½ìœ¼ë¡œ ê°„ì£¼
        stats.missed++;
      }
    }
  });

  return statsMap;
}

// ============================================
// ì§€ì—° ê°ì§€
// ============================================

/**
 * ì§€ì—° ì‹¬ê°ë„ ê³„ì‚°
 */
function calculateSeverity(
  delayDays: number,
  progressRate: number,
  missedPlans: number,
  totalPlans: number
): DelaySeverity {
  if (delayDays <= 0 && progressRate >= 90) {
    return "none";
  }

  if (delayDays <= 1 && progressRate >= 80) {
    return "low";
  }

  if (delayDays <= 3 && progressRate >= 70) {
    return "medium";
  }

  if (delayDays <= 7 && progressRate >= 50) {
    return "high";
  }

  return "critical";
}

/**
 * ì§€ì—° ì›ì¸ ë¶„ì„
 */
function analyzeCauses(
  plans: Plan[],
  progressRate: number,
  dailyStats: Map<string, { total: number; completed: number; inProgress: number; missed: number }>,
  currentDate: string
): DelayCause[] {
  const causes: DelayCause[] = [];

  // ë‚®ì€ ì™„ë£Œìœ¨
  if (progressRate < 70) {
    causes.push("low_completion_rate");
  }

  // ë¯¸ì™„ë£Œ í”Œëœ ëˆ„ì 
  let totalMissed = 0;
  dailyStats.forEach((stats) => {
    totalMissed += stats.missed;
  });
  if (totalMissed > plans.length * 0.1) {
    // ì „ì²´ í”Œëœì˜ 10% ì´ìƒ ëˆ„ë½
    causes.push("missed_plans");
  }

  // ì§„í–‰ ì†ë„ ì €í•˜ (ìµœê·¼ 3ì¼ í‰ê·  ì™„ë£Œìœ¨ì´ ì „ì²´ í‰ê· ë³´ë‹¤ ë‚®ìŒ)
  const parsedCurrentDate = parseISO(currentDate);
  const recentDates = Array.from(dailyStats.keys())
    .filter((date) => {
      const parsedDate = parseISO(date);
      return isValidDate(parsedDate) && isValidDate(parsedCurrentDate) && isBefore(parsedDate, parsedCurrentDate);
    })
    .sort()
    .slice(-3);

  if (recentDates.length > 0) {
    let recentCompleted = 0;
    let recentTotal = 0;
    recentDates.forEach((date) => {
      const stats = dailyStats.get(date);
      if (stats) {
        recentCompleted += stats.completed;
        recentTotal += stats.total;
      }
    });

    const recentRate =
      recentTotal > 0 ? (recentCompleted / recentTotal) * 100 : 0;
    if (recentRate < progressRate - 10) {
      // ìµœê·¼ 3ì¼ ì™„ë£Œìœ¨ì´ ì „ì²´ í‰ê· ë³´ë‹¤ 10%p ì´ìƒ ë‚®ìŒ
      causes.push("slow_progress");
    }
  }

  return causes;
}

/**
 * ì˜ˆìƒ ì™„ë£Œì¼ ê³„ì‚°
 */
function calculateCompletionDate(
  plans: Plan[],
  startDate: string,
  endDate: string,
  progressRate: number
): string | null {
  try {
    if (progressRate >= 100) {
      return format(new Date(), "yyyy-MM-dd");
    }

    // ë‚ ì§œ íŒŒì‹± ë° ìœ íš¨ì„± ê²€ì‚¬
    const start = parseISO(startDate);
    const end = parseISO(endDate);

    if (!isValidDate(start) || !isValidDate(end)) {
      console.warn("[calculateCompletionDate] ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œ:", {
        startDate,
        endDate,
      });
      return null;
    }

    const totalDays = differenceInDays(end, start);

    // totalDaysê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ ìŒìˆ˜ì¸ ê²½ìš°
    if (totalDays <= 0 || !isFinite(totalDays)) {
      console.warn("[calculateCompletionDate] ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œ ë²”ìœ„:", {
        startDate,
        endDate,
        totalDays,
      });
      return null;
    }

    const remainingProgress = 100 - progressRate;

    if (remainingProgress <= 0) {
      return format(new Date(), "yyyy-MM-dd");
    }

    // ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì˜ˆìƒ ì™„ë£Œì¼ ê³„ì‚°
    const progressPerDay = progressRate / Math.max(1, totalDays);

    // progressPerDayê°€ 0ì´ê±°ë‚˜ ìŒìˆ˜ì¸ ê²½ìš° ì²˜ë¦¬
    if (progressPerDay <= 0 || !isFinite(progressPerDay)) {
      // ì§„í–‰ë¥ ì´ 0ì´ê±°ë‚˜ ìŒìˆ˜ì¸ ê²½ìš°, ì˜¤ëŠ˜ ë‚ ì§œ ë°˜í™˜
      return format(new Date(), "yyyy-MM-dd");
    }

    const remainingDays = Math.ceil(remainingProgress / progressPerDay);

    // remainingDaysë¥¼ í•©ë¦¬ì ì¸ ë²”ìœ„ë¡œ ì œí•œ (ìµœëŒ€ 365ì¼)
    const clampedRemainingDays = Math.min(Math.max(0, remainingDays), 365);

    if (!isFinite(clampedRemainingDays)) {
      console.warn("[calculateCompletionDate] ìœ íš¨í•˜ì§€ ì•Šì€ remainingDays:", {
        remainingDays,
        clampedRemainingDays,
      });
      return null;
    }

    // addDaysë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì „í•˜ê²Œ ë‚ ì§œ ê³„ì‚°
    const today = new Date();
    const expectedDate = addDays(today, clampedRemainingDays);

    if (!isValidDate(expectedDate)) {
      console.warn("[calculateCompletionDate] ê³„ì‚°ëœ ë‚ ì§œê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ:", {
        expectedDate,
      });
      return null;
    }

    return format(expectedDate, "yyyy-MM-dd");
  } catch (error) {
    console.error("[calculateCompletionDate] ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜:", error);
    return null;
  }
}

/**
 * í•™ìŠµ ì§€ì—° ë¶„ì„
 * 
 * @param input í”Œëœ ê·¸ë£¹ ë¶„ì„ ì…ë ¥
 * @returns ì§€ì—° ë¶„ì„ ê²°ê³¼
 */
export function analyzeDelay(
  input: PlanGroupAnalysisInput
): DelayAnalysis {
  const { plans, startDate, endDate, currentDate } = input;
  
  // ë‚ ì§œ íŒŒì‹± ë° ìœ íš¨ì„± ê²€ì‚¬
  const parsedStartDate = parseISO(startDate);
  const parsedEndDate = parseISO(endDate);
  
  if (!isValidDate(parsedStartDate) || !isValidDate(parsedEndDate)) {
    console.warn("[analyzeDelay] ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œ:", {
      startDate,
      endDate,
    });
    // ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œì¸ ê²½ìš° ê¸°ë³¸ê°’ ë°˜í™˜
    return {
      severity: "none",
      delayDays: 0,
      causes: [],
      description: "ë‚ ì§œ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      progressRate: 0,
      expectedCompletionDate: null,
      actualCompletionDate: null,
      affectedDates: [],
      details: {
        totalPlans: plans.length,
        completedPlans: 0,
        missedPlans: 0,
        averageCompletionRate: 0,
        dailyRequiredPlans: 0,
        dailyActualPlans: 0,
      },
    };
  }

  const today = currentDate || format(new Date(), "yyyy-MM-dd");
  const parsedToday = parseISO(today);
  
  if (!isValidDate(parsedToday)) {
    console.warn("[analyzeDelay] ìœ íš¨í•˜ì§€ ì•Šì€ í˜„ì¬ ë‚ ì§œ:", today);
    // ìœ íš¨í•˜ì§€ ì•Šì€ í˜„ì¬ ë‚ ì§œì¸ ê²½ìš° ì˜¤ëŠ˜ ë‚ ì§œ ì‚¬ìš©
    const todayDate = new Date();
    const todayStr = format(todayDate, "yyyy-MM-dd");
    return analyzeDelay({
      ...input,
      currentDate: todayStr,
    });
  }

  // ê¸°ë³¸ í†µê³„ ê³„ì‚°
  const totalPlans = plans.length;
  const completedPlans = plans.filter(isPlanCompleted).length;
  const missedPlans = plans.filter(
    (p) =>
      p.plan_date &&
      isBefore(parseISO(p.plan_date), parsedToday) &&
      !isPlanCompleted(p)
  ).length;

  // ì§„í–‰ë¥  ê³„ì‚°
  const totalProgress = plans.reduce(
    (sum, plan) => sum + calculatePlanProgress(plan),
    0
  );
  const averageProgress = totalPlans > 0 ? totalProgress / totalPlans : 0;
  const progressRate = Math.round(averageProgress);

  // ë‚ ì§œë³„ í†µê³„
  const dailyStats = calculateDailyStats(plans);

  // ì¼ì¼ í‰ê·  ê³„ì‚°
  const uniqueDates = Array.from(dailyStats.keys());
  const dailyRequiredPlans =
    uniqueDates.length > 0
      ? totalPlans / uniqueDates.length
      : 0;
  const dailyActualPlans =
    uniqueDates.length > 0
      ? completedPlans / uniqueDates.length
      : 0;

  // ì§€ì—° ì¼ìˆ˜ ê³„ì‚° (ê³„íš ëŒ€ë¹„ ì‹¤ì œ ì§„í–‰ë¥  ê¸°ë°˜)
  const daysFromStart = differenceInDays(parsedToday, parsedStartDate);
  const totalDaysRange = differenceInDays(parsedEndDate, parsedStartDate);
  
  if (totalDaysRange <= 0 || !isFinite(totalDaysRange)) {
    console.warn("[analyzeDelay] ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œ ë²”ìœ„:", {
      startDate,
      endDate,
      totalDaysRange,
    });
    // ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œ ë²”ìœ„ì¸ ê²½ìš° ê¸°ë³¸ê°’ ë°˜í™˜
    return {
      severity: "none",
      delayDays: 0,
      causes: [],
      description: "ë‚ ì§œ ë²”ìœ„ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
      progressRate,
      expectedCompletionDate: null,
      actualCompletionDate: null,
      affectedDates: [],
      details: {
        totalPlans,
        completedPlans,
        missedPlans,
        averageCompletionRate: progressRate,
        dailyRequiredPlans: Math.round((uniqueDates.length > 0 ? totalPlans / uniqueDates.length : 0) * 10) / 10,
        dailyActualPlans: Math.round((uniqueDates.length > 0 ? completedPlans / uniqueDates.length : 0) * 10) / 10,
      },
    };
  }
  
  const expectedProgress = (daysFromStart / Math.max(1, totalDaysRange)) * 100;
  const delayProgress = expectedProgress - progressRate;
  const delayDays = Math.max(0, Math.ceil((delayProgress / 100) * totalDaysRange));

  // ì§€ì—° ì‹¬ê°ë„ ê³„ì‚°
  const severity = calculateSeverity(
    delayDays,
    progressRate,
    missedPlans,
    totalPlans
  );

  // ì§€ì—° ì›ì¸ ë¶„ì„
  const causes = analyzeCauses(plans, progressRate, dailyStats, today);

  // ì˜ˆìƒ ì™„ë£Œì¼ ê³„ì‚°
  const expectedCompletionDate = calculateCompletionDate(
    plans,
    startDate,
    endDate,
    progressRate
  );
  
  // expectedCompletionDateê°€ nullì´ë©´ actualCompletionDateë„ null
  let actualCompletionDate: string | null = null;
  if (expectedCompletionDate) {
    try {
      const parsedExpectedDate = parseISO(expectedCompletionDate);
      if (isValidDate(parsedExpectedDate)) {
        const actualDate = addDays(parsedExpectedDate, delayDays);
        if (isValidDate(actualDate)) {
          actualCompletionDate = format(actualDate, "yyyy-MM-dd");
        } else {
          console.warn("[analyzeDelay] ê³„ì‚°ëœ actualCompletionDateê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ:", {
            expectedCompletionDate,
            delayDays,
            actualDate,
          });
        }
      } else {
        console.warn("[analyzeDelay] expectedCompletionDate íŒŒì‹± ì‹¤íŒ¨:", {
          expectedCompletionDate,
        });
      }
    } catch (error) {
      console.error("[analyzeDelay] actualCompletionDate ê³„ì‚° ì¤‘ ì˜¤ë¥˜:", error);
    }
  }

  // ì˜í–¥ë°›ëŠ” ë‚ ì§œ ëª©ë¡ (ë¯¸ì™„ë£Œ í”Œëœì´ ìˆëŠ” ê³¼ê±° ë‚ ì§œ)
  const affectedDates = Array.from(dailyStats.keys())
    .filter((date) => {
      const stats = dailyStats.get(date);
      if (!stats || stats.missed <= 0) {
        return false;
      }
      const parsedDate = parseISO(date);
      return isValidDate(parsedDate) && isBefore(parsedDate, parsedToday);
    })
    .sort();

  // ì„¤ëª… ìƒì„±
  const description = generateDescription(severity, delayDays, causes, progressRate);

  return {
    severity,
    delayDays,
    causes,
    description,
    progressRate,
    expectedCompletionDate,
    actualCompletionDate,
    affectedDates,
    details: {
      totalPlans,
      completedPlans,
      missedPlans,
      averageCompletionRate: progressRate,
      dailyRequiredPlans: Math.round(dailyRequiredPlans * 10) / 10,
      dailyActualPlans: Math.round(dailyActualPlans * 10) / 10,
    },
  };
}

/**
 * ì„¤ëª… ìƒì„±
 */
function generateDescription(
  severity: DelaySeverity,
  delayDays: number,
  causes: DelayCause[],
  progressRate: number
): string {
  if (severity === "none") {
    return "í•™ìŠµì´ ê³„íšëŒ€ë¡œ ì§„í–‰ë˜ê³  ìˆìŠµë‹ˆë‹¤.";
  }

  const causeMessages: Record<DelayCause, string> = {
    low_completion_rate: "ì™„ë£Œìœ¨ì´ ë‚®ìŠµë‹ˆë‹¤",
    missed_plans: "ë¯¸ì™„ë£Œ í”Œëœì´ ëˆ„ì ë˜ì—ˆìŠµë‹ˆë‹¤",
    slow_progress: "ì§„í–‰ ì†ë„ê°€ ì €í•˜ë˜ì—ˆìŠµë‹ˆë‹¤",
    overload: "í•™ìŠµëŸ‰ì´ ê³¼ë¶€í•˜ ìƒíƒœì…ë‹ˆë‹¤",
    schedule_conflict: "ì¼ì • ì¶©ëŒì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
  };

  const causeText = causes.map((c) => causeMessages[c]).join(", ");
  const severityText =
    severity === "critical"
      ? "ì‹¬ê°"
      : severity === "high"
      ? "ë†’ìŒ"
      : severity === "medium"
      ? "ë³´í†µ"
      : "ë‚®ìŒ";

  return `í•™ìŠµ ì§€ì—°ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤ (${severityText} ìˆ˜ì¤€, ì•½ ${delayDays}ì¼ ì§€ì—°). ì§„í–‰ë¥  ${progressRate}%, ì›ì¸: ${causeText}.`;
}
</file>

<file path="jobQueue.ts">
/**
 * ì¬ì¡°ì • Job Queue ì¸í„°í˜ì´ìŠ¤
 * 
 * ëŒ€ê·œëª¨ ì¬ì¡°ì •ì„ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ Job Queue ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
 * ì‹¤ì œ êµ¬í˜„ì€ Supabase Edge Function ë˜ëŠ” ì™¸ë¶€ Queue ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/jobQueue
 */

import type { AdjustmentInput } from './scheduleEngine';
import type { RescheduleResult } from '@/app/(student)/actions/plan-groups/reschedule';

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¬ì¡°ì • Job ìƒíƒœ
 */
export type RescheduleJobStatus = 'pending' | 'processing' | 'completed' | 'failed';

/**
 * ì¬ì¡°ì • Job
 */
export interface RescheduleJob {
  id: string;
  groupId: string;
  studentId: string;
  adjustments: AdjustmentInput[];
  status: RescheduleJobStatus;
  progress: number; // 0-100
  result?: RescheduleResult;
  error?: string;
  createdAt: string;
  startedAt?: string;
  completedAt?: string;
  estimatedDuration?: number; // ì˜ˆìƒ ì†Œìš” ì‹œê°„ (ì´ˆ)
}

/**
 * Job ìƒì„± ì…ë ¥
 */
export interface CreateJobInput {
  groupId: string;
  studentId: string;
  adjustments: AdjustmentInput[];
  reason?: string;
}

// ============================================
// Job Queue í•¨ìˆ˜
// ============================================

/**
 * ì¬ì¡°ì • Job ìƒì„± (íì— ì¶”ê°€)
 * 
 * @param input Job ìƒì„± ì…ë ¥
 * @returns ìƒì„±ëœ Job ID
 */
export async function enqueueRescheduleJob(
  input: CreateJobInput
): Promise<string> {
  // TODO: ì‹¤ì œ êµ¬í˜„
  // 1. reschedule_log í…Œì´ë¸”ì— 'pending' ìƒíƒœë¡œ ë ˆì½”ë“œ ìƒì„±
  // 2. Job Queueì— ì‘ì—… ì¶”ê°€ (Supabase Edge Function ë˜ëŠ” ì™¸ë¶€ Queue)
  // 3. Job ID ë°˜í™˜
  
  throw new Error('Not implemented: Job QueueëŠ” í–¥í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
}

/**
 * Job ìƒíƒœ ì¡°íšŒ
 * 
 * @param jobId Job ID
 * @returns Job ìƒíƒœ
 */
export async function getRescheduleJobStatus(
  jobId: string
): Promise<RescheduleJob | null> {
  // TODO: ì‹¤ì œ êµ¬í˜„
  // 1. reschedule_log í…Œì´ë¸”ì—ì„œ ì¡°íšŒ
  // 2. Job Queueì—ì„œ ìƒíƒœ ì¡°íšŒ
  // 3. í†µí•©í•˜ì—¬ ë°˜í™˜
  
  throw new Error('Not implemented: Job QueueëŠ” í–¥í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
}

/**
 * Job ì·¨ì†Œ
 * 
 * @param jobId Job ID
 * @returns ì·¨ì†Œ ì„±ê³µ ì—¬ë¶€
 */
export async function cancelRescheduleJob(
  jobId: string
): Promise<boolean> {
  // TODO: ì‹¤ì œ êµ¬í˜„
  // 1. Job Queueì—ì„œ ì·¨ì†Œ ìš”ì²­
  // 2. reschedule_log ìƒíƒœ ì—…ë°ì´íŠ¸
  
  throw new Error('Not implemented: Job QueueëŠ” í–¥í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
}

/**
 * Job ì¬ì‹œë„
 * 
 * @param jobId Job ID
 * @returns ìƒˆ Job ID
 */
export async function retryRescheduleJob(
  jobId: string
): Promise<string> {
  // TODO: ì‹¤ì œ êµ¬í˜„
  // 1. ê¸°ì¡´ Job ì •ë³´ ì¡°íšŒ
  // 2. ìƒˆ Job ìƒì„±
  
  throw new Error('Not implemented: Job QueueëŠ” í–¥í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
}

// ============================================
// Job Queue êµ¬í˜„ ì²´í¬
// ============================================

/**
 * Job Queue êµ¬í˜„ ì—¬ë¶€ í™•ì¸
 * 
 * @returns êµ¬í˜„ ì—¬ë¶€
 */
export function isJobQueueEnabled(): boolean {
  // í™˜ê²½ ë³€ìˆ˜ë‚˜ ì„¤ì •ì„ í†µí•´ í™•ì¸
  return process.env.ENABLE_RESCHEDULE_JOB_QUEUE === 'true';
}
</file>

<file path="logger.ts">
/**
 * ì¬ì¡°ì • ëª¨ë“ˆ ë¡œê¹… ìœ í‹¸ë¦¬í‹°
 * 
 * êµ¬ì¡°í™”ëœ ë¡œê¹…ì„ ì œê³µí•˜ì—¬ ë””ë²„ê¹… ë° ëª¨ë‹ˆí„°ë§ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * í”„ë¡œë•ì…˜ì—ì„œëŠ” ë¡œê·¸ ë ˆë²¨ì— ë”°ë¼ ì¶œë ¥ì„ ì œì–´í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/logger
 */

// ============================================
// ë¡œê·¸ ë ˆë²¨
// ============================================

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

const LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

/**
 * í˜„ì¬ ë¡œê·¸ ë ˆë²¨ (í™˜ê²½ ë³€ìˆ˜ë¡œ ì„¤ì • ê°€ëŠ¥)
 * ê°œë°œ í™˜ê²½ì—ì„œëŠ” debug, í”„ë¡œë•ì…˜ì—ì„œëŠ” warn ê¶Œì¥
 */
const CURRENT_LOG_LEVEL: LogLevel = 
  (process.env.RESCHEDULE_LOG_LEVEL as LogLevel) || 
  (process.env.NODE_ENV === 'production' ? 'warn' : 'debug');

// ============================================
// ë¡œê±° í•¨ìˆ˜
// ============================================

interface LogContext {
  /** ë¡œê·¸ ë°œìƒ ëª¨ë“ˆ */
  module: string;
  /** í•¨ìˆ˜ ë˜ëŠ” ì‘ì—… ì´ë¦„ */
  action?: string;
  /** ê´€ë ¨ ID (groupId ë“±) */
  id?: string;
  /** ì¶”ê°€ ë°ì´í„° */
  data?: Record<string, unknown>;
  /** ì—ëŸ¬ ê°ì²´ */
  error?: Error;
  /** ì‹¤í–‰ ì‹œê°„ (ms) */
  duration?: number;
}

/**
 * ë¡œê·¸ ë©”ì‹œì§€ í¬ë§·íŒ…
 */
function formatLogMessage(level: LogLevel, message: string, context: LogContext): string {
  const timestamp = new Date().toISOString();
  const prefix = `[${timestamp}] [${level.toUpperCase()}] [reschedule/${context.module}]`;
  
  let formatted = `${prefix} ${message}`;
  
  if (context.action) {
    formatted += ` action=${context.action}`;
  }
  if (context.id) {
    formatted += ` id=${context.id}`;
  }
  if (context.duration !== undefined) {
    formatted += ` duration=${context.duration}ms`;
  }
  
  return formatted;
}

/**
 * ë¡œê·¸ ë ˆë²¨ ì²´í¬
 */
function shouldLog(level: LogLevel): boolean {
  return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[CURRENT_LOG_LEVEL];
}

/**
 * ì¬ì¡°ì • ë¡œê±°
 */
export const rescheduleLogger = {
  /**
   * ë””ë²„ê·¸ ë¡œê·¸ (ê°œë°œìš©)
   */
  debug(message: string, context: Omit<LogContext, 'module'> & { module?: string }) {
    if (!shouldLog('debug')) return;
    console.debug(formatLogMessage('debug', message, { module: 'general', ...context }));
    if (context.data) {
      console.debug('  Data:', JSON.stringify(context.data, null, 2));
    }
  },

  /**
   * ì •ë³´ ë¡œê·¸
   */
  info(message: string, context: Omit<LogContext, 'module'> & { module?: string }) {
    if (!shouldLog('info')) return;
    console.log(formatLogMessage('info', message, { module: 'general', ...context }));
    if (context.data) {
      console.log('  Data:', JSON.stringify(context.data, null, 2));
    }
  },

  /**
   * ê²½ê³  ë¡œê·¸
   */
  warn(message: string, context: Omit<LogContext, 'module'> & { module?: string }) {
    if (!shouldLog('warn')) return;
    console.warn(formatLogMessage('warn', message, { module: 'general', ...context }));
    if (context.data) {
      console.warn('  Data:', JSON.stringify(context.data, null, 2));
    }
  },

  /**
   * ì—ëŸ¬ ë¡œê·¸
   */
  error(message: string, context: Omit<LogContext, 'module'> & { module?: string }) {
    if (!shouldLog('error')) return;
    console.error(formatLogMessage('error', message, { module: 'general', ...context }));
    if (context.error) {
      console.error('  Error:', context.error.message);
      console.error('  Stack:', context.error.stack);
    }
    if (context.data) {
      console.error('  Data:', JSON.stringify(context.data, null, 2));
    }
  },

  /**
   * ì„±ëŠ¥ ì¸¡ì • í—¬í¼
   * @returns stop í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ duration ë°˜í™˜
   */
  startTimer(): () => number {
    const start = performance.now();
    return () => Math.round(performance.now() - start);
  },
};

// ëª¨ë“ˆë³„ ë¡œê±° í”„ë¦¬ì…‹
export const previewCacheLogger = {
  debug: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.debug(message, { ...context, module: 'previewCache' }),
  info: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.info(message, { ...context, module: 'previewCache' }),
  warn: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.warn(message, { ...context, module: 'previewCache' }),
  error: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.error(message, { ...context, module: 'previewCache' }),
};

export const transactionLogger = {
  debug: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.debug(message, { ...context, module: 'transaction' }),
  info: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.info(message, { ...context, module: 'transaction' }),
  warn: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.warn(message, { ...context, module: 'transaction' }),
  error: (message: string, context: Omit<LogContext, 'module'> = {}) => 
    rescheduleLogger.error(message, { ...context, module: 'transaction' }),
};
</file>

<file path="patternAnalyzer.ts">
/**
 * ì¬ì¡°ì • íŒ¨í„´ ë¶„ì„ê¸°
 * 
 * ì¬ì¡°ì • ì´ë ¥ì„ ë¶„ì„í•˜ì—¬ íŒ¨í„´ì„ íŒŒì•…í•˜ê³  ê°œì„  ì œì•ˆì„ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/patternAnalyzer
 */

import type { RescheduleLogItem } from "@/app/(student)/actions/plan-groups/rescheduleHistory";
import type { SupabaseClient } from "@supabase/supabase-js";
import { analyzeDelay } from "./delayDetector";
import type { Plan } from "@/lib/data/studentPlans";

// ============================================
// ìƒìˆ˜ ì •ì˜ (Magic Numbers)
// ============================================

const TREND_THRESHOLDS = {
  INCREASING: 1.2,
  DECREASING: 0.8,
};

const TOP_CONTENT_LIMIT = 5;

const DATE_RANGE_BUCKETS = {
  WEEK: 7,
  TWO_WEEKS: 14,
  MONTH: 30,
};

const SUGGESTION_THRESHOLDS = {
  HIGH_FREQUENCY: 2, // ì›” 2íšŒ ì´ìƒ
  CONTENT_RESCHEDULE: 3, // 3íšŒ ì´ìƒ ì¬ì¡°ì •ëœ ì½˜í…ì¸ 
};

const EFFECTIVENESS_THRESHOLDS = {
  SUCCESS_HIGH: 90,
  SUCCESS_MEDIUM: 70,
  ROLLBACK_LOW: 5,
  ROLLBACK_MEDIUM: 15,
};

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¬ì¡°ì • ì¶”ì²œ
 */
export interface RescheduleRecommendation {
  /** í”Œëœ ê·¸ë£¹ ID */
  groupId: string;
  /** í”Œëœ ê·¸ë£¹ ì´ë¦„ */
  groupName?: string;
  /** ì¬ì¡°ì •ì´ í•„ìš”í•œ ì´ìœ  */
  reason: string;
  /** ìš°ì„ ìˆœìœ„ */
  priority: "high" | "medium" | "low";
  /** ì˜ˆìƒ ì˜í–¥ */
  estimatedImpact: {
    /** ì˜í–¥ë°›ëŠ” í”Œëœ ìˆ˜ */
    plansAffected: number;
  };
}

/**
 * ì¬ì¡°ì • íŒ¨í„´ ë¶„ì„ ê²°ê³¼
 */
export interface ReschedulePatternAnalysis {
  /** ì¬ì¡°ì • ë¹ˆë„ */
  frequency: {
    total: number;
    perMonth: number;
    perWeek: number;
    trend: "increasing" | "decreasing" | "stable";
  };
  /** ìì£¼ ì¬ì¡°ì •ë˜ëŠ” ì½˜í…ì¸  */
  frequentlyRescheduledContents: Array<{
    content_id: string;
    rescheduleCount: number;
    lastRescheduledAt: string;
  }>;
  /** ì¬ì¡°ì • íŒ¨í„´ */
  patterns: {
    mostCommonType: "range" | "replace" | "full_regeneration";
    averagePlansChanged: number;
    averageAffectedDates: number;
    commonDateRanges: Array<{
      range: string; // ì˜ˆ: "1-7ì¼", "8-14ì¼"
      count: number;
    }>;
  };
  /** ê°œì„  ì œì•ˆ */
  suggestions: Array<{
    type: "reduce_frequency" | "optimize_content" | "adjust_schedule";
    priority: number; // 1-5
    title: string;
    description: string;
    reason: string;
  }>;
}

/**
 * ì¬ì¡°ì • íš¨ê³¼ ë¶„ì„ ê²°ê³¼
 */
export interface RescheduleEffectAnalysis {
  /** ì¬ì¡°ì • ì „í›„ ë¹„êµ */
  beforeAfter: {
    averagePlansBefore: number;
    averagePlansAfter: number;
    averageChange: number;
  };
  /** ì„±ê³µë¥  */
  successRate: number;
  /** ë¡¤ë°±ë¥  */
  rollbackRate: number;
  /** í‰ê·  ì¬ì¡°ì • ê°„ê²© (ì¼) */
  averageIntervalDays: number;
  /** ì¬ì¡°ì • íš¨ê³¼ í‰ê°€ */
  effectiveness: "high" | "medium" | "low";
  /** íš¨ê³¼ ì„¤ëª… */
  effectivenessDescription: string;
}

// ============================================
// íŒ¨í„´ ë¶„ì„
// ============================================

/**
 * ì¬ì¡°ì • ë¹ˆë„ ë¶„ì„
 */
function analyzeFrequency(logs: RescheduleLogItem[]): {
  total: number;
  perMonth: number;
  perWeek: number;
  trend: "increasing" | "decreasing" | "stable";
} {
  if (logs.length === 0) {
    return {
      total: 0,
      perMonth: 0,
      perWeek: 0,
      trend: "stable",
    };
  }

  // ë‚ ì§œ ë²”ìœ„ ê³„ì‚°
  const dates = logs
    .map((log) => new Date(log.created_at))
    .sort((a, b) => a.getTime() - b.getTime());

  const firstDate = dates[0];
  const lastDate = dates[dates.length - 1];
  const daysDiff =
    (lastDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24);

  const perMonth = daysDiff > 0 ? (logs.length / daysDiff) * 30 : 0;
  const perWeek = daysDiff > 0 ? (logs.length / daysDiff) * 7 : 0;

  // íŠ¸ë Œë“œ ë¶„ì„ (ìµœê·¼ 3ê°œì›” vs ì´ì „ 3ê°œì›”)
  const now = new Date();
  const threeMonthsAgo = new Date(now);
  threeMonthsAgo.setMonth(now.getMonth() - 3);
  const sixMonthsAgo = new Date(now);
  sixMonthsAgo.setMonth(now.getMonth() - 6);

  const recentLogs = logs.filter(
    (log) => new Date(log.created_at) >= threeMonthsAgo
  );
  const olderLogs = logs.filter(
    (log) =>
      new Date(log.created_at) >= sixMonthsAgo &&
      new Date(log.created_at) < threeMonthsAgo
  );

  let trend: "increasing" | "decreasing" | "stable" = "stable";
  if (recentLogs.length > olderLogs.length * TREND_THRESHOLDS.INCREASING) {
    trend = "increasing";
  } else if (recentLogs.length < olderLogs.length * TREND_THRESHOLDS.DECREASING) {
    trend = "decreasing";
  }

  return {
    total: logs.length,
    perMonth: Math.round(perMonth * 10) / 10,
    perWeek: Math.round(perWeek * 10) / 10,
    trend,
  };
}

/**
 * ìì£¼ ì¬ì¡°ì •ë˜ëŠ” ì½˜í…ì¸  ì‹ë³„
 */
function identifyFrequentlyRescheduledContents(
  logs: RescheduleLogItem[]
): Array<{
  content_id: string;
  rescheduleCount: number;
  lastRescheduledAt: string;
}> {
  const contentMap = new Map<
    string,
    { count: number; lastDate: string }
  >();

  logs.forEach((log) => {
    if (log.adjusted_contents && log.adjusted_contents.length > 0) {
      log.adjusted_contents.forEach((contentId) => {
        const existing = contentMap.get(contentId);
        if (existing) {
          existing.count++;
          if (log.created_at > existing.lastDate) {
            existing.lastDate = log.created_at;
          }
        } else {
          contentMap.set(contentId, {
            count: 1,
            lastDate: log.created_at,
          });
        }
      });
    }
  });

  return Array.from(contentMap.entries())
    .map(([content_id, data]) => ({
      content_id,
      rescheduleCount: data.count,
      lastRescheduledAt: data.lastDate,
    }))
    .sort((a, b) => b.rescheduleCount - a.rescheduleCount)
    .slice(0, TOP_CONTENT_LIMIT); // ìƒìœ„ 5ê°œë§Œ ë°˜í™˜
}

/**
 * ì¬ì¡°ì • íŒ¨í„´ ë¶„ì„
 */
function analyzePatterns(logs: RescheduleLogItem[]): {
  mostCommonType: "range" | "replace" | "full_regeneration";
  averagePlansChanged: number;
  averageAffectedDates: number;
  commonDateRanges: Array<{
    range: string;
    count: number;
  }>;
} {
  if (logs.length === 0) {
    return {
      mostCommonType: "range",
      averagePlansChanged: 0,
      averageAffectedDates: 0,
      commonDateRanges: [],
    };
  }

  // í‰ê·  í”Œëœ ë³€í™” ê³„ì‚°
  const totalPlansChanged = logs.reduce(
    (sum, log) => sum + Math.abs(log.plans_after_count - log.plans_before_count),
    0
  );
  const averagePlansChanged = Math.round((totalPlansChanged / logs.length) * 10) / 10;

  // í‰ê·  ì˜í–¥ë°›ëŠ” ë‚ ì§œ ìˆ˜ ê³„ì‚°
  const totalAffectedDates = logs.reduce(
    (sum, log) => sum + (log.affected_dates?.length || 0),
    0
  );
  const averageAffectedDates = Math.round((totalAffectedDates / logs.length) * 10) / 10;

  // ë‚ ì§œ ë²”ìœ„ íŒ¨í„´ ë¶„ì„
  const dateRangeMap = new Map<string, number>();
  logs.forEach((log) => {
    if (log.date_range) {
      const from = new Date(log.date_range.from);
      const to = new Date(log.date_range.to);
      const daysDiff = Math.ceil(
        (to.getTime() - from.getTime()) / (1000 * 60 * 60 * 24)
      );

      let range: string;
      if (daysDiff <= DATE_RANGE_BUCKETS.WEEK) {
        range = "1-7ì¼";
      } else if (daysDiff <= DATE_RANGE_BUCKETS.TWO_WEEKS) {
        range = "8-14ì¼";
      } else if (daysDiff <= DATE_RANGE_BUCKETS.MONTH) {
        range = "15-30ì¼";
      } else {
        range = "30ì¼ ì´ìƒ";
      }

      dateRangeMap.set(range, (dateRangeMap.get(range) || 0) + 1);
    }
  });

  const commonDateRanges = Array.from(dateRangeMap.entries())
    .map(([range, count]) => ({ range, count }))
    .sort((a, b) => b.count - a.count);

  return {
    mostCommonType: "range", // TODO: adjusted_contentsì—ì„œ íƒ€ì… ì¶”ì¶œ
    averagePlansChanged,
    averageAffectedDates,
    commonDateRanges,
  };
}

/**
 * ê°œì„  ì œì•ˆ ìƒì„±
 */
function generateSuggestions(
  analysis: {
    frequency: ReturnType<typeof analyzeFrequency>;
    frequentlyRescheduledContents: ReturnType<typeof identifyFrequentlyRescheduledContents>;
    patterns: ReturnType<typeof analyzePatterns>;
  }
): Array<{
  type: "reduce_frequency" | "optimize_content" | "adjust_schedule";
  priority: number;
  title: string;
  description: string;
  reason: string;
}> {
  const suggestions: Array<{
    type: "reduce_frequency" | "optimize_content" | "adjust_schedule";
    priority: number;
    title: string;
    description: string;
    reason: string;
  }> = [];

  // ì¬ì¡°ì • ë¹ˆë„ê°€ ë†’ìœ¼ë©´ ë¹ˆë„ ê°ì†Œ ì œì•ˆ
  if (analysis.frequency.perMonth > SUGGESTION_THRESHOLDS.HIGH_FREQUENCY) {
    suggestions.push({
      type: "reduce_frequency",
      priority: 5,
      title: "ì¬ì¡°ì • ë¹ˆë„ ê°ì†Œ",
      description: `í˜„ì¬ ì›” í‰ê·  ${analysis.frequency.perMonth}íšŒ ì¬ì¡°ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ˆê¸° í”Œëœ ì„¤ê³„ë¥¼ ë” ì‹ ì¤‘í•˜ê²Œ í•˜ë©´ ì¬ì¡°ì • ë¹ˆë„ë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`,
      reason: `ì¬ì¡°ì • ë¹ˆë„ê°€ ë†’ì•„ í•™ìŠµ ê³„íšì˜ ì•ˆì •ì„±ì´ ë–¨ì–´ì§‘ë‹ˆë‹¤.`,
    });
  }

  // ìì£¼ ì¬ì¡°ì •ë˜ëŠ” ì½˜í…ì¸ ê°€ ìˆìœ¼ë©´ ìµœì í™” ì œì•ˆ
  if (analysis.frequentlyRescheduledContents.length > 0) {
    const topContent = analysis.frequentlyRescheduledContents[0];
    if (topContent.rescheduleCount >= SUGGESTION_THRESHOLDS.CONTENT_RESCHEDULE) {
      suggestions.push({
        type: "optimize_content",
        priority: 4,
        title: "ì½˜í…ì¸  ë²”ìœ„ ìµœì í™”",
        description: `${topContent.content_id} ì½˜í…ì¸ ê°€ ${topContent.rescheduleCount}íšŒ ì¬ì¡°ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ˆê¸° ë²”ìœ„ ì„¤ì •ì„ ì¬ê²€í† í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.`,
        reason: `íŠ¹ì • ì½˜í…ì¸ ê°€ ë°˜ë³µì ìœ¼ë¡œ ì¬ì¡°ì •ë˜ê³  ìˆìŠµë‹ˆë‹¤.`,
      });
    }
  }

  // íŠ¸ë Œë“œê°€ ì¦ê°€í•˜ë©´ ì¼ì • ì¡°ì • ì œì•ˆ
  if (analysis.frequency.trend === "increasing") {
    suggestions.push({
      type: "adjust_schedule",
      priority: 3,
      title: "ì¼ì • ì¡°ì • ê³ ë ¤",
      description: "ì¬ì¡°ì • ë¹ˆë„ê°€ ì¦ê°€í•˜ê³  ìˆìŠµë‹ˆë‹¤. í•™ìŠµ ì¼ì •ì´ë‚˜ ëª©í‘œë¥¼ ì¬ê²€í† í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.",
      reason: `ì¬ì¡°ì • ë¹ˆë„ê°€ ì¦ê°€í•˜ëŠ” ì¶”ì„¸ì…ë‹ˆë‹¤.`,
    });
  }

  return suggestions.sort((a, b) => b.priority - a.priority);
}

/**
 * ì¬ì¡°ì • íŒ¨í„´ ë¶„ì„
 * 
 * @param logs ì¬ì¡°ì • ë¡œê·¸ ëª©ë¡
 * @returns íŒ¨í„´ ë¶„ì„ ê²°ê³¼
 */
export function analyzeReschedulePatterns(
  logs: RescheduleLogItem[]
): ReschedulePatternAnalysis {
  const frequency = analyzeFrequency(logs);
  const frequentlyRescheduledContents =
    identifyFrequentlyRescheduledContents(logs);
  const patterns = analyzePatterns(logs);
  const suggestions = generateSuggestions({
    frequency,
    frequentlyRescheduledContents,
    patterns,
  });

  return {
    frequency,
    frequentlyRescheduledContents,
    patterns,
    suggestions,
  };
}

/**
 * ì¬ì¡°ì •ì´ í•„ìš”í•œ í”Œëœ ê·¸ë£¹ ê°ì§€
 * 
 * í•™ìƒì˜ í™œì„± í”Œëœ ê·¸ë£¹ë“¤ì„ ë¶„ì„í•˜ì—¬ ì¬ì¡°ì •ì´ í•„ìš”í•œ ê·¸ë£¹ì„ ì°¾ìŠµë‹ˆë‹¤.
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param studentId í•™ìƒ ID
 * @returns ì¬ì¡°ì • ì¶”ì²œ ëª©ë¡ (ìš°ì„ ìˆœìœ„ ìˆœ)
 */
export async function detectRescheduleNeeds(
  supabase: SupabaseClient,
  studentId: string
): Promise<RescheduleRecommendation[]> {
  try {
    // 1. í•™ìƒì˜ í™œì„± í”Œëœ ê·¸ë£¹ ì¡°íšŒ
    const { data: planGroups, error: groupsError } = await supabase
      .from("plan_groups")
      .select("id, name, period_start, period_end, status")
      .eq("student_id", studentId)
      .in("status", ["active", "saved"])
      .is("deleted_at", null)
      .order("created_at", { ascending: false });

    if (groupsError) {
      console.error("[detectRescheduleNeeds] í”Œëœ ê·¸ë£¹ ì¡°íšŒ ì‹¤íŒ¨:", groupsError);
      return [];
    }

    if (!planGroups || planGroups.length === 0) {
      return [];
    }

    // 2. ì¼ê´„ ì¡°íšŒ: ëª¨ë“  ê´€ë ¨ í”Œëœì„ í•œ ë²ˆì— ê°€ì ¸ì˜µë‹ˆë‹¤ (N+1 ë¬¸ì œ í•´ê²°)
    const validGroups = planGroups.filter(g => g.period_start && g.period_end);
    const groupIds = validGroups.map(g => g.id);

    if (groupIds.length === 0) {
      return [];
    }

    const { data: allPlans, error: plansError } = await supabase
      .from("student_plan")
      .select("*")
      .in("plan_group_id", groupIds)
      .eq("student_id", studentId)
      .order("plan_date", { ascending: true });

    if (plansError) {
      console.error("[detectRescheduleNeeds] í”Œëœ ì¼ê´„ ì¡°íšŒ ì‹¤íŒ¨:", plansError);
      return [];
    }

    // í”Œëœì„ ê·¸ë£¹ë³„ë¡œ ë¶„ë¥˜
    const plansByGroupId = new Map<string, typeof allPlans>();
    
    (allPlans || []).forEach(plan => {
      const gId = plan.plan_group_id;
      if (!plansByGroupId.has(gId)) {
        plansByGroupId.set(gId, []);
      }
      plansByGroupId.get(gId)!.push(plan);
    });

    const recommendations: RescheduleRecommendation[] = [];

    // 3. ê° ê·¸ë£¹ë³„ë¡œ ì§€ì—° ë¶„ì„ ìˆ˜í–‰ (ë©”ëª¨ë¦¬ ìƒì—ì„œ ì²˜ë¦¬)
    for (const group of validGroups) {
      const groupPlans = plansByGroupId.get(group.id) || [];

      if (groupPlans.length === 0) {
        continue;
      }

      // Plan íƒ€ì…ìœ¼ë¡œ ë³€í™˜ (delayDetectorê°€ ê¸°ëŒ€í•˜ëŠ” í˜•ì‹)
      const planList: Plan[] = groupPlans.map((plan) => ({
        id: plan.id,
        tenant_id: plan.tenant_id,
        student_id: plan.student_id,
        plan_date: plan.plan_date,
        block_index: plan.block_index ?? 0,
        content_type: plan.content_type,
        content_id: plan.content_id,
        chapter: plan.chapter,
        planned_start_page_or_time: plan.planned_start_page_or_time,
        planned_end_page_or_time: plan.planned_end_page_or_time,
        completed_amount: plan.completed_amount,
        progress: plan.progress,
        is_reschedulable: plan.is_reschedulable,
        plan_group_id: plan.plan_group_id,
        start_time: plan.start_time,
        end_time: plan.end_time,
        actual_start_time: plan.actual_start_time,
        actual_end_time: plan.actual_end_time,
        total_duration_seconds: plan.total_duration_seconds,
        paused_duration_seconds: plan.paused_duration_seconds,
        pause_count: plan.pause_count,
        plan_number: plan.plan_number,
        sequence: plan.sequence,
        memo: plan.memo,
        day_type: plan.day_type,
        week: plan.week,
        day: plan.day,
        is_partial: plan.is_partial,
        is_continued: plan.is_continued,
        content_title: plan.content_title,
        content_subject: plan.content_subject,
        content_subject_category: plan.content_subject_category,
        content_category: plan.content_category,
        created_at: plan.created_at,
        updated_at: plan.updated_at,
        status: plan.status as "pending" | "in_progress" | "completed" | "cancelled" | null,
      }));

      // 4. ì§€ì—° ë¶„ì„ ìˆ˜í–‰
      const delayAnalysis = analyzeDelay({
        plans: planList,
        startDate: group.period_start,
        endDate: group.period_end,
      });

      // 5. ì§€ì—°ì´ ìˆëŠ” ê·¸ë£¹ë§Œ í•„í„°ë§ (severityê°€ "none"ì´ ì•„ë‹Œ ê²½ìš°)
      if (delayAnalysis.severity === "none") {
        continue;
      }

      // 6. ìš°ì„ ìˆœìœ„ ë§¤í•‘ (severity â†’ priority)
      let priority: "high" | "medium" | "low";
      if (
        delayAnalysis.severity === "critical" ||
        delayAnalysis.severity === "high"
      ) {
        priority = "high";
      } else if (delayAnalysis.severity === "medium") {
        priority = "medium";
      } else {
        priority = "low";
      }

      // 7. RescheduleRecommendation ìƒì„±
      recommendations.push({
        groupId: group.id,
        groupName: group.name || undefined,
        reason: delayAnalysis.description,
        priority,
        estimatedImpact: {
          plansAffected: delayAnalysis.details.missedPlans || delayAnalysis.details.totalPlans,
        },
      });
    }

    // 8. ìš°ì„ ìˆœìœ„ë³„ ì •ë ¬ (high â†’ medium â†’ low)
    const priorityOrder: Record<"high" | "medium" | "low", number> = {
      high: 3,
      medium: 2,
      low: 1,
    };

    recommendations.sort(
      (a, b) => priorityOrder[b.priority] - priorityOrder[a.priority]
    );

    return recommendations;
  } catch (error) {
    console.error("[detectRescheduleNeeds] ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜:", error);
    return [];
  }
}

/**
 * ì¬ì¡°ì • íš¨ê³¼ ë¶„ì„
 * 
 * @param logs ì¬ì¡°ì • ë¡œê·¸ ëª©ë¡
 * @returns íš¨ê³¼ ë¶„ì„ ê²°ê³¼
 */
export function analyzeRescheduleEffects(
  logs: RescheduleLogItem[]
): RescheduleEffectAnalysis {
  if (logs.length === 0) {
    return {
      beforeAfter: {
        averagePlansBefore: 0,
        averagePlansAfter: 0,
        averageChange: 0,
      },
      successRate: 0,
      rollbackRate: 0,
      averageIntervalDays: 0,
      effectiveness: "low",
      effectivenessDescription: "ì¬ì¡°ì • ì´ë ¥ì´ ì—†ìŠµë‹ˆë‹¤.",
    };
  }

  // ì¬ì¡°ì • ì „í›„ ë¹„êµ
  const totalPlansBefore = logs.reduce(
    (sum, log) => sum + log.plans_before_count,
    0
  );
  const totalPlansAfter = logs.reduce(
    (sum, log) => sum + log.plans_after_count,
    0
  );
  const averagePlansBefore = Math.round((totalPlansBefore / logs.length) * 10) / 10;
  const averagePlansAfter = Math.round((totalPlansAfter / logs.length) * 10) / 10;
  const averageChange = averagePlansAfter - averagePlansBefore;

  // ì„±ê³µë¥  ë° ë¡¤ë°±ë¥ 
  const successfulLogs = logs.filter((log) => log.status === "completed");
  const rolledBackLogs = logs.filter((log) => log.status === "rolled_back");
  const successRate = Math.round((successfulLogs.length / logs.length) * 100);
  const rollbackRate = Math.round((rolledBackLogs.length / logs.length) * 100);

  // í‰ê·  ì¬ì¡°ì • ê°„ê²©
  const sortedLogs = [...logs].sort(
    (a, b) =>
      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
  );
  let totalIntervalDays = 0;
  for (let i = 1; i < sortedLogs.length; i++) {
    const prevDate = new Date(sortedLogs[i - 1].created_at);
    const currDate = new Date(sortedLogs[i].created_at);
    const daysDiff =
      (currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24);
    totalIntervalDays += daysDiff;
  }
  const averageIntervalDays =
    sortedLogs.length > 1
      ? Math.round((totalIntervalDays / (sortedLogs.length - 1)) * 10) / 10
      : 0;

  // íš¨ê³¼ í‰ê°€
  let effectiveness: "high" | "medium" | "low" = "medium";
  let effectivenessDescription = "";

  if (successRate >= EFFECTIVENESS_THRESHOLDS.SUCCESS_HIGH && rollbackRate <= EFFECTIVENESS_THRESHOLDS.ROLLBACK_LOW) {
    effectiveness = "high";
    effectivenessDescription = "ì¬ì¡°ì •ì´ íš¨ê³¼ì ìœ¼ë¡œ ì´ë£¨ì–´ì§€ê³  ìˆìŠµë‹ˆë‹¤.";
  } else if (successRate >= EFFECTIVENESS_THRESHOLDS.SUCCESS_MEDIUM && rollbackRate <= EFFECTIVENESS_THRESHOLDS.ROLLBACK_MEDIUM) {
    effectiveness = "medium";
    effectivenessDescription = "ì¬ì¡°ì •ì´ ëŒ€ì²´ë¡œ íš¨ê³¼ì ì…ë‹ˆë‹¤. ì¼ë¶€ ê°œì„  ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤.";
  } else {
    effectiveness = "low";
    effectivenessDescription = "ì¬ì¡°ì • íš¨ê³¼ê°€ ë‚®ìŠµë‹ˆë‹¤. ì¬ì¡°ì • ì „ëµì„ ì¬ê²€í† í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.";
  }

  return {
    beforeAfter: {
      averagePlansBefore,
      averagePlansAfter,
      averageChange,
    },
    successRate,
    rollbackRate,
    averageIntervalDays,
    effectiveness,
    effectivenessDescription,
  };
}
</file>

<file path="periodCalculator.test.ts">
/**
 * ì¬ì¡°ì • ê¸°ê°„ ê³„ì‚°ê¸° ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
 * 
 * @module lib/reschedule/periodCalculator.test
 */

import { describe, it, expect } from 'vitest';
import {
  getTodayDateString,
  getNextDayString,
  getDaysBetween,
  isDateBefore,
  isDateBeforeOrEqual,
  getAdjustedPeriod,
  getAdjustedPeriodWithDetails,
  validateReschedulePeriod,
  PeriodCalculationError,
} from './periodCalculator';

describe('ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜', () => {
  describe('getTodayDateString', () => {
    it('YYYY-MM-DD í˜•ì‹ ë°˜í™˜', () => {
      const today = getTodayDateString();
      expect(today).toMatch(/^\d{4}-\d{2}-\d{2}$/);
    });
  });

  describe('getNextDayString', () => {
    it('ë‹¤ìŒ ë‚  ë°˜í™˜', () => {
      expect(getNextDayString('2025-12-10')).toBe('2025-12-11');
    });

    it('ì›”ë§ â†’ ë‹¤ìŒë‹¬ ì´ˆ', () => {
      expect(getNextDayString('2025-12-31')).toBe('2026-01-01');
    });

    it('2ì›” ë§ â†’ 3ì›” ì´ˆ', () => {
      expect(getNextDayString('2025-02-28')).toBe('2025-03-01');
    });
  });

  describe('getDaysBetween', () => {
    it('ê°™ì€ ë‚ ì€ 1ì¼', () => {
      expect(getDaysBetween('2025-12-10', '2025-12-10')).toBe(1);
    });

    it('ì—°ì† ì´í‹€ì€ 2ì¼', () => {
      expect(getDaysBetween('2025-12-10', '2025-12-11')).toBe(2);
    });

    it('ì¼ì£¼ì¼ì€ 7ì¼', () => {
      expect(getDaysBetween('2025-12-10', '2025-12-16')).toBe(7);
    });
  });

  describe('isDateBefore', () => {
    it('ì´ì „ ë‚ ì§œ í™•ì¸', () => {
      expect(isDateBefore('2025-12-10', '2025-12-11')).toBe(true);
      expect(isDateBefore('2025-12-11', '2025-12-10')).toBe(false);
    });

    it('ê°™ì€ ë‚ ì§œëŠ” false', () => {
      expect(isDateBefore('2025-12-10', '2025-12-10')).toBe(false);
    });
  });

  describe('isDateBeforeOrEqual', () => {
    it('ì´ì „ ë˜ëŠ” ê°™ì€ ë‚ ì§œ í™•ì¸', () => {
      expect(isDateBeforeOrEqual('2025-12-10', '2025-12-11')).toBe(true);
      expect(isDateBeforeOrEqual('2025-12-10', '2025-12-10')).toBe(true);
      expect(isDateBeforeOrEqual('2025-12-11', '2025-12-10')).toBe(false);
    });
  });
});

describe('getAdjustedPeriod', () => {
  const today = '2025-12-10';
  const groupEnd = '2025-12-31';

  describe('ì „ì²´ ì¬ì¡°ì • (ë‚ ì§œ ë²”ìœ„ ë¯¸ì§€ì •)', () => {
    it('ì˜¤ëŠ˜ ë‹¤ìŒë‚ ë¶€í„° ê·¸ë£¹ ì¢…ë£Œì¼ê¹Œì§€ ë°˜í™˜', () => {
      const result = getAdjustedPeriod(null, today, groupEnd);
      expect(result.start).toBe('2025-12-11');
      expect(result.end).toBe('2025-12-31');
    });

    it('includeToday=trueë©´ ì˜¤ëŠ˜ë¶€í„° ì‹œì‘', () => {
      const result = getAdjustedPeriod(null, today, groupEnd, true);
      expect(result.start).toBe('2025-12-10');
      expect(result.end).toBe('2025-12-31');
    });

    it('ê·¸ë£¹ ì¢…ë£Œì¼ì´ ì˜¤ëŠ˜ ì´ì „ì´ë©´ ì—ëŸ¬', () => {
      expect(() => {
        getAdjustedPeriod(null, today, '2025-12-09');
      }).toThrow(PeriodCalculationError);
    });
  });

  describe('ë‚ ì§œ ë²”ìœ„ ì§€ì •', () => {
    it('ì„ íƒ ë²”ìœ„ê°€ ì˜¤ëŠ˜ ì´í›„ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©', () => {
      const dateRange = { from: '2025-12-15', to: '2025-12-20' };
      const result = getAdjustedPeriod(dateRange, today, groupEnd);
      expect(result.start).toBe('2025-12-15');
      expect(result.end).toBe('2025-12-20');
    });

    it('ì‹œì‘ì¼ì´ ì˜¤ëŠ˜ ì´ì „ì´ë©´ ì˜¤ëŠ˜ ë‹¤ìŒë‚ ë¡œ ì¡°ì •', () => {
      const dateRange = { from: '2025-12-05', to: '2025-12-20' };
      const result = getAdjustedPeriod(dateRange, today, groupEnd);
      expect(result.start).toBe('2025-12-11');
      expect(result.end).toBe('2025-12-20');
    });

    it('ì¢…ë£Œì¼ì´ ê·¸ë£¹ ì¢…ë£Œì¼ ì´í›„ë©´ ê·¸ë£¹ ì¢…ë£Œì¼ë¡œ ì¡°ì •', () => {
      const dateRange = { from: '2025-12-15', to: '2026-01-15' };
      const result = getAdjustedPeriod(dateRange, today, groupEnd);
      expect(result.start).toBe('2025-12-15');
      expect(result.end).toBe('2025-12-31');
    });

    it('ì¢…ë£Œì¼ì´ ì‹œì‘ì¼ ì´ì „ì´ë©´ ì—ëŸ¬', () => {
      const dateRange = { from: '2025-12-20', to: '2025-12-15' };
      expect(() => {
        getAdjustedPeriod(dateRange, today, groupEnd);
      }).toThrow(PeriodCalculationError);
    });

    it('ì„ íƒ ë²”ìœ„ ì „ì²´ê°€ ì˜¤ëŠ˜ ì´ì „ì´ë©´ ì—ëŸ¬', () => {
      const dateRange = { from: '2025-12-01', to: '2025-12-09' };
      expect(() => {
        getAdjustedPeriod(dateRange, today, groupEnd);
      }).toThrow(PeriodCalculationError);
    });
  });
});

describe('getAdjustedPeriodWithDetails', () => {
  const today = '2025-12-10';
  const groupEnd = '2025-12-31';

  it('ì¡°ì • ì—¬ë¶€ ì™€ ê°€ìš© ì¼ìˆ˜ ë°˜í™˜', () => {
    const dateRange = { from: '2025-12-05', to: '2025-12-20' };
    const result = getAdjustedPeriodWithDetails(dateRange, today, groupEnd);
    
    expect(result.period.start).toBe('2025-12-11');
    expect(result.period.end).toBe('2025-12-20');
    expect(result.adjustedFromToday).toBe(true);
    expect(result.originalStart).toBe('2025-12-05');
    expect(result.availableDays).toBe(10); // 12/11 ~ 12/20 = 10ì¼
  });

  it('ì¡°ì •ì´ í•„ìš” ì—†ìœ¼ë©´ adjustedFromToday=false', () => {
    const dateRange = { from: '2025-12-15', to: '2025-12-20' };
    const result = getAdjustedPeriodWithDetails(dateRange, today, groupEnd);
    
    expect(result.adjustedFromToday).toBe(false);
    expect(result.originalStart).toBeUndefined();
  });
});

describe('validateReschedulePeriod', () => {
  const today = '2025-12-10';
  const groupEnd = '2025-12-31';

  it('ìœ íš¨í•œ ê¸°ê°„ì€ valid=true', () => {
    const result = validateReschedulePeriod(
      { from: '2025-12-15', to: '2025-12-20' },
      today,
      groupEnd
    );
    expect(result.valid).toBe(true);
    expect(result.error).toBeUndefined();
  });

  it('ìœ íš¨í•˜ì§€ ì•Šì€ ê¸°ê°„ì€ valid=falseì™€ ì—ëŸ¬ ë©”ì‹œì§€', () => {
    const result = validateReschedulePeriod(
      { from: '2025-12-01', to: '2025-12-09' },
      today,
      groupEnd
    );
    expect(result.valid).toBe(false);
    expect(result.error).toBeDefined();
    expect(result.errorCode).toBe('PAST_DATE_RANGE');
  });
});
</file>

<file path="periodCalculator.ts">
/**
 * ì¬ì¡°ì • ê¸°ê°„ ê³„ì‚°ê¸°
 * 
 * ì¬ì¡°ì • ê¸°ê°„ì„ ì˜¤ëŠ˜ ì´í›„ë¡œ ê²°ì •í•©ë‹ˆë‹¤.
 * ê³¼ê±° ë‚ ì§œëŠ” ì¬ì¡°ì • ëŒ€ìƒì—ì„œ ì œì™¸í•˜ê³ , ì˜¤ëŠ˜ ë‹¤ìŒë‚ ë¶€í„° ì¬ì¡°ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/periodCalculator
 */

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì¬ì¡°ì • ê¸°ê°„
 */
export interface AdjustedPeriod {
  start: string; // YYYY-MM-DD
  end: string;   // YYYY-MM-DD
}

/**
 * ê¸°ê°„ ê³„ì‚° ê²°ê³¼
 */
export interface PeriodCalculationResult {
  period: AdjustedPeriod;
  adjustedFromToday: boolean; // ì˜¤ëŠ˜ ì´í›„ë¡œ ì¡°ì •ë˜ì—ˆëŠ”ì§€
  originalStart?: string;     // ì›ë˜ ì‹œì‘ì¼ (ì¡°ì •ëœ ê²½ìš°)
  availableDays: number;      // ì‚¬ìš© ê°€ëŠ¥í•œ ì¼ìˆ˜
}

/**
 * ê¸°ê°„ ê³„ì‚° ì—ëŸ¬
 */
export class PeriodCalculationError extends Error {
  constructor(
    message: string,
    public readonly code: 'NO_REMAINING_PERIOD' | 'INVALID_DATE_RANGE' | 'PAST_DATE_RANGE'
  ) {
    super(message);
    this.name = 'PeriodCalculationError';
  }
}

// ============================================
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
// ============================================

/**
 * ì˜¤ëŠ˜ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸° (YYYY-MM-DD í˜•ì‹)
 */
export function getTodayDateString(): string {
  const today = new Date();
  return today.toISOString().split('T')[0];
}

/**
 * ë‹¤ìŒë‚  ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
 */
export function getNextDayString(dateString: string): string {
  const date = new Date(dateString);
  date.setDate(date.getDate() + 1);
  return date.toISOString().split('T')[0];
}

/**
 * ë‘ ë‚ ì§œ ì‚¬ì´ì˜ ì¼ìˆ˜ ê³„ì‚°
 */
export function getDaysBetween(startDate: string, endDate: string): number {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const diffTime = end.getTime() - start.getTime();
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // ì‹œì‘ì¼, ì¢…ë£Œì¼ í¬í•¨
}

/**
 * ë‚ ì§œ ë¹„êµ (a < b)
 */
export function isDateBefore(a: string, b: string): boolean {
  return new Date(a) < new Date(b);
}

/**
 * ë‚ ì§œ ë¹„êµ (a <= b)
 */
export function isDateBeforeOrEqual(a: string, b: string): boolean {
  return new Date(a) <= new Date(b);
}

// ============================================
// ì¬ì¡°ì • ê¸°ê°„ ê²°ì • í•¨ìˆ˜
// ============================================

/**
 * ì¬ì¡°ì • ê¸°ê°„ ê²°ì •
 * 
 * ì˜¤ëŠ˜ ì´í›„ì˜ ì¬ì¡°ì • ê¸°ê°„ì„ ê²°ì •í•©ë‹ˆë‹¤.
 * 
 * @param dateRange ì‚¬ìš©ìê°€ ì„ íƒí•œ ë‚ ì§œ ë²”ìœ„ (nullì´ë©´ ì „ì²´ ì¬ì¡°ì •)
 * @param today ì˜¤ëŠ˜ ë‚ ì§œ (YYYY-MM-DD)
 * @param groupEnd í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼ (YYYY-MM-DD)
 * @param includeToday ì˜¤ëŠ˜ ë‚ ì§œ í¬í•¨ ì—¬ë¶€ (ê¸°ë³¸ê°’: false)
 * @returns ì¬ì¡°ì • ê¸°ê°„ (start, end)
 * @throws PeriodCalculationError ê¸°ê°„ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°
 * 
 * @example
 * ```ts
 * // ì „ì²´ ì¬ì¡°ì •
 * const period = getAdjustedPeriod(null, '2025-12-10', '2025-12-31');
 * // { start: '2025-12-11', end: '2025-12-31' }
 * 
 * // ë‚ ì§œ ë²”ìœ„ ì§€ì •
 * const period = getAdjustedPeriod(
 *   { from: '2025-12-05', to: '2025-12-20' },
 *   '2025-12-10',
 *   '2025-12-31'
 * );
 * // { start: '2025-12-11', end: '2025-12-20' }
 * 
 * // ì˜¤ëŠ˜ ë‚ ì§œ í¬í•¨
 * const period = getAdjustedPeriod(
 *   null,
 *   '2025-12-10',
 *   '2025-12-31',
 *   true
 * );
 * // { start: '2025-12-10', end: '2025-12-31' }
 * ```
 */
export function getAdjustedPeriod(
  dateRange: { from: string; to: string } | null,
  today: string,
  groupEnd: string,
  includeToday: boolean = false
): AdjustedPeriod {
  const startDate = includeToday ? today : getNextDayString(today);
  const tomorrow = getNextDayString(today);

  // ì „ì²´ ì¬ì¡°ì • (ë‚ ì§œ ë²”ìœ„ ë¯¸ì§€ì •)
  if (!dateRange) {
    // ì˜¤ëŠ˜ ì´í›„ ê¸°ê°„ì´ ë‚¨ì•„ìˆëŠ”ì§€ í™•ì¸
    if (isDateBefore(groupEnd, startDate)) {
      throw new PeriodCalculationError(
        'ì¬ì¡°ì •í•  ê¸°ê°„ì´ ë‚¨ì•„ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼ì´ ì˜¤ëŠ˜ ì´ì „ì…ë‹ˆë‹¤.',
        'NO_REMAINING_PERIOD'
      );
    }

    return {
      start: startDate,
      end: groupEnd,
    };
  }

  // ë‚ ì§œ ë²”ìœ„ ì§€ì •ëœ ê²½ìš°
  const { from, to } = dateRange;

  // ë‚ ì§œ ë²”ìœ„ ìœ íš¨ì„± ê²€ì¦
  if (isDateBefore(to, from)) {
    throw new PeriodCalculationError(
      'ì¢…ë£Œì¼ì´ ì‹œì‘ì¼ë³´ë‹¤ ì´ì „ì…ë‹ˆë‹¤.',
      'INVALID_DATE_RANGE'
    );
  }

  // ì„ íƒí•œ ë²”ìœ„ê°€ ëª¨ë‘ ì‹œì‘ì¼ ì´ì „ì¸ ê²½ìš°
  if (isDateBefore(to, startDate)) {
    throw new PeriodCalculationError(
      'ì„ íƒí•œ ë‚ ì§œ ë²”ìœ„ì— ìœ íš¨í•œ ê¸°ê°„ì´ í¬í•¨ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
      'PAST_DATE_RANGE'
    );
  }

  // ì‹œì‘ì¼ ì¡°ì •: ì‹œì‘ì¼ ì´í›„ë¡œ ì„¤ì •
  const adjustedStart = isDateBefore(from, startDate) ? startDate : from;

  // ì¢…ë£Œì¼: groupEndë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šë„ë¡ (ì„ íƒì‚¬í•­)
  const adjustedEnd = isDateBefore(groupEnd, to) ? groupEnd : to;

  return {
    start: adjustedStart,
    end: adjustedEnd,
  };
}

/**
 * ì¬ì¡°ì • ê¸°ê°„ ê²°ì • (ìƒì„¸ ê²°ê³¼)
 * 
 * ì¡°ì • ì—¬ë¶€ì™€ ì‚¬ìš© ê°€ëŠ¥í•œ ì¼ìˆ˜ ë“± ìƒì„¸ ì •ë³´ë¥¼ í•¨ê»˜ ë°˜í™˜í•©ë‹ˆë‹¤.
 * 
 * @param dateRange ì‚¬ìš©ìê°€ ì„ íƒí•œ ë‚ ì§œ ë²”ìœ„
 * @param today ì˜¤ëŠ˜ ë‚ ì§œ
 * @param groupEnd í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼
 * @param includeToday ì˜¤ëŠ˜ ë‚ ì§œ í¬í•¨ ì—¬ë¶€ (ê¸°ë³¸ê°’: false)
 * @returns ê¸°ê°„ ê³„ì‚° ìƒì„¸ ê²°ê³¼
 */
export function getAdjustedPeriodWithDetails(
  dateRange: { from: string; to: string } | null,
  today: string,
  groupEnd: string,
  includeToday: boolean = false
): PeriodCalculationResult {
  const tomorrow = getNextDayString(today);
  const startDate = includeToday ? today : tomorrow;
  const period = getAdjustedPeriod(dateRange, today, groupEnd, includeToday);

  const wasAdjusted = dateRange
    ? isDateBefore(dateRange.from, startDate)
    : false;

  return {
    period,
    adjustedFromToday: wasAdjusted,
    originalStart: wasAdjusted && dateRange ? dateRange.from : undefined,
    availableDays: getDaysBetween(period.start, period.end),
  };
}

/**
 * ì¬ì¡°ì • ê¸°ê°„ ê²€ì¦
 * 
 * ì§€ì •ëœ ë‚ ì§œ ë²”ìœ„ê°€ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 * 
 * @param dateRange ê²€ì¦í•  ë‚ ì§œ ë²”ìœ„
 * @param today ì˜¤ëŠ˜ ë‚ ì§œ
 * @param groupEnd í”Œëœ ê·¸ë£¹ ì¢…ë£Œì¼
 * @returns ìœ íš¨ì„± ê²€ì¦ ê²°ê³¼
 */
export function validateReschedulePeriod(
  dateRange: { from: string; to: string } | null,
  today: string,
  groupEnd: string,
  includeToday: boolean = false
): { valid: boolean; error?: string; errorCode?: PeriodCalculationError['code'] } {
  try {
    getAdjustedPeriod(dateRange, today, groupEnd, includeToday);
    return { valid: true };
  } catch (error) {
    if (error instanceof PeriodCalculationError) {
      return {
        valid: false,
        error: error.message,
        errorCode: error.code,
      };
    }
    return {
      valid: false,
      error: 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    };
  }
}
</file>

<file path="previewCache.ts">
/**
 * ì¬ì¡°ì • ë¯¸ë¦¬ë³´ê¸° ê²°ê³¼ ìºì‹±
 * 
 * ë¯¸ë¦¬ë³´ê¸° ê²°ê³¼ë¥¼ ìºì‹±í•˜ì—¬ ë™ì¼í•œ ìš”ì²­ì— ëŒ€í•´ ë¹ ë¥´ê²Œ ì‘ë‹µí•©ë‹ˆë‹¤.
 * LRU(Least Recently Used) ì •ì±…ìœ¼ë¡œ ìµœëŒ€ í•­ëª© ìˆ˜ë¥¼ ì œí•œí•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/previewCache
 */

import type { ReschedulePreviewResult } from '@/app/(student)/actions/plan-groups/reschedule';
import type { AdjustmentInput } from './scheduleEngine';

// ============================================
// ì„¤ì • (í™˜ê²½ ë³€ìˆ˜ ì§€ì›)
// ============================================

/**
 * ìºì‹œ ì„¤ì •ê°’
 * í™˜ê²½ ë³€ìˆ˜ë¡œ ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥
 */
export const CACHE_CONFIG = {
  /** ìºì‹œ TTL (Time To Live) - ê¸°ë³¸ 5ë¶„ */
  TTL_MS: parseInt(process.env.RESCHEDULE_CACHE_TTL_MS || '300000', 10),
  /** ìºì‹œ ìµœëŒ€ í•­ëª© ìˆ˜ - ê¸°ë³¸ 100ê°œ */
  MAX_ITEMS: parseInt(process.env.RESCHEDULE_CACHE_MAX_ITEMS || '100', 10),
  /** ìºì‹œ ì •ë¦¬ ì£¼ê¸° - ê¸°ë³¸ 10ë¶„ */
  CLEANUP_INTERVAL_MS: parseInt(process.env.RESCHEDULE_CACHE_CLEANUP_MS || '600000', 10),
} as const;

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ìºì‹œ í•­ëª©
 */
interface CacheItem {
  result: ReschedulePreviewResult;
  timestamp: number;
  expiresAt: number;
  lastAccessed: number; // LRUë¥¼ ìœ„í•œ ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„
}

// ============================================
// ìºì‹œ ì €ì¥ì†Œ (ë©”ëª¨ë¦¬ ê¸°ë°˜ LRU)
// ============================================

/**
 * ìºì‹œ ì €ì¥ì†Œ (Map ê¸°ë°˜)
 * í”„ë¡œë•ì…˜ì—ì„œëŠ” Redis ë“±ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
 */
const cacheStore = new Map<string, CacheItem>();

/**
 * LRU ìºì‹œ ì •ë¦¬ (ìµœëŒ€ í•­ëª© ìˆ˜ ì´ˆê³¼ ì‹œ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°)
 */
function evictLRU(): void {
  if (cacheStore.size <= CACHE_CONFIG.MAX_ITEMS) return;

  // ì‚­ì œí•  í•­ëª© ìˆ˜
  const itemsToRemove = cacheStore.size - CACHE_CONFIG.MAX_ITEMS;
  
  // lastAccessed ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ
  const entries = Array.from(cacheStore.entries())
    .sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
  
  for (let i = 0; i < itemsToRemove; i++) {
    if (entries[i]) {
      cacheStore.delete(entries[i][0]);
    }
  }
  
  if (itemsToRemove > 0) {
    console.debug(`[previewCache] LRU ì •ë¦¬: ${itemsToRemove}ê°œ í•­ëª© ì œê±° (í˜„ì¬: ${cacheStore.size}ê°œ)`);
  }
}

// ìºì‹œ ì •ë¦¬ íƒ€ì´ë¨¸ ì‹œì‘
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    cleanupExpiredCache();
  }, CACHE_CONFIG.CLEANUP_INTERVAL_MS);
}

// ============================================
// ìºì‹œ í‚¤ ìƒì„±
// ============================================

/**
 * ë¯¸ë¦¬ë³´ê¸° ìºì‹œ í‚¤ ìƒì„±
 * 
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 * @param adjustments ì¡°ì • ìš”ì²­ ëª©ë¡
 * @param rescheduleDateRange ì¬ì¡°ì •í•  í”Œëœ ë²”ìœ„ (ì„ íƒ)
 * @param placementDateRange ìƒˆ í”Œëœ ë°°ì¹˜ ë²”ìœ„ (ì„ íƒ)
 * @param includeToday ì˜¤ëŠ˜ í¬í•¨ ì—¬ë¶€
 * @returns ìºì‹œ í‚¤
 */
export function generatePreviewCacheKey(
  groupId: string,
  adjustments: AdjustmentInput[],
  rescheduleDateRange?: { from: string; to: string } | null,
  placementDateRange?: { from: string; to: string } | null,
  includeToday: boolean = false
): string {
  // ì¡°ì • ìš”ì²­ì„ ì •ë ¬í•˜ì—¬ ë™ì¼í•œ ì¡°ì •ì— ëŒ€í•´ ê°™ì€ í‚¤ ìƒì„±
  const sortedAdjustments = [...adjustments].sort((a, b) => {
    if (a.plan_content_id !== b.plan_content_id) {
      return a.plan_content_id.localeCompare(b.plan_content_id);
    }
    return a.change_type.localeCompare(b.change_type);
  });

  // ìºì‹œ í‚¤ êµ¬ì„± ìš”ì†Œ
  const keyComponents = {
    adjustments: sortedAdjustments,
    rescheduleDateRange: rescheduleDateRange || null,
    placementDateRange: placementDateRange || null,
    includeToday,
  };

  // JSON ë¬¸ìì—´ë¡œ ì§ë ¬í™”
  const keyStr = JSON.stringify(keyComponents);
  
  // FNV-1a í•´ì‹œ (ë¹ ë¥´ê³  ì¶©ëŒ ì ìŒ)
  let hash = 2166136261;
  for (let i = 0; i < keyStr.length; i++) {
    hash ^= keyStr.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }

  return `reschedule_preview:${groupId}:${(hash >>> 0).toString(36)}`;
}

// ============================================
// ìºì‹œ ì¡°íšŒ/ì €ì¥
// ============================================

/**
 * ìºì‹œëœ ë¯¸ë¦¬ë³´ê¸° ê²°ê³¼ ì¡°íšŒ
 * 
 * @param key ìºì‹œ í‚¤
 * @returns ìºì‹œëœ ê²°ê³¼ ë˜ëŠ” null
 */
export async function getCachedPreview(
  key: string
): Promise<ReschedulePreviewResult | null> {
  const item = cacheStore.get(key);
  
  if (!item) {
    return null;
  }

  // ë§Œë£Œ í™•ì¸
  if (Date.now() > item.expiresAt) {
    cacheStore.delete(key);
    return null;
  }

  // LRU: ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„ ê°±ì‹ 
  item.lastAccessed = Date.now();

  return item.result;
}

/**
 * ë¯¸ë¦¬ë³´ê¸° ê²°ê³¼ ìºì‹±
 * 
 * @param key ìºì‹œ í‚¤
 * @param result ë¯¸ë¦¬ë³´ê¸° ê²°ê³¼
 */
export async function cachePreviewResult(
  key: string,
  result: ReschedulePreviewResult
): Promise<void> {
  const now = Date.now();
  
  cacheStore.set(key, {
    result,
    timestamp: now,
    expiresAt: now + CACHE_CONFIG.TTL_MS,
    lastAccessed: now,
  });

  // ìºì‹œ í¬ê¸° ì œí•œ ì´ˆê³¼ ì‹œ LRU ì •ë¦¬
  evictLRU();
}

/**
 * ìºì‹œ ì‚­ì œ
 * 
 * @param key ìºì‹œ í‚¤
 */
export function deleteCachedPreview(key: string): void {
  cacheStore.delete(key);
}

/**
 * í”Œëœ ê·¸ë£¹ ê´€ë ¨ ìºì‹œ ëª¨ë‘ ì‚­ì œ
 * 
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 */
export function clearGroupCache(groupId: string): void {
  const prefix = `reschedule_preview:${groupId}:`;
  const keysToDelete: string[] = [];
  
  for (const key of cacheStore.keys()) {
    if (key.startsWith(prefix)) {
      keysToDelete.push(key);
    }
  }
  
  keysToDelete.forEach((key) => cacheStore.delete(key));
}

/**
 * ë§Œë£Œëœ ìºì‹œ ì •ë¦¬
 */
function cleanupExpiredCache(): void {
  const now = Date.now();
  const keysToDelete: string[] = [];
  
  for (const [key, item] of cacheStore.entries()) {
    if (now > item.expiresAt) {
      keysToDelete.push(key);
    }
  }
  
  keysToDelete.forEach((key) => cacheStore.delete(key));
  
  if (keysToDelete.length > 0) {
    console.log(`[previewCache] ${keysToDelete.length}ê°œì˜ ë§Œë£Œëœ ìºì‹œ í•­ëª© ì •ë¦¬`);
  }
}

/**
 * ìºì‹œ í†µê³„ ì¡°íšŒ
 * 
 * @returns ìºì‹œ í†µê³„
 */
export function getCacheStats(): {
  totalItems: number;
  expiredItems: number;
  memoryUsage: number; // ëŒ€ëµì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (ë°”ì´íŠ¸)
} {
  const now = Date.now();
  let expiredCount = 0;
  let totalSize = 0;
  
  for (const item of cacheStore.values()) {
    if (now > item.expiresAt) {
      expiredCount++;
    }
    // ëŒ€ëµì ì¸ í¬ê¸° ê³„ì‚° (JSON ë¬¸ìì—´ ê¸¸ì´)
    totalSize += JSON.stringify(item.result).length;
  }
  
  return {
    totalItems: cacheStore.size,
    expiredItems: expiredCount,
    memoryUsage: totalSize,
  };
}
</file>

<file path="rollbackValidator.ts">
/**
 * ë¡¤ë°± ê²€ì¦ ìœ í‹¸ë¦¬í‹°
 * 
 * ì¬ì¡°ì • ë¡¤ë°± ê°€ëŠ¥ ì—¬ë¶€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/rollbackValidator
 */

import type { SupabaseClient } from '@supabase/supabase-js';
import { isRollbackable } from '@/lib/utils/planStatusUtils';

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ë¡¤ë°± ì°¨ë‹¨ ìš”ì¸
 */
export interface RollbackBlocker {
  planId: string;
  status: string;
  reason: string;
}

/**
 * ë¡¤ë°± ê²€ì¦ ê²°ê³¼
 */
export interface RollbackValidation {
  canRollback: boolean;
  reason?: string;
  blockers?: RollbackBlocker[];
}

// ============================================
// ê²€ì¦ í•¨ìˆ˜
// ============================================

/**
 * ë¡¤ë°± ê°€ëŠ¥ ì—¬ë¶€ ê²€ì¦
 * 
 * ì¬ì¡°ì • ë¡œê·¸ì— ì—°ê²°ëœ ìƒˆ í”Œëœë“¤ì´ ëª¨ë‘ ë¡¤ë°± ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * 
 * ë¡¤ë°± ê°€ëŠ¥ ì¡°ê±´:
 * - ìƒˆ í”Œëœ ì¤‘ statusê°€ 'pending'ì¸ ê²ƒë§Œ (ì•„ì§ ì‹œì‘í•˜ì§€ ì•ŠìŒ)
 * - ìƒˆ í”Œëœ ì¤‘ statusê°€ 'in_progress' ë˜ëŠ” 'completed'ê°€ ìˆìœ¼ë©´ ë¡¤ë°± ë¶ˆê°€
 * 
 * @param supabase Supabase í´ë¼ì´ì–¸íŠ¸
 * @param rescheduleLogId ì¬ì¡°ì • ë¡œê·¸ ID
 * @returns ë¡¤ë°± ê²€ì¦ ê²°ê³¼
 */
export async function validateRollback(
  supabase: SupabaseClient,
  rescheduleLogId: string
): Promise<RollbackValidation> {
  try {
    // 1. ì¬ì¡°ì • ë¡œê·¸ ì¡°íšŒ
    const { data: log, error: logError } = await supabase
      .from('reschedule_log')
      .select('*')
      .eq('id', rescheduleLogId)
      .single();

    if (logError || !log) {
      return {
        canRollback: false,
        reason: 'ì¬ì¡°ì • ë¡œê·¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
      };
    }

    // 2. ì´ë¯¸ ë¡¤ë°±ëœ ê²½ìš°
    if (log.status === 'rolled_back') {
      return {
        canRollback: false,
        reason: 'ì´ë¯¸ ë¡¤ë°±ëœ ì¬ì¡°ì •ì…ë‹ˆë‹¤.',
      };
    }

    // 3. ì¬ì¡°ì • ë¡œê·¸ì— ì—°ê²°ëœ plan_history ì¡°íšŒ
    const { data: histories, error: historyError } = await supabase
      .from('plan_history')
      .select('plan_id')
      .eq('reschedule_log_id', rescheduleLogId);

    if (historyError) {
      console.error('[rollbackValidator] plan_history ì¡°íšŒ ì‹¤íŒ¨:', historyError);
      return {
        canRollback: false,
        reason: 'íˆìŠ¤í† ë¦¬ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
      };
    }

    if (!histories || histories.length === 0) {
      return {
        canRollback: false,
        reason: 'ë¡¤ë°±í•  í”Œëœì´ ì—†ìŠµë‹ˆë‹¤.',
      };
    }

    // 4. ì¬ì¡°ì • í›„ ìƒì„±ëœ ìƒˆ í”Œëœ ì¡°íšŒ
    // plan_historyì— ë°±ì—…ëœ í”Œëœì˜ plan_idë¥¼ ê¸°ë°˜ìœ¼ë¡œ
    // ê°™ì€ plan_group_idì—ì„œ ìƒˆë¡œ ìƒì„±ëœ í”Œëœì„ ì°¾ì•„ì•¼ í•¨
    // í•˜ì§€ë§Œ í˜„ì¬ êµ¬ì¡°ì—ì„œëŠ” ì§ì ‘ì ì¸ ì—°ê²°ì´ ì—†ìœ¼ë¯€ë¡œ,
    // reschedule_logì˜ plan_group_idì™€ created_atì„ ê¸°ì¤€ìœ¼ë¡œ ì¡°íšŒ

    const { data: newPlans, error: plansError } = await supabase
      .from('student_plan')
      .select('id, status, is_active, created_at')
      .eq('plan_group_id', log.plan_group_id)
      .eq('student_id', log.student_id)
      .eq('is_active', true)
      .gte('created_at', log.created_at); // ì¬ì¡°ì • ì´í›„ ìƒì„±ëœ í”Œëœ

    if (plansError) {
      console.error('[rollbackValidator] ìƒˆ í”Œëœ ì¡°íšŒ ì‹¤íŒ¨:', plansError);
      return {
        canRollback: false,
        reason: 'ìƒˆ í”Œëœ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
      };
    }

    // 5. ë¡¤ë°± ë¶ˆê°€ëŠ¥í•œ í”Œëœ í™•ì¸
    const blockers: RollbackBlocker[] = [];
    const rollbackablePlans: string[] = [];

    (newPlans || []).forEach((plan) => {
      if (isRollbackable(plan)) {
        rollbackablePlans.push(plan.id);
      } else {
        blockers.push({
          planId: plan.id,
          status: plan.status || 'unknown',
          reason: getBlockerReason(plan.status || 'unknown'),
        });
      }
    });

    // 6. ë¡¤ë°± ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨
    if (blockers.length > 0) {
      return {
        canRollback: false,
        reason: `${blockers.length}ê°œì˜ í”Œëœì´ ì´ë¯¸ ì‹œì‘ë˜ì—ˆê±°ë‚˜ ì™„ë£Œë˜ì–´ ë¡¤ë°±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
        blockers,
      };
    }

    // 7. ì‹œê°„ ì œí•œ í™•ì¸ (24ì‹œê°„)
    const now = new Date();
    const logCreatedAt = new Date(log.created_at);
    const hoursSinceCreation = (now.getTime() - logCreatedAt.getTime()) / (1000 * 60 * 60);

    if (hoursSinceCreation > 24) {
      return {
        canRollback: false,
        reason: 'ì¬ì¡°ì • í›„ 24ì‹œê°„ì´ ì§€ë‚˜ ë¡¤ë°±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
      };
    }

    return {
      canRollback: true,
    };
  } catch (error) {
    console.error('[rollbackValidator] ê²€ì¦ ì¤‘ ì—ëŸ¬:', error);
    return {
      canRollback: false,
      reason: error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    };
  }
}

/**
 * ë¡¤ë°± ì°¨ë‹¨ ì‚¬ìœ  ë°˜í™˜
 * 
 * @param status í”Œëœ ìƒíƒœ
 * @returns ì°¨ë‹¨ ì‚¬ìœ 
 */
function getBlockerReason(status: string): string {
  switch (status) {
    case 'in_progress':
      return 'í•™ìŠµì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.';
    case 'completed':
      return 'í•™ìŠµì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
    case 'canceled':
      return 'í”Œëœì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.';
    default:
      return `ìƒíƒœ: ${status}`;
  }
}
</file>

<file path="scheduleEngine.ts">
/**
 * ì¬ì¡°ì • ìŠ¤ì¼€ì¤„ ì—”ì§„
 * 
 * ì¬ì¡°ì • ê¸°ëŠ¥ì—ì„œ í”Œëœì„ ì¬ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ìˆœìˆ˜ í•¨ìˆ˜ í˜•íƒœì˜ ìŠ¤ì¼€ì¤„ ì—”ì§„ì…ë‹ˆë‹¤.
 * DB I/O ì—†ì´ ìˆœìˆ˜ ê³„ì‚°ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/scheduleEngine
 */

import type { PlanGroup, PlanContent } from '@/lib/types/plan';
import type { ScheduledPlan } from '@/lib/plan/scheduler';

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ì½˜í…ì¸  ìŠ¤ëƒ…ìƒ· (ì¬ì¡°ì • ì „ ìƒíƒœ)
 */
export interface ContentSnapshot {
  content_id: string;
  content_type: 'book' | 'lecture' | 'custom';
  range: {
    start: number;
    end: number;
  };
}

/**
 * ì¡°ì • ì…ë ¥ (ì¬ì¡°ì • ìš”ì²­)
 */
export interface AdjustmentInput {
  plan_content_id: string; // plan_contents í…Œì´ë¸”ì˜ ID
  change_type: 'range' | 'replace' | 'full';
  before: ContentSnapshot;
  after: ContentSnapshot;
}
// Note: GeneratedPlanResultì™€ ScheduleEngineInput íƒ€ì…ì€
// generatePlans í•¨ìˆ˜ ì œê±°ì™€ í•¨ê»˜ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.
// í”Œëœ ìƒì„±ì€ reschedule.tsì—ì„œ generatePlansFromGroupì„ ì§ì ‘ í˜¸ì¶œí•©ë‹ˆë‹¤.

// ============================================
// ìŠ¤ì¼€ì¤„ ì—”ì§„ í•¨ìˆ˜
// ============================================

/**
 * ì¡°ì •ëœ ì½˜í…ì¸  ëª©ë¡ ìƒì„±
 * 
 * adjustmentsë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê¸°ì¡´ contentsë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * 
 * @param contents ê¸°ì¡´ ì½˜í…ì¸  ëª©ë¡
 * @param adjustments ì¡°ì • ìš”ì²­ ëª©ë¡
 * @returns ì¡°ì •ëœ ì½˜í…ì¸  ëª©ë¡
 */
export function applyAdjustments(
  contents: PlanContent[],
  adjustments: AdjustmentInput[]
): PlanContent[] {
  const adjustmentMap = new Map<string, AdjustmentInput>();
  adjustments.forEach((adj) => {
    adjustmentMap.set(adj.plan_content_id, adj);
  });

  return contents.map((content) => {
    const adjustment = adjustmentMap.get(content.id || '');
    if (!adjustment) {
      // ì¡°ì •ë˜ì§€ ì•Šì€ ì½˜í…ì¸ ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
      return content;
    }

    // ì¡°ì • ì ìš©
    switch (adjustment.change_type) {
      case 'range':
        // ë²”ìœ„ë§Œ ìˆ˜ì •
        return {
          ...content,
          start_range: adjustment.after.range.start,
          end_range: adjustment.after.range.end,
        };
      case 'replace':
        // ì½˜í…ì¸  êµì²´
        return {
          ...content,
          content_id: adjustment.after.content_id,
          content_type: adjustment.after.content_type,
          start_range: adjustment.after.range.start,
          end_range: adjustment.after.range.end,
        };
      case 'full':
        // ì „ì²´ ì¬ìƒì„± (ë²”ìœ„ì™€ ì½˜í…ì¸  ëª¨ë‘ ë³€ê²½)
        return {
          ...content,
          content_id: adjustment.after.content_id,
          content_type: adjustment.after.content_type,
          start_range: adjustment.after.range.start,
          end_range: adjustment.after.range.end,
        };
      default:
        return content;
    }
  });
}

// ============================================
// í”Œëœ ìƒì„± í•¨ìˆ˜
// ============================================
// Note: í”Œëœ ìƒì„± ë¡œì§ì€ reschedule.tsì—ì„œ ì§ì ‘ generatePlansFromGroupì„ í˜¸ì¶œí•©ë‹ˆë‹¤.
// ì´ ëª¨ë“ˆì€ ì¡°ì •(adjustments) ì ìš©ê³¼ ìš”ì•½ ìƒì„±ë§Œ ë‹´ë‹¹í•©ë‹ˆë‹¤.

/**
 * ì¡°ì • ìš”ì•½ ìƒì„±
 * 
 * adjustmentsë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë³€ê²½ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * @param adjustments ì¡°ì • ìš”ì²­ ëª©ë¡
 * @returns ì¡°ì • ìš”ì•½
 */
export function generateAdjustmentSummary(adjustments: AdjustmentInput[]): {
  range_changes: number;
  replacements: number;
  full_regenerations: number;
} {
  const summary = {
    range_changes: 0,
    replacements: 0,
    full_regenerations: 0,
  };

  adjustments.forEach((adj) => {
    switch (adj.change_type) {
      case 'range':
        summary.range_changes++;
        break;
      case 'replace':
        summary.replacements++;
        break;
      case 'full':
        summary.full_regenerations++;
        break;
    }
  });

  return summary;
}
</file>

<file path="transaction.ts">
/**
 * ì¬ì¡°ì • íŠ¸ëœì­ì…˜ ë˜í¼ í•¨ìˆ˜
 * 
 * ì¬ì¡°ì • ì‘ì—…ì„ ì•ˆì „í•˜ê²Œ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ê°ì‹¸ì„œ ì‹¤í–‰í•©ë‹ˆë‹¤.
 * ë™ì‹œì„± ì œì–´ ë° ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/transaction
 */

import { createSupabaseServerClient } from '@/lib/supabase/server';
import { acquirePlanGroupLock } from '@/lib/utils/planGroupLock';
import type { SupabaseClient } from '@supabase/supabase-js';

// ============================================
// íŠ¸ëœì­ì…˜ ë˜í¼ íƒ€ì…
// ============================================

/**
 * íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì‹¤í–‰í•  í•¨ìˆ˜ íƒ€ì…
 */
export type TransactionOperation<T> = (
  supabase: SupabaseClient
) => Promise<T>;

// ============================================
// íŠ¸ëœì­ì…˜ ì‹¤í–‰
// ============================================

/**
 * ì¬ì¡°ì • íŠ¸ëœì­ì…˜ ì‹¤í–‰
 * 
 * í”Œëœ ê·¸ë£¹ ë‹¨ìœ„ë¡œ ë½ì„ íšë“í•œ í›„ ì‘ì—…ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
 * ì—ëŸ¬ ë°œìƒ ì‹œ ìë™ìœ¼ë¡œ ë¡¤ë°±ë©ë‹ˆë‹¤.
 * 
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 * @param operation íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì‹¤í–‰í•  ì‘ì—…
 * @returns ì‘ì—… ê²°ê³¼
 * 
 * @throws {Error} ì‘ì—… ì‹¤íŒ¨ ì‹œ
 */
export async function executeRescheduleTransaction<T>(
  groupId: string,
  operation: TransactionOperation<T>
): Promise<T> {
  const supabase = await createSupabaseServerClient();
  
  try {
    // 1. í”Œëœ ê·¸ë£¹ ë½ íšë“ (ë™ì‹œì„± ì œì–´)
    const lockAcquired = await acquirePlanGroupLock(supabase, groupId);
    if (!lockAcquired) {
      throw new Error(
        `í”Œëœ ê·¸ë£¹ ${groupId}ì— ëŒ€í•œ ì¬ì¡°ì •ì´ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.`
      );
    }
    
    // 2. íŠ¸ëœì­ì…˜ ì‹œì‘ (SupabaseëŠ” ìë™ìœ¼ë¡œ íŠ¸ëœì­ì…˜ ê´€ë¦¬)
    // ì‹¤ì œë¡œëŠ” ê° ì¿¼ë¦¬ê°€ ìë™ìœ¼ë¡œ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë¬¶ì´ì§€ë§Œ,
    // ëª…ì‹œì ìœ¼ë¡œ BEGIN/COMMITì„ ì‚¬ìš©í•˜ë ¤ë©´ RPC í•¨ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
    
    // 3. ì‘ì—… ì‹¤í–‰
    const result = await operation(supabase);
    
    // 4. ì„±ê³µ ì‹œ ìë™ ì»¤ë°‹ (Supabase í´ë¼ì´ì–¸íŠ¸ëŠ” ìë™ ì»¤ë°‹)
    return result;
  } catch (error) {
    // ì—ëŸ¬ ë°œìƒ ì‹œ ìë™ ë¡¤ë°± (Supabase í´ë¼ì´ì–¸íŠ¸ëŠ” ìë™ ë¡¤ë°±)
    console.error('[reschedule/transaction] íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * ì¬ì¡°ì • íŠ¸ëœì­ì…˜ ì‹¤í–‰ (ì¬ì‹œë„ í¬í•¨)
 * 
 * ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“± ì¼ì‹œì  ì˜¤ë¥˜ì— ëŒ€í•´ ì¬ì‹œë„ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
 * 
 * @param groupId í”Œëœ ê·¸ë£¹ ID
 * @param operation íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì‹¤í–‰í•  ì‘ì—…
 * @param maxRetries ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ (ê¸°ë³¸: 3)
 * @returns ì‘ì—… ê²°ê³¼
 */
export async function executeRescheduleTransactionWithRetry<T>(
  groupId: string,
  operation: TransactionOperation<T>,
  maxRetries: number = 3
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await executeRescheduleTransaction(groupId, operation);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      // ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬ì¸ì§€ í™•ì¸
      const isRetryable = isRetryableError(lastError);
      
      if (!isRetryable || attempt === maxRetries) {
        throw lastError;
      }
      
      // ì¬ì‹œë„ ì „ ëŒ€ê¸° (ì§€ìˆ˜ ë°±ì˜¤í”„)
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
      await new Promise((resolve) => setTimeout(resolve, delay));
      
      console.warn(
        `[reschedule/transaction] ì¬ì‹œë„ ${attempt}/${maxRetries} (${delay}ms ëŒ€ê¸°)`
      );
    }
  }
  
  throw lastError || new Error('Unknown error');
}

/**
 * ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬ì¸ì§€ í™•ì¸
 * 
 * @param error ì—ëŸ¬ ê°ì²´
 * @returns ì¬ì‹œë„ ê°€ëŠ¥ ì—¬ë¶€
 */
function isRetryableError(error: Error): boolean {
  // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜, íƒ€ì„ì•„ì›ƒ, ì¼ì‹œì  DB ì˜¤ë¥˜ ë“±
  const retryableMessages = [
    'network',
    'timeout',
    'connection',
    'ECONNRESET',
    'ETIMEDOUT',
    'deadlock',
    'lock',
  ];
  
  const errorMessage = error.message.toLowerCase();
  return retryableMessages.some((msg) => errorMessage.includes(msg));
}
</file>

<file path="uncompletedRangeCalculator.test.ts">
/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚°ê¸° ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
 * 
 * @module lib/reschedule/uncompletedRangeCalculator.test
 */

import { describe, it, expect } from 'vitest';
import {
  calculateUncompletedRange,
  calculateUncompletedRangeBounds,
  applyUncompletedRangeToContents,
  type UncompletedPlanData,
  type UncompletedRangeBounds,
} from './uncompletedRangeCalculator';

describe('calculateUncompletedRange', () => {
  it('ë¹ˆ í”Œëœ ëª©ë¡ì—ì„œ ë¹ˆ Map ë°˜í™˜', () => {
    const result = calculateUncompletedRange([]);
    expect(result.size).toBe(0);
  });

  it('ì™„ë£Œëœ í”Œëœì€ ë¯¸ì§„í–‰ ë²”ìœ„ 0', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 19 },
    ];
    const result = calculateUncompletedRange(plans);
    expect(result.get('c1')).toBe(0);
  });

  it('ë¯¸ì™„ë£Œ í”Œëœì˜ ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚°', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 10 },
    ];
    const result = calculateUncompletedRange(plans);
    // ê³„íš: 1-20 (19í˜ì´ì§€), ì™„ë£Œ: 10, ë¯¸ì§„í–‰: 9
    expect(result.get('c1')).toBe(9);
  });

  it('ì—¬ëŸ¬ í”Œëœì˜ ë¯¸ì§„í–‰ ë²”ìœ„ í•©ì‚°', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 10 }, // ë¯¸ì§„í–‰: 9
      { content_id: 'c1', planned_start_page_or_time: 21, planned_end_page_or_time: 40, completed_amount: 0 }, // ë¯¸ì§„í–‰: 19
    ];
    const result = calculateUncompletedRange(plans);
    expect(result.get('c1')).toBe(28); // 9 + 19
  });

  it('ë‹¤ë¥¸ ì½˜í…ì¸ ëŠ” ë³„ë„ë¡œ ê³„ì‚°', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 10, completed_amount: 0 }, // ë¯¸ì§„í–‰: 9
      { content_id: 'c2', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 5 }, // ë¯¸ì§„í–‰: 14
    ];
    const result = calculateUncompletedRange(plans);
    expect(result.get('c1')).toBe(9);
    expect(result.get('c2')).toBe(14);
  });

  it('ì´ˆê³¼ ì™„ë£Œëœ ê²½ìš° ë¯¸ì§„í–‰ 0 (ìŒìˆ˜ ë°©ì§€)', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 30 },
    ];
    const result = calculateUncompletedRange(plans);
    expect(result.get('c1')).toBe(0);
  });

  it('null ê°’ ì²˜ë¦¬', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: null, planned_end_page_or_time: null, completed_amount: null },
    ];
    const result = calculateUncompletedRange(plans);
    expect(result.get('c1')).toBe(0);
  });
});

describe('calculateUncompletedRangeBounds', () => {
  it('ë¹ˆ í”Œëœ ëª©ë¡ì—ì„œ ë¹ˆ Map ë°˜í™˜', () => {
    const result = calculateUncompletedRangeBounds([]);
    expect(result.size).toBe(0);
  });

  it('ë‹¨ì¼ ë¯¸ì§„í–‰ í”Œëœì˜ ë²”ìœ„ ê³„ì‚°', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 11, planned_end_page_or_time: 20, completed_amount: 0 },
    ];
    const result = calculateUncompletedRangeBounds(plans);
    const bounds = result.get('c1');
    expect(bounds).toBeDefined();
    expect(bounds?.startRange).toBe(11);
    expect(bounds?.endRange).toBe(20);
    expect(bounds?.totalUncompleted).toBe(9);
  });

  it('ë¶€ë¶„ ì™„ë£Œëœ í”Œëœì˜ ì‹œì‘ì  ì¡°ì •', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 11, planned_end_page_or_time: 20, completed_amount: 5 },
    ];
    const result = calculateUncompletedRangeBounds(plans);
    const bounds = result.get('c1');
    expect(bounds).toBeDefined();
    // ì‹œì‘ì : 11 + 5 = 16 (ì™„ë£Œëœ ë§Œí¼ ì´ë™)
    expect(bounds?.startRange).toBe(16);
    expect(bounds?.endRange).toBe(20);
    expect(bounds?.totalUncompleted).toBe(4);
  });

  it('ì—¬ëŸ¬ í”Œëœì˜ ë²”ìœ„ ë³‘í•© (min/max)', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 11, planned_end_page_or_time: 15, completed_amount: 0 },
      { content_id: 'c1', planned_start_page_or_time: 16, planned_end_page_or_time: 20, completed_amount: 2 },
      { content_id: 'c1', planned_start_page_or_time: 21, planned_end_page_or_time: 30, completed_amount: 0 },
    ];
    const result = calculateUncompletedRangeBounds(plans);
    const bounds = result.get('c1');
    expect(bounds).toBeDefined();
    expect(bounds?.startRange).toBe(11); // ìµœì†Œ ì‹œì‘ì 
    expect(bounds?.endRange).toBe(30); // ìµœëŒ€ ì¢…ë£Œì 
    expect(bounds?.totalUncompleted).toBe(4 + 2 + 9); // í•©ê³„
  });

  it('ì™„ë£Œëœ í”Œëœë§Œ ìˆìœ¼ë©´ ê²°ê³¼ ì—†ìŒ', () => {
    const plans: UncompletedPlanData[] = [
      { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 10, completed_amount: 9 },
    ];
    const result = calculateUncompletedRangeBounds(plans);
    expect(result.has('c1')).toBe(false);
  });
});

describe('applyUncompletedRangeToContents', () => {
  it('ë¯¸ì§„í–‰ ë²”ìœ„ê°€ ì—†ìœ¼ë©´ ì›ë³¸ ìœ ì§€', () => {
    const contents = [{ content_id: 'c1', start_range: 1, end_range: 100 }];
    const boundsMap = new Map<string, UncompletedRangeBounds>();
    
    const result = applyUncompletedRangeToContents(contents, boundsMap);
    
    expect(result[0].start_range).toBe(1);
    expect(result[0].end_range).toBe(100);
  });

  it('ë¯¸ì§„í–‰ ì‹œì‘ì ìœ¼ë¡œ start_range ì¡°ì •', () => {
    const contents = [{ content_id: 'c1', start_range: 1, end_range: 100 }];
    const boundsMap = new Map<string, UncompletedRangeBounds>([
      ['c1', { startRange: 21, endRange: 50, totalUncompleted: 30 }],
    ]);
    
    const result = applyUncompletedRangeToContents(contents, boundsMap);
    
    // start_rangeëŠ” ë¯¸ì§„í–‰ ì‹œì‘ì ìœ¼ë¡œ ì¡°ì •
    expect(result[0].start_range).toBe(21);
    // end_rangeëŠ” ì›ë˜ ê°’ ìœ ì§€ (ìˆ˜ì •ëœ ë¡œì§)
    expect(result[0].end_range).toBe(100);
  });

  it('ì›ë³¸ ì‹œì‘ì ë³´ë‹¤ ë¯¸ì§„í–‰ ì‹œì‘ì ì´ ì‘ìœ¼ë©´ ì›ë³¸ ì‹œì‘ì  ìœ ì§€', () => {
    const contents = [{ content_id: 'c1', start_range: 30, end_range: 100 }];
    const boundsMap = new Map<string, UncompletedRangeBounds>([
      ['c1', { startRange: 10, endRange: 50, totalUncompleted: 40 }],
    ]);
    
    const result = applyUncompletedRangeToContents(contents, boundsMap);
    
    // ì›ë³¸ ì‹œì‘ì ì´ ë” í¬ë¯€ë¡œ ìœ ì§€
    expect(result[0].start_range).toBe(30);
    expect(result[0].end_range).toBe(100);
  });

  it('selectedContentIdsë¡œ í•„í„°ë§', () => {
    const contents = [
      { content_id: 'c1', start_range: 1, end_range: 100 },
      { content_id: 'c2', start_range: 1, end_range: 50 },
    ];
    const boundsMap = new Map<string, UncompletedRangeBounds>([
      ['c1', { startRange: 21, endRange: 50, totalUncompleted: 30 }],
      ['c2', { startRange: 11, endRange: 30, totalUncompleted: 20 }],
    ]);
    const selectedContentIds = new Set(['c1']);
    
    const result = applyUncompletedRangeToContents(contents, boundsMap, selectedContentIds);
    
    // c1ì€ ì¡°ì •ë¨
    expect(result[0].start_range).toBe(21);
    // c2ëŠ” ì„ íƒë˜ì§€ ì•Šì•„ ì›ë³¸ ìœ ì§€
    expect(result[1].start_range).toBe(1);
  });

  it('ì¡°ì • ê²°ê³¼ê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì›ë³¸ ìœ ì§€', () => {
    const contents = [{ content_id: 'c1', start_range: 1, end_range: 10 }];
    const boundsMap = new Map<string, UncompletedRangeBounds>([
      // ì‹œì‘ì ì´ ëì ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ê²½ìš°
      ['c1', { startRange: 20, endRange: 5, totalUncompleted: 0 }],
    ]);
    
    const result = applyUncompletedRangeToContents(contents, boundsMap);
    
    // ë¯¸ì§„í–‰ ë²”ìœ„ê°€ 0ì´ë©´ ì›ë³¸ ìœ ì§€
    expect(result[0].start_range).toBe(1);
    expect(result[0].end_range).toBe(10);
  });

  it('id í•„ë“œë¡œë„ ë§¤ì¹­ ê°€ëŠ¥', () => {
    const contents = [{ id: 'c1', start_range: 1, end_range: 100 }];
    const boundsMap = new Map<string, UncompletedRangeBounds>([
      ['c1', { startRange: 21, endRange: 50, totalUncompleted: 30 }],
    ]);
    
    const result = applyUncompletedRangeToContents(contents, boundsMap);
    
    expect(result[0].start_range).toBe(21);
    expect(result[0].end_range).toBe(100);
  });
});
</file>

<file path="uncompletedRangeCalculator.ts">
/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚°ê¸°
 * 
 * ì˜¤ëŠ˜ ì´ì „ì˜ ë¯¸ì§„í–‰ í”Œëœ ë²”ìœ„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
 * ì¬ì¡°ì • ì‹œ ë¯¸ì™„ë£Œëœ í•™ìŠµëŸ‰ì„ í–¥í›„ ì¼ì •ì— ì¬ë¶„ë°°í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.
 * 
 * @module lib/reschedule/uncompletedRangeCalculator
 */

// ============================================
// íƒ€ì… ì •ì˜
// ============================================

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚°ì„ ìœ„í•œ í”Œëœ ë°ì´í„°
 */
export interface UncompletedPlanData {
  content_id: string;
  planned_start_page_or_time: number | null;
  planned_end_page_or_time: number | null;
  completed_amount: number | null;
}

/**
 * ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ ê²°ê³¼
 */
export interface UncompletedRangeResult {
  contentId: string;
  uncompletedRange: number;
  totalPlanned: number;
  totalCompleted: number;
}

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ì‹œì‘ì ê³¼ ì¢…ë£Œì  ì •ë³´
 */
export interface UncompletedRangeBounds {
  startRange: number;
  endRange: number;
  totalUncompleted: number;
}

// ============================================
// ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚° í•¨ìˆ˜
// ============================================

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚°
 * 
 * ì˜¤ëŠ˜ ì´ì „ì˜ ë¯¸ì§„í–‰ í”Œëœ ë²”ìœ„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
 * ê° í”Œëœë³„ ë¯¸ì§„í–‰ ë²”ìœ„ë¥¼ ê³„ì‚°í•˜ê³  ì½˜í…ì¸ ë³„ë¡œ í•©ì‚°í•©ë‹ˆë‹¤.
 * 
 * @param plans ì˜¤ëŠ˜ ì´ì „ì˜ í”Œëœ ëª©ë¡ (pending, in_progress ìƒíƒœ)
 * @returns ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ Map (content_id -> uncompleted_range)
 * 
 * @example
 * ```ts
 * const plans = [
 *   { content_id: 'c1', planned_start_page_or_time: 1, planned_end_page_or_time: 20, completed_amount: 10 },
 *   { content_id: 'c1', planned_start_page_or_time: 21, planned_end_page_or_time: 40, completed_amount: null },
 * ];
 * const result = calculateUncompletedRange(plans);
 * // Map { 'c1' => 30 } (10 + 20 = 30 ë¯¸ì§„í–‰)
 * ```
 */
export function calculateUncompletedRange(
  plans: UncompletedPlanData[]
): Map<string, number> {
  const uncompletedRangeMap = new Map<string, number>();

  for (const plan of plans) {
    if (!plan.content_id) continue;

    // ê³„íšëœ ë²”ìœ„ ê³„ì‚°
    const plannedStart = plan.planned_start_page_or_time ?? 0;
    const plannedEnd = plan.planned_end_page_or_time ?? 0;
    const plannedAmount = Math.max(0, plannedEnd - plannedStart);

    // ì™„ë£Œëœ ì–‘
    const completedAmount = plan.completed_amount ?? 0;

    // ë¯¸ì§„í–‰ ë²”ìœ„ ê³„ì‚° (ìŒìˆ˜ ë°©ì§€)
    const uncompletedAmount = Math.max(0, plannedAmount - completedAmount);

    // ì½˜í…ì¸ ë³„ í•©ì‚°
    const currentTotal = uncompletedRangeMap.get(plan.content_id) ?? 0;
    uncompletedRangeMap.set(plan.content_id, currentTotal + uncompletedAmount);
  }

  return uncompletedRangeMap;
}

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ ìƒì„¸ ì •ë³´ ê³„ì‚°
 * 
 * ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ì™€ í•¨ê»˜ ìƒì„¸ í†µê³„ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * 
 * @param plans ì˜¤ëŠ˜ ì´ì „ì˜ í”Œëœ ëª©ë¡
 * @returns ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ ìƒì„¸ ê²°ê³¼ ë°°ì—´
 */
export function calculateUncompletedRangeDetails(
  plans: UncompletedPlanData[]
): UncompletedRangeResult[] {
  const statsMap = new Map<string, {
    uncompletedRange: number;
    totalPlanned: number;
    totalCompleted: number;
  }>();

  for (const plan of plans) {
    if (!plan.content_id) continue;

    const plannedStart = plan.planned_start_page_or_time ?? 0;
    const plannedEnd = plan.planned_end_page_or_time ?? 0;
    const plannedAmount = Math.max(0, plannedEnd - plannedStart);
    const completedAmount = plan.completed_amount ?? 0;
    const uncompletedAmount = Math.max(0, plannedAmount - completedAmount);

    const current = statsMap.get(plan.content_id) ?? {
      uncompletedRange: 0,
      totalPlanned: 0,
      totalCompleted: 0,
    };

    statsMap.set(plan.content_id, {
      uncompletedRange: current.uncompletedRange + uncompletedAmount,
      totalPlanned: current.totalPlanned + plannedAmount,
      totalCompleted: current.totalCompleted + completedAmount,
    });
  }

  return Array.from(statsMap.entries()).map(([contentId, stats]) => ({
    contentId,
    ...stats,
  }));
}

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ì‹œì‘ì ê³¼ ì¢…ë£Œì  ê³„ì‚°
 * 
 * ì˜¤ëŠ˜ ì´ì „ì˜ ë¯¸ì§„í–‰ í”Œëœ ë²”ìœ„ë¥¼ ê³„ì‚°í•˜ì—¬ ì½˜í…ì¸ ë³„ë¡œ ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ì‹¤ì œ ì‹œì‘ì ê³¼ ì¢…ë£Œì ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 * ë¶€ë¶„ ì™„ë£Œëœ í”Œëœë„ ê³ ë ¤í•˜ì—¬ ì •í™•í•œ ë¯¸ì§„í–‰ ë²”ìœ„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
 * 
 * @param plans ì˜¤ëŠ˜ ì´ì „ì˜ í”Œëœ ëª©ë¡ (pending, in_progress ìƒíƒœ)
 * @returns ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ Bounds Map (content_id -> UncompletedRangeBounds)
 * 
 * @example
 * ```ts
 * const plans = [
 *   { content_id: 'c1', planned_start_page_or_time: 11, planned_end_page_or_time: 15, completed_amount: 0 },
 *   { content_id: 'c1', planned_start_page_or_time: 16, planned_end_page_or_time: 20, completed_amount: 5 },
 *   { content_id: 'c1', planned_start_page_or_time: 21, planned_end_page_or_time: 25, completed_amount: 2 },
 * ];
 * const result = calculateUncompletedRangeBounds(plans);
 * // Map {
 * //   'c1' => {
 * //     startRange: 11,  // ìµœì†Œ ì‹œì‘ì 
 * //     endRange: 25,    // ìµœëŒ€ ì¢…ë£Œì 
 * //     totalUncompleted: 10  // ì´ ë¯¸ì§„í–‰ ë²”ìœ„ (4 + 4 + 2)
 * //   }
 * // }
 * ```
 */
export function calculateUncompletedRangeBounds(
  plans: UncompletedPlanData[]
): Map<string, UncompletedRangeBounds> {
  const boundsMap = new Map<string, UncompletedRangeBounds>();

  // ì½˜í…ì¸ ë³„ë¡œ ê·¸ë£¹í™”
  const plansByContent = new Map<string, UncompletedPlanData[]>();
  for (const plan of plans) {
    if (!plan.content_id) continue;
    
    if (!plansByContent.has(plan.content_id)) {
      plansByContent.set(plan.content_id, []);
    }
    plansByContent.get(plan.content_id)!.push(plan);
  }

  // ê° ì½˜í…ì¸ ë³„ë¡œ ë²”ìœ„ ê³„ì‚°
  for (const [contentId, contentPlans] of plansByContent.entries()) {
    let minStartRange = Infinity;
    let maxEndRange = -Infinity;
    let totalUncompleted = 0;

    for (const plan of contentPlans) {
      const plannedStart = plan.planned_start_page_or_time ?? 0;
      const plannedEnd = plan.planned_end_page_or_time ?? 0;
      const plannedAmount = Math.max(0, plannedEnd - plannedStart);
      const completedAmount = plan.completed_amount ?? 0;
      const uncompletedAmount = Math.max(0, plannedAmount - completedAmount);

      // ë¯¸ì§„í–‰ ë²”ìœ„ê°€ ìˆëŠ” ê²½ìš°ë§Œ ì²˜ë¦¬
      if (uncompletedAmount > 0) {
        // ë¶€ë¶„ ì™„ë£Œëœ ê²½ìš°, ì‹¤ì œ ë¯¸ì§„í–‰ ì‹œì‘ì  ê³„ì‚°
        const actualStartRange = plannedStart + completedAmount;
        const actualEndRange = plannedEnd;

        minStartRange = Math.min(minStartRange, actualStartRange);
        maxEndRange = Math.max(maxEndRange, actualEndRange);
        totalUncompleted += uncompletedAmount;
      }
    }

    // ìœ íš¨í•œ ë²”ìœ„ê°€ ìˆëŠ” ê²½ìš°ë§Œ ì¶”ê°€
    if (minStartRange !== Infinity && maxEndRange !== -Infinity && totalUncompleted > 0) {
      boundsMap.set(contentId, {
        startRange: minStartRange,
        endRange: maxEndRange,
        totalUncompleted,
      });
    }
  }

  return boundsMap;
}

/**
 * ë¯¸ì§„í–‰ ë²”ìœ„ë¥¼ ì½˜í…ì¸ ì— ì ìš©
 * 
 * ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ì‹œì‘ì ì„ ì‚¬ìš©í•˜ì—¬ ì½˜í…ì¸ ì˜ start_rangeë¥¼ ì¡°ì •í•©ë‹ˆë‹¤.
 * ì¬ì¡°ì • ì‹œ ì™„ë£Œëœ ë¶€ë¶„ì€ ê±´ë„ˆë›°ê³ , ë¯¸ì§„í–‰ëœ ë¶€ë¶„ë¶€í„° í•™ìŠµì„ ì¬ê°œí•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 * 
 * **ì¤‘ìš”**: end_rangeëŠ” ì›ë˜ ê°’ì„ ìœ ì§€í•©ë‹ˆë‹¤. ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ëì ìœ¼ë¡œ ì œí•œí•˜ë©´
 * ì•„ì§ ë°°ì •ë˜ì§€ ì•Šì€ ë‚˜ë¨¸ì§€ ë²”ìœ„ê°€ ëˆ„ë½ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
 * 
 * @param contents ì½˜í…ì¸  ëª©ë¡
 * @param uncompletedBoundsMap ì½˜í…ì¸ ë³„ ë¯¸ì§„í–‰ ë²”ìœ„ Bounds Map
 * @param selectedContentIds ì„ íƒëœ ì½˜í…ì¸  ID Set (ì„ íƒ, ì§€ì • ì‹œ í•´ë‹¹ ì½˜í…ì¸ ë§Œ ì²˜ë¦¬)
 * @returns ë¯¸ì§„í–‰ ë²”ìœ„ê°€ ì ìš©ëœ ì½˜í…ì¸  ëª©ë¡
 * 
 * @example
 * ```ts
 * // ì˜ˆì‹œ: 1-100 í˜ì´ì§€ ì¤‘ 1-10ê¹Œì§€ ì™„ë£Œ, 11-30ê¹Œì§€ ë¯¸ì§„í–‰ í”Œëœ ì¡´ì¬
 * const contents = [
 *   { content_id: 'c1', start_range: 1, end_range: 100 }
 * ];
 * const boundsMap = new Map([
 *   ['c1', { startRange: 11, endRange: 30, totalUncompleted: 20 }]
 * ]);
 * const result = applyUncompletedRangeToContents(contents, boundsMap);
 * // [{ content_id: 'c1', start_range: 11, end_range: 100 }]
 * // ê²°ê³¼: 11í˜ì´ì§€ë¶€í„° 100í˜ì´ì§€ê¹Œì§€ ì¬ë°°ì • (ì™„ë£Œëœ 1-10ì€ ì œì™¸)
 * ```
 */
export function applyUncompletedRangeToContents<T extends {
  id?: string;
  content_id?: string;
  start_range?: number | null;
  end_range?: number | null;
}>(
  contents: T[],
  uncompletedBoundsMap: Map<string, UncompletedRangeBounds>,
  selectedContentIds?: Set<string>
): T[] {
  return contents.map(content => {
    // content_id ë˜ëŠ” idë¡œ ë§¤ì¹­
    const contentId = content.content_id || content.id;
    if (!contentId) return content;

    // ì„ íƒëœ ì½˜í…ì¸ ë§Œ ì²˜ë¦¬ (selectedContentIdsê°€ ì£¼ì–´ì§„ ê²½ìš°)
    if (selectedContentIds && selectedContentIds.size > 0 && !selectedContentIds.has(contentId)) {
      return content;
    }

    const bounds = uncompletedBoundsMap.get(contentId);
    if (!bounds || bounds.totalUncompleted <= 0) return content;

    // ì›ë˜ ë²”ìœ„ ê°€ì ¸ì˜¤ê¸°
    const originalStartRange = content.start_range ?? 0;
    const originalEndRange = content.end_range ?? 0;

    // ì‹œì‘ì  ì¡°ì •: ë¯¸ì§„í–‰ ì‹œì‘ì ë¶€í„° ì‹œì‘
    // ì›ë˜ ì‹œì‘ì ê³¼ ë¯¸ì§„í–‰ ì‹œì‘ì  ì¤‘ í° ê°’ ì‚¬ìš© (ì™„ë£Œëœ ë¶€ë¶„ ê±´ë„ˆë›°ê¸°)
    const adjustedStartRange = Math.max(originalStartRange, bounds.startRange);
    
    // ì¢…ë£Œì : ì›ë˜ ì¢…ë£Œì  ìœ ì§€ (ë‚˜ë¨¸ì§€ ë²”ìœ„ë„ ì¬ë°°ì • ëŒ€ìƒì— í¬í•¨)
    // ë¯¸ì§„í–‰ ë²”ìœ„ì˜ ëì ìœ¼ë¡œ ì œí•œí•˜ì§€ ì•ŠìŒ
    const adjustedEndRange = originalEndRange;

    // ì¡°ì •ëœ ë²”ìœ„ê°€ ìœ íš¨í•œì§€ í™•ì¸
    if (adjustedStartRange >= adjustedEndRange) {
      // ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš° ì›ë³¸ ë°˜í™˜
      return content;
    }

    return {
      ...content,
      start_range: adjustedStartRange,
      end_range: adjustedEndRange,
    };
  });
}
</file>

</files>
