# 학생 연결 코드 시스템 문제점 검토

## 검토 일자
2025-12-19

## 검토 범위
- PostgreSQL 함수 `link_student_with_connection_code`
- `app/actions/auth.ts`의 `linkStudentWithConnectionCode` 함수
- 에러 처리 및 보안 고려사항

---

## 🔴 심각한 문제점

### 1. 함수 호출 권한 문제

**위치**: `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:222`

**문제점**:
```sql
GRANT EXECUTE ON FUNCTION link_student_with_connection_code(uuid, text) TO authenticated;
```

- `authenticated` 사용자 모두가 함수를 호출할 수 있음
- 클라이언트 사이드에서 직접 호출 가능 (보안 취약점)
- `SECURITY DEFINER`로 실행되므로 RLS 정책을 우회하여 모든 데이터 접근 가능

**영향**:
- 악의적인 사용자가 다른 학생의 연결 코드를 사용하여 계정을 탈취할 수 있음
- 임의의 사용자 ID로 학생 레코드를 생성할 수 있음

**권장 해결책**:
- 함수 호출 권한을 `service_role` 또는 특정 역할로만 제한
- 또는 함수 내부에서 추가 권한 검증 로직 추가

---

## ⚠️ 중간 수준 문제점

### 2. 동시성 문제 (Race Condition)

**위치**: `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:24-55, 176-180`

**문제점**:
```sql
-- 1. 코드 조회 및 검증 (24-55줄)
SELECT ... INTO v_code_record
FROM student_connection_codes
WHERE connection_code = p_connection_code;

-- 8. 코드 업데이트 (176-180줄)
UPDATE student_connection_codes
SET used_at = now()
WHERE connection_code = p_connection_code
  AND used_at IS NULL;
```

- 두 사용자가 동시에 같은 연결 코드를 사용하려고 할 때:
  1. 사용자 A가 코드 조회 (used_at IS NULL 확인)
  2. 사용자 B가 코드 조회 (used_at IS NULL 확인)
  3. 사용자 A가 코드 업데이트
  4. 사용자 B도 코드 업데이트 시도 (이미 사용됨)
- 트랜잭션 격리 수준에 따라 중복 사용 가능성

**영향**:
- 같은 연결 코드가 두 번 사용될 수 있음
- 데이터 무결성 문제

**권장 해결책**:
- `SELECT FOR UPDATE`를 사용하여 행 잠금
- 또는 `UPDATE ... WHERE used_at IS NULL RETURNING` 패턴 사용

### 3. 에러 메시지에 민감한 정보 노출 가능성

**위치**: `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:204-208`

**문제점**:
```sql
WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', '학생 계정 연결 중 오류가 발생했습니다: ' || SQLERRM
  );
```

- `SQLERRM`에 데이터베이스 내부 정보가 포함될 수 있음
- 테이블명, 컬럼명, 제약조건명 등이 노출될 수 있음

**영향**:
- 데이터베이스 구조 정보 유출
- 보안 취약점 노출

**권장 해결책**:
- 일반적인 에러 메시지만 반환
- 상세 에러는 로그에만 기록

### 4. NULL 값 처리 불완전

**위치**: `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:82-110`

**문제점**:
```sql
INSERT INTO students (
  ...
  is_active
) VALUES (
  ...
  COALESCE(v_existing_student.is_active, true)
);
```

- `is_active`만 `COALESCE` 처리
- 다른 필드들(`name`, `grade`, `class` 등)도 NULL일 수 있음
- NOT NULL 제약조건이 있는 필드에 NULL이 들어가면 에러 발생

**영향**:
- 필수 필드가 NULL인 경우 함수 실행 실패
- 데이터 무결성 문제

**권장 해결책**:
- 모든 필수 필드에 대한 NULL 체크 및 기본값 설정
- 또는 함수 시작 부분에서 필수 필드 검증

---

## 💡 개선 권장사항

### 5. 프로필/진로 정보 조회 로직

**위치**: `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:71-79`

**현재 구현**:
```sql
SELECT * INTO v_profile
FROM student_profiles
WHERE id = v_student_id;

IF v_profile IS NOT NULL THEN
  -- 프로필 정보 재생성
END IF;
```

**검토 결과**:
- ✅ 올바른 구현: `SELECT INTO`는 레코드가 없으면 변수를 NULL로 설정
- ✅ `IS NOT NULL` 체크로 존재 여부 확인
- ⚠️ 다만 `FOUND` 플래그를 사용하는 것이 더 명시적일 수 있음

**권장 개선**:
```sql
SELECT * INTO STRICT v_profile
FROM student_profiles
WHERE id = v_student_id;
-- STRICT를 사용하면 레코드가 없을 때 자동으로 에러 발생
```

또는

```sql
SELECT * INTO v_profile
FROM student_profiles
WHERE id = v_student_id;

IF FOUND THEN
  -- 프로필 정보 재생성
END IF;
```

### 6. 연결 코드 검증 중복

**위치**: 
- `lib/utils/connectionCodeUtils.ts:15-60` (클라이언트 사이드 검증)
- `supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql:24-55` (서버 사이드 검증)

**현재 구현**:
- 클라이언트 사이드에서 `validateConnectionCode` 호출
- 서버 사이드에서도 PostgreSQL 함수 내부에서 검증

**검토 결과**:
- ✅ 중복이지만 보안상 좋음: 클라이언트 검증은 UX 개선, 서버 검증은 보안
- ✅ PostgreSQL 함수 내부 검증이 더 안전 (트랜잭션 내에서)

**권장 개선**:
- 현재 구조 유지 (보안을 위해 서버 사이드 검증 필수)

### 7. 에러 처리 일관성

**위치**: `app/actions/auth.ts:251-298`

**현재 구현**:
```typescript
const { data, error } = await supabase.rpc(...);

if (error) {
  return { success: false, error: error.message };
}

if (!data || !data.success) {
  return { success: false, error: data?.error };
}
```

**검토 결과**:
- ✅ 기본적인 에러 처리 구현
- ⚠️ `StudentError` 클래스를 사용하지 않음 (일관성 부족)

**권장 개선**:
- `StudentError` 클래스를 사용하여 에러 처리 표준화
- 에러 코드 기반 처리

### 8. 로깅 및 모니터링

**위치**: `app/actions/auth.ts:272-298`

**현재 구현**:
- `console.error`로 에러 로깅
- `console.log`로 성공 로깅

**검토 결과**:
- ✅ 기본적인 로깅 구현
- ⚠️ 구조화된 로깅 없음
- ⚠️ 에러 트래킹 서비스 통합 없음

**권장 개선**:
- 구조화된 로깅 (JSON 형식)
- 에러 트래킹 서비스 통합 (Sentry 등)
- 성공/실패 메트릭 수집

---

## 📋 우선순위별 개선 계획

### 높은 우선순위 (보안 관련)

1. **함수 호출 권한 제한** (심각)
   - `GRANT EXECUTE`를 `service_role` 또는 특정 역할로만 제한
   - 또는 함수 내부에서 추가 권한 검증

2. **동시성 문제 해결** (중간)
   - `SELECT FOR UPDATE` 사용
   - 또는 `UPDATE ... WHERE used_at IS NULL RETURNING` 패턴

### 중간 우선순위 (안정성 관련)

3. **에러 메시지 보안 강화**
   - `SQLERRM` 대신 일반적인 메시지만 반환
   - 상세 에러는 로그에만 기록

4. **NULL 값 처리 완전성**
   - 모든 필수 필드에 대한 NULL 체크
   - 기본값 설정 또는 검증 로직 추가

### 낮은 우선순위 (코드 품질 관련)

5. **에러 처리 표준화**
   - `StudentError` 클래스 사용
   - 에러 코드 기반 처리

6. **로깅 개선**
   - 구조화된 로깅
   - 에러 트래킹 서비스 통합

---

## 🔍 추가 검토 필요 사항

### 9. 트랜잭션 격리 수준

**검토 필요**:
- PostgreSQL의 기본 격리 수준 (READ COMMITTED)에서 동시성 문제 가능성
- `SERIALIZABLE` 격리 수준 고려 필요 여부

### 10. 함수 성능

**검토 필요**:
- 여러 테이블 조회 및 INSERT 작업
- 인덱스 최적화 여부
- 대량 처리 시 성능 영향

### 11. 롤백 시나리오

**검토 필요**:
- 각 단계에서 실패 시 롤백 동작 확인
- 부분 실패 시 데이터 일관성 보장 여부

---

## 📝 결론

### 즉시 수정 필요
1. 함수 호출 권한 제한 (보안 취약점)
2. 동시성 문제 해결 (데이터 무결성)

### 단기 개선 권장
3. 에러 메시지 보안 강화
4. NULL 값 처리 완전성

### 장기 개선 권장
5. 에러 처리 표준화
6. 로깅 및 모니터링 개선

---

**검토 완료 시간**: 2025-12-19
**검토자**: AI Assistant
**다음 검토 예정**: 보안 취약점 수정 후 재검토




