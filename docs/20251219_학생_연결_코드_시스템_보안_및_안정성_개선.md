# 학생 연결 코드 시스템 보안 및 안정성 개선

## 개요

문제점 검토 결과를 바탕으로 보안 취약점과 안정성 문제를 해결하고, 2025년 PostgreSQL/Supabase 모범 사례를 적용하여 시스템을 개선했습니다.

**작업 일자**: 2025-12-19  
**마이그레이션 파일**: `supabase/migrations/20251219124149_fix_link_student_with_connection_code_security.sql`  
**수정 파일**: `app/actions/auth.ts`

## 주요 개선 사항

### 1. 함수 호출 권한 제한 (보안 강화)

**문제**: `GRANT EXECUTE TO authenticated`로 모든 인증된 사용자가 함수 호출 가능

**해결**:
- `authenticated`, `anon`, `public` 권한 제거
- `service_role`만 호출 가능하도록 제한
- Supabase 모범 사례: SECURITY DEFINER 함수는 명시적 권한 제한 필요

**변경 내용**:
```sql
-- 기존 권한 제거
REVOKE EXECUTE ON FUNCTION link_student_with_connection_code(uuid, text) FROM authenticated, anon, public;

-- service_role은 기본적으로 모든 함수 실행 권한이 있으므로 명시적 GRANT 불필요
```

### 2. search_path 설정 추가 (보안 모범 사례)

**문제**: SECURITY DEFINER 함수에 `set search_path` 설정 없음

**해결**:
- Supabase 모범 사례에 따라 `set search_path = ''` 추가
- 모든 테이블 참조를 스키마로 명시 (`public.`)

**변경 내용**:
```sql
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- 모든 테이블 참조를 public.으로 명시
FROM public.student_connection_codes
FROM public.students
FROM public.student_profiles
FROM public.student_career_goals
```

### 3. 동시성 문제 해결 (데이터 무결성)

**문제**: 동일 연결 코드를 동시에 사용할 때 중복 사용 가능

**해결**:
- `SELECT FOR UPDATE`를 사용하여 행 잠금
- `UPDATE ... WHERE used_at IS NULL RETURNING` 패턴으로 원자적 업데이트

**변경 내용**:
```sql
-- SELECT FOR UPDATE로 행 잠금
SELECT student_id, expires_at, used_at
INTO v_code_record
FROM public.student_connection_codes
WHERE connection_code = p_connection_code
FOR UPDATE;  -- 행 잠금 추가

-- 원자적 업데이트: RETURNING으로 업데이트 확인
UPDATE public.student_connection_codes
SET used_at = now()
WHERE connection_code = p_connection_code
  AND used_at IS NULL
RETURNING id INTO v_updated_code_id;

IF NOT FOUND THEN
  RAISE EXCEPTION '연결 코드가 이미 사용되었거나 존재하지 않습니다.';
END IF;
```

### 4. 에러 메시지 보안 강화

**문제**: `SQLERRM`에 데이터베이스 내부 정보 노출 가능

**해결**:
- 일반적인 에러 메시지만 반환
- 상세 에러는 PostgreSQL 로그에만 기록 (`RAISE WARNING` 사용)

**변경 내용**:
```sql
WHEN OTHERS THEN
  -- 상세 에러는 로그에만 기록
  RAISE WARNING 'link_student_with_connection_code error: user_id: %, connection_code: %, error: %', p_user_id, p_connection_code, SQLERRM;
  RETURN jsonb_build_object(
    'success', false,
    'error', '학생 계정 연결 중 오류가 발생했습니다. 관리자에게 문의하세요.'
  );
```

### 5. NULL 값 처리 완전성

**문제**: 필수 필드에 대한 NULL 체크 불완전

**해결**:
- 함수 시작 부분에서 필수 필드 검증
- NOT NULL 제약조건이 있는 필드에 대한 기본값 설정

**변경 내용**:
```sql
-- 필수 필드 검증
IF v_existing_student.name IS NULL OR v_existing_student.name = '' THEN
  RETURN jsonb_build_object(
    'success', false,
    'error', '학생 이름 정보가 없습니다.'
  );
END IF;

-- INSERT 시 NULL 처리
INSERT INTO public.students (
  id,
  tenant_id,
  name,
  grade,
  class,
  birth_date,
  school_id,
  school_type,
  division,
  student_number,
  enrolled_at,
  status,
  is_active
) VALUES (
  p_user_id,
  v_existing_student.tenant_id,
  COALESCE(v_existing_student.name, ''),
  COALESCE(v_existing_student.grade, ''),
  v_existing_student.class,
  v_existing_student.birth_date,
  v_existing_student.school_id,
  v_existing_student.school_type,
  v_existing_student.division,
  v_existing_student.student_number,
  v_existing_student.enrolled_at,
  COALESCE(v_existing_student.status, 'enrolled'),
  COALESCE(v_existing_student.is_active, true)
);
```

### 6. 에러 처리 표준화 (코드 품질)

**문제**: `StudentError` 클래스를 사용하지 않음

**해결**:
- `app/actions/auth.ts`에서 `StudentError` 사용
- 에러 코드 기반 처리

**변경 내용**:
```typescript
import { StudentError, StudentErrorCodes, toStudentError } from "@/lib/errors/studentErrors";
import { logError } from "@/lib/errors/handler";

async function linkStudentWithConnectionCode(...) {
  try {
    // ... 기존 코드 ...
    
    if (error) {
      const studentError = toStudentError(
        error,
        StudentErrorCodes.LINK_STUDENT_FAILED,
        { userId, connectionCode }
      );
      logError(studentError, {
        function: "linkStudentWithConnectionCode",
        userId,
        connectionCode,
        supabaseError: error,
      });
      return {
        success: false,
        error: studentError.userMessage,
      };
    }
  } catch (error) {
    const studentError = toStudentError(
      error,
      StudentErrorCodes.UNKNOWN_ERROR,
      { userId, connectionCode }
    );
    logError(studentError, {
      function: "linkStudentWithConnectionCode",
      userId,
      connectionCode,
      exception: true,
    });
    return {
      success: false,
      error: studentError.userMessage,
    };
  }
}
```

### 7. 로깅 개선 (모니터링)

**문제**: 구조화된 로깅 없음

**해결**:
- `lib/errors/handler.ts`의 `logError` 함수 활용
- 구조화된 로깅 추가

**변경 내용**:
```typescript
import { logError } from "@/lib/errors/handler";

// 에러 발생 시
if (error) {
  logError(studentError, {
    function: "linkStudentWithConnectionCode",
    userId,
    connectionCode,
    supabaseError: error,
  });
}

// 성공 로깅 (구조화된 로깅)
console.log("[auth] 연결 코드로 학생 계정 연결 성공", {
  function: "linkStudentWithConnectionCode",
  userId,
  connectionCode,
  result: {
    studentId: data.student_id,
    oldStudentId: data.old_student_id,
  },
});
```

## 테스트 계획

### 1. 보안 테스트

- [ ] authenticated 사용자가 함수 호출 시도 → 실패 확인
- [ ] service_role만 호출 가능 확인

### 2. 동시성 테스트

- [ ] 동일 연결 코드를 동시에 사용 시도 → 한 번만 성공 확인

### 3. 에러 처리 테스트

- [ ] 각 에러 시나리오별 메시지 확인
- [ ] 민감 정보 노출 없음 확인

### 4. NULL 값 테스트

- [ ] 필수 필드가 NULL인 경우 처리 확인

## 참고 자료

- Supabase 문서: SECURITY DEFINER 함수 모범 사례
- PostgreSQL 문서: SELECT FOR UPDATE 동시성 제어
- Context7: Supabase 함수 보안 패턴

## 마이그레이션 적용 방법

```bash
# Supabase CLI를 사용하여 마이그레이션 적용
supabase db push

# 또는 직접 SQL 실행
psql -h <host> -U postgres -d postgres -f supabase/migrations/20251219124149_fix_link_student_with_connection_code_security.sql
```

## 롤백 방법

문제가 발생할 경우 다음 SQL을 실행하여 이전 버전으로 롤백할 수 있습니다:

```sql
-- 이전 마이그레이션 파일의 함수 정의를 다시 실행
-- supabase/migrations/20251219114051_create_link_student_with_connection_code_function.sql
```

## 영향 범위

- **보안**: 함수 호출 권한이 제한되어 보안이 강화되었습니다.
- **안정성**: 동시성 문제와 NULL 값 처리가 개선되었습니다.
- **모니터링**: 구조화된 로깅으로 디버깅이 용이해졌습니다.
- **사용자 경험**: 표준화된 에러 메시지로 일관된 사용자 경험을 제공합니다.

## 다음 단계

1. 마이그레이션 적용 및 테스트
2. 프로덕션 환경 배포
3. 모니터링 및 로그 확인
4. 사용자 피드백 수집



