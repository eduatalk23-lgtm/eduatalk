# 캠프 템플릿 초대자 삭제 후 목록 갱신 개선

## 작업 개요

캠프 템플릿 상세 페이지에서 발송된 초대를 삭제한 후, 학생 초대 폼의 학생 목록이 자동으로 갱신되지 않는 문제를 해결했습니다.

## 작업 일자

2025년 12월 22일

## 문제 분석

### 발견된 문제점

1. **초대 삭제 후 목록 미갱신**: `CampInvitationList`에서 발송된 초대를 삭제한 후, `StudentInvitationForm`의 학생 목록이 갱신되지 않아 삭제된 학생이 다시 초대 가능한 목록에 나타나지 않음
2. **상태 동기화 부재**: 초대 삭제와 학생 목록 갱신이 연동되지 않음

### 원인 분석

- `CampTemplateDetail`의 `handleDeleteInvitations` 함수는 발송된 초대 목록만 갱신하고, `StudentInvitationForm`의 학생 목록은 갱신하지 않음
- `StudentInvitationForm`은 초기 로드 시에만 이미 초대된 학생을 필터링하고, 이후 초대 삭제 시 자동으로 갱신되지 않음

## 수정 내용

### 1. StudentInvitationForm 컴포넌트 수정

**파일**: `app/(admin)/admin/camp-templates/[id]/StudentInvitationForm.tsx`

#### 변경 사항

1. **refreshKey prop 추가**: 외부에서 목록 갱신을 트리거할 수 있는 prop 추가
   ```typescript
   type StudentInvitationFormProps = {
     templateId: string;
     templateStatus?: "draft" | "active" | "archived";
     onInvitationSent?: () => void;
     refreshKey?: number; // 추가
   };
   ```

2. **useEffect 의존성에 refreshKey 추가**: refreshKey가 변경될 때마다 학생 목록 다시 로드
   ```typescript
   // 초기 로드 및 refreshKey 변경 시 학생 목록 갱신
   useEffect(() => {
     loadStudents();
   }, [loadStudents, refreshKey]);
   ```

### 2. CampTemplateDetail 컴포넌트 수정

**파일**: `app/(admin)/admin/camp-templates/[id]/CampTemplateDetail.tsx`

#### 변경 사항

1. **studentFormRefreshKey 상태 추가**: 학생 초대 폼 갱신을 위한 상태 추가
   ```typescript
   const [studentFormRefreshKey, setStudentFormRefreshKey] = useState(0);
   ```

2. **handleDeleteInvitations 함수 수정**: 초대 삭제 후 학생 폼 목록도 갱신
   ```typescript
   const handleDeleteInvitations = useCallback((deletedCount: number) => {
     adjustPageAfterDeletion(deletedCount, invitationTotal);
     loadInvitations(invitationPage, invitationPageSize, invitationFilters);
     // 학생 초대 폼의 목록도 갱신 (삭제된 학생이 다시 목록에 나타나도록)
     setStudentFormRefreshKey((prev) => prev + 1);
   }, [adjustPageAfterDeletion, invitationTotal, invitationPage, invitationPageSize, invitationFilters, loadInvitations]);
   ```

3. **StudentInvitationForm에 refreshKey prop 전달**
   ```typescript
   <StudentInvitationForm
     templateId={template.id}
     templateStatus={template.status}
     onInvitationSent={handleInvitationSent}
     refreshKey={studentFormRefreshKey}
   />
   ```

## 동작 흐름

### 개선 전

1. 사용자가 발송된 초대 목록에서 초대 삭제
2. `CampInvitationList`의 초대 목록만 갱신됨
3. `StudentInvitationForm`의 학생 목록은 갱신되지 않음
4. 삭제된 학생이 다시 초대 가능한 목록에 나타나지 않음

### 개선 후

1. 사용자가 발송된 초대 목록에서 초대 삭제
2. `CampInvitationList`의 초대 목록 갱신
3. `handleDeleteInvitations`에서 `studentFormRefreshKey` 증가
4. `StudentInvitationForm`의 `refreshKey` prop 변경 감지
5. `useEffect`에서 `loadStudents()` 호출하여 학생 목록 다시 로드
6. 삭제된 학생이 다시 초대 가능한 목록에 나타남

## 테스트 시나리오

### 시나리오 1: 단일 초대 삭제

1. 캠프 템플릿 상세 페이지 접속
2. 학생 초대 폼에서 학생 선택 및 초대 발송
3. 발송된 초대 목록에서 해당 초대 삭제
4. **확인**: 학생 초대 폼의 학생 목록에 삭제된 학생이 다시 나타남

### 시나리오 2: 일괄 초대 삭제

1. 캠프 템플릿 상세 페이지 접속
2. 학생 초대 폼에서 여러 학생 선택 및 초대 발송
3. 발송된 초대 목록에서 여러 초대 선택 후 일괄 삭제
4. **확인**: 학생 초대 폼의 학생 목록에 삭제된 모든 학생이 다시 나타남

### 시나리오 3: 필터링된 상태에서 삭제

1. 학생 초대 폼에서 학년/반 필터 적용
2. 초대 발송 후 삭제
3. **확인**: 필터 조건에 맞는 삭제된 학생이 목록에 다시 나타남

## 기술적 고려사항

### refreshKey 패턴 사용 이유

- **간단하고 명확**: prop 변경을 통한 갱신 트리거는 React의 표준 패턴
- **상태 관리 최소화**: 별도의 복잡한 상태 관리 없이 간단한 카운터로 해결
- **의존성 명확**: `useEffect`의 의존성 배열에 `refreshKey`를 추가하여 명확한 갱신 시점 보장

### 대안 고려 사항

1. **useImperativeHandle + ref**: 더 복잡하고 React의 선언적 패턴과 맞지 않음
2. **Context API**: 전역 상태 관리가 필요하지 않은 경우 과도한 추상화
3. **이벤트 리스너**: React의 데이터 흐름과 맞지 않음

## 관련 파일

- `app/(admin)/admin/camp-templates/[id]/StudentInvitationForm.tsx`
- `app/(admin)/admin/camp-templates/[id]/CampTemplateDetail.tsx`
- `app/(admin)/admin/camp-templates/[id]/CampInvitationList.tsx`

## 향후 개선 사항

- 초대 삭제 시 Optimistic Update 패턴 적용 고려 (현재는 서버 응답 후 갱신)
- 학생 목록 로드 성능 최적화 (대량 학생 처리 시)



