# 플랜 생성 콘텐츠 ID 매핑 근본 원인 해결

**작업 일시**: 2025-12-22  
**목적**: 학생의 플랜 그룹 생성과 관리자의 남은 단계 진행 간 차이로 인한 외래 키 제약 조건 위반 오류 근본 해결

---

## 문제 상황

관리자가 캠프 템플릿 참여자의 남은 단계를 진행할 때 플랜 생성 중 외래 키 제약 조건 위반 오류가 계속 발생했습니다.

### 에러 메시지

```
Error [AppError]: 플랜 저장에 실패했습니다. 강의(048f5e20...)가 존재하지 않습니다. 
콘텐츠가 삭제되었거나 contentIdMap에 매핑되지 않았을 수 있습니다.
```

---

## 근본 원인 분석

### 데이터 흐름 차이점

#### 1. 학생의 플랜 그룹 생성

**흐름**:
1. `submitCampParticipation` → `createPlanGroupAction` 호출
2. `createPlanContents` 직접 호출
3. `plan_contents.content_id`에 **마스터 콘텐츠 ID** 저장
4. `plan_contents.master_content_id`에도 같은 값 저장
5. 플랜은 생성하지 않음 (Step 3에서만 제출)

**특징**:
- `skipContentValidation: true`로 콘텐츠 검증 건너뜀
- 마스터 콘텐츠 ID를 그대로 저장

#### 2. 관리자의 남은 단계 진행

**흐름**:
1. `continueCampStepsForAdmin` → `savePlanContents` 호출
2. `validateAndResolveContent`를 통해 검증 및 변환
3. 마스터 콘텐츠를 학생 콘텐츠로 복사
4. `plan_contents.content_id`에 **학생 콘텐츠 ID** 저장
5. Step 7에서 `generatePlansFromGroupAction` 호출하여 플랜 생성

**특징**:
- 콘텐츠 검증 및 변환 수행
- 학생 콘텐츠 ID로 저장

### 문제의 핵심

**`generatePlansFromGroup` 함수에 원본 `contents` 배열을 전달**하고 있었습니다:

```typescript
// ❌ 문제: 원본 contents 전달
scheduledPlans = await generatePlansFromGroup(
  group,
  contents, // 원본 contents (마스터 콘텐츠 ID 포함 가능)
  // ...
);
```

이 함수는 내부에서 `c.content_id`를 그대로 사용하여 플랜을 생성하므로:
- 생성된 플랜의 `content_id`가 원본 콘텐츠 ID(마스터 콘텐츠 ID일 수 있음)
- `planPayloads`를 생성할 때 이 ID를 사용
- 외래 키 제약 조건 위반 발생

---

## 해결 방법

### 1. `master_content_id` 우선 사용

`plan_contents`의 `master_content_id` 필드를 우선 사용하도록 수정:

```typescript
const getResolvedContentId = (content: PlanContent): string => {
  return content.master_content_id || content.content_id;
};
```

**효과**:
- 학생이 마스터 콘텐츠 ID를 저장해도 `master_content_id` 필드에서 읽을 수 있음
- 관리자가 변환한 경우 `content_id` 사용

### 2. `generatePlansFromGroup` 호출 전 `contents` 변환

`contentIdMap`을 사용하여 `contents` 배열의 `content_id`를 변환:

```typescript
// ✅ 해결: contentIdMap에 매핑된 콘텐츠만 포함
const transformedContents = contents
  .filter((c) => {
    if (isDummyContent(c.content_id)) return true;
    return contentIdMap.has(c.content_id);
  })
  .map((c) => {
    const finalContentId = contentIdMap.get(c.content_id) || c.content_id;
    return {
      ...c,
      content_id: finalContentId,
    };
  });

scheduledPlans = await generatePlansFromGroup(
  group,
  transformedContents, // 변환된 contents 전달
  // ...
);
```

**효과**:
- `generatePlansFromGroup`에서 생성된 플랜의 `content_id`는 이미 학생 콘텐츠 ID
- 추가 변환 불필요

### 3. `contentIdMap` 생성 로직 개선

원본 `content_id`를 키로 사용하도록 수정:

```typescript
// 직접 조회한 학생 콘텐츠 매핑
(directBooksResult.data || []).forEach((b) => {
  // resolvedContentId가 b.id인 원본 content_id 찾기
  const originalContent = bookContents.find((c) => c.resolvedContentId === b.id);
  if (originalContent) {
    contentIdMap.set(originalContent.content_id, b.id);
  }
});
```

**효과**:
- `contentIdMap`의 키가 항상 원본 `content_id`
- `transformedContents` 생성 시 올바른 매핑 사용

### 4. `planPayloads` 생성 로직 단순화

`transformedContents`를 사용했으므로 추가 변환 불필요:

```typescript
// transformedContents를 사용했으므로 segment.plan.content_id는 이미 학생 콘텐츠 ID
const finalContentId = segment.plan.content_id;
```

**효과**:
- 불필요한 변환 제거
- 코드 단순화

---

## 적용된 수정 사항

### 파일별 변경 내용

#### 1. `generatePlansRefactored.ts`

- ✅ `master_content_id` 우선 사용 로직 추가
- ✅ `transformedContents` 생성 및 필터링
- ✅ `generatePlansFromGroup`에 변환된 `contents` 전달
- ✅ `planPayloads` 생성 로직 단순화
- ✅ `contentIdMap` 생성 시 원본 `content_id`를 키로 사용

#### 2. `contentResolver.ts` (resolveContentIds)

- ✅ `master_content_id` 우선 사용 로직 적용
- ✅ `resolvedContentId` 사용하여 조회

---

## 검증 로직

### 플랜 저장 전 검증

1. **콘텐츠 존재 여부 확인**: `books`와 `lectures` 테이블에서 실제 존재 확인
2. **존재하지 않는 콘텐츠 필터링**: 플랜에서 자동 제외
3. **최종 검증**: 모든 플랜의 `content_id`가 검증된 콘텐츠인지 확인

### 에러 처리

- 외래 키 제약 조건 위반 시 명확한 에러 메시지
- 문제가 되는 콘텐츠 ID와 타입 정보 포함
- 상세한 디버깅 정보 로그 출력

---

## 예상 효과

1. ✅ 학생이 마스터 콘텐츠 ID를 저장해도 플랜 생성 시 정상 동작
2. ✅ 관리자와 학생의 플랜 생성 로직 차이로 인한 오류 해결
3. ✅ `plan_contents.master_content_id` 필드 활용으로 일관성 확보
4. ✅ 외래 키 제약 조건 위반 완전 방지

---

## 테스트 시나리오

### 시나리오 1: 학생이 먼저 플랜 그룹 생성

1. 학생이 Step 3에서 제출
   - `plan_contents.content_id`에 마스터 콘텐츠 ID 저장
   - `plan_contents.master_content_id`에도 같은 값 저장
2. 관리자가 Step 4-6 진행
   - `savePlanContents`가 학생 콘텐츠 ID로 변환
3. 관리자가 Step 7에서 플랜 생성
   - ✅ `master_content_id` 우선 사용으로 정상 동작

### 시나리오 2: 관리자가 먼저 진행

1. 학생이 Step 3에서 제출
   - `plan_contents.content_id`에 마스터 콘텐츠 ID 저장
2. 관리자가 Step 4-6 진행
   - 일부 콘텐츠만 변환 (여전히 마스터 콘텐츠 ID 존재)
3. 관리자가 Step 7에서 플랜 생성
   - ✅ `master_content_id` 우선 사용으로 정상 동작
   - ✅ `transformedContents`에서 매핑되지 않은 콘텐츠 제외

---

## 관련 파일

- `app/(student)/actions/plan-groups/generatePlansRefactored.ts`
- `lib/plan/contentResolver.ts` (resolveContentIds 함수)
- `app/(student)/actions/plan-groups/previewPlansRefactored.ts` (resolveContentIds 사용)

---

## 참고

- `plan_contents` 테이블의 `master_content_id` 필드는 이미 존재하며 조회 시 포함됨
- 학생이 플랜 그룹 생성 시 `master_content_id`도 함께 저장됨
- 이 수정으로 학생과 관리자의 플랜 생성 로직 차이 문제 완전 해결




