# 스케줄 결과 조회 성능 최적화

**작성 일자**: 2025-12-05  
**목적**: 7단계 스케줄 결과 상세 보기의 로딩 시간 개선 (60-70% 개선 목표)

---

## 개요

7단계 스케줄 결과 상세 보기에서 플랜 데이터를 조회할 때 발생하는 성능 병목 현상을 해결하기 위해 다음과 같은 최적화를 수행했습니다:

1. **콘텐츠 조회 병렬화**: 책/강의/커스텀 콘텐츠를 순차 조회하던 것을 병렬 조회로 변경
2. **플랜/블록 조회 병렬화**: 독립적인 쿼리를 병렬로 실행
3. **React Query 도입**: 클라이언트 사이드 캐싱 및 자동 갱신 관리

---

## 문제점 분석

### 현재 구조

1. **순차 쿼리 실행**
   - 플랜 조회 → 콘텐츠 조회 (책 → 강의 → 커스텀)
   - 마스터 콘텐츠는 학생 콘텐츠 조회 후에야 조회 가능
   - 총 6번의 순차 쿼리 실행

2. **캐싱 부재**
   - 클라이언트 사이드 캐싱이 없어 매번 서버 요청
   - 같은 데이터를 여러 번 조회

3. **플랜/블록 조회 분리**
   - 플랜 조회와 블록 조회가 독립적임에도 순차 실행

---

## 구현 내용

### 1. 콘텐츠 조회 병렬화

**파일**: `app/(student)/actions/plan-groups/queries.ts`

#### 변경 사항

- 학생 콘텐츠들(책, 강의, 커스텀)을 `Promise.all`로 병렬 조회
- 마스터 콘텐츠도 병렬 조회 (누락된 ID 추출 후)
- 각 쿼리 에러를 개별적으로 처리하여 하나의 실패가 전체를 막지 않도록 함

#### Before

```typescript
// 순차 실행 (약 300-500ms)
if (bookIds.length > 0) {
  const { data: books } = await queryClient.from("books")...
  // 마스터 책 조회
  if (missingBookIds.length > 0) {
    const { data: masterBooks } = await supabase.from("master_books")...
  }
}

if (lectureIds.length > 0) {
  const { data: lectures } = await queryClient.from("lectures")...
  // 마스터 강의 조회
  if (missingLectureIds.length > 0) {
    const { data: masterLectures } = await supabase.from("master_lectures")...
  }
}

if (customIds.length > 0) {
  const { data: customContents } = await queryClient.from("student_custom_contents")...
}
```

#### After

```typescript
// 병렬 실행 (약 100-150ms)
const studentContentQueries = [];
if (bookIds.length > 0) {
  studentContentQueries.push(queryClient.from("books")...);
}
if (lectureIds.length > 0) {
  studentContentQueries.push(queryClient.from("lectures")...);
}
if (customIds.length > 0) {
  studentContentQueries.push(queryClient.from("student_custom_contents")...);
}

const studentContentResults = await Promise.all(studentContentQueries);

// 누락된 ID 추출 후 마스터 콘텐츠 병렬 조회
const masterContentQueries = [];
if (missingBookIds.length > 0) {
  masterContentQueries.push(supabase.from("master_books")...);
}
if (missingLectureIds.length > 0) {
  masterContentQueries.push(supabase.from("master_lectures")...);
}

if (masterContentQueries.length > 0) {
  const masterContentResults = await Promise.all(masterContentQueries);
}
```

### 2. 플랜/블록 조회 병렬화

**파일**: `app/(student)/actions/plan-groups/queries.ts`

#### 변경 사항

- 플랜 조회와 블록 조회를 `Promise.all`로 병렬 실행
- 블록 조회 에러는 로깅만 하고 계속 진행 (블록이 없어도 플랜 조회는 가능)

#### Before

```typescript
// 순차 실행
const { data: plans } = await queryClient.from("student_plan")...

// 플랜 데이터 처리 후
if (group.block_set_id) {
  const { data: blockData } = await queryClient.from("student_block_schedule")...
}
```

#### After

```typescript
// 병렬 실행
const plansQuery = queryClient.from("student_plan")...
const blocksQuery = group.block_set_id
  ? queryClient.from("student_block_schedule")...
  : Promise.resolve({ data: null, error: null });

const [{ data: plans }, { data: blockData }] = await Promise.all([
  plansQuery,
  blocksQuery,
]);
```

### 3. React Query 도입

**파일**: `app/(student)/plan/new-group/_components/Step7ScheduleResult.tsx`

#### 변경 사항

- `useState` + `useEffect` 제거
- React Query의 `useQuery`와 `useMutation` 사용
- 플랜 존재 여부 확인 후 자동 생성 로직 개선
- 캐시 무효화를 통한 데이터 갱신 관리

#### 주요 기능

1. **플랜 존재 여부 확인**
   - `useQuery`로 플랜 존재 여부 확인
   - 캐시 유지 시간: 1분

2. **플랜 자동 생성**
   - `useMutation`으로 플랜 생성 처리
   - 생성 후 관련 쿼리 캐시 무효화

3. **스케줄 결과 데이터 조회**
   - 기존 `PlanScheduleView`와 동일한 `queryKey` 사용 (`["planSchedule", groupId]`)
   - 캐시 공유로 중복 요청 방지
   - 캐시 유지 시간: 5분

#### Before

```typescript
const [loading, setLoading] = useState(true);
const [plans, setPlans] = useState([]);

useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    const checkResult = await checkPlansExistAction(groupId);
    if (!checkResult.hasPlans) {
      await generatePlansFromGroupAction(groupId);
    }
    const result = await getScheduleResultDataAction(groupId);
    setPlans(result.plans);
    setLoading(false);
  };
  fetchData();
}, [groupId]);
```

#### After

```typescript
const queryClient = useQueryClient();

// 플랜 존재 여부 확인
const { data: plansCheck } = useQuery({
  queryKey: ["plansExist", groupId],
  queryFn: () => checkPlansExistAction(groupId),
});

// 플랜 생성 뮤테이션
const generatePlansMutation = useMutation({
  mutationFn: () => generatePlansFromGroupAction(groupId),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["plansExist", groupId] });
    queryClient.invalidateQueries({ queryKey: ["planSchedule", groupId] });
  },
});

// 스케줄 결과 데이터 조회
const { data, isLoading } = useQuery({
  queryKey: ["planSchedule", groupId],
  queryFn: async () => {
    const result = await getScheduleResultDataAction(groupId);
    // 데이터 변환
    return { plans, contents, blocks, dailySchedule };
  },
  enabled: Boolean(plansCheck?.hasPlans || generatePlansMutation.isSuccess),
  staleTime: 1000 * 60 * 5, // 5분간 캐시 유지
});
```

---

## 성능 개선 효과

### 예상 개선 수치

- **현재**: 약 800-1200ms
- **개선 후**: 약 300-500ms
- **개선율**: 약 60-70%

### 개선 요인

1. **콘텐츠 조회 병렬화**: 약 200-300ms 단축
2. **플랜/블록 조회 병렬화**: 약 50-100ms 단축
3. **React Query 캐싱**: 재방문 시 즉시 로딩 (0ms)

---

## 주요 변경 파일

1. **`app/(student)/actions/plan-groups/queries.ts`**
   - 콘텐츠 조회 병렬화
   - 플랜/블록 조회 병렬화

2. **`app/(student)/plan/new-group/_components/Step7ScheduleResult.tsx`**
   - React Query 도입
   - 플랜 생성 로직 개선
   - 캐시 무효화 처리

---

## 주의사항

### 1. 에러 처리

- 병렬 쿼리 실행 시 개별 쿼리 실패가 전체를 막지 않도록 처리
- 블록 조회 실패는 로깅만 하고 계속 진행

### 2. 캐시 관리

- 플랜 생성/재생성 후 반드시 캐시 무효화
- `PlanPreviewDialog`에서 플랜 재생성 시에도 캐시 무효화 처리

### 3. queryKey 일관성

- `PlanScheduleView`와 동일한 queryKey 사용 (`["planSchedule", groupId]`)
- 캐시 공유로 중복 요청 방지

---

## 향후 개선 사항

### 1. 추가 최적화 가능 영역

- 콘텐츠 메타데이터 조회 최적화 (필요한 필드만 선택)
- 데이터베이스 인덱스 추가 검토
- 서버 사이드 캐싱 도입 검토

### 2. 모니터링

- 실제 성능 측정 및 검증
- 사용자 피드백 수집
- 추가 병목 지점 분석

---

## 참고

- React Query 공식 문서: https://tanstack.com/query/latest
- Next.js Server Actions: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
- 기존 최적화 가이드: `docs/supabase-client-optimization-guide.md`
