# 플랜 그룹 중복 생성 방지

## 문제 상황

플랜을 한 번 만드는 과정에서 플랜 그룹이 3개 이상 생성되는 문제가 발생했습니다.

터미널 로그 분석 결과:
- `POST /plan/new-group` 요청이 여러 번 발생 (740-767줄)
- 각 요청마다 새로운 플랜 그룹 ID가 생성됨 (5개)
- 플랜 생성은 마지막 그룹에 대해서만 실행됨 (787-812줄)

## 원인 분석

### 원인 1: `handleSubmit` 함수에 중복 호출 방지 로직이 없음

- `startTransition`은 비동기이므로 즉시 반환됨
- 사용자가 빠르게 여러 번 클릭하면 여러 번의 `startTransition`이 시작됨
- 각 `startTransition`마다 `createPlanGroupAction`이 호출되어 플랜 그룹이 중복 생성됨

### 원인 2: `isPending`만으로는 부족함

- `isPending`은 React의 상태 업데이트가 진행 중인지만 체크
- 실제 비동기 작업(서버 요청)이 완료되기 전에 다시 호출될 수 있음

### 원인 3: 플랜 그룹 생성 조건이 잘못됨 (핵심 원인)

- 기존 조건: `if (isEditMode && draftGroupId)`
- 일반 모드에서 `isEditMode = false`이므로, `draftGroupId`가 있어도 `createPlanGroupAction`이 호출됨
- **매 단계마다 새로운 플랜 그룹이 생성되는 문제 발생**

## 해결 방안

### 해결 1: `useRef`를 사용한 중복 호출 방지

`useRef`를 사용하여 실행 중인지 추적하는 방식으로 중복 호출을 방지합니다.

1. **`isSubmittingRef` 추가**
   - `useRef(false)`로 실행 중인지 추적
   - `startTransition` 시작 전에 `true`로 설정
   - `finally` 블록에서 항상 `false`로 해제

2. **`handleSubmit` 함수 시작 부분에 체크 추가**
   - `isSubmittingRef.current` 또는 `isPending`이 `true`이면 즉시 반환

### 해결 2: 플랜 그룹 생성 조건 수정 (핵심 수정)

`draftGroupId`가 있으면 기존 플랜 그룹을 업데이트하도록 조건 수정

## 수정 내용

### PlanGroupWizard.tsx

**1. `isSubmittingRef` 추가**:
```typescript
const [isPending, startTransition] = useTransition();
const isSubmittingRef = useRef(false); // 중복 호출 방지용
const [draftGroupId, setDraftGroupId] = useState<string | null>(
  initialData?.groupId || null
);
```

**2. `handleSubmit` 함수에 중복 호출 방지 로직 추가**:
```typescript
const handleSubmit = (generatePlans: boolean = true) => {
  // 중복 호출 방지: 이미 실행 중이면 무시
  if (isSubmittingRef.current || isPending) {
    return;
  }

  // Step 6 검증 (학습 분량 관련만)
  if (currentStep === 6) {
    if (!validateStep(6)) {
      return;
    }
  } else if (!isTemplateMode && !isCampMode) {
    // 일반 모드에서 Step 6가 아닌 경우 (이전 버전 호환성)
    if (!validateStep(6)) {
      return;
    }
  }

  isSubmittingRef.current = true;

  startTransition(async () => {
    try {
      // ... 기존 코드 ...
    } catch (error) {
      // ... 에러 처리 ...
    } finally {
      // 실행 완료 후 플래그 해제
      isSubmittingRef.current = false;
    }
  });
};
```

**3. 플랜 그룹 생성 조건 수정 (핵심 수정)**:

**변경 전**:
```typescript
if (isEditMode && draftGroupId) {
  // 수정 모드: draft 상태면 updatePlanGroupDraftAction, 아니면 updatePlanGroupAction
  // 현재는 draft 상태만 수정 가능하므로 updatePlanGroupDraftAction 사용
  await updatePlanGroupDraftAction(draftGroupId, creationData);
  finalGroupId = draftGroupId;
} else {
  // 생성 모드
  // 캠프 모드에서 Step 4에서 제출할 때는 콘텐츠 검증 건너뛰기 (콘텐츠가 없어도 제출 가능)
  const skipContentValidation = isCampMode && currentStep === 4 && !isAdminContinueMode;
  const result = await createPlanGroupAction(creationData, {
    skipContentValidation,
  });
  // ...
}
```

**변경 후**:
```typescript
// 이미 플랜 그룹이 생성되어 있으면 업데이트, 아니면 새로 생성
if (draftGroupId) {
  // 기존 플랜 그룹 업데이트 (수정 모드 또는 이전 단계에서 생성된 경우)
  await updatePlanGroupDraftAction(draftGroupId, creationData);
  finalGroupId = draftGroupId;
} else {
  // 새 플랜 그룹 생성
  // 캠프 모드에서 Step 4에서 제출할 때는 콘텐츠 검증 건너뛰기 (콘텐츠가 없어도 제출 가능)
  const skipContentValidation = isCampMode && currentStep === 4 && !isAdminContinueMode;
  const result = await createPlanGroupAction(creationData, {
    skipContentValidation,
  });
  // ...
}
```

## 결과

이제 플랜 그룹 중복 생성 문제가 해결되었습니다:

1. ✅ `handleSubmit`이 실행 중일 때 다시 호출되면 즉시 반환
2. ✅ `isSubmittingRef`로 실제 비동기 작업 완료까지 추적
3. ✅ `finally` 블록으로 에러 발생 시에도 플래그 해제 보장
4. ✅ 사용자가 빠르게 여러 번 클릭해도 한 번만 실행
5. ✅ **`draftGroupId`가 있으면 기존 플랜 그룹을 업데이트** (핵심 수정)

## 테스트 시나리오

1. 일반 모드에서 플랜 그룹 생성
2. Step 4 → Step 5 → Step 6 → Step 7 순서로 진행
3. 플랜 그룹이 1개만 생성되는지 확인 (Step 4에서 처음 생성, 이후 단계에서는 업데이트)
4. Step 6에서 "다음" 버튼을 빠르게 여러 번 클릭해도 플랜 그룹이 추가로 생성되지 않는지 확인
5. 플랜이 정상적으로 생성되는지 확인

## 관련 파일

- `app/(student)/plan/new-group/_components/PlanGroupWizard.tsx`

