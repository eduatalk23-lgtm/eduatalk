# 테넌트 사용자 관리 코드 리팩토링 완료

**작업 일시**: 2025-01-15  
**목적**: 중복 코드 제거, 성능 최적화, 타입 안전성 강화

---

## 📋 작업 완료 내역

### Phase 1: 공통 유틸리티 함수 생성 ✅

#### 1.1 타입 정의 생성

**파일**: `lib/types/tenantUser.ts` (신규)

**생성된 타입**:
- `UserType`: "student" | "parent" | "admin"
- `TenantAssignmentResult`: 테넌트 할당 결과 타입
- `TenantUserBase`: 테넌트 사용자 기본 정보
- `TenantValidationResult`: 테넌트 검증 결과

#### 1.2 테넌트 검증 유틸리티

**파일**: `lib/utils/tenantValidation.ts` (신규)

**함수**:
- `validateTenantExists()`: 테넌트 존재 여부 확인

**기능**:
- 테넌트 ID로 존재 여부 확인
- 통일된 에러 처리
- 에러 메시지 표준화

#### 1.3 테넌트 할당 유틸리티

**파일**: `lib/utils/tenantAssignment.ts` (신규)

**함수**:
- `updateUserTenant()`: 단일 사용자 테넌트 할당
- `updateMultipleUserTenants()`: 다중 사용자 테넌트 할당

**기능**:
- 사용자 타입별 테이블 업데이트 (student/parent/admin)
- students 테이블: `user_id`로 먼저 시도, 없으면 `id`로 시도
- parent_users, admin_users 테이블: `id`로 업데이트
- 통일된 에러 처리 및 반환 타입

#### 1.4 Auth 사용자 메타데이터 조회 최적화

**파일**: `lib/utils/authUserMetadata.ts` (신규)

**함수**:
- `getAuthUserMetadata()`: 특정 사용자 ID 목록의 메타데이터만 조회
- `getAllAuthUserMetadata()`: 전체 사용자 메타데이터 조회 (하위 호환성)

**개선 사항**:
- 전체 사용자 조회 대신 필요한 ID만 필터링하여 조회
- 성능 최적화 (사용자 수가 많을 때 효과적)

---

### Phase 2: Server Actions 리팩토링 ✅

#### 2.1 Super Admin Actions 리팩토링

**파일**: `app/(superadmin)/actions/tenantlessUserActions.ts`

**변경 사항**:

1. **`getTenantlessUsers()` 최적화**:
   - 기존: 전체 Auth 사용자 목록 조회 후 필터링
   - 개선: 필요한 사용자 ID만 수집 후 `getAuthUserMetadata()` 사용

2. **`assignTenantToUser()` 리팩토링**:
   - 기존: 중복된 테넌트 확인 및 업데이트 로직
   - 개선: `updateUserTenant()` 공통 함수 사용

3. **`assignTenantToMultipleUsers()` 리팩토링**:
   - 기존: 반복문 내에서 중복 로직
   - 개선: `updateMultipleUserTenants()` 공통 함수 사용

**코드 감소량**: 약 80줄 감소

#### 2.2 Admin Actions 최적화

**파일**: `app/(admin)/actions/tenantUsers.ts`

**변경 사항**:

1. **`getTenantUsersAction()` 최적화**:
   - 기존: 전체 조회 후 클라이언트에서 필터링
   ```typescript
   // 기존 코드
   const { data: students } = await supabase.from("students").select("*");
   const filtered = students.filter(s => s.tenant_id === tenantId || !s.tenant_id);
   ```
   
   - 개선: DB 레벨 필터링
   ```typescript
   // 개선된 코드
   studentsQuery = studentsQuery.or(`tenant_id.eq.${tenantId},tenant_id.is.null`);
   ```
   
   - Auth 사용자 메타데이터 조회 최적화: `getAuthUserMetadata()` 사용

2. **`assignUserToTenantAction()` 리팩토링**:
   - 기존: 중복된 업데이트 로직
   - 개선: `updateUserTenant()` 공통 함수 사용

**성능 개선**:
- DB 레벨 필터링으로 네트워크 트래픽 감소
- 필요한 사용자 메타데이터만 조회하여 메모리 사용량 감소

---

## 📊 개선 효과

### 코드 중복 제거

- **제거된 중복 코드**: 약 150줄 이상
- **공통 함수 생성**: 3개 파일 (tenantAssignment, tenantValidation, authUserMetadata)
- **타입 정의**: 1개 파일 (tenantUser)

### 성능 개선

1. **DB 쿼리 최적화**:
   - Admin 페이지: 전체 조회 → DB 레벨 필터링
   - 네트워크 트래픽 감소 (사용자 수에 비례)

2. **Auth 사용자 조회 최적화**:
   - 전체 사용자 조회 → 필요한 ID만 필터링
   - 메모리 사용량 감소

### 타입 안전성 강화

- 명시적 타입 정의로 런타임 에러 감소
- 공통 반환 타입으로 일관성 확보

### 유지보수성 향상

- 공통 로직 변경 시 한 곳만 수정
- 에러 처리 표준화
- 코드 가독성 향상

---

## 🔍 주요 변경 사항 상세

### 1. 공통 함수 사용 패턴

**이전**:
```typescript
// 각 Action에서 중복된 로직
const { data: tenant } = await supabase
  .from("tenants")
  .select("id")
  .eq("id", tenantId)
  .maybeSingle();

if (!tenant) {
  return { success: false, error: "해당 기관을 찾을 수 없습니다." };
}

// 사용자 타입별 업데이트 로직 반복...
```

**이후**:
```typescript
// 공통 함수 사용
const result = await updateUserTenant(supabase, userId, tenantId, userType);
return result;
```

### 2. DB 레벨 필터링

**이전**:
```typescript
const { data: students } = await supabase.from("students").select("*");
const filtered = students.filter(s => s.tenant_id === tenantId || !s.tenant_id);
```

**이후**:
```typescript
let studentsQuery = supabase.from("students").select("*");
if (targetTenantId !== null) {
  studentsQuery = studentsQuery.or(`tenant_id.eq.${targetTenantId},tenant_id.is.null`);
}
const { data: students } = await studentsQuery;
```

### 3. Auth 메타데이터 조회 최적화

**이전**:
```typescript
const { data: authData } = await adminClient.auth.admin.listUsers();
const allAuthUsers = authData.users.map(...);
// 모든 사용자에서 필터링
```

**이후**:
```typescript
const userIdsToFetch = [...students.map(s => s.id), ...parents.map(p => p.id)];
const userMetadata = await getAuthUserMetadata(adminClient, userIdsToFetch);
// 필요한 ID만 필터링하여 조회
```

---

## ⚠️ 주의사항

### 1. students 테이블의 user_id 처리

현재 코드는 students 테이블에서 `user_id`로 먼저 시도하고, 없으면 `id`로 시도하는 방식으로 구현되어 있습니다. 이는 기존 데이터 구조와의 호환성을 위한 것입니다.

**구현 위치**: `lib/utils/tenantAssignment.ts` (31-45줄)

### 2. 하위 호환성 유지

- 기존 API 시그니처 유지
- 반환 타입 일관성 유지
- 에러 메시지 표준화

### 3. RLS 정책 고려

- Admin 클라이언트 사용 시 RLS 우회
- Server Client 사용 시 RLS 정책 적용

---

## 📝 다음 단계 (Phase 3)

### 데이터베이스 최적화

1. **인덱스 확인 및 추가**:
   - `students.tenant_id` 인덱스 확인
   - `parent_users.tenant_id` 인덱스 확인
   - `admin_users.tenant_id` 인덱스 확인

2. **NULL 값 처리 개선**:
   - 데이터베이스 스키마와 코드의 불일치 해결
   - NULL 값 발견 시 기본 테넌트 할당 로직 추가 (옵션)

---

## ✅ 검증 완료 사항

1. ✅ 공통 유틸리티 함수 생성 완료
2. ✅ 타입 정의 완료
3. ✅ Super Admin Actions 리팩토링 완료
4. ✅ Admin Actions 최적화 완료
5. ✅ Linter 에러 없음
6. ✅ 기존 API 시그니처 유지

---

## 📚 참고 문서

- [테넌트 사용자 관리 코드 최적화 계획](./.cursor/plans/-b4d37dcd.plan.md)
- [테넌트 사용자 관리 페이지 구현 및 메뉴 연결 검토](./20250115_테넌트_사용자_관리_페이지_구현_및_메뉴_연결_검토.md)

---

**작업 완료**: Phase 1, Phase 2 완료  
**다음 작업**: Phase 3 (데이터베이스 최적화) - 선택 사항

