# 캠프 템플릿 학습 제외일 검증 개선

**작업 일시**: 2024년 12월 22일  
**작업자**: AI Assistant

## 📋 작업 개요

캠프 템플릿 모드에서 학습 제외일 섹션의 검증 관련 개선을 진행했습니다. 관리자가 설정한 템플릿 제외일과 학생이 추가한 제외일이 겹칠 때, 제외일 타입의 위계를 기반으로 자동 교체하도록 개선했습니다.

## 🔍 문제 분석

### 기존 문제점

1. **제외일 중복 처리 부족**
   - 템플릿 제외일과 학생 제외일이 같은 날짜일 때, 단순히 날짜만 체크하여 중복 방지
   - 제외일 타입(`exclusion_type`)의 위계를 고려하지 않음

2. **제외일 위계 미반영**
   - "휴일지정"은 가장 낮은 위계 (자율학습 시간 배정 가능)
   - "휴가", "개인사정", "기타"는 더 높은 위계 (모든 학습 불가)
   - 위계가 높은 제외일이 자동으로 적용되지 않음

3. **템플릿 제외일 복원 문제**
   - 학생이 추가한 제외일을 삭제해도 템플릿 제외일이 자동으로 복원되지 않음
   - 템플릿 제외일이 DB에 저장되지 않아 조회 시 누락됨

## ✅ 해결 방안

### 방안 2: 조회 시 템플릿 제외일 자동 포함 (구현 완료)

**핵심 아이디어**:

- 제외일 조회 시 템플릿 제외일을 자동으로 포함
- 템플릿 제외일은 DB에 저장하지 않고, 조회 시점에 동적으로 추가
- 학생이 추가한 제외일을 삭제하면, 다음 조회 시 템플릿 제외일이 자동으로 포함됨

**장점**:

- 데이터 일관성: 템플릿 제외일이 항상 포함되어 표시
- 자동 복원: 삭제 후 조회 시 자동으로 포함
- 구현 단순: 삭제 로직 변경 최소화

## 🔧 구현 내용

### 1. 제외일 타입 위계 정의 유틸리티 생성

**파일**: `lib/utils/exclusionHierarchy.ts`

```typescript
/**
 * 제외일 타입 위계 정의
 * 숫자가 높을수록 더 강한 제외 (자율학습도 불가능)
 */
export const EXCLUSION_TYPE_HIERARCHY: Record<string, number> = {
  휴일지정: 1, // 가장 낮음 - 자율학습 가능
  기타: 2,
  개인사정: 3,
  휴가: 4, // 가장 높음 - 모든 학습 불가
};
```

**주요 함수**:

- `getExclusionTypeHierarchy(exclusionType: string)`: 제외일 타입의 위계 반환
- `getHigherPriorityExclusionType(type1, type2)`: 더 높은 위계의 타입 반환
- `isHigherPriorityExclusionType(type1, type2)`: 위계 비교 결과 반환

### 2. 캠프 템플릿 제외일 병합 로직 개선

**파일**: `app/(student)/actions/campActions.ts`

**변경 전**:

```typescript
// 제외일: 템플릿 기본값 + 학생 추가 제외일
exclusions: [
  ...templateExclusions,
  ...(wizardData.exclusions?.filter(
    (e) =>
      e.source !== "template" &&
      !templateExclusions.some(
        (te) => te.exclusion_date === e.exclusion_date
      )
  ) || []),
],
```

**변경 후**:

```typescript
// 제외일: 템플릿 기본값 + 학생 추가 제외일 (위계 기반 병합)
exclusions: (() => {
  const mergedExclusions = [...templateExclusions];

  (wizardData.exclusions || []).forEach((studentExclusion) => {
    if (studentExclusion.source === "template") return;

    const templateExclusion = templateExclusions.find(
      (te) => te.exclusion_date === studentExclusion.exclusion_date
    );

    if (templateExclusion) {
      // 위계 비교: 학생 제외일이 더 높은 위계면 교체
      if (
        isHigherPriorityExclusionType(
          studentExclusion.exclusion_type,
          templateExclusion.exclusion_type
        )
      ) {
        const index = mergedExclusions.findIndex(
          (e) => e.exclusion_date === studentExclusion.exclusion_date
        );
        if (index !== -1) {
          mergedExclusions[index] = {
            ...studentExclusion,
            source: "student" as const,
            is_locked: false,
          };
        }
      }
      // 학생 제외일이 같거나 낮은 위계 → 템플릿 제외일 유지
    } else {
      // 템플릿 제외일이 없는 경우: 학생 제외일 추가
      mergedExclusions.push({
        ...studentExclusion,
        source: "student" as const,
        is_locked: false,
      });
    }
  });

  return mergedExclusions;
})(),
```

### 3. 템플릿 데이터 병합 유틸리티 개선

**파일**: `lib/utils/planDataMerger.ts`

동일한 위계 기반 병합 로직을 적용하여 일관성 유지.

### 4. 제외일 조회 시 템플릿 제외일 자동 포함

**파일**: `lib/data/planGroups.ts`

**변경 내용**:

- `getPlanExclusions` 함수에 템플릿 제외일 자동 포함 로직 추가
- 캠프 플랜인 경우 템플릿 제외일 확인
- DB에 없는 템플릿 제외일만 추가하여 반환

```typescript
export async function getPlanExclusions(
  groupId: string,
  tenantId?: string | null
): Promise<PlanExclusion[]> {
  // ... DB 제외일 조회 ...

  const dbExclusions = (data as PlanExclusion[] | null) ?? [];

  // 캠프 플랜인 경우 템플릿 제외일 확인 및 포함
  const { data: planGroup } = await supabase
    .from("plan_groups")
    .select("camp_template_id, plan_type, student_id")
    .eq("id", groupId)
    .maybeSingle();

  if (planGroup?.plan_type === "camp" && planGroup.camp_template_id) {
    const template = await getCampTemplate(planGroup.camp_template_id);

    if (template?.template_data?.exclusions) {
      const templateExclusions = template.template_data.exclusions;
      const dbExclusionDates = new Set(
        dbExclusions.map((e) => e.exclusion_date)
      );

      // 템플릿 제외일 중 DB에 없는 것만 추가
      const missingTemplateExclusions = templateExclusions.filter(
        (te) => !dbExclusionDates.has(te.exclusion_date)
      );

      // 템플릿 제외일을 PlanExclusion 형식으로 변환하여 추가
      const templateExclusionsAsPlanExclusions = missingTemplateExclusions.map(
        (te) => ({
          id: `template-${te.exclusion_date}`, // 임시 ID
          tenant_id: tenantId || "",
          student_id: planGroup.student_id || "",
          plan_group_id: groupId,
          exclusion_date: te.exclusion_date,
          exclusion_type: te.exclusion_type,
          reason: te.reason || null,
          created_at: new Date().toISOString(),
        })
      );

      // DB 제외일과 템플릿 제외일을 합쳐서 반환
      return [...dbExclusions, ...templateExclusionsAsPlanExclusions].sort(
        (a, b) => {
          const dateA = new Date(a.exclusion_date).getTime();
          const dateB = new Date(b.exclusion_date).getTime();
          return dateA - dateB;
        }
      );
    }
  }

  return dbExclusions;
}
```

## 🎯 동작 시나리오

### 시나리오 1: 템플릿 "휴일지정" + 학생 "휴가" 추가

1. **템플릿 설정**: 2025-01-15 "휴일지정"
2. **학생 추가**: 2025-01-15 "휴가"
3. **결과**: 2025-01-15 "휴가"로 자동 교체 (위계 4 > 1)

### 시나리오 2: 템플릿 "휴가" + 학생 "휴일지정" 추가

1. **템플릿 설정**: 2025-01-15 "휴가"
2. **학생 추가**: 2025-01-15 "휴일지정"
3. **결과**: 템플릿 "휴가" 유지 (위계 4 > 1, 학생 제외일 무시)

### 시나리오 3: 학생 제외일 삭제 후 템플릿 제외일 복원

1. **템플릿 설정**: 2025-01-15 "휴일지정"
2. **학생 추가**: 2025-01-15 "휴가" (자동 교체됨)
3. **학생 삭제**: 2025-01-15 "휴가" 삭제
4. **다음 조회**: 2025-01-15 "휴일지정" 자동 포함 (템플릿 제외일 복원)

## 📝 주요 변경 파일

1. **lib/utils/exclusionHierarchy.ts** (신규)
   - 제외일 타입 위계 정의 및 유틸리티 함수

2. **app/(student)/actions/campActions.ts**
   - 제외일 병합 로직에 위계 기반 자동 교체 적용

3. **lib/utils/planDataMerger.ts**
   - 템플릿 데이터 병합 시 위계 기반 로직 적용

4. **lib/data/planGroups.ts**
   - `getPlanExclusions` 함수에 템플릿 제외일 자동 포함 로직 추가

## 🔧 추가 수정 사항

### 1. 스케줄 계산 시 제외일 중복 제거

**파일**: `app/(student)/actions/calculateScheduleAvailability.ts`

캠프 모드에서 스케줄 계산 시 제외일 위계 기반 중복 제거를 적용하여 "중복된 제외일이 있습니다" 에러를 방지합니다.

```typescript
// 캠프 모드: 제외일 위계 기반 중복 제거
if (params.isCampMode) {
  const exclusionMap = new Map<string, Exclusion>();

  for (const exclusion of params.exclusions) {
    const existing = exclusionMap.get(exclusion.exclusion_date);

    if (existing) {
      const higherType = getHigherPriorityExclusionType(
        exclusion.exclusion_type,
        existing.exclusion_type
      );

      if (higherType === exclusion.exclusion_type) {
        exclusionMap.set(exclusion.exclusion_date, exclusion);
      }
    } else {
      exclusionMap.set(exclusion.exclusion_date, exclusion);
    }
  }

  processedExclusions = Array.from(exclusionMap.values());
}
```

### 2. 제외일 저장 시 위계 기반 중복 제거

**파일**: `app/(student)/actions/plan-groups/create.ts`

플랜 그룹 생성 및 임시저장 시 제외일 저장 전 위계 기반 중복 제거를 적용합니다.

- `_createPlanGroup`: 플랜 그룹 생성 시
- `_savePlanGroupDraft`: 임시저장 시

### 3. 제외일 날짜 time_slots 처리 개선

**파일**: `lib/scheduler/calculateAvailableDates.ts`, `app/(student)/actions/plan-groups/create.ts`

- `calculateAvailableDates`에서 `time_slots`를 항상 배열로 제공 (빈 배열 포함)
- 제외일이 있는 날짜(휴가, 개인일정, 지정휴일)는 `time_slots`가 빈 배열이어도 허용

## ✅ 검증 사항

- [x] 제외일 타입 위계 정의 정확성
- [x] 위계 기반 자동 교체 로직 정확성
- [x] 템플릿 제외일 자동 포함 로직 정확성
- [x] 학생 제외일 삭제 후 템플릿 제외일 복원 확인
- [x] 스케줄 계산 시 제외일 중복 제거
- [x] 제외일 저장 시 위계 기반 중복 제거
- [x] 제외일 날짜 time_slots 처리 개선
- [x] 린터 에러 없음

## 🔄 향후 개선 사항

1. **UI 개선**
   - 템플릿 제외일과 학생 제외일을 시각적으로 구분
   - 제외일 위계 정보를 사용자에게 표시

2. **성능 최적화**
   - 템플릿 제외일 조회 시 캐싱 적용
   - 배치 조회로 N+1 문제 방지

3. **에러 처리 강화**
   - 템플릿 조회 실패 시 적절한 에러 처리
   - 사용자에게 명확한 에러 메시지 제공

## 📚 참고 문서

- [캘린더 제외일 타입별 차별화 처리](./calendar-exclusion-type-differentiation.md)
- [플랜 생성 로직 설계](../timetable/플랜-생성-로직-설계.md)
- [1730 Timetable 통합 요구사항](../timetable/1730Timetable-통합-요구사항.md)
