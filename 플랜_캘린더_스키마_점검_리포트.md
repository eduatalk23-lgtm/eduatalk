# 플랜 캘린더 데이터 스키마 점검 리포트

**점검 일자**: 2025-01-22  
**점검 범위**: 플랜 캘린더 관련 데이터베이스 스키마 및 쿼리 패턴

---

## 📋 목차

1. [전체 구조 개요](#전체-구조-개요)
2. [주요 테이블 분석](#주요-테이블-분석)
3. [인덱스 최적화 상태](#인덱스-최적화-상태)
4. [데이터 일관성 검토](#데이터-일관성-검토)
5. [성능 최적화 제안](#성능-최적화-제안)
6. [발견된 이슈 및 개선사항](#발견된-이슈-및-개선사항)

---

## 전체 구조 개요

### 핵심 테이블 관계도

```
plan_groups (플랜 그룹 메타데이터)
  ├── student_plan (개별 플랜 항목)
  │   └── [denormalized fields: content_title, content_subject, ...]
  ├── plan_contents (플랜 그룹-콘텐츠 관계)
  └── [daily_schedule JSONB 캐시]

plan_exclusions (학생별 제외일 - 전역 관리)
  └── student_id (plan_group_id와 분리)

academy_schedules (학생별 학원 일정 - 전역 관리)
  └── student_id (plan_group_id와 분리)
```

### 캘린더 페이지 데이터 흐름

```typescript
1. 활성 플랜 그룹 조회 (status='active')
   ↓
2. 플랜 그룹 기간 범위 계산 (period_start ~ period_end)
   ↓
3. 해당 기간의 모든 플랜 조회 (student_plan)
   ↓
4. 활성 그룹에 속한 플랜만 필터링 (plan_group_id)
   ↓
5. 제외일 조회 (plan_exclusions - student_id 기반)
   ↓
6. 학원 일정 조회 (academy_schedules - student_id 기반)
```

---

## 주요 테이블 분석

### 1. `student_plan` 테이블

#### 현재 구조

```sql
- id (uuid, PK)
- tenant_id (uuid, FK → tenants)
- student_id (uuid, FK → students)
- plan_date (date, NOT NULL) ⭐ 캘린더 핵심 필드
- block_index (integer, NOT NULL)
- content_type (text, CHECK: 'book'|'lecture'|'custom')
- content_id (uuid, NOT NULL)
- chapter (text, nullable)
- planned_start_page_or_time (integer, nullable)
- planned_end_page_or_time (integer, nullable)
- completed_amount (integer, nullable)
- progress (numeric, CHECK: 0-100)
- is_reschedulable (boolean, DEFAULT true)
- plan_group_id (uuid, FK → plan_groups, nullable) ⭐ 그룹 참조
- actual_start_time (timestamptz, nullable) ⭐ 시간 측정
- actual_end_time (timestamptz, nullable) ⭐ 시간 측정
- total_duration_seconds (integer, nullable) ⭐ 시간 측정
- paused_duration_seconds (integer, DEFAULT 0) ⭐ 시간 측정
- pause_count (integer, DEFAULT 0) ⭐ 시간 측정
- content_title (text, nullable) ⭐ Denormalized
- content_subject (text, nullable) ⭐ Denormalized
- content_subject_category (text, nullable) ⭐ Denormalized
- content_category (text, nullable) ⭐ Denormalized
- created_at (timestamptz, DEFAULT now())
- updated_at (timestamptz, DEFAULT now())
```

#### ✅ 강점

1. **Denormalized 필드**: `content_title`, `content_subject` 등이 있어 조인 없이 조회 가능
2. **플랜 그룹 참조**: `plan_group_id`로 그룹별 필터링 가능
3. **시간 측정 필드**: 실제 학습 시간 추적 가능
4. **인덱스 최적화**: `student_id + plan_date` 복합 인덱스 존재

#### ⚠️ 주의사항

1. **plan_group_id NULL 허용**: 레거시 데이터 대응을 위해 nullable이지만, 캘린더에서는 필터링 필요
2. **Denormalized 필드 동기화**: 콘텐츠 정보 변경 시 업데이트 필요 (트리거 또는 애플리케이션 레벨)

---

### 2. `plan_groups` 테이블

#### 현재 구조

```sql
- id (uuid, PK)
- tenant_id (uuid, FK → tenants)
- student_id (uuid, FK → students)
- name (varchar(200), nullable)
- plan_purpose (varchar(50), CHECK: '내신대비'|'모의고사'|'수능'|'기타')
- scheduler_type (varchar(50), nullable)
- period_start (date, NOT NULL) ⭐ 캘린더 기간 시작
- period_end (date, NOT NULL) ⭐ 캘린더 기간 종료
- target_date (date, nullable) ⭐ D-day
- block_set_id (uuid, FK → student_block_sets, nullable)
- status (varchar(20), DEFAULT 'draft', CHECK: 'draft'|'saved'|'active'|'paused'|'completed'|'cancelled') ⭐ 활성화 상태
- deleted_at (timestamptz, nullable) ⭐ Soft Delete
- daily_schedule (jsonb, nullable) ⭐ JSONB 캐시
- created_at (timestamptz, DEFAULT now())
- updated_at (timestamptz, DEFAULT now())
```

#### ✅ 강점

1. **기간 관리**: `period_start`, `period_end`로 명확한 기간 정의
2. **상태 관리**: `status` 필드로 활성화 상태 제어
3. **Soft Delete**: `deleted_at`으로 삭제 데이터 보존
4. **JSONB 캐시**: `daily_schedule`로 계산 결과 캐싱 가능

#### ⚠️ 주의사항

1. **scheduler_type CHECK 제약**: 마이그레이션과 타입 정의 불일치 가능성
   - 마이그레이션: `'성적기반', '1730_timetable', '전략취약과목', '커스텀'`
   - 타입 정의: `'자동스케줄러' | '1730_timetable'`
   - ⚠️ **불일치 발견**: 확인 필요

---

### 3. `plan_exclusions` 테이블

#### 현재 구조

```sql
- id (uuid, PK)
- tenant_id (uuid, FK → tenants)
- student_id (uuid, FK → students, NOT NULL) ⭐ 학생별 전역 관리
- plan_group_id (uuid, FK → plan_groups, nullable) ⚠️ 레거시 (하위 호환성)
- exclusion_date (date, NOT NULL) ⭐ 제외일
- exclusion_type (varchar(20), CHECK: '휴가'|'개인사정'|'휴일지정'|'기타')
- reason (text, nullable)
- created_at (timestamptz, DEFAULT now())
```

#### ✅ 강점

1. **학생별 전역 관리**: 모든 플랜 그룹에 공통 적용
2. **인덱스 최적화**: `student_id + exclusion_date` 복합 인덱스

#### ⚠️ 주의사항

1. **plan_group_id 레거시**: 하위 호환성을 위해 유지되지만, 새로운 데이터는 `student_id`만 사용
2. **중복 제약 없음**: 같은 날짜에 여러 제외일 등록 가능 (애플리케이션 레벨에서 처리)

---

### 4. `academy_schedules` 테이블

#### 현재 구조

```sql
- id (uuid, PK)
- tenant_id (uuid, FK → tenants)
- student_id (uuid, FK → students, NOT NULL) ⭐ 학생별 전역 관리
- academy_id (uuid, FK → academies, nullable) ⭐ 학원 참조
- plan_group_id (uuid, FK → plan_groups, nullable) ⚠️ 레거시 (하위 호환성)
- day_of_week (integer, CHECK: 0-6) ⭐ 요일
- start_time (time, NOT NULL) ⭐ 시작 시간
- end_time (time, NOT NULL) ⭐ 종료 시간
- academy_name (varchar(100), nullable) ⚠️ 레거시 (하위 호환성)
- subject (varchar(50), nullable) ⭐ 과목
- created_at (timestamptz, DEFAULT now())
- updated_at (timestamptz, DEFAULT now())
```

#### ✅ 강점

1. **학생별 전역 관리**: 모든 플랜 그룹에 공통 적용
2. **학원 참조**: `academy_id`로 학원 정보 연결
3. **인덱스 최적화**: `student_id + day_of_week` 복합 인덱스

#### ⚠️ 주의사항

1. **plan_group_id 레거시**: 하위 호환성을 위해 유지되지만, 새로운 데이터는 `student_id`만 사용
2. **academy_name 레거시**: `academy_id` 사용 권장

---

## 인덱스 최적화 상태

### ✅ 잘 최적화된 인덱스

#### `student_plan` 테이블

```sql
✅ idx_student_plan_student_id (student_id)
✅ idx_student_plan_student_date (student_id, plan_date) ⭐ 캘린더 쿼리 최적화
✅ idx_student_plan_group_id (plan_group_id)
✅ idx_student_plan_group_date (plan_group_id, plan_date) ⭐ 그룹별 날짜 조회
✅ idx_student_plan_content_subject (content_subject) WHERE content_subject IS NOT NULL
✅ idx_student_plan_date_subject (plan_date, content_subject) ⭐ 날짜+과목 조회
```

#### `plan_groups` 테이블

```sql
✅ idx_plan_groups_student_id (student_id)
✅ idx_plan_groups_student_status (student_id, status) ⭐ 활성 그룹 조회
✅ idx_plan_groups_period (period_start, period_end) ⭐ 기간 조회
✅ idx_plan_groups_daily_schedule (daily_schedule) USING gin ⭐ JSONB 쿼리
```

#### `plan_exclusions` 테이블

```sql
✅ idx_plan_exclusions_student_id (student_id)
✅ idx_plan_exclusions_student_id_exclusion_date (student_id, exclusion_date) ⭐ 학생별 날짜 조회
```

#### `academy_schedules` 테이블

```sql
✅ idx_academy_schedules_student_id (student_id)
✅ idx_academy_schedules_student_id_day_of_week (student_id, day_of_week) ⭐ 학생별 요일 조회
```

### ⚠️ 개선 가능한 인덱스

1. **`student_plan.plan_date` 단독 인덱스**: 날짜 범위 조회 시 유용할 수 있음
   ```sql
   -- 현재: idx_student_plan_student_date (student_id, plan_date) 존재
   -- 제안: 단독 인덱스는 불필요 (복합 인덱스가 더 효율적)
   ```

2. **`plan_groups.status` 단독 인덱스**: 활성 그룹 조회 시 유용
   ```sql
   -- 현재: idx_plan_groups_student_status (student_id, status) 존재
   -- 제안: 단독 인덱스는 불필요 (복합 인덱스가 더 효율적)
   ```

---

## 데이터 일관성 검토

### ✅ 잘 관리되는 부분

1. **외래키 제약**: 모든 테이블에 적절한 FK 제약 존재
2. **CHECK 제약**: `content_type`, `status`, `exclusion_type` 등에 CHECK 제약
3. **Soft Delete**: `plan_groups.deleted_at`으로 삭제 데이터 보존
4. **트리거**: `updated_at` 자동 업데이트 트리거 존재

### ⚠️ 주의가 필요한 부분

1. **Denormalized 필드 동기화**
   - `student_plan.content_title` 등이 콘텐츠 정보와 불일치할 수 있음
   - **해결책**: 콘텐츠 업데이트 시 트리거 또는 애플리케이션 레벨에서 동기화

2. **plan_group_id NULL 허용**
   - 레거시 데이터 대응을 위해 nullable
   - 캘린더 페이지에서 필터링 필요 (현재 구현됨)

3. **scheduler_type 불일치**
   - 마이그레이션: `'성적기반', '1730_timetable', '전략취약과목', '커스텀'`
   - 타입 정의: `'자동스케줄러' | '1730_timetable'`
   - **해결책**: 일치시키거나 마이그레이션 필요

---

## 성능 최적화 제안

### 1. 캘린더 쿼리 최적화

#### 현재 쿼리 패턴

```typescript
// 1. 활성 플랜 그룹 조회
getPlanGroupsForStudent({ studentId, status: 'active' })
// 인덱스: idx_plan_groups_student_status ✅

// 2. 플랜 조회 (날짜 범위)
getPlansForStudent({ studentId, dateRange: { start, end } })
// 인덱스: idx_student_plan_student_date ✅

// 3. 제외일 조회
getStudentExclusions(studentId)
// 인덱스: idx_plan_exclusions_student_id ✅

// 4. 학원 일정 조회
getStudentAcademySchedules(studentId)
// 인덱스: idx_academy_schedules_student_id ✅
```

#### ✅ 최적화 상태: 양호

모든 주요 쿼리가 적절한 인덱스를 사용하고 있습니다.

### 2. Denormalized 필드 활용

#### 현재 구현

```typescript
// 캘린더 페이지에서 denormalized 필드 직접 사용
const plansWithContent = filteredPlans.map((plan) => ({
  ...plan,
  contentTitle: plan.content_title || "제목 없음",
  contentSubject: plan.content_subject || null,
  // ...
}));
```

#### ✅ 최적화 상태: 양호

조인 없이 데이터 조회 가능하여 성능 향상.

### 3. JSONB 캐시 활용

#### 현재 구조

```sql
plan_groups.daily_schedule (jsonb)
-- 인덱스: idx_plan_groups_daily_schedule USING gin ✅
```

#### 💡 활용 제안

- 스케줄러 계산 결과를 JSONB로 캐싱하여 재계산 방지
- 현재는 컬럼만 존재하고 활용 여부 확인 필요

---

## 발견된 이슈 및 개선사항

### 🔴 Critical Issues

#### 1. scheduler_type 불일치

**문제**:
- 마이그레이션 CHECK 제약: `'성적기반', '1730_timetable', '전략취약과목', '커스텀'`
- TypeScript 타입: `'자동스케줄러' | '1730_timetable'`

**영향**:
- 데이터베이스와 애플리케이션 간 불일치로 인한 오류 가능

**해결책**:
```sql
-- 옵션 1: CHECK 제약 수정 (권장)
ALTER TABLE plan_groups 
DROP CONSTRAINT IF EXISTS plan_groups_scheduler_type_check;

ALTER TABLE plan_groups 
ADD CONSTRAINT plan_groups_scheduler_type_check 
CHECK (scheduler_type IN ('자동스케줄러', '1730_timetable'));

-- 옵션 2: 기존 데이터 마이그레이션 후 제약 수정
UPDATE plan_groups 
SET scheduler_type = '자동스케줄러' 
WHERE scheduler_type = '성적기반';
```

### 🟡 Medium Priority Issues

#### 2. Denormalized 필드 동기화 메커니즘 부재

**문제**:
- `student_plan.content_title` 등이 콘텐츠 정보 변경 시 자동 업데이트되지 않음

**해결책**:
```sql
-- 트리거 생성 (예시)
CREATE OR REPLACE FUNCTION sync_plan_content_metadata()
RETURNS TRIGGER AS $$
BEGIN
  -- books 테이블 업데이트 시
  IF TG_TABLE_NAME = 'books' THEN
    UPDATE student_plan
    SET 
      content_title = NEW.title,
      content_subject = NEW.subject,
      content_subject_category = NEW.subject_category
    WHERE content_type = 'book' AND content_id = NEW.id;
  END IF;
  
  -- lectures 테이블 업데이트 시
  IF TG_TABLE_NAME = 'lectures' THEN
    UPDATE student_plan
    SET 
      content_title = NEW.title,
      content_subject = NEW.subject,
      content_subject_category = NEW.subject_category
    WHERE content_type = 'lecture' AND content_id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### 3. plan_group_id NULL 데이터 처리

**현재 상태**: ✅ 캘린더 페이지에서 필터링됨

```typescript
// app/(student)/plan/calendar/page.tsx:91-94
const filteredPlans = allPlans.filter((plan) => {
  return plan.plan_group_id && activeGroupIds.has(plan.plan_group_id);
});
```

**제안**: 레거시 데이터 정리 마이그레이션 고려

### 🟢 Low Priority Issues

#### 4. academy_schedules.academy_id NULL 허용

**현재 상태**: 하위 호환성을 위해 `academy_name`도 유지

**제안**: 새로운 데이터는 `academy_id` 필수로 변경 고려

#### 5. plan_exclusions 중복 제약 없음

**현재 상태**: 애플리케이션 레벨에서 중복 체크

**제안**: 데이터베이스 레벨 유니크 제약 추가 고려
```sql
-- 단, 같은 날짜에 여러 제외일이 필요한 경우도 있을 수 있으므로 신중히 결정
CREATE UNIQUE INDEX IF NOT EXISTS idx_plan_exclusions_student_date 
ON plan_exclusions(student_id, exclusion_date);
```

---

## 최종 권장사항

### 즉시 조치 필요

1. ✅ **scheduler_type 불일치 해결**: 데이터베이스와 TypeScript 타입 일치시키기

### 단기 개선 (1-2주)

2. ✅ **Denormalized 필드 동기화 트리거**: 콘텐츠 업데이트 시 자동 동기화
3. ✅ **레거시 데이터 정리**: `plan_group_id` NULL 데이터 처리

### 중장기 개선 (1-2개월)

4. ✅ **JSONB 캐시 활용**: `daily_schedule` 필드 적극 활용
5. ✅ **모니터링 추가**: 캘린더 쿼리 성능 모니터링

---

## 결론

### 전체 평가: ⭐⭐⭐⭐ (4/5)

**강점**:
- 인덱스 최적화가 잘 되어 있음
- Denormalized 필드로 조인 최소화
- 학생별 전역 관리 구조로 데이터 중복 방지

**개선 필요**:
- scheduler_type 불일치 해결
- Denormalized 필드 동기화 메커니즘 추가

**전체적으로 잘 설계된 스키마이며, 몇 가지 개선사항만 반영하면 더욱 견고해질 것입니다.**

---

**리포트 작성일**: 2025-01-22  
**다음 점검 권장일**: 2025-02-22 (1개월 후)

